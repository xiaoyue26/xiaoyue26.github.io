<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>scala笔记 | 笔记本</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="http:&#x2F;&#x2F;www.runoob.com&#x2F;scala&#x2F;scala-data-types.htmlscala api:http:&#x2F;&#x2F;www.scala-lang.org&#x2F;api&#x2F;current&#x2F;scala&#x2F;Nothing.htmlhttp:&#x2F;&#x2F;blog.csdn.net&#x2F;bluishglc&#x2F;article&#x2F;details&#x2F;55668192 运算优先级: 在Scala里所有以“:”结尾的运算符是右关">
<meta property="og:type" content="article">
<meta property="og:title" content="scala笔记">
<meta property="og:url" content="http://xiaoyue26.github.io/2017/05/17/scala%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="笔记本">
<meta property="og:description" content="http:&#x2F;&#x2F;www.runoob.com&#x2F;scala&#x2F;scala-data-types.htmlscala api:http:&#x2F;&#x2F;www.scala-lang.org&#x2F;api&#x2F;current&#x2F;scala&#x2F;Nothing.htmlhttp:&#x2F;&#x2F;blog.csdn.net&#x2F;bluishglc&#x2F;article&#x2F;details&#x2F;55668192 运算优先级: 在Scala里所有以“:”结尾的运算符是右关">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2017-05-17T12:02:38.000Z">
<meta property="article:modified_time" content="2020-04-18T15:38:11.298Z">
<meta property="article:author" content="风梦七">
<meta property="article:tag" content="scala">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="笔记本" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    
  
  
<link rel="stylesheet" href="/css/style.css">

  

<meta name="generator" content="Hexo 4.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    
    <div id="header-inner" class="inner">
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://xiaoyue26.github.io"></form>
      </div>
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">首页</a>
        
          <a class="main-nav-link" href="/archives">归档</a>
        
          <a class="main-nav-link" href="/about">关于</a>
        
      </nav>
      
    </div>
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">笔记本</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">风梦七</a>
        </h2>
      
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-scala笔记" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/05/17/scala%E7%AC%94%E8%AE%B0/" class="article-date">
  <time datetime="2017-05-17T12:02:38.000Z" itemprop="datePublished">2017-05-17</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/spark/">spark</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      scala笔记
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <p><a href="http://www.runoob.com/scala/scala-data-types.html" target="_blank" rel="noopener">http://www.runoob.com/scala/scala-data-types.html</a><br>scala api:<br><a href="http://www.scala-lang.org/api/current/scala/Nothing.html" target="_blank" rel="noopener">http://www.scala-lang.org/api/current/scala/Nothing.html</a><br><a href="http://blog.csdn.net/bluishglc/article/details/55668192" target="_blank" rel="noopener">http://blog.csdn.net/bluishglc/article/details/55668192</a></p>
<h1 id="运算优先级"><a href="#运算优先级" class="headerlink" title="运算优先级:"></a>运算优先级:</h1><blockquote>
<p>在Scala里所有以“:”结尾的运算符是右关联的，其他的运算符都是左关联的</p>
</blockquote>
<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Byte,Int,Short,Long等略.</span></span><br><span class="line"><span class="type">Unit</span> : 表示void. 表示无值，和其他语言中void等同。用作不返回任何结果的方法的结果类型。<span class="type">Unit</span>只有一个实例值，写成()。</span><br><span class="line"></span><br><span class="line"><span class="type">Null</span> : <span class="literal">null</span> 或空引用,<span class="type">Null</span>类是<span class="literal">null</span>引用对象的类型，它是每个引用类（继承自<span class="type">AnyRef</span>的类）的子类。<span class="type">Null</span>不兼容值类型</span><br><span class="line"></span><br><span class="line"><span class="type">Nothing</span> : <span class="type">Nothing</span>类型在<span class="type">Scala</span>的类层级的最低端；它是任何其他类型的子类型。</span><br><span class="line"></span><br><span class="line"><span class="type">Any</span> : <span class="type">Any</span>是所有其他类的超类</span><br><span class="line"><span class="comment">// Any有两个子类：AnyVal和AnyRef</span></span><br><span class="line"></span><br><span class="line"><span class="type">AnyRef</span>	: <span class="type">AnyRef</span>类是<span class="type">Scala</span>里所有引用类(reference <span class="class"><span class="keyword">class</span>)<span class="title">的基类</span></span></span><br></pre></td></tr></table></figure>
<p>Nothing和Unit的区别:</p>
<blockquote>
<ol>
<li>Unit有一个值 ()<br>Nothing没有值.</li>
<li>以Unit为返回值的话,方法能正常结束;<br>以Nothing为返回值的话,方法只能以异常退出.</li>
</ol>
</blockquote>
<p><a href="http://blog.csdn.net/bluejoe2000/article/details/30465175" target="_blank" rel="noopener">http://blog.csdn.net/bluejoe2000/article/details/30465175</a></p>
<h1 id="变量与常量"><a href="#变量与常量" class="headerlink" title="变量与常量:"></a>变量与常量:</h1><ul>
<li><p>val</p>
<blockquote>
<p>value,值. 定义时立即求值. (饿汉求值). 只求一次.</p>
</blockquote>
</li>
<li><p>var</p>
<blockquote>
<p>variable,变量.  定义时立即求值. 可改变赋值. 只求一次.</p>
</blockquote>
</li>
<li><p>def</p>
<blockquote>
<p>define. 每次使用时才求值.(惰性求值). 求N次</p>
</blockquote>
</li>
<li><p>lazy val</p>
<blockquote>
<p>懒求值. 第一次使用时求值,但只求一次.</p>
</blockquote>
</li>
<li><p>退出cli</p>
<blockquote>
<p>:q 或 sys.exit</p>
</blockquote>
</li>
<li><p>查看版本:</p>
<blockquote>
<p>scala –version</p>
</blockquote>
</li>
</ul>
<h1 id="访问修饰符"><a href="#访问修饰符" class="headerlink" title="访问修饰符"></a>访问修饰符</h1><blockquote>
<p>private: Scala 中的 private 限定符，比 Java 更严格，在嵌套类情况下，外层类甚至不能访问被嵌套类的私有成员。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Outer&#123;</span><br><span class="line">    class Inner&#123;</span><br><span class="line">    private def f()&#123;println(&quot;f&quot;)&#125;</span><br><span class="line">    class InnerMost&#123;</span><br><span class="line">        f() &#x2F;&#x2F; 正确</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    (new Inner).f() &#x2F;&#x2F;错误</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>protected:在 scala 中，对保护（Protected）成员的访问比 java 更严格一些。因为它只允许保护成员在定义了该成员的的类的子类中被访问。而在java中，用protected关键字修饰的成员，除了定义了该成员的类的子类可以访问，同一个包里的其他类也可以进行访问。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">package p&#123;</span><br><span class="line">class Super&#123;</span><br><span class="line">    protected def f() &#123;println(&quot;f&quot;)&#125;</span><br><span class="line">    &#125;</span><br><span class="line">	class Sub extends Super&#123;</span><br><span class="line">	    f() &#x2F;&#x2F; 正确</span><br><span class="line">	&#125;</span><br><span class="line">	class Other&#123;</span><br><span class="line">		(new Super).f() &#x2F;&#x2F;错误</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>public: 任何地方都可以被访问</p>
</blockquote>
<blockquote>
<p>private[x],protected[x]:这里的x指代某个所属的包、类或单例对象。如果写成private[x],读作”这个成员除了对[…]中的类或[…]中的包中的类及它们的伴生对象可见外，对其它所有类都是private。<br>这种技巧在横跨了若干包的大型项目中非常有用，它允许你定义一些在你项目的若干子包中可见但对于项目外部的客户却始终不可见的东西。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">package bobsrocckets&#123;</span><br><span class="line">    package navigation&#123;</span><br><span class="line">        private[bobsrockets] class Navigator&#123;</span><br><span class="line">         protected[navigation] def useStarChart()&#123;&#125;</span><br><span class="line">         class LegOfJourney&#123;</span><br><span class="line">             private[Navigator] val distance &#x3D; 100</span><br><span class="line">             &#125;</span><br><span class="line">            private[this] var speed &#x3D; 200</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        package launch&#123;</span><br><span class="line">        import navigation._</span><br><span class="line">        object Vehicle&#123;</span><br><span class="line">        private[launch] val guide &#x3D; new Navigator</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述例子中，类Navigator被标记为private[bobsrockets]就是说这个类对包含在bobsrockets包里的所有的类和对象可见。<br>比如说，从Vehicle对象里对Navigator的访问是被允许的，因为对象Vehicle包含在包launch中，而launch包在bobsrockets中，相反，所有在包bobsrockets之外的代码都不能访问类Navigator。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Student&#123;  </span><br><span class="line">  var age&#x3D;20     &#x2F;&#x2F;底层编译器会自动为age添加get和set的公有方法 </span><br><span class="line">  private[this] var gender&#x3D;&quot;male&quot; </span><br><span class="line">  &#x2F;&#x2F;private[this] 只有该类的this可以使用  </span><br><span class="line">  private var name&#x3D;&quot;clow&quot;</span><br><span class="line">  &#x2F;&#x2F;声明了private,底层编译器会自动为私有的name添加get和set的私有方法  </span><br><span class="line">  &#x2F;&#x2F;但是可以自己定义属性方法  </span><br><span class="line">  def getName&#x3D;this.name  </span><br><span class="line">  def setName(value:String)&#123;this.name&#x3D;value&#125;  </span><br><span class="line">&#125;  </span><br><span class="line">&#x2F;&#x2F;构造器的使用  </span><br><span class="line">class Teacher &#123;  </span><br><span class="line">  var age: Int &#x3D; _  </span><br><span class="line">  var name: String &#x3D; _  &#x2F;&#x2F;可以预留  </span><br><span class="line">  </span><br><span class="line">&#x2F;&#x2F;重载的构造器 和public Teacher()&#123;&#125;类似  </span><br><span class="line">def this(age: Int, name: String)&#123;  </span><br><span class="line">    this() &#x2F;&#x2F;必须得调用一次主构造器  </span><br><span class="line">    this.age&#x3D;age  </span><br><span class="line">    this.name&#x3D;name  </span><br><span class="line">&#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="下划线的用法"><a href="#下划线的用法" class="headerlink" title="下划线的用法"></a>下划线的用法</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 1、作为“通配符”，类似Java中的*。如</span><br><span class="line">import scala.math._</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 2、:_*作为一个整体，告诉编译器你希望将某个参数当作参数序列处理</span><br><span class="line">val s &#x3D; sum(1 to 5:_*)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">3、&#x2F;&#x2F;指代一个集合中的每个元素。例如我们要在一个Array a中筛出偶数，并乘以2，可以用以下办法：</span><br><span class="line">a.filter(_%2&#x3D;&#x3D;0).map(2*_)</span><br><span class="line">&#x2F;&#x2F;又如要对缓冲数组ArrayBuffer b排序，可以这样：</span><br><span class="line">val after &#x3D; a.sortWith(_.compareTo(_) &gt; 0)</span><br><span class="line">&#x2F;&#x2F; 默认顺序: val aSorted &#x3D; a.sorted</span><br><span class="line"></span><br><span class="line">4、在元组中，可以用方法_1, _2, _3访问组员。如a._2。其中句点可以用空格替代。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">5、使用模式匹配可以用来获取元组的组员，</span><br><span class="line">例如</span><br><span class="line">val (first, second, third) &#x3D; t</span><br><span class="line">但如果不是所有的部件都需要，那么可以在不需要的部件位置上使用_。比如上一例中</span><br><span class="line">val (first, second, _) &#x3D; t</span><br><span class="line">val (first, _) &#x3D; (1, 2)</span><br><span class="line"></span><br><span class="line">6、还有一点，下划线_代表的是某一类型的默认值。对于Int来说，它是0。对于Double来说，它是0.0对于引用类型，它是null.</span><br></pre></td></tr></table></figure>
<p><a href="https://my.oschina.net/leejun2005/blog/405305" target="_blank" rel="noopener">https://my.oschina.net/leejun2005/blog/405305</a></p>
<h1 id="scala的函数和方法"><a href="#scala的函数和方法" class="headerlink" title="scala的函数和方法:"></a>scala的函数和方法:</h1><blockquote>
<p>Scala 有函数和方法，二者在语义上的区别很小。Scala 方法是类的一部分，而函数是一个对象可以赋值给一个变量。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">函数也类似于一个变量,类似函数指针的概念.</span><br><span class="line">stackoverflow上推荐的代码风格是:</span><br><span class="line">1. 加上 &#x3D; 号;</span><br><span class="line">2. 加上函数的返回值类型.</span><br><span class="line"></span><br><span class="line">“&#x3D;”并不只是用来分割函数签名和函数体的，它的另一个作用是告诉编译器是否对函数的返回值进行类型推断！如果省去&#x3D;,则认为函数是没有返回值的！</span><br><span class="line"></span><br><span class="line">闭包:</span><br><span class="line">闭包是一个函数，返回值依赖于声明在函数外部的一个或多个变量。</span><br><span class="line">闭包所引用的外部变量,会被trace,在闭包context内都不会被gc释放.</span><br><span class="line">&#x2F;&#x2F; 我看来闭包就是一个侧漏的函数,一点也不封闭. 作用是用于一些延迟执行的函数. 比如传递给spark的rdd.</span><br></pre></td></tr></table></figure>

<h1 id="传参"><a href="#传参" class="headerlink" title="传参:"></a>传参:</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;传值调用（call-by-value）：先计算参数表达式的值，再应用到函数内部；</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;传名调用（call-by-name）：将未计算的参数表达式直接应用到函数内部</span><br><span class="line">&#x2F;&#x2F; 类似于宏替换</span><br><span class="line">def delayed( t: &#x3D;&gt; Long ) &#x3D; &#123;</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h1 id="List符号函数"><a href="#List符号函数" class="headerlink" title="List符号函数"></a>List符号函数</h1><blockquote>
<p>优先使用 <code>++</code> 而不是 <code>:::</code> ;<br>优先使用 <code>+:</code> 而不是 <code>::</code>;<br>冒号靠近List.</p>
</blockquote>
<h1 id="actor"><a href="#actor" class="headerlink" title="actor"></a>actor</h1><p><a href="http://www.cnblogs.com/vikings-blog/p/3942417.html" target="_blank" rel="noopener">http://www.cnblogs.com/vikings-blog/p/3942417.html</a></p>
<h1 id="函数和方法-def和val区别"><a href="#函数和方法-def和val区别" class="headerlink" title="函数和方法,def和val区别:"></a>函数和方法,def和val区别:</h1><p><a href="http://www.jianshu.com/p/9b9519a36d78" target="_blank" rel="noopener">http://www.jianshu.com/p/9b9519a36d78</a></p>
<p>经测试,scala是从Function0定义到了Function22;<br>而没有Function23,因此函数对象最多22个参数.</p>
<h1 id="object和class的区别"><a href="#object和class的区别" class="headerlink" title="object和class的区别"></a>object和class的区别</h1><ol>
<li><code>class</code>中均为实例成员函数\变量;</li>
<li><code>object</code>中均为static函数变量,为单例模式使用.<br>若<code>object</code>还与类同名,则为伴生对象,类似于友元,还可以访问私有成员.</li>
<li>声明一个object， 一个匿名类就会被创建。</li>
</ol>
<p>使用方法:</p>
<blockquote>
<ol>
<li>成员函数,变量: new一个对象出来调用;</li>
<li>静态函数,变量,或者想使用单例模式: 在同文件中写一个object,然后通过object来定义静态成员,并写使用接口. 如果需要访问私有成员,则这个<code>object</code>需要和class同名.</li>
</ol>
</blockquote>
<p>总结:</p>
<ol>
<li><code>class</code>: 实例成员的集合</li>
<li><code>object</code>:  静态成员的集合</li>
<li>单例: private构造函数,然后创建<code>object</code>. 因为需要访问构造函数,所以其实真正能用的单例对象都是同名的伴生对象. 非同名的object只能称为未关联class的object,可以作为main程序调用. </li>
<li>访问私有成员: 创建同名<code>object</code>(伴生对象)</li>
</ol>
<h1 id="scala类修饰符"><a href="#scala类修饰符" class="headerlink" title="scala类修饰符"></a>scala类修饰符</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;1.使用var声明field,则该field将同时拥有getter和setter </span><br><span class="line">class MongoClient(var host:String, var port:Int)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;2.使用val声明field,则该field只有getter。这意味着在初始化之后，你将无法再修改它的值。 </span><br><span class="line">class MongoClient(val host:String, val port:Int)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;3.如果没有任何修饰符，则该field是完全私有的。 </span><br><span class="line">class MongoClient(host:String, port:Int)</span><br></pre></td></tr></table></figure>
<p>但是注意对于Case Class，则稍有不同！Case Class对于通过Primary Constructor声明的字段自动添加val修饰，使之变为只读的。</p>
<h1 id="主构造函数：Primary-Constructor"><a href="#主构造函数：Primary-Constructor" class="headerlink" title="主构造函数：Primary Constructor"></a>主构造函数：Primary Constructor</h1><p>scala的主构造函数指的是在定义Class时声明的那个函数. 函数的参数就是类的参数,函数体就是类定义中可执行的部分.<br>(感觉连类也像是一个函数)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class MongoClient(var host: String, var port: Int) &#123;</span><br><span class="line">  def this() &#x3D; &#123; &#x2F;&#x2F; 重载构造函数</span><br><span class="line">    this(null, 0)</span><br><span class="line">    host &#x3D; &quot;127.0.0.1&quot;</span><br><span class="line">    port &#x3D; 27017</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Trait-特征"><a href="#Trait-特征" class="headerlink" title="Trait 特征"></a>Trait 特征</h1><blockquote>
<p>带有方法实现\字段的接口,没有参数 (使用的extends关键字,因此更像是抽象类)<br>“堆栈化”（叠加）继承特性: 从左到右入栈,从右到左出栈解析;忽略已经出现的方法.(右侧优先深度优先)</p>
</blockquote>
<ul>
<li>特征构造顺序(与序列化相反)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">父类构造器</span><br><span class="line">特征构造器(从右到左)</span><br><span class="line">每个特征当中，父特征先被构造</span><br><span class="line">子类构造器</span><br></pre></td></tr></table></figure>
Trait与接口的区别在于,Trait可以直接添加到对象上,而不用在<code>class</code>中声明.</li>
<li>示例如下<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">trait Debugger &#123;</span><br><span class="line">  def log(message: String) &#123;</span><br><span class="line">    println(message)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Worker &#123;</span><br><span class="line">  def work() &#123;</span><br><span class="line">    println(&quot;working innocently&quot;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">object TestLogger extends App &#123;</span><br><span class="line">  val worker &#x3D; new Worker() with Debugger &#x2F;&#x2F; 这里直接附加trait</span><br><span class="line">  worker.work()</span><br><span class="line">  worker.log(&quot;log here&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





</li>
</ul>
<h1 id="Case-Class"><a href="#Case-Class" class="headerlink" title="Case Class"></a>Case Class</h1><p>主构造函数的所有参数会被自动限定为val,也就意味着这个字段是外部可读的。<br><code>Case Class</code>可以方便得用于DTO(或者叫V0,数据传输对象)的创建,当你希望设计一个类只是作为数据载体的时候.</p>
<p>scala编译器会为case class自动生成一个伴生对象,为class生成4个常用方法:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">equals</span><br><span class="line">hashcode</span><br><span class="line">toString</span><br><span class="line">copy</span><br><span class="line">&#x2F;&#x2F; copy方法会基于当前实例的所有字段值复制一个新的实例并返回</span><br></pre></td></tr></table></figure>
<p>为伴生对象object生成2个常用方法:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apply</span><br><span class="line">unapply</span><br></pre></td></tr></table></figure>
<p>上述行为的实现,从编译后的代码看,似乎只写了这些:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">with scala.Product with scala.Serializable</span><br></pre></td></tr></table></figure>
<p>可能这些方法就在Product和Serializable里? 点进去看是空的.</p>
<ul>
<li>sealed关键字<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;sealed关键字声明其他trait都不能再继承当前的trait</span><br><span class="line">&#x2F;&#x2F;除非这个类与声明的这个trait在同一个class文件里!</span><br><span class="line">sealed trait QueryOption</span><br><span class="line">case object NoOption extends QueryOption</span><br><span class="line">case class Sort(sorting: DBObject, anotherOption: QueryOption) extends QueryOption</span><br><span class="line">case class Skip(number: Int, anotherOption: QueryOption) extends QueryOption </span><br><span class="line">case class Limit(limit: Int, anotherOption: QueryOption) extends QueryOption</span><br></pre></td></tr></table></figure>
case class的companion object是隐式自动生成的<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">case class Person(firstName:String, lastName: String)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;注意：case class的companion object是隐式自动生成的！下面的代码并不是手动编写的。</span><br><span class="line">object Person &#123;</span><br><span class="line">    def apply(firstName:String, lastName:String) &#x3D; &#123;</span><br><span class="line">        new Person(firstName, lastName)</span><br><span class="line">    &#125;</span><br><span class="line">    def unapply(p:Person): Option[(String, String)] &#x3D;</span><br><span class="line">        Some((p.firstName, p.lastName))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="unapply"><a href="#unapply" class="headerlink" title="unapply"></a>unapply</h1><p>Scala 提取器是一个带有unapply方法的对象。unapply方法算是apply方法的反向操作：unapply接受一个对象，然后从对象中提取值，提取的值通常是用来构造该对象的值。</p>
<h1 id="泛型之-Invariant-与-Covariance-Contravariance"><a href="#泛型之-Invariant-与-Covariance-Contravariance" class="headerlink" title="泛型之 Invariant 与 Covariance/Contravariance"></a>泛型之 Invariant 与 Covariance/Contravariance</h1><blockquote>
<p>默认情况下,scala的泛型是Invariant,也就是强类型,不允许自动上下转型.</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; +A 表示自动允许向上转型</span><br><span class="line">&#x2F;&#x2F; -A 表示接受向下转型</span><br><span class="line">case class Item[+A](a: A) &#123; def get: A &#x3D; a &#125;</span><br><span class="line">val c: Item[Car] &#x3D; new Item[Volvo](new Volvo) </span><br><span class="line">&#x2F;&#x2F; 用父类指针接了子类</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; -A 表示接受向下转型</span><br><span class="line">case class Check[-A]() &#123;def check(a: A) &#123;&#125;&#125;</span><br><span class="line">val d:Check[VolvoWagon]&#x3D; new Check[Volvo]() </span><br><span class="line">&#x2F;&#x2F; 用子类指针接了父类</span><br></pre></td></tr></table></figure>


<h1 id="Null-None-Nothing-Nil"><a href="#Null-None-Nothing-Nil" class="headerlink" title="Null/None/Nothing/Nil"></a>Null/None/Nothing/Nil</h1><blockquote>
</blockquote>
<ol>
<li><p><code>null</code>是<code>Null</code>的唯一对象。<br><code>Null</code>是所有引用类型的子类,<br><code>Any</code>&lt;-<code>AnyRef</code>&lt;-<code>Null</code>;</p>
</li>
<li><p><code>Nothing</code>是所有类型的子类.返回值是<code>Unit</code>表示没有返回值,返回值是<code>Nothing</code>表示不但没有返回值,而且还不返回,要想离开这个函数只能抛异常;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如果一个函数可以返回Int,也可以抛异常,则这个函数的返回类型写Int即可. 因为Nothing也是Int的子类, 返回类型可以接受向上转型.</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>None</code>是<code>Option</code>的子类. <code>Option</code>&lt;-<code>Some</code>/<code>None</code>;</p>
</li>
<li><p><code>Nil</code>是所有List[T]的子类,表示空列表. (List的声明为List[+A],接受向上转型)</p>
</li>
</ol>
<h1 id="type-关键字"><a href="#type-关键字" class="headerlink" title="type 关键字"></a>type 关键字</h1><blockquote>
<p>scala里的类型，除了在定义class,trait,object时会产生类型，还可以通过type关键字来声明类型。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">def typeOf[T](v: T): String &#x3D; v match &#123;</span><br><span class="line">    case _: Int &#x3D;&gt; &quot;Int&quot;</span><br><span class="line">    case _: String &#x3D;&gt; &quot;String&quot;</span><br><span class="line">    case _ &#x3D;&gt; &quot;Unknown&quot;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  def test1(): Unit &#x3D; &#123;</span><br><span class="line">    type S &#x3D; String</span><br><span class="line">    val objS:S&#x3D;&quot;string of S&quot;</span><br><span class="line">    println(typeOf(objS))</span><br><span class="line">    println(classOf[S])</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>



<h1 id="lt-与-gt"><a href="#lt-与-gt" class="headerlink" title="&lt;: 与 &gt;:"></a>&lt;: 与 &gt;:</h1><p>类型上确界和类型下确界</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; T &lt;: Animal的意思是：T必须是Animal的子类(&lt;&#x3D;)</span><br><span class="line">def biophony[T &lt;: Animal](things: Seq[T]): Unit &#x3D; things foreach (_.sound())</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; &gt;: 传入 Animal的父类或自身, 此时若传入子类,则会被自动向上转型成Animal指针,但实际调用的依然是子类方法</span><br><span class="line">def biophony[T &gt;: Animal](things: Seq[T]) &#x3D; things</span><br></pre></td></tr></table></figure>
<h1 id="Mutable-和-Immutable"><a href="#Mutable-和-Immutable" class="headerlink" title="Mutable 和 Immutable"></a>Mutable 和 Immutable</h1><blockquote>
<p>Mutable: 被修改时返回原对象引用<br>Immutable: 被修改时返回新对象的引用</p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://xiaoyue26.github.io/2017/05/17/scala%E7%AC%94%E8%AE%B0/" data-id="ck96cxplu004pmaam3e0h6i2s" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/scala/" rel="tag">scala</a></li></ul>

    </footer>
  </div>
  
    
 
<script src="/jquery/jquery.min.js"></script>

  <div id="random_posts">
    <h2>推荐文章</h2>
    <div class="random_posts_ul">
      <script>
          var random_count =4
          var site = {BASE_URI:'/'};
          function load_random_posts(obj) {
              var arr=site.posts;
              if (!obj) return;
              // var count = $(obj).attr('data-count') || 6;
              for (var i, tmp, n = arr.length; n; i = Math.floor(Math.random() * n), tmp = arr[--n], arr[n] = arr[i], arr[i] = tmp);
              arr = arr.slice(0, random_count);
              var html = '<ul>';
            
              for(var j=0;j<arr.length;j++){
                var item=arr[j];
                html += '<li><strong>' + 
                item.date + ':&nbsp;&nbsp;<a href="' + (site.BASE_URI+item.uri) + '">' + 
                (item.title || item.uri) + '</a></strong>';
                if(item.excerpt){
                  html +='<div class="post-excerpt">'+item.excerpt+'</div>';
                }
                html +='</li>';
                
              }
              $(obj).html(html + '</ul>');
          }
          $('.random_posts_ul').each(function () {
              var c = this;
              if (!site.posts || !site.posts.length){
                  $.getJSON(site.BASE_URI + 'js/posts.js',function(json){site.posts = json;load_random_posts(c)});
              } 
               else{
                load_random_posts(c);
              }
          });
      </script>
    </div>
  </div>

    
<nav id="article-nav">
  
    <a href="/2017/09/28/sqoop%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">上一篇</strong>
      <div class="article-nav-title">
        
          sqoop学习笔记
        
      </div>
    </a>
  
  
    <a href="/2017/04/24/spark%E7%AC%94%E8%AE%B0/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">下一篇</strong>
      <div class="article-nav-title">spark笔记</div>
    </a>
  
</nav>

  
</article>
 
     
  <div class="comments" id="comments">
    
     
       
      <div id="cloud-tie-wrapper" class="cloud-tie-wrapper"></div>
    
       
      
      
           <div id="gitment_comments"></div>
    
      
  </div>
 
  

</section>
           
    <aside id="sidebar">
  
    

  
    
    <div class="widget-wrap">
    
      <div class="widget" id="toc-widget-fixed">
      
        <strong class="toc-title">文章目录</strong>
        <div class="toc-widget-list">
              <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#运算优先级"><span class="toc-number">1.</span> <span class="toc-text">运算优先级:</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#数据类型"><span class="toc-number">2.</span> <span class="toc-text">数据类型</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#变量与常量"><span class="toc-number">3.</span> <span class="toc-text">变量与常量:</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#访问修饰符"><span class="toc-number">4.</span> <span class="toc-text">访问修饰符</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#下划线的用法"><span class="toc-number">5.</span> <span class="toc-text">下划线的用法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#scala的函数和方法"><span class="toc-number">6.</span> <span class="toc-text">scala的函数和方法:</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#传参"><span class="toc-number">7.</span> <span class="toc-text">传参:</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#List符号函数"><span class="toc-number">8.</span> <span class="toc-text">List符号函数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#actor"><span class="toc-number">9.</span> <span class="toc-text">actor</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#函数和方法-def和val区别"><span class="toc-number">10.</span> <span class="toc-text">函数和方法,def和val区别:</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#object和class的区别"><span class="toc-number">11.</span> <span class="toc-text">object和class的区别</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#scala类修饰符"><span class="toc-number">12.</span> <span class="toc-text">scala类修饰符</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#主构造函数：Primary-Constructor"><span class="toc-number">13.</span> <span class="toc-text">主构造函数：Primary Constructor</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Trait-特征"><span class="toc-number">14.</span> <span class="toc-text">Trait 特征</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Case-Class"><span class="toc-number">15.</span> <span class="toc-text">Case Class</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#unapply"><span class="toc-number">16.</span> <span class="toc-text">unapply</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#泛型之-Invariant-与-Covariance-Contravariance"><span class="toc-number">17.</span> <span class="toc-text">泛型之 Invariant 与 Covariance&#x2F;Contravariance</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Null-None-Nothing-Nil"><span class="toc-number">18.</span> <span class="toc-text">Null&#x2F;None&#x2F;Nothing&#x2F;Nil</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#type-关键字"><span class="toc-number">19.</span> <span class="toc-text">type 关键字</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#lt-与-gt"><span class="toc-number">20.</span> <span class="toc-text">&lt;: 与 &gt;:</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Mutable-和-Immutable"><span class="toc-number">21.</span> <span class="toc-text">Mutable 和 Immutable</span></a></li></ol>
          </div>
      </div>
    </div>

  
    

  
    
  
    
  
    

  
</aside>

      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-left">
      &copy; 2014 - 2022 风梦七&nbsp;|&nbsp;
      主题 <a href="https://github.com/giscafer/hexo-theme-cafe/" target="_blank">Cafe</a>
    </div>
     <div id="footer-right">
      联系方式&nbsp;|&nbsp;296671657@qq.com
    </div>
  </div>
</footer>
 
<script src="/jquery/jquery.min.js"></script>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">首页</a>
  
    <a href="/archives" class="mobile-nav-link">归档</a>
  
    <a href="/about" class="mobile-nav-link">关于</a>
  
</nav>
    <img class="back-to-top-btn" src="/images/fly-to-top.png"/>
<script>
// Elevator script included on the page, already.
window.onload = function() {
  var elevator = new Elevator({
    selector:'.back-to-top-btn',
    element: document.querySelector('.back-to-top-btn'),
    duration: 1000 // milliseconds
  });
}
</script>
      

  
    <script>
      var cloudTieConfig = {
        url: document.location.href, 
        sourceId: "",
        productKey: "e2fb4051c49842688ce669e634bc983f",
        target: "cloud-tie-wrapper"
      };
    </script>
    <script src="https://img1.ws.126.net/f2e/tie/yun/sdk/loader.js"></script>
    

  







<!-- author:forvoid begin -->
<!-- author:forvoid begin -->

  <link rel="stylesheet" href="https://jjeejj.github.io/css/gitment.css">
  <script src="https://www.wenjunjiang.win/js/gitment.js"></script>
  <script>
  var gitment = new Gitment({
    // id: '页面 ID', // 可选。默认为 location.href
    owner: 'xiaoyue26',
    repo: 'comment',
    oauth: {
    client_id: 'cfe53b938f0d4c782371',
    client_secret: 'f96e68ae1103e7500c106aa3656a8bb31fe0ee99',
    }
  })
  gitment.render(document.getElementById("gitment_comments"))
</script>


<!-- author:forvoid end -->

<!-- author:forvoid begin -->

<!-- author:forvoid end -->

<!-- author:forvoid end -->


  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      })
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      })
    </script>
    <script type="text/javascript" src="https://cdn.rawgit.com/mathjax/MathJax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


 
<script src="/js/is.js"></script>



  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>


<script src="/js/elevator.js"></script>

  </div>
</body>
</html>