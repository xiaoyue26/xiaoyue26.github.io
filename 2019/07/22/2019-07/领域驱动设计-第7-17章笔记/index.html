<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>领域驱动设计-第7~17章笔记 | 笔记本</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="第七章 实例：货物运输系统1. 需求 跟踪货物的主要处理部署； 预约货物； 货物到达某一处理步骤时自动发送发票。  领域语言货物: cargo客户: customer规格: specification运输动作: carrier movement  一个cargo(货物)涉及到多个customer(客户)，每个customer承担不同角色。 cargo的运送目标已指定； 由一系列满足specific">
<meta property="og:type" content="article">
<meta property="og:title" content="领域驱动设计-第7~17章笔记">
<meta property="og:url" content="http://xiaoyue26.github.io/2019/07/22/2019-07/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1-%E7%AC%AC7-17%E7%AB%A0%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="笔记本">
<meta property="og:description" content="第七章 实例：货物运输系统1. 需求 跟踪货物的主要处理部署； 预约货物； 货物到达某一处理步骤时自动发送发票。  领域语言货物: cargo客户: customer规格: specification运输动作: carrier movement  一个cargo(货物)涉及到多个customer(客户)，每个customer承担不同角色。 cargo的运送目标已指定； 由一系列满足specific">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://xiaoyue26.github.io/images/2019-07/chapter7_class.png">
<meta property="og:image" content="http://xiaoyue26.github.io/images/2019-07/agg_root.png">
<meta property="og:image" content="http://xiaoyue26.github.io/images/2019-07/repository.png">
<meta property="og:image" content="http://xiaoyue26.github.io/images/2019-07/handling_event.png">
<meta property="og:image" content="http://xiaoyue26.github.io/images/2019-07/module.png">
<meta property="og:image" content="http://xiaoyue26.github.io/images/2019-07/breakthrough.png">
<meta property="og:image" content="http://xiaoyue26.github.io/images/2019-07/overbook.png">
<meta property="og:image" content="http://xiaoyue26.github.io/images/2019-07/specification.png">
<meta property="og:image" content="http://xiaoyue26.github.io/images/2019-07/deep_model.png">
<meta property="og:image" content="http://xiaoyue26.github.io/images/2019-07/paint1.png">
<meta property="og:image" content="http://xiaoyue26.github.io/images/2019-07/paint2.png">
<meta property="og:image" content="http://xiaoyue26.github.io/images/2019-07/and_spec.png">
<meta property="og:image" content="http://xiaoyue26.github.io/images/2019-07/cheap_spec.png">
<meta property="og:image" content="http://xiaoyue26.github.io/images/2019-07/share_pie.png">
<meta property="og:image" content="http://xiaoyue26.github.io/images/2019-07/share_pie_vo.png">
<meta property="og:image" content="http://xiaoyue26.github.io/images/2019-07/class11_1.png">
<meta property="og:image" content="http://xiaoyue26.github.io/images/2019-07/class11_7.png">
<meta property="og:image" content="http://xiaoyue26.github.io/images/2019-07/policy.png">
<meta property="og:image" content="http://xiaoyue26.github.io/images/2019-07/composite.png">
<meta property="og:image" content="http://xiaoyue26.github.io/images/2019-07/context_map.png">
<meta property="og:image" content="http://xiaoyue26.github.io/images/2019-07/bounded_context.png">
<meta property="og:image" content="http://xiaoyue26.github.io/images/2019-07/context_map2.png">
<meta property="og:image" content="http://xiaoyue26.github.io/images/2019-07/refine.png">
<meta property="og:image" content="http://xiaoyue26.github.io/images/2019-07/layer_struct.png">
<meta property="og:image" content="http://xiaoyue26.github.io/images/2019-07/layer1.png">
<meta property="og:image" content="http://xiaoyue26.github.io/images/2019-07/layer2.png">
<meta property="og:image" content="http://xiaoyue26.github.io/images/2019-07/knowledge_level.png">
<meta property="og:image" content="http://xiaoyue26.github.io/images/2019-07/domain_all.png">
<meta property="og:image" content="http://xiaoyue26.github.io/images/2019-07/layer_all2.png">
<meta property="article:published_time" content="2019-07-22T02:09:04.000Z">
<meta property="article:modified_time" content="2020-04-18T15:38:11.286Z">
<meta property="article:author" content="风梦七">
<meta property="article:tag" content="DDD">
<meta property="article:tag" content="设计">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://xiaoyue26.github.io/images/2019-07/chapter7_class.png">
  
    <link rel="alternate" href="/atom.xml" title="笔记本" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    
  
  
<link rel="stylesheet" href="/css/style.css">

  

<meta name="generator" content="Hexo 4.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    
    <div id="header-inner" class="inner">
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://xiaoyue26.github.io"></form>
      </div>
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">首页</a>
        
          <a class="main-nav-link" href="/archives">归档</a>
        
          <a class="main-nav-link" href="/about">关于</a>
        
      </nav>
      
    </div>
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">笔记本</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">风梦七</a>
        </h2>
      
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-2019-07/领域驱动设计-第7-17章笔记" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/22/2019-07/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1-%E7%AC%AC7-17%E7%AB%A0%E7%AC%94%E8%AE%B0/" class="article-date">
  <time datetime="2019-07-22T02:09:04.000Z" itemprop="datePublished">2019-07-22</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/java/">java</a>►<a class="article-category-link" href="/categories/java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      领域驱动设计-第7~17章笔记
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <h1 id="第七章-实例：货物运输系统"><a href="#第七章-实例：货物运输系统" class="headerlink" title="第七章 实例：货物运输系统"></a>第七章 实例：货物运输系统</h1><h2 id="1-需求"><a href="#1-需求" class="headerlink" title="1. 需求"></a>1. 需求</h2><ol>
<li>跟踪货物的主要处理部署；</li>
<li>预约货物；</li>
<li>货物到达某一处理步骤时自动发送发票。</li>
</ol>
<h2 id="领域语言"><a href="#领域语言" class="headerlink" title="领域语言"></a>领域语言</h2><p>货物: cargo<br>客户: customer<br>规格: specification<br>运输动作: carrier movement</p>
<ol>
<li>一个cargo(货物)涉及到多个customer(客户)，每个customer承担不同角色。</li>
<li>cargo的运送目标已指定；</li>
<li>由一系列满足specification(规格)的carrier movement(运输动作)来完成运送目标。</li>
</ol>
<img src="/images/2019-07/chapter7_class.png" class="" width="800" height="1200" title="chapter7_class">
<p>上述类图中Customer包括托运人、收货人、快递员等角色。<br>（都是我们软件要服务的客户）<br>Handling Event可以细分为不同种类的事件（装货、卸货、提货…）</p>
<h2 id="隔离领域"><a href="#隔离领域" class="headerlink" title="隔离领域"></a>隔离领域</h2><p>要把领域层划分出来，首先识别出3个用户层的应用程序功能：</p>
<ol>
<li>跟踪查询: 访问某个cargo过去、现在的处理情况;(Delivery History)</li>
<li>预定: 注册一个cargo；</li>
<li>事件日志记录: 为1准备信息。<br>三个应用层类：<br>Tracking Query,Booking Application,Incident Logging Applicatoin。<br>这三个应用层类只是协调者，负责向领域层提问。</li>
</ol>
<h2 id="区分Entity和Value-Object"><a href="#区分Entity和Value-Object" class="headerlink" title="区分Entity和Value Object"></a>区分Entity和Value Object</h2><p>看对象是必须被跟踪的实体还是仅表示一个基本值。</p>
<p><code>Customer</code>: Entity<br><code>Cargo</code>: Entity<br><code>Handling Event</code>和<code>Carrier Movement</code>: Entity<br><code>Delivery History</code>: Entity<br><code>Delivery Specification</code>: Value Object: 可替换，货物满足的规则只要等效即可，并不一定需要是某一个id的规则。<br><code>Role</code>: Value Object.</p>
<h2 id="设计关联"><a href="#设计关联" class="headerlink" title="设计关联"></a>设计关联</h2><p>双向关联往往会产生问题，因此要研究把双向关联转换成单向关联。<br>好处：</p>
<ol>
<li>双向关联=&gt;单向关联：降低出错概率；</li>
<li>研究遍历方向过程中：让领域更加清晰。</li>
</ol>
<p>把低频需求的遍历方向交给数据库实现；<br>留下的单向遍历作为领域层的单向引用。</p>
<h2 id="Aggregate边界"><a href="#Aggregate边界" class="headerlink" title="Aggregate边界"></a>Aggregate边界</h2><p>Customer: 根<br>Location: 根<br>Carrier Movement: 根<br>Cargo: 根,它的边界可以囊括所有因它才存在的弱实体: <code>Delivery History</code>,<code>Delivery Specification</code>。<br>(分发历史、分发规则(VO)、处理事件)</p>
<p><code>Handling Event</code>： </p>
<ol>
<li>查找某个<code>Delivery History</code>中的<code>Handling Event</code>;</li>
<li>查找某次<code>Carrier Movement</code>的操作，需要<code>Handling Event</code>的id，需要<code>Handling Event</code>作为根。</li>
</ol>
<h2 id="创建Repository"><a href="#创建Repository" class="headerlink" title="创建Repository"></a>创建Repository</h2><p>作为根的Entity创建repository.<br>（其他就不创建了，精简类的数量）</p>
<img src="/images/2019-07/agg_root.png" class="" width="800" height="1200" title="agg_root">

<p>如图有7个Entity,5个根。<br>应对的需求:</p>
<ol>
<li>用户选择承担不同角色：发货方、收货人；Customer;</li>
<li>货物目的地需要Location;</li>
<li>用户需要查找装货的Carrier Movement;</li>
<li>用户需要输入系统哪个Cargo完成了装货: Cargo;</li>
<li>Handling Event的需求待定。<br>如下图是加上了repository后：<img src="/images/2019-07/repository.png" class="" width="800" height="1200" title="repository">

</li>
</ol>
<h2 id="用例"><a href="#用例" class="headerlink" title="用例"></a>用例</h2><h3 id="1-更改目的地"><a href="#1-更改目的地" class="headerlink" title="1. 更改目的地"></a>1. 更改目的地</h3><p><code>Delivery Specification</code>是个VO，可以直接创建一个新的，替换旧的即可。</p>
<h2 id="2-重复预订"><a href="#2-重复预订" class="headerlink" title="2. 重复预订"></a>2. 重复预订</h2><p>常常会需要基于旧的cargo作为原型创建新的cargo。<br>（重复下单同一种商品）</p>
<ol>
<li>Delivery History: 应创建新、空的；（其他弱实体同）</li>
<li>Customer Roles: 和原来的cargo引用同样的运输角色Customer。</li>
<li>Tracking ID: 新增。</li>
</ol>
<p>总结三类：</p>
<ol>
<li>弱实体、边界内：创建新的、空的。</li>
<li>边界外：可以引用相同的。</li>
<li>根：新增（自增id）。</li>
</ol>
<h2 id="从需求频次出发简化设计"><a href="#从需求频次出发简化设计" class="headerlink" title="从需求频次出发简化设计"></a>从需求频次出发简化设计</h2><img src="/images/2019-07/handling_event.png" class="" width="800" height="1200" title="handling_event">
<p>Handling Event相关需求的频次：<br>创建、新增：高频<br>查询： 低频</p>
<p>由于查询<code>Delivery History</code>中的<code>Handling Event</code>是低频需求，因此可以考虑不在<code>Delivery History</code>中直接存储<code>Handling Event</code>数组，这样节省了存储开销，也降低了维护一致性的成本。这里创建、新增<code>Handling Event</code>是高频的，因此如果<code>Delivery History</code>中是存储数组，要频繁维护一致性，而且是Agg边界外的改动引起Agg边界内的变动，属于不合理设计。</p>
<p>综上：可将<code>Delivery History</code>中的<code>Handling Event</code>改为即时查询接口，而不是直接存储数组。</p>
<p>优点：使Handling Event的新建变得简单，不会与Cargo Agg发生争用。</p>
<blockquote>
<p>换句话说，类似于我们平时设计表字段的时候，高频查询的字段直接放到同一个表里头（可能有时候会反三范式），低频的抽出来扔另一张表(弱实体)里。原文这里是对象级的讨论。</p>
</blockquote>
<h2 id="Module：模块化"><a href="#Module：模块化" class="headerlink" title="Module：模块化"></a>Module：模块化</h2><img src="/images/2019-07/module.png" class="" width="800" height="1200" title="module">
<p>将紧密关联的实体封装到一个模块。</p>
<h2 id="引入新特性：-配额检查"><a href="#引入新特性：-配额检查" class="headerlink" title="引入新特性： 配额检查"></a>引入新特性： 配额检查</h2><p><code>Allocation Checker</code>: 确保高利润的商品能够运输完，确保大部分商品不会因为运力不足退单毁约。</p>
<ul>
<li>输入：</li>
</ul>
<ol>
<li>某cargo: 已经预订了多少; （或这个分类已经预订了多少）</li>
<li>某cargo: 最大预订配额。（或这个分类最大配额）</li>
</ol>
<ul>
<li>输出:<br>是否能继续预订。</li>
</ul>
<h3 id="实现1"><a href="#实现1" class="headerlink" title="实现1"></a>实现1</h3><p>如小猿的做法: 配额是存储在商品信息里头的。<br>(参见warehouse)</p>
<h3 id="实现2"><a href="#实现2" class="headerlink" title="实现2:"></a>实现2:</h3><p>配额是由另一个系统提供的。<br>同一个商品可以属于不同的类别，影响不同层面的配额。<br>这样配额相关属性抽离出来变成一类弱实体。</p>
<h1 id="第三部分-通过重构来加深理解"><a href="#第三部分-通过重构来加深理解" class="headerlink" title="第三部分 通过重构来加深理解"></a>第三部分 通过重构来加深理解</h1><p>目标：巧妙的领域模型<br>手段：不断重构，加深对领域的理解</p>
<h2 id="重构"><a href="#重构" class="headerlink" title="重构"></a>重构</h2><p>重构的定义是在不改变功能的前提下重新设计它。</p>
<p>重构的层次:</p>
<ol>
<li>微重构；（累积成更深层次重构）；// 参见《重构》一书</li>
<li>源于对领域的新认知；</li>
<li>设计模式重构。</li>
</ol>
<h2 id="深层模型"><a href="#深层模型" class="headerlink" title="深层模型"></a>深层模型</h2><p>浅层模型： 在需求文档中确定名词和动词，初始建模；（不够成熟深入）（只有具体元素）<br>深层模型： 穿过领域表象，清楚表达领域专家主要关注点以及最相关知识。（恰当的抽象元素和具体元素）</p>
<h2 id="深层模型与柔性设计"><a href="#深层模型与柔性设计" class="headerlink" title="深层模型与柔性设计"></a>深层模型与柔性设计</h2><p>（柔性设计详见第10章）<br>好的深层模型能方便地支持柔性设计。</p>
<h2 id="发现过程"><a href="#发现过程" class="headerlink" title="发现过程"></a>发现过程</h2><p>（发现过程、捕捉领域核心概念详见第9章）<br>第11章: 分析模式<br>第12章: 设计模式</p>
<h1 id="第八章-突破"><a href="#第八章-突破" class="headerlink" title="第八章 突破"></a>第八章 突破</h1><img src="/images/2019-07/breakthrough.png" class="" width="800" height="1200" title="breakthrough">
<p>如上图所示，重构在某个节点的投入可能会有很大的回报。<br>（如果突然孵化了对项目的最重要理解，会给项目带来重大冲击）<br>即使是小的改进也可以防止系统退化。</p>
<h2 id="突破案例"><a href="#突破案例" class="headerlink" title="突破案例"></a>突破案例</h2><p>背景：<br>管理银团贷款的程序。<br>基本需求：<br>跟踪支持整个贷款过程。</p>
<h3 id="大致过程"><a href="#大致过程" class="headerlink" title="大致过程"></a>大致过程</h3><p>原先的设计绑定了放贷股份和信贷股份，错误的理解。<br>突然有一天明白了两者基本无关联，重新设计了模型，得到突破，快速迭代。</p>
<p>总结： 好的模型能让无技术背景的业务方也能快速理解。（而不是抱怨专业性太强看不懂）</p>
<h1 id="第九章-深层模型"><a href="#第九章-深层模型" class="headerlink" title="第九章 深层模型"></a>第九章 深层模型</h1><h2 id="倾听语言"><a href="#倾听语言" class="headerlink" title="倾听语言"></a>倾听语言</h2><p>线索：</p>
<ol>
<li>用户长期抱怨、频繁查询的场景，可能是遗漏了重要领域对象。</li>
<li>领域专家试图纠正你的术语；</li>
<li>用户感到困惑的名词。</li>
<li>始终无法形成DSL。(讨论中的术语经常超出DSL范围)</li>
</ol>
<h2 id="会计示例"><a href="#会计示例" class="headerlink" title="会计示例"></a>会计示例</h2><p>主要讲的是学了会计学以后模型更合理，深层。</p>
<h2 id="约束的提炼"><a href="#约束的提炼" class="headerlink" title="约束的提炼"></a>约束的提炼</h2><p>约束包括显式规则、隐式规则。<br>遇到如下情况时，应将隐式规则提炼到显式对象(显式规则)：</p>
<ol>
<li>计算约束所需数据从定义上不属于这个对象；</li>
<li>相关规则在多个对象出现，代码重复；</li>
<li>设计和需求围绕着这些规则，而这些约束却分散在过程代码中。</li>
</ol>
<h3 id="将规则显式提炼的案例：超订策略"><a href="#将规则显式提炼的案例：超订策略" class="headerlink" title="将规则显式提炼的案例：超订策略"></a>将规则显式提炼的案例：超订策略</h3><img src="/images/2019-07/overbook.png" class="" width="800" height="1200" title="overbook">
<p>如上图voyage表示实际座席、cargo表示售出货物。<br>同时引入overbooking policy来显式封装超订的规则约束。</p>
<p>两个矛盾的点：</p>
<ol>
<li>不希望过程变成模型的主要部分；</li>
<li>重要的过程则必须显露在模型中。<br>把握这个边界的诀窍：<br>这个过程是否经常被领域专家提起，或者仅作为程序机制的一部分。</li>
</ol>
<h2 id="模式：-Specification"><a href="#模式：-Specification" class="headerlink" title="模式： Specification"></a>模式： Specification</h2><img src="/images/2019-07/specification.png" class="" width="800" height="1200" title="specification">
<p>一般性的，可以将约束、规则提取出来，作为领域层的Value Object。<br>用途包括：</p>
<ul>
<li>选择</li>
<li>过滤</li>
<li>按规格创建/生成对象。</li>
</ul>
<h1 id="第十章-柔性设计"><a href="#第十章-柔性设计" class="headerlink" title="第十章 柔性设计"></a>第十章 柔性设计</h1><p>柔性设计是深层模型的补充。<br>当我们把隐式概念抽离显式表达出来以后，就有原料来进行柔性设计了。</p>
<p>过多抽象层、间接设计=&gt;过度设计<br>适当抽象层、间接设计=&gt;柔性设计</p>
<p>简单并不容易做到。<br>柔性设计需要揭示深层次的底层模型，把它潜在的部分明确展示出来。</p>
<p>具体方法包括如下：</p>
<h2 id="1-模式：表现意图的接口-Intention-Revealing-Interface"><a href="#1-模式：表现意图的接口-Intention-Revealing-Interface" class="headerlink" title="1. 模式：表现意图的接口(Intention-Revealing Interface)"></a>1. 模式：表现意图的接口(Intention-Revealing Interface)</h2><img src="/images/2019-07/deep_model.png" class="" width="800" height="1200" title="deep_model">
<p>Intention-Revealing Interface: 表现意图的接口<br>有了它以后能够区分出：<br>Side-Effect-Freefunction: 无副作用的函数<br>StandAloneClass: 松耦合对象<br>Conceptual Contours: 概念边界\概念轮廓<br>Closeure of Operation: 闭合操作<br>甚至能基于接口直接编写单元测试中的断言。<br>（有时候可能无法达到这么理想，需要在单元测试中写Assert来进一步注释）</p>
<p>设计人员的客户包括其他合作开发人员。<br>接口中包含更多信息时，开发人员可以更有效地使用对象。<br>（否则就必须深入研究对象的内部机制、理解细节，失去了封装的价值）</p>
<p>接口设计重点：<br>给出意图、副作用、作用；<br>但无需给出具体实现细节。</p>
<h2 id="2-模式：无副作用函数（Size-Effect-free-function）"><a href="#2-模式：无副作用函数（Size-Effect-free-function）" class="headerlink" title="2. 模式：无副作用函数（Size-Effect-free function）"></a>2. 模式：无副作用函数（Size-Effect-free function）</h2><p>通过区分有无副作用，可以进一步降低查看底层实现的开销。<br>常见的无副作用操作：查询。<br>可以通过VO对象把一些操作也转化成无副作用。</p>
<p>一些复杂操作可以进一步分解成：有副作用、无副作用的两个操作。</p>
<p>挖掘深层模型案例：<br>油漆：</p>
<img src="/images/2019-07/paint1.png" class="" width="800" height="1200" title="paint1">
<p>第一步：把接口意图明确（混合两种油漆）</p>
<img src="/images/2019-07/paint2.png" class="" width="800" height="1200" title="paint2">
<p>第二步：原来的方法只修改paint1，不改paint2；不符合常识，后继开发人员也无法理解。改成深层模型，原来的paint改为不可变（Stock Paint），单独引入被混合后的油漆(Mixed Paint)。</p>
<h2 id="3-模式：-Assertion"><a href="#3-模式：-Assertion" class="headerlink" title="3. 模式： Assertion"></a>3. 模式： Assertion</h2><p>用断言把副作用明确表示出来。</p>
<h2 id="4-概念轮廓、概念边界"><a href="#4-概念轮廓、概念边界" class="headerlink" title="4. 概念轮廓、概念边界"></a>4. 概念轮廓、概念边界</h2><p>我们应该对每个依赖关系提出质疑，直到证实它确实表示对象的基本概念。<br>尽量把模块之间的依赖重构为模块内依赖；<br>模块内依赖重构为尽量少的对象之间的依赖。</p>
<h2 id="5-低耦合的对象"><a href="#5-低耦合的对象" class="headerlink" title="5. 低耦合的对象"></a>5. 低耦合的对象</h2><h2 id="6-模式：闭合操作-Closure-of-Operation"><a href="#6-模式：闭合操作-Closure-of-Operation" class="headerlink" title="6. 模式：闭合操作 Closure of Operation"></a>6. 模式：闭合操作 Closure of Operation</h2><p>实数集合上进行加减乘除后结果仍在实数集合中，这就是闭合操作。<br>像刚才油漆的混合操作之后得到的仍然是油漆，这就极大降低了依赖。</p>
<h2 id="7-声明式设计"><a href="#7-声明式设计" class="headerlink" title="7. 声明式设计"></a>7. 声明式设计</h2><p>声明式语言常见的有sql、各种配置文件。<br>比如把nginx的配置文件nginx.conf看作一种语言，则它是声明式的。(无法限定过程细节)<br>声明式设计就是写一段DSL，然后生成一份满足声明的约束条件的代码。比如mybatis里头用工具(jar包)+xml配置生成orm相关java代码。</p>
<ul>
<li>好处: 避免开发人员去写单调乏味容易出错的代码；</li>
<li>坏处: 生成的代码不灵活,声明可能不足以表达一切。</li>
</ul>
<h2 id="8-声明式设计风格"><a href="#8-声明式设计风格" class="headerlink" title="8. 声明式设计风格"></a>8. 声明式设计风格</h2><p>将上述几个模式组合以后，可以使用声明式设计风格。</p>
<h3 id="声明式风格的Specification"><a href="#声明式风格的Specification" class="headerlink" title="声明式风格的Specification"></a>声明式风格的Specification</h3><h4 id="1-用逻辑运算组合Specification-闭包操作模式"><a href="#1-用逻辑运算组合Specification-闭包操作模式" class="headerlink" title="1.用逻辑运算组合Specification (闭包操作模式)"></a>1.用逻辑运算组合Specification (闭包操作模式)</h4><p>运算组合结果还是Specification</p>
<img src="/images/2019-07/and_spec.png" class="" width="800" height="1200" title="and_spec">
<p>如图,可以通过子类的方法实现这种设计。（开销很大）</p>
<img src="/images/2019-07/cheap_spec.png" class="" width="800" height="1200" title="cheap_spec">
<p>如图，还可以通过逻辑算法来实现这种设计，这个栈的含义是:<br><code>and ( not (armored) , not(ventilated))</code><br>这种实现的优点: 对象个数少,内存使用效率高;<br>这种实现的缺点: 需要更高级的开发人员。</p>
<h2 id="9-切入问题的角度-（如何优化设计）"><a href="#9-切入问题的角度-（如何优化设计）" class="headerlink" title="9. 切入问题的角度 （如何优化设计）"></a>9. 切入问题的角度 （如何优化设计）</h2><h3 id="1-分割子领域"><a href="#1-分割子领域" class="headerlink" title="1. 分割子领域"></a>1. 分割子领域</h3><h3 id="2-尽可能利用已有的形式"><a href="#2-尽可能利用已有的形式" class="headerlink" title="2. 尽可能利用已有的形式"></a>2. 尽可能利用已有的形式</h3><p>从头创建一个严密的概念框架不能作为一项日常工作。<br>因此我们经常需要对建立已久的概念系统加以修改和利用。</p>
<h3 id="示例：-股份数学"><a href="#示例：-股份数学" class="headerlink" title="示例： 股份数学"></a>示例： 股份数学</h3><p>还钱=&gt;钱的分配按放贷股份</p>
<p>首先第一步: 把有无副作用的函数分离；(查归查，改归改)<br>3个函数:<br>计算分配方案;<br>执行(分配方案);<br>查询余额。</p>
<h4 id="第二步：把隐式概念变成显式概念"><a href="#第二步：把隐式概念变成显式概念" class="headerlink" title="第二步：把隐式概念变成显式概念"></a>第二步：把隐式概念变成显式概念</h4><img src="/images/2019-07/share_pie.png" class="" width="800" height="1200" title="share_pie">
<p>显式引入股份份额的概念(share_pie)。<br>然后把分配方案的计算委托给share_pie，这样简化了loan对象,可以进行复杂的计算。<br>share_pie可以作为VO（因为计算是无副作用而且通用的）</p>
<h4 id="第三步-引入闭合操作-运算"><a href="#第三步-引入闭合操作-运算" class="headerlink" title="第三步: 引入闭合操作(运算)"></a>第三步: 引入闭合操作(运算)</h4><img src="/images/2019-07/share_pie_vo.png" class="" width="800" height="1200" title="share_pie_vo">
<p>股份的份额运算变成闭合操作，并且由于是VO（不可变），每次返回新的Share pie.</p>
<p>最后把上层调用代码用声明式的风格改写即可。</p>
<p>核心思想： 把复杂计算封装到无状态的VO中。看情况引入闭合逻辑运算，进一步扩充计算能力。</p>
<h1 id="第11章-分析模式的应用"><a href="#第11章-分析模式的应用" class="headerlink" title="第11章 分析模式的应用"></a>第11章 分析模式的应用</h1><h2 id="案例：-账户的利息计算"><a href="#案例：-账户的利息计算" class="headerlink" title="案例： 账户的利息计算"></a>案例： 账户的利息计算</h2><p>需求：</p>
<ol>
<li>计算利息；</li>
<li>跟踪借款、付款、手续费；<br>（两种过账）<br>初始类图:<img src="/images/2019-07/class11_1.png" class="" width="800" height="1200" title="class11_1">

</li>
</ol>
<h3 id="引入复式记账-简化平账的并发问题"><a href="#引入复式记账-简化平账的并发问题" class="headerlink" title="引入复式记账(简化平账的并发问题)"></a>引入复式记账(简化平账的并发问题)</h3><p>加入每次的交易记录(不可变条目)，类似于所有快照都记录。<br>(Transaction)</p>
<h3 id="进一步挖掘需求"><a href="#进一步挖掘需求" class="headerlink" title="进一步挖掘需求"></a>进一步挖掘需求</h3><p>区分“应计项目”(accrual)和实际过账；<br>应记项目：立即发生；<br>实际过账：可以延迟。<br>例如利息可以每天计算，但只在月末过账。（例如夜间批量过账）<br>新的类图:</p>
<img src="/images/2019-07/class11_7.png" class="" width="800" height="1200" title="class11_7">
<p>注意到图中获取利息和费用的函数都是无副作用的。</p>
<h3 id="进一步考察过账需求"><a href="#进一步考察过账需求" class="headerlink" title="进一步考察过账需求"></a>进一步考察过账需求</h3><p>过账的触发时机：</p>
<ol>
<li>立即触发: 每次新增交易(Entry被插入)都触发，进行所有更新；</li>
<li>手动触发：向Account发送命令来触发过账规则；（进行更新）</li>
<li>基于规则触发：由代理驱动。<br>实际实现中可能根据过账的类型来决定触发时机（是否实时到账）。</li>
</ol>
<h1 id="第12章-将设计模式应用于模型"><a href="#第12章-将设计模式应用于模型" class="headerlink" title="第12章 将设计模式应用于模型"></a>第12章 将设计模式应用于模型</h1><p>有些设计模式可以用作领域模式：</p>
<h2 id="Strategy-Policy-模式"><a href="#Strategy-Policy-模式" class="headerlink" title="Strategy(Policy)模式"></a>Strategy(Policy)模式</h2><img src="/images/2019-07/policy.png" class="" width="800" height="1200" title="policy">
<p>模式中有一些可以灵活更换的策略(无状态)。<br>如路径查找中，可以选择时间最短或者成本最低等等策略。</p>
<h2 id="Composite模式"><a href="#Composite模式" class="headerlink" title="Composite模式"></a>Composite模式</h2><img src="/images/2019-07/composite.png" class="" width="800" height="1200" title="composite">
<p>复杂领域建模时，会遇到多个部分组成的重要对象。(可能继续嵌套)<br>例如航线可能由多个航段组成。航段可以进一步划分。</p>
<p>原文: 其他可用的设计模式不再一一列举</p>
<h1 id="第13章-通过重构得到更深层的理解"><a href="#第13章-通过重构得到更深层的理解" class="headerlink" title="第13章 通过重构得到更深层的理解"></a>第13章 通过重构得到更深层的理解</h1><p>(1)以领域为本;<br>(2)用不同的方式看待事物；<br>(3)坚持与领域专家对话。</p>
<h2 id="开始重构"><a href="#开始重构" class="headerlink" title="开始重构"></a>开始重构</h2><p>一段复杂或笨拙的代码：<br>问题的根源在于领域模型中的概念或者关系发生了错误。</p>
<p>另一种例外就是代码很整洁，但是与领域专家的语言不一致，这可能会埋下隐患，因此依然需要重构。</p>
<p>方法：</p>
<ul>
<li>请教领域专家：寻找灵感；</li>
<li>借鉴已有的经验、案例。</li>
<li>不用完全证明修改的合理性后再修改，应该掌握一个度然后持续重构。<br>(类似于物种进化过程中的爆发变化和间断平衡)</li>
</ul>
<h1 id="第四部分：-战略设计"><a href="#第四部分：-战略设计" class="headerlink" title="第四部分： 战略设计"></a>第四部分： 战略设计</h1><p>三个主题：</p>
<ol>
<li>上下文：ContextMap,也就是模块化；(Bounded Context)</li>
<li>精炼: 重点关心项目中最有价值、特殊的方面，其他组件外包；(Core Domain)</li>
<li>大比例结构: 大分层。(4个左右)(Responsibility Layer)</li>
</ol>
<h1 id="第14章-上下文-保持模型的完整性"><a href="#第14章-上下文-保持模型的完整性" class="headerlink" title="第14章 上下文: 保持模型的完整性"></a>第14章 上下文: 保持模型的完整性</h1><p>需要保证模型的内部统一性，不要有模棱两可的意义、规则的冲突。<br>（举个案例两个团队使用同一个模型出错，最后分开成两个不同场景的模型了）</p>
<p>Bounded context: 限界上下文，定义每个模型的应用范围；<br>Context Map: 上下文图，给出项目上下文和它们之间关系的总体视图；</p>
<img src="/images/2019-07/context_map.png" class="" width="800" height="1200" title="ContextMap">
<p>Continuous Integration: 持续集成,小项目使用,模型统一;<br>Shared Kernel: 共享内核;平等团队合作；<br>Customer/Supplier Teams: 上下游合作,有共同的直接上级；<br>Conformist: 跟随者，沿用类似内核；（上游写得不错，直接拿过来增强即可）<br>Open Host Service: 支持多个客户；(与多个外部系统集成时)<br>Seperate Ways: 团队自由工作(没有共同直接上级)；或者上游写得太烂，直接抛弃重写。<br>Anticorruption Layer: 隔离层，单向转换。（与遗留系统集成时）或者上游写得太烂，一边重构一边用。</p>
<h2 id="Bounded-Context"><a href="#Bounded-Context" class="headerlink" title="Bounded Context"></a>Bounded Context</h2><p>类似于细胞膜一样，缩小模型的命名空间、覆盖范围。<br>降低成员之间沟通的成本（DSL中术语太多记不住，洪泛了）</p>
<p>一个模型只在一个上下文中使用。</p>
<p>// Bounded Context和Module还是有所区别。一个是逻辑上的，一个是物理上的。</p>
<p>识别不一致:</p>
<ol>
<li>场景发生变化后：接口不匹配了。</li>
<li>重复的概念和假同源: 使用相同的术语，但其实是不同的模型。</li>
</ol>
<h2 id="Continuous-Integration-持续集成"><a href="#Continuous-Integration-持续集成" class="headerlink" title="Continuous Integration: 持续集成"></a>Continuous Integration: 持续集成</h2><p>在一个Bounded Context中的模型应该持续集成，保持一致性。<br>（小团队、高频交流）</p>
<h2 id="Context-Map-全局视图"><a href="#Context-Map-全局视图" class="headerlink" title="Context Map: 全局视图"></a>Context Map: 全局视图</h2><p>ContextMap同时服务于项目管理和软件设计。<br>甚至要按照它来安排办公室的物理位置。</p>
<h3 id="案例：预订context和运输context"><a href="#案例：预订context和运输context" class="headerlink" title="案例：预订context和运输context"></a>案例：预订context和运输context</h3><img src="/images/2019-07/bounded_context.png" class="" width="800" height="1200" title="bounded_context">
<p>预订Context: 完成Route Specification=&gt;地点代码的转换；<br>运输Context: 完成Node标识=&gt;行程表、航程安排的转换。<br>两个上下文之间的接口非常小，可以由Side_Effect_free function构成，由于<br>同时使用两个上下文，因此可以应用有效的路线安排算法。</p>
<h3 id="其他要点"><a href="#其他要点" class="headerlink" title="其他要点"></a>其他要点</h3><ol>
<li>确定Context的边界；(每个人都知道)</li>
<li>每个上下文应当有名字，方便讨论；(加入DSL)</li>
</ol>
<p>将这两点文档化。</p>
<h3 id="Context-Map中一些常见的模式"><a href="#Context-Map中一些常见的模式" class="headerlink" title="Context Map中一些常见的模式"></a>Context Map中一些常见的模式</h3><p>持续集成模式：<br>紧密集成产品的优秀团队：大的统一的模型</p>
<p>Shared Kernel（共享内核）/Customer-supplier(客户供应商)：</p>
<ul>
<li>团队协调能力有限;</li>
<li>为不同的用户群提供服务;</li>
</ul>
<p>Separate Way(独立自主)模式:</p>
<ul>
<li>集成并不重要时;</li>
</ul>
<p>Open Host Service(开放主机服务)/Anticorruption Layer(防护层)：</p>
<ul>
<li>与遗留系统或外部系统进行一定程度集成时。</li>
</ul>
<h2 id="Shared-Kernel-共享内核"><a href="#Shared-Kernel-共享内核" class="headerlink" title="Shared Kernel (共享内核)"></a>Shared Kernel (共享内核)</h2><p>持续集成是开销最大的，开销稍微小一点的是共享内核。<br>（仅持续集成内核部分）</p>
<p>从领域模型中选出两个团队都同意共享的一个子集。<br>一个团队在没与另一个团队商量之前不应擅自更改它。</p>
<p><strong>测试</strong><br>需要自动测试套件</p>
<p>可以每周进行一次内核的合并。</p>
<p>Shared Kernel通常是Core Domain(参见精炼部分，Core Domain就是精炼出来的项目需要解决的最核心逻辑)，或者一组Generic Subdomain(通用子领域)。</p>
<h2 id="Customer-Supplier-Development-Team-客户-供应商模式"><a href="#Customer-Supplier-Development-Team-客户-供应商模式" class="headerlink" title="Customer/Supplier Development Team(客户/供应商模式)"></a>Customer/Supplier Development Team(客户/供应商模式)</h2><p>适用情况：</p>
<ol>
<li>一个子系统服务于另一个子系统；</li>
<li>下游很少向上游反馈信息，单向依赖；</li>
<li>两个子系统为完全不同的用户群服务。 </li>
</ol>
<p>上下游很自然得分割到两个Bounded Context中。</p>
<p>注意事项：</p>
<ul>
<li>上下游负责的两个团队的行政关系：最好有共同的直接上级；<br>原因：需要正式规定团队之间的关系、责任。<br>两者有工作依赖关系，相互制约，如果无法互相推动可能导致交付delay。 </li>
</ul>
<p><strong>测试</strong><br>两个团队一起开发自动验收测试，验证预期的接口。<br>降低耦合性。上游团队做出修改时不必担心对下游团队产生副作用。<br>(接力赛时前面的选手不能一直回头看，他需要相信队友能把棒准确交到他手中，否则整个团队的速度都会慢下来)</p>
<h2 id="Conformist-跟随者模式"><a href="#Conformist-跟随者模式" class="headerlink" title="Conformist(跟随者模式)"></a>Conformist(跟随者模式)</h2><p>适用情况：<br>依然是上下游关系，但没有共同直接上级。<br>(管理层次相隔很远，无法推动)</p>
<p>此时下游团队只能靠自己了，3种选择：</p>
<ol>
<li>放弃对上游的利用: Separete Way(独立自主模式)</li>
<li>Anticorruption Layer: (防护层模式)上游写得很烂，一边重构一边用；</li>
<li>Conformist: (跟随者模式)上游写得不错，拿过来进行增强即可。</li>
</ol>
<p>Conformist与Shared Kernel类似都是用了相同内核，但是Conformist中另一个团队对合作没有兴趣。</p>
<h2 id="Anticorruption-Layer-防护层模式"><a href="#Anticorruption-Layer-防护层模式" class="headerlink" title="Anticorruption Layer(防护层模式)"></a>Anticorruption Layer(防护层模式)</h2><p>适用情况：<br>遗留代码写得烂，或上游写得不行但重写代价太高时，只能一边写一边重构。</p>
<p>一般重构不要直接全盘否定，这样工作量太大不可能立即完成。</p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>Facade: 外观模式: 子系统可供替换的接口，方便切换新老实现；<br>Adapter: 适配器：把新老系统转换成相同的接口。</p>
<p>个人思考：<br>微服务级别的隔离，部分请求发给新服务（一切都要灰度测试）</p>
<h2 id="Separate-Way-独立自主模式"><a href="#Separate-Way-独立自主模式" class="headerlink" title="Separate Way(独立自主模式)"></a>Separate Way(独立自主模式)</h2><p>如果集成的收益很小，代价很高，可以考虑不集成。</p>
<h2 id="Open-Host-Service（开放主机服务）"><a href="#Open-Host-Service（开放主机服务）" class="headerlink" title="Open Host Service（开放主机服务）"></a>Open Host Service（开放主机服务）</h2><p>适用情况：<br>需要和大量其他系统集成时。</p>
<p>定义一个协议，使我们的系统可以作为一组Service供其它系统访问。<br>开放这个协议，让所有需要与我们系统集成的人都可以使用它。<br>当有新的集成需求时，增强并扩展这个协议。<br>（如果只是特殊需求，可以写个一次性的转换器，共享协议应该简单而且内聚）</p>
<h2 id="Published-Language-公共语言"><a href="#Published-Language-公共语言" class="headerlink" title="Published Language(公共语言)"></a>Published Language(公共语言)</h2><p>两个Bounded Context之间模型转换的时候，<br>交换信息时如果有共同语言(无歧义)能简化转换。<br>如Open Host Service模式中，如果能发明一种简单好理解的共享协议，别的系统就能快速接入。</p>
<p>公共语言可能是： XML,JSON…</p>
<h2 id="模型的集成统一"><a href="#模型的集成统一" class="headerlink" title="模型的集成统一"></a>模型的集成统一</h2><p>集成的过程中往往会出现互相冲突的领域模型。<br>因此要适当简化，宁可缺少喷水功能，也不要包含不正确的特性。</p>
<h2 id="Context的边界选择："><a href="#Context的边界选择：" class="headerlink" title="Context的边界选择："></a>Context的边界选择：</h2><p>大的Context适用情况:</p>
<ol>
<li>用一个统一的模型来处理时，用户任务之间流动更顺畅；</li>
<li>一个内聚模型比两个更容易理解；</li>
<li>两个模型转换很难；</li>
<li>共享语言可以使团队沟通起来更清楚。 </li>
</ol>
<p>小的Context适用情况：</p>
<ol>
<li>降低了开发之间的沟通开销；</li>
<li>降低规模后：持续集成更容易了；</li>
<li>太大的上下文需要更高级的抽象模型：相关技巧人员短缺；</li>
<li>不同模型满足一些特殊需求。</li>
</ol>
<h2 id="集成外部系统的经验"><a href="#集成外部系统的经验" class="headerlink" title="集成外部系统的经验"></a>集成外部系统的经验</h2><ol>
<li>首先考虑不集成：Seperate Way模式；</li>
<li>外部系统写得好：Conformist模式：</li>
<li>外部系统写得烂：Anticorruption Layer。</li>
</ol>
<img src="/images/2019-07/context_map2.png" class="" width="800" height="1200" title="context_map2">

<h1 id="第15章-精炼-Core-Domain"><a href="#第15章-精炼-Core-Domain" class="headerlink" title="第15章 精炼 (Core Domain)"></a>第15章 精炼 (Core Domain)</h1><p>领域驱动的核心是把领域层提取出来；<br>还可以进一步把领域层中最核心要解决的问题（项目的立项根因）提取出来：<br>Core Domain。 </p>
<p>核心思想：专注于核心问题，而不被大量次要问题所淹没。</p>
<p>精炼包括：</p>
<ol>
<li>帮助成员掌握系统的总体设计及协调；</li>
<li>找到一个适度规模的核心模型，加入到通用语言，促进沟通；</li>
<li>指导重构；</li>
<li>专注于模型中最有价值的部分；</li>
<li>指导外包、现成组件的使用以及任务委派。</li>
</ol>
<img src="/images/2019-07/refine.png" class="" width="800" height="1200" title="refine">

<h2 id="Core-Domain模式"><a href="#Core-Domain模式" class="headerlink" title="Core Domain模式"></a>Core Domain模式</h2><p>尽量压缩Core Domain，在Core Domain中努力开发深层模型和柔性设计。<br>(让最有才能的人来开发Core Domain，自主开发的软件的最大价值在于对Core Domain的完全控制。应该让最有才能的人+领域专家长期合作开发)</p>
<p>Domain Vision Statement: 领域前景说明<br>Highlighted Core : 突出的核心<br>Generic Subdomain: 通用子领域：模型中最普通不特别的部分；<br>Cohesive Mechanism: 内聚机制<br>Seperated Core: 隔离的核心：核心外的实现可替换<br>Abstract Core: 抽象内核：连核心的实现也是可替换的。</p>
<h2 id="Generic-Subdomain"><a href="#Generic-Subdomain" class="headerlink" title="Generic Subdomain"></a>Generic Subdomain</h2><p>通用子领域：与项目目标无直接联系，增加复杂性，不限于仅在本项目可以使用。（如数据库连接池这种纯技术的部分、带时区的日期和时间功能）</p>
<p>它们的解决方案：</p>
<ol>
<li>购买现成的；</li>
<li>使用开源的；</li>
<li>把实现外包出去；</li>
<li>内部实现它。</li>
</ol>
<h2 id="Domain-Vision-Statement领域前景说明-1页"><a href="#Domain-Vision-Statement领域前景说明-1页" class="headerlink" title="Domain Vision Statement领域前景说明(1页)"></a>Domain Vision Statement领域前景说明(1页)</h2><p>不涉及技术指标，但要把项目和其他项目区分开来。<br>描述支持的功能和目标。<br>（区别于某个版本的技术规格）</p>
<h2 id="Highlighted-Core-3-7页"><a href="#Highlighted-Core-3-7页" class="headerlink" title="Highlighted Core(3~7页)"></a>Highlighted Core(3~7页)</h2><p>在代码级完成Core Domain前，可以先文档级描述Core Domain。<br>描述Core Domain及内部元素的主要交互。<br>尽量精简。</p>
<h2 id="Cohesive-Mechanism-内聚机制"><a href="#Cohesive-Mechanism-内聚机制" class="headerlink" title="Cohesive Mechanism(内聚机制)"></a>Cohesive Mechanism(内聚机制)</h2><p>分离出去的代码要内聚，用Intention-revealing接口来公开功能。<br>从而留下更小的Core Domain。<br>（例如可以分离Specification对象(规格)）</p>
<p>Generic Subdomain与Cohesize Mechanism都是为Core domain减负。</p>
<h2 id="Segregated-Core-分离内核"><a href="#Segregated-Core-分离内核" class="headerlink" title="Segregated Core(分离内核)"></a>Segregated Core(分离内核)</h2><p>等到上述步骤完成，内核逐渐与其他部分分离开。<br>进一步重构，彻底去掉代码耦合，把内核分离出来。</p>
<h2 id="Abstract-Core-抽象内核"><a href="#Abstract-Core-抽象内核" class="headerlink" title="Abstract Core(抽象内核)"></a>Abstract Core(抽象内核)</h2><p>把模型中最基本的概念识别出来，分离到不同的类、抽象类、接口中。<br>详细的实现留在子领域定义的module中。</p>
<p><strong>综上</strong><br>重构时也应当优先重构Core Domain。</p>
<h1 id="第16章-大比例结构"><a href="#第16章-大比例结构" class="headerlink" title="第16章 大比例结构"></a>第16章 大比例结构</h1><p>前文：上下文（Bounded Context）,精炼(Core Domain/Generic Subdomain)<br>分离出很多Module后，要找一个类非常困难。<br>这个时候为了便于管理： 大比例结构(约4层)</p>
<img src="/images/2019-07/layer_struct.png" class="" width="800" height="1200" title="layer_struct">

<p>Evolving Order: 逐步进化演化。<br>System Metaphor: 隐喻思维；（用一些比喻、如防火墙）<br>Responsibility layer: 职责模式<br>Knowlege level: 知识级别模式；<br>Plugggable Component Framework: 解耦组件；</p>
<h2 id="System-Metaphor模式"><a href="#System-Metaphor模式" class="headerlink" title="System Metaphor模式"></a>System Metaphor模式</h2><p>隐喻模式。<br>例如核和外层的比喻，防火墙的比喻。<br>用比喻来分层。（但是宁缺毋滥）</p>
<h2 id="Responsibility-Layer职责分层模式"><a href="#Responsibility-Layer职责分层模式" class="headerlink" title="Responsibility Layer职责分层模式"></a>Responsibility Layer职责分层模式</h2><p>类似于MVC中Repository等，上层可以访问下层，下层则不能访问上层。<br>还可以根据访问频率、状态变化频率分层。</p>
<h2 id="运输系统-投资银行案例"><a href="#运输系统-投资银行案例" class="headerlink" title="运输系统/投资银行案例"></a>运输系统/投资银行案例</h2><p>作业层<br>能力层<br>决策支持层<br>潜能层<br>承诺层</p>
<img src="/images/2019-07/layer1.png" class="" width="800" height="1200" title="layer1">
<img src="/images/2019-07/layer2.png" class="" width="800" height="1200" title="layer2">
<p>（类似于Controller,logic,repository层等等）</p>
<h2 id="Knowledge-level知识级别模式"><a href="#Knowledge-level知识级别模式" class="headerlink" title="Knowledge level知识级别模式"></a>Knowledge level知识级别模式</h2><img src="/images/2019-07/knowledge_level.png" class="" width="800" height="1200" title="knowledge_level">
<p>与Reponsibily layer的区别在于两个层之间互相依赖。<br>案例用的是养老金分配的知识级别模式。<br>某些模型能根据元数据来工作，知识级别较高。</p>
<h2 id="Pluggable-Component-Framework"><a href="#Pluggable-Component-Framework" class="headerlink" title="Pluggable Component Framework"></a>Pluggable Component Framework</h2><p>一个中央hub上支持所需的协议，可以灵活替换组件。<br>这种模式一般是经过很长时间演变后产生。<br>（起码在Abstract Core之后）</p>
<h2 id="最小化"><a href="#最小化" class="headerlink" title="最小化"></a>最小化</h2><p>一开始使用最松散的System metaphor隐喻模式，逐渐深化。</p>
<h1 id="第17章-领域驱动设计的综合运用"><a href="#第17章-领域驱动设计的综合运用" class="headerlink" title="第17章 领域驱动设计的综合运用"></a>第17章 领域驱动设计的综合运用</h1><img src="/images/2019-07/domain_all.png" class="" width="800" height="1200" title="domain_all">
<p>综合使用前面的三点：<br>上下文、精炼、大比例结构。</p>
<h2 id="大比例结合上下文-bounded-context"><a href="#大比例结合上下文-bounded-context" class="headerlink" title="大比例结合上下文(bounded context)"></a>大比例结合上下文(bounded context)</h2><p>把不同bounded context放到不同层</p>
<h2 id="大比例结合精炼"><a href="#大比例结合精炼" class="headerlink" title="大比例结合精炼"></a>大比例结合精炼</h2><p>帮助理清Core Domain内部关系和Generic subdomain之间关系。<br>（放到不同层）</p>
<img src="/images/2019-07/layer_all2.png" class="" width="800" height="1200" title="layer_all2">
<p>大比例结合上下文后的图如上所示。</p>
<h2 id="战略设计决策的6个要点"><a href="#战略设计决策的6个要点" class="headerlink" title="战略设计决策的6个要点"></a>战略设计决策的6个要点</h2><ol>
<li>决策传达到整个团队；</li>
<li>决策过程收集反馈；</li>
<li>计划允许演变；</li>
<li>架构团队和开发团队都需要聪明人；</li>
<li>简约、谦逊原则；（不要对开发形成障碍）</li>
<li>对象职责专一而开发人员是多面手。</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://xiaoyue26.github.io/2019/07/22/2019-07/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1-%E7%AC%AC7-17%E7%AB%A0%E7%AC%94%E8%AE%B0/" data-id="ck96cxpq000j5maambbi918wj" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/DDD/" rel="tag">DDD</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AE%BE%E8%AE%A1/" rel="tag">设计</a></li></ul>

    </footer>
  </div>
  
    
 
<script src="/jquery/jquery.min.js"></script>

  <div id="random_posts">
    <h2>推荐文章</h2>
    <div class="random_posts_ul">
      <script>
          var random_count =4
          var site = {BASE_URI:'/'};
          function load_random_posts(obj) {
              var arr=site.posts;
              if (!obj) return;
              // var count = $(obj).attr('data-count') || 6;
              for (var i, tmp, n = arr.length; n; i = Math.floor(Math.random() * n), tmp = arr[--n], arr[n] = arr[i], arr[i] = tmp);
              arr = arr.slice(0, random_count);
              var html = '<ul>';
            
              for(var j=0;j<arr.length;j++){
                var item=arr[j];
                html += '<li><strong>' + 
                item.date + ':&nbsp;&nbsp;<a href="' + (site.BASE_URI+item.uri) + '">' + 
                (item.title || item.uri) + '</a></strong>';
                if(item.excerpt){
                  html +='<div class="post-excerpt">'+item.excerpt+'</div>';
                }
                html +='</li>';
                
              }
              $(obj).html(html + '</ul>');
          }
          $('.random_posts_ul').each(function () {
              var c = this;
              if (!site.posts || !site.posts.length){
                  $.getJSON(site.BASE_URI + 'js/posts.js',function(json){site.posts = json;load_random_posts(c)});
              } 
               else{
                load_random_posts(c);
              }
          });
      </script>
    </div>
  </div>

    
<nav id="article-nav">
  
    <a href="/2019/07/27/2019-07/disruptor%E7%AC%94%E8%AE%B0/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">上一篇</strong>
      <div class="article-nav-title">
        
          disruptor笔记——代替blockingQueue和java9flowAPI
        
      </div>
    </a>
  
  
    <a href="/2019/07/06/2019-07/hll%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">下一篇</strong>
      <div class="article-nav-title">hll算法原理</div>
    </a>
  
</nav>

  
</article>
 
     
  <div class="comments" id="comments">
    
     
       
      <div id="cloud-tie-wrapper" class="cloud-tie-wrapper"></div>
    
       
      
      
           <div id="gitment_comments"></div>
    
      
  </div>
 
  

</section>
           
    <aside id="sidebar">
  
    

  
    
    <div class="widget-wrap">
    
      <div class="widget" id="toc-widget-fixed">
      
        <strong class="toc-title">文章目录</strong>
        <div class="toc-widget-list">
              <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#第七章-实例：货物运输系统"><span class="toc-number">1.</span> <span class="toc-text">第七章 实例：货物运输系统</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-需求"><span class="toc-number">1.1.</span> <span class="toc-text">1. 需求</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#领域语言"><span class="toc-number">1.2.</span> <span class="toc-text">领域语言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#隔离领域"><span class="toc-number">1.3.</span> <span class="toc-text">隔离领域</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#区分Entity和Value-Object"><span class="toc-number">1.4.</span> <span class="toc-text">区分Entity和Value Object</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#设计关联"><span class="toc-number">1.5.</span> <span class="toc-text">设计关联</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Aggregate边界"><span class="toc-number">1.6.</span> <span class="toc-text">Aggregate边界</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#创建Repository"><span class="toc-number">1.7.</span> <span class="toc-text">创建Repository</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#用例"><span class="toc-number">1.8.</span> <span class="toc-text">用例</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-更改目的地"><span class="toc-number">1.8.1.</span> <span class="toc-text">1. 更改目的地</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-重复预订"><span class="toc-number">1.9.</span> <span class="toc-text">2. 重复预订</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#从需求频次出发简化设计"><span class="toc-number">1.10.</span> <span class="toc-text">从需求频次出发简化设计</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Module：模块化"><span class="toc-number">1.11.</span> <span class="toc-text">Module：模块化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#引入新特性：-配额检查"><span class="toc-number">1.12.</span> <span class="toc-text">引入新特性： 配额检查</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#实现1"><span class="toc-number">1.12.1.</span> <span class="toc-text">实现1</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#实现2"><span class="toc-number">1.12.2.</span> <span class="toc-text">实现2:</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#第三部分-通过重构来加深理解"><span class="toc-number">2.</span> <span class="toc-text">第三部分 通过重构来加深理解</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#重构"><span class="toc-number">2.1.</span> <span class="toc-text">重构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#深层模型"><span class="toc-number">2.2.</span> <span class="toc-text">深层模型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#深层模型与柔性设计"><span class="toc-number">2.3.</span> <span class="toc-text">深层模型与柔性设计</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#发现过程"><span class="toc-number">2.4.</span> <span class="toc-text">发现过程</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#第八章-突破"><span class="toc-number">3.</span> <span class="toc-text">第八章 突破</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#突破案例"><span class="toc-number">3.1.</span> <span class="toc-text">突破案例</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#大致过程"><span class="toc-number">3.1.1.</span> <span class="toc-text">大致过程</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#第九章-深层模型"><span class="toc-number">4.</span> <span class="toc-text">第九章 深层模型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#倾听语言"><span class="toc-number">4.1.</span> <span class="toc-text">倾听语言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#会计示例"><span class="toc-number">4.2.</span> <span class="toc-text">会计示例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#约束的提炼"><span class="toc-number">4.3.</span> <span class="toc-text">约束的提炼</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#将规则显式提炼的案例：超订策略"><span class="toc-number">4.3.1.</span> <span class="toc-text">将规则显式提炼的案例：超订策略</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#模式：-Specification"><span class="toc-number">4.4.</span> <span class="toc-text">模式： Specification</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#第十章-柔性设计"><span class="toc-number">5.</span> <span class="toc-text">第十章 柔性设计</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-模式：表现意图的接口-Intention-Revealing-Interface"><span class="toc-number">5.1.</span> <span class="toc-text">1. 模式：表现意图的接口(Intention-Revealing Interface)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-模式：无副作用函数（Size-Effect-free-function）"><span class="toc-number">5.2.</span> <span class="toc-text">2. 模式：无副作用函数（Size-Effect-free function）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-模式：-Assertion"><span class="toc-number">5.3.</span> <span class="toc-text">3. 模式： Assertion</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-概念轮廓、概念边界"><span class="toc-number">5.4.</span> <span class="toc-text">4. 概念轮廓、概念边界</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-低耦合的对象"><span class="toc-number">5.5.</span> <span class="toc-text">5. 低耦合的对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-模式：闭合操作-Closure-of-Operation"><span class="toc-number">5.6.</span> <span class="toc-text">6. 模式：闭合操作 Closure of Operation</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-声明式设计"><span class="toc-number">5.7.</span> <span class="toc-text">7. 声明式设计</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-声明式设计风格"><span class="toc-number">5.8.</span> <span class="toc-text">8. 声明式设计风格</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#声明式风格的Specification"><span class="toc-number">5.8.1.</span> <span class="toc-text">声明式风格的Specification</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-用逻辑运算组合Specification-闭包操作模式"><span class="toc-number">5.8.1.1.</span> <span class="toc-text">1.用逻辑运算组合Specification (闭包操作模式)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-切入问题的角度-（如何优化设计）"><span class="toc-number">5.9.</span> <span class="toc-text">9. 切入问题的角度 （如何优化设计）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-分割子领域"><span class="toc-number">5.9.1.</span> <span class="toc-text">1. 分割子领域</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-尽可能利用已有的形式"><span class="toc-number">5.9.2.</span> <span class="toc-text">2. 尽可能利用已有的形式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#示例：-股份数学"><span class="toc-number">5.9.3.</span> <span class="toc-text">示例： 股份数学</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#第二步：把隐式概念变成显式概念"><span class="toc-number">5.9.3.1.</span> <span class="toc-text">第二步：把隐式概念变成显式概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#第三步-引入闭合操作-运算"><span class="toc-number">5.9.3.2.</span> <span class="toc-text">第三步: 引入闭合操作(运算)</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#第11章-分析模式的应用"><span class="toc-number">6.</span> <span class="toc-text">第11章 分析模式的应用</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#案例：-账户的利息计算"><span class="toc-number">6.1.</span> <span class="toc-text">案例： 账户的利息计算</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#引入复式记账-简化平账的并发问题"><span class="toc-number">6.1.1.</span> <span class="toc-text">引入复式记账(简化平账的并发问题)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#进一步挖掘需求"><span class="toc-number">6.1.2.</span> <span class="toc-text">进一步挖掘需求</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#进一步考察过账需求"><span class="toc-number">6.1.3.</span> <span class="toc-text">进一步考察过账需求</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#第12章-将设计模式应用于模型"><span class="toc-number">7.</span> <span class="toc-text">第12章 将设计模式应用于模型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Strategy-Policy-模式"><span class="toc-number">7.1.</span> <span class="toc-text">Strategy(Policy)模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Composite模式"><span class="toc-number">7.2.</span> <span class="toc-text">Composite模式</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#第13章-通过重构得到更深层的理解"><span class="toc-number">8.</span> <span class="toc-text">第13章 通过重构得到更深层的理解</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#开始重构"><span class="toc-number">8.1.</span> <span class="toc-text">开始重构</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#第四部分：-战略设计"><span class="toc-number">9.</span> <span class="toc-text">第四部分： 战略设计</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#第14章-上下文-保持模型的完整性"><span class="toc-number">10.</span> <span class="toc-text">第14章 上下文: 保持模型的完整性</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Bounded-Context"><span class="toc-number">10.1.</span> <span class="toc-text">Bounded Context</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Continuous-Integration-持续集成"><span class="toc-number">10.2.</span> <span class="toc-text">Continuous Integration: 持续集成</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Context-Map-全局视图"><span class="toc-number">10.3.</span> <span class="toc-text">Context Map: 全局视图</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#案例：预订context和运输context"><span class="toc-number">10.3.1.</span> <span class="toc-text">案例：预订context和运输context</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#其他要点"><span class="toc-number">10.3.2.</span> <span class="toc-text">其他要点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Context-Map中一些常见的模式"><span class="toc-number">10.3.3.</span> <span class="toc-text">Context Map中一些常见的模式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Shared-Kernel-共享内核"><span class="toc-number">10.4.</span> <span class="toc-text">Shared Kernel (共享内核)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Customer-Supplier-Development-Team-客户-供应商模式"><span class="toc-number">10.5.</span> <span class="toc-text">Customer&#x2F;Supplier Development Team(客户&#x2F;供应商模式)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Conformist-跟随者模式"><span class="toc-number">10.6.</span> <span class="toc-text">Conformist(跟随者模式)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Anticorruption-Layer-防护层模式"><span class="toc-number">10.7.</span> <span class="toc-text">Anticorruption Layer(防护层模式)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#实现"><span class="toc-number">10.7.1.</span> <span class="toc-text">实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Separate-Way-独立自主模式"><span class="toc-number">10.8.</span> <span class="toc-text">Separate Way(独立自主模式)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Open-Host-Service（开放主机服务）"><span class="toc-number">10.9.</span> <span class="toc-text">Open Host Service（开放主机服务）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Published-Language-公共语言"><span class="toc-number">10.10.</span> <span class="toc-text">Published Language(公共语言)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#模型的集成统一"><span class="toc-number">10.11.</span> <span class="toc-text">模型的集成统一</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Context的边界选择："><span class="toc-number">10.12.</span> <span class="toc-text">Context的边界选择：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#集成外部系统的经验"><span class="toc-number">10.13.</span> <span class="toc-text">集成外部系统的经验</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#第15章-精炼-Core-Domain"><span class="toc-number">11.</span> <span class="toc-text">第15章 精炼 (Core Domain)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Core-Domain模式"><span class="toc-number">11.1.</span> <span class="toc-text">Core Domain模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Generic-Subdomain"><span class="toc-number">11.2.</span> <span class="toc-text">Generic Subdomain</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Domain-Vision-Statement领域前景说明-1页"><span class="toc-number">11.3.</span> <span class="toc-text">Domain Vision Statement领域前景说明(1页)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Highlighted-Core-3-7页"><span class="toc-number">11.4.</span> <span class="toc-text">Highlighted Core(3~7页)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Cohesive-Mechanism-内聚机制"><span class="toc-number">11.5.</span> <span class="toc-text">Cohesive Mechanism(内聚机制)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Segregated-Core-分离内核"><span class="toc-number">11.6.</span> <span class="toc-text">Segregated Core(分离内核)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Abstract-Core-抽象内核"><span class="toc-number">11.7.</span> <span class="toc-text">Abstract Core(抽象内核)</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#第16章-大比例结构"><span class="toc-number">12.</span> <span class="toc-text">第16章 大比例结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#System-Metaphor模式"><span class="toc-number">12.1.</span> <span class="toc-text">System Metaphor模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Responsibility-Layer职责分层模式"><span class="toc-number">12.2.</span> <span class="toc-text">Responsibility Layer职责分层模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#运输系统-投资银行案例"><span class="toc-number">12.3.</span> <span class="toc-text">运输系统&#x2F;投资银行案例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Knowledge-level知识级别模式"><span class="toc-number">12.4.</span> <span class="toc-text">Knowledge level知识级别模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Pluggable-Component-Framework"><span class="toc-number">12.5.</span> <span class="toc-text">Pluggable Component Framework</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#最小化"><span class="toc-number">12.6.</span> <span class="toc-text">最小化</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#第17章-领域驱动设计的综合运用"><span class="toc-number">13.</span> <span class="toc-text">第17章 领域驱动设计的综合运用</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#大比例结合上下文-bounded-context"><span class="toc-number">13.1.</span> <span class="toc-text">大比例结合上下文(bounded context)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#大比例结合精炼"><span class="toc-number">13.2.</span> <span class="toc-text">大比例结合精炼</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#战略设计决策的6个要点"><span class="toc-number">13.3.</span> <span class="toc-text">战略设计决策的6个要点</span></a></li></ol></li></ol>
          </div>
      </div>
    </div>

  
    

  
    
  
    
  
    

  
</aside>

      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-left">
      &copy; 2014 - 2022 风梦七&nbsp;|&nbsp;
      主题 <a href="https://github.com/giscafer/hexo-theme-cafe/" target="_blank">Cafe</a>
    </div>
     <div id="footer-right">
      联系方式&nbsp;|&nbsp;296671657@qq.com
    </div>
  </div>
</footer>
 
<script src="/jquery/jquery.min.js"></script>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">首页</a>
  
    <a href="/archives" class="mobile-nav-link">归档</a>
  
    <a href="/about" class="mobile-nav-link">关于</a>
  
</nav>
    <img class="back-to-top-btn" src="/images/fly-to-top.png"/>
<script>
// Elevator script included on the page, already.
window.onload = function() {
  var elevator = new Elevator({
    selector:'.back-to-top-btn',
    element: document.querySelector('.back-to-top-btn'),
    duration: 1000 // milliseconds
  });
}
</script>
      

  
    <script>
      var cloudTieConfig = {
        url: document.location.href, 
        sourceId: "",
        productKey: "e2fb4051c49842688ce669e634bc983f",
        target: "cloud-tie-wrapper"
      };
    </script>
    <script src="https://img1.ws.126.net/f2e/tie/yun/sdk/loader.js"></script>
    

  







<!-- author:forvoid begin -->
<!-- author:forvoid begin -->

  <link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css">
  <script src="https://imsun.github.io/gitment/dist/gitment.browser.js"></script> 
  <script>
  var gitment = new Gitment({
    // id: '页面 ID', // 可选。默认为 location.href
    owner: 'xiaoyue26',
    repo: 'comment',
    oauth: {
    client_id: 'cfe53b938f0d4c782371',
    client_secret: 'f96e68ae1103e7500c106aa3656a8bb31fe0ee99',
    }
  })
  gitment.render(document.getElementById("gitment_comments"))
</script>


<!-- author:forvoid end -->

<!-- author:forvoid begin -->

<!-- author:forvoid end -->

<!-- author:forvoid end -->


  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      })
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      })
    </script>
    <script type="text/javascript" src="https://cdn.rawgit.com/mathjax/MathJax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


 
<script src="/js/is.js"></script>



  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>


<script src="/js/elevator.js"></script>

  </div>
</body>
</html>