<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>笔记本</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="笔记本">
<meta property="og:url" content="http://xiaoyue26.github.io/index.html">
<meta property="og:site_name" content="笔记本">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="风梦七">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="笔记本" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    
  
  
<link rel="stylesheet" href="/css/style.css">

  

<meta name="generator" content="Hexo 4.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    
    <div id="header-inner" class="inner">
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://xiaoyue26.github.io"></form>
      </div>
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">首页</a>
        
          <a class="main-nav-link" href="/archives">归档</a>
        
          <a class="main-nav-link" href="/about">关于</a>
        
      </nav>
      
    </div>
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">笔记本</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">风梦七</a>
        </h2>
      
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-2022-02/http3-quic优缺点及原因" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/02/17/2022-02/http3-quic%E4%BC%98%E7%BC%BA%E7%82%B9%E5%8F%8A%E5%8E%9F%E5%9B%A0/" class="article-date">
  <time datetime="2022-02-17T02:09:02.000Z" itemprop="datePublished">2022-02-17</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/http/">http</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/02/17/2022-02/http3-quic%E4%BC%98%E7%BC%BA%E7%82%B9%E5%8F%8A%E5%8E%9F%E5%9B%A0/">http3_quic优缺点及原因</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <h1 id="WHAT-HTTP3-QUIC是什么？"><a href="#WHAT-HTTP3-QUIC是什么？" class="headerlink" title="WHAT: HTTP3/QUIC是什么？"></a>WHAT: HTTP3/QUIC是什么？</h1><p>QUIC: <code>Quick UDP Internet Connections</code><br>谷歌主导的网络协议，用udp代替tcp来作为http的传输协议。<br>HTTP3就是<code>HTTP over QUIC</code>。</p>
<img src="/images/2022-02/quic_struct.png" class="" width="800" height="1200" title="quic_struct">
<p>如上图所示是http2和http over quic的对比。<br>可以看到图中的分层不是完全对齐的，这是因为以前的分层方式不合理，影响了性能，因此quic重新划分了更合理的分层结构。<br>原来的tcp(传输层)和tls(会话层)要分别建立连接，增加了不必要的rtt。<br>quic在tls1.3的基础上，统一建立连接，然后再基于udp传输。<br>QUIC层的分层:<br>UDP层: 只管传输，不管连接；<br>Connection层: 复杂建连相关、拥塞控制(bbr_v2)、安全(tls1.3)；通过cid来确认唯一连接;<br>Stream层: 负责多路复用；基于Connection层，通过StreamID进行唯一流确认，stream对stream frame进行传输管理;</p>
<p>使用TCP的协议: SPDY/HTTP2<br>使用UDP的协议: quic/HTTP3</p>
<h1 id="WHY-QUIC的优点-为啥要使用QUIC"><a href="#WHY-QUIC的优点-为啥要使用QUIC" class="headerlink" title="WHY: QUIC的优点(为啥要使用QUIC)"></a>WHY: QUIC的优点(为啥要使用QUIC)</h1><ul>
<li>连接迁移优化</li>
<li>队头阻塞优化</li>
<li>拥塞控制优化</li>
<li>握手优化</li>
</ul>
<p>quic的优点其实也对应着解决了以前http协议栈中的几个缺点。</p>
<h2 id="连接迁移功能"><a href="#连接迁移功能" class="headerlink" title="连接迁移功能"></a>连接迁移功能</h2><h3 id="以前tcp的缺点"><a href="#以前tcp的缺点" class="headerlink" title="以前tcp的缺点"></a>以前tcp的缺点</h3><p>移动客户端ip变化以后，连接断开，需要重新握手、创建新的连接。<br>我们日常生活中坐车、旅行等场景下，用手机上网，经过不同的基站，移动网络切换是比较常见的场景，<br>因此可能会经历频繁的连接重建，体验较差。</p>
<blockquote>
<p>为什么tcp有这个缺点:<br>tcp用通信双方的ip+port(4元组)来标示一个连接，因此客户端ip变了的话，连接就变了。<br>tcp很老了，最早的时候手机还不普及，固定电脑的ip基本上不会变。</p>
</blockquote>
<p><code>http over quic</code>则可以在客户端ip变化时，依然保持连接不断，减少了rtt，提高了体验；</p>
<h3 id="quic如何解决这个问题的"><a href="#quic如何解决这个问题的" class="headerlink" title="quic如何解决这个问题的"></a>quic如何解决这个问题的</h3><p>上面有说的tcp这个缺点的原因是标示连接唯一性的方式，所以很自然的思路是用别的方式来标示连接唯一性。<br>quic的方法是用connectionId（cid,64位）来唯一确定一个连接，客户端ip变化以后，cid不变，因此连接可以不断开。</p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>对于quic server:<br>如果根据客户端ip路由，连接迁移会失败；得根据cid路由；<br>一般得路由到同主机、同进程，才能保证连接迁移成功。<br>或者把连接相关的有状态信息存储在分布式缓存中(比如把session ticket存储在redis中)。</p>
<p>quic协议考虑到cid对于路由的重要性，因此cid是明文存储的。</p>
<h2 id="解决了队头阻塞问题-多路复用功能增强"><a href="#解决了队头阻塞问题-多路复用功能增强" class="headerlink" title="解决了队头阻塞问题(多路复用功能增强)"></a>解决了队头阻塞问题(多路复用功能增强)</h2><img src="/images/2022-02/quic_multi_stream.png" class="" width="800" height="1200" title="quic_multi_stream">
<h3 id="以前tcp的缺点-1"><a href="#以前tcp的缺点-1" class="headerlink" title="以前tcp的缺点"></a>以前tcp的缺点</h3><p>tcp队头阻塞的原因:<br>窗口更新机制: 滑动窗口的更新依赖于最左边的包的ack，如果队头的包一直没有ack，窗口不往后滑;<br>拥塞控制算法: 丢包以后启动丢包重传,窗口变小;<br>这些最终表现是tcp层面的队头阻塞。</p>
<ul>
<li>http1.0: 明文短连接，多个tcp连接；</li>
<li>http1.1: keepalive机制，长连接，复用同一个tcp连接，降低了建立连接的开销（节省了握手时间）；<br>客户端:pipeline机制，可以并行发；<br>服务端:必须顺序回，有队头阻塞；（同域名下的请求复用同一个连接，但必须排队）</li>
<li>http2: 用stream层解决http层面的队头阻塞（让同域名下的请求不排队了，间隔进行），但是还是有tcp层面的队头阻塞;<h3 id="quic如何解决这个问题的-1"><a href="#quic如何解决这个问题的-1" class="headerlink" title="quic如何解决这个问题的"></a>quic如何解决这个问题的</h3>解决TCP层面的队头阻塞，本质上是要开发一个新的流量控制、拥塞控制的整套方案放在UDP层之上。<br>quic的改进:<br>(1)窗口更新机制: 当已经读取的数据大于最大接收窗口的一半时，发送WINDOW_UPDATE帧告诉发送者，接收窗口已经更新。<br>(2)拥塞控制算法: 由于底层是udp，没有拥塞控制算法，因此quic需要实现拥塞控制算法。<br>quic在应用层实现拥塞控制算法，如bbr,bbr_v2，核心思想是用rtt来预测带宽情况。<br>tcp用丢包事件来判断带宽情况，比较不准。但tcp之所以这么傻，也是因为tcp中的一些约束，很难准确判断rtt的大小。<br>比如seq number机制，重传的时候无法判断是超时重传的包还是第一个包经过很长时间收到了，因为seq number相同。<br>quic的seq number改进: 通过streamId+offset, packet number的机制，重传的包packet number递增，这样可以算准rtt。</li>
</ul>
<h2 id="吞吐量更大（新拥塞控制算法）"><a href="#吞吐量更大（新拥塞控制算法）" class="headerlink" title="吞吐量更大（新拥塞控制算法）"></a>吞吐量更大（新拥塞控制算法）</h2><p>接上一节，quic开发了新的拥塞控制算法，吞吐量更大，更能利用带宽：<br>cubic vs bbr:</p>
<img src="/images/2022-02/cubic_vs_bbr.png" class="" width="400" height="600" title="cubic_vs_bbr">
<p>可以看到tcp默认的cubic拥塞控制算法频繁上下调整滑动窗口大小，锯齿状；<br>而bbr倾向于平稳发送，在实际带宽比较平稳的场景下，吞吐量更大。（图中折线下方的面积更大）</p>
<p>原来tcp为什么没有解决这个问题：<br>(1)tcp在linux内核里，升级太困难了。<br>(2)参考上一节，tcp的一些约束导致rtt算不准。比如ack delay、重传包的seq number不变。</p>
<h2 id="耗时短。握手-rtt减少；重连-0RTT特性。"><a href="#耗时短。握手-rtt减少；重连-0RTT特性。" class="headerlink" title="耗时短。握手-rtt减少；重连-0RTT特性。"></a>耗时短。握手-rtt减少；重连-0RTT特性。</h2><p>原来https over tcp的缺点:<br>(1)握手阶段: tls层和tcp层重复建立连接；<br>(2)握手阶段: tls1.2需要考虑历史包袱，考虑达到最大兼容性，握手需要2RTT;<br>(3)重连阶段: tls1.2需要一次握手;</p>
<h3 id="quic如何解决这个问题的-2"><a href="#quic如何解决这个问题的-2" class="headerlink" title="quic如何解决这个问题的"></a>quic如何解决这个问题的</h3><p>(1)握手阶段合并: 只建立一次连接，省掉tcp握手的1rtt。<br>将建立连接这件事统一放在quic层里，udp只专心做传输的事情。<br>(2)握手阶段: 1RTT。运气不好的话还是2RTT。<br>参考tls1.3，去掉不安全的算法，在客户端预置一些密码套件。<br>第一个握手客户端就直接选定加密协议，并生成相应的随机数，相当于跳过了tls1.2第一个rtt的协商；<br>如果服务端不支持，则使用HelloRetryRequest继续。<br>大部分情况下，都可以省掉第一次的rtt;<br>(3)重连阶段: 0 RTT。<br>参考tls1.3的session ticket(quic叫server config)，客户端和服务端都缓存之前握手协商好的配置。<br>重连的时候，客户端直接把配置和数据一起发给服务端。</p>
<h4 id="0RTT的前提："><a href="#0RTT的前提：" class="headerlink" title="0RTT的前提："></a>0RTT的前提：</h4><p>1。client不清缓存；（过期前）<br>2。通过cid路由到同一个server进程；<br>(或者服务端对于server config有统一缓存)<br>缺点：牺牲了一定时间内的前向安全；（过期时间内）</p>
<h1 id="QUIC的缺点"><a href="#QUIC的缺点" class="headerlink" title="QUIC的缺点"></a>QUIC的缺点</h1><h2 id="CPU开销大"><a href="#CPU开销大" class="headerlink" title="CPU开销大"></a>CPU开销大</h2><p>http over quic与http over tcp相比，cpu开销可能会更大。<br>如果没有特别优化，单机qps可能下降50%。<br>主要有以下几个原因：</p>
<h3 id="内核态vs用户态"><a href="#内核态vs用户态" class="headerlink" title="内核态vs用户态"></a>内核态vs用户态</h3><p>(1)原来拥塞控制在tcp，在内核，执行在内核态，性能更高；<br>解决方案: 暂时没想到;<br>(2)quic限定udp报文大小&lt;=1mtu(IPV6下为1350，IPV4下为1370)。<br>由于包的大小不能很大 =&gt; 因此包的数量会较多=&gt; 系统调用很多 =&gt; 性能下降。<br>解决方案:<br>(2.1)批处理；用sendmmsg，一次系统调用发多个udp包；<br>(2.2)网卡GSO offload方案，降低cpu消耗;</p>
<blockquote>
<p>quic对包的大小有两个限制<br>(1) initial包&gt;=1200: 预防UDP攻击；（反射攻击）<br>如果数据本身不足1200，用padding方式填充到1200字节。<br>反射攻击:<br>  被利用服务器输出流量与输入流量的比值我们称之为放大系数。<br>  这个系数与被利用服务器所提供的 UDP 服务有关。<br>  之前提到的利用 Memcache 漏洞的 DRDoS 攻击，可以获得稳定的 60000 倍放大系数。<br>  而我们日常使用的 DNS 则可以轻松的获得 50 倍的放大系数。<br>  由放大系数反推，我们可以知道，如果一个 UDP 服务被利用以后，放大系数小于等于1的话，则不存在利用价值.<br>  因为这个时候，只从带宽流量方面考虑的话，还不如直接利用攻击主机对被攻击服务器进行攻击效率高。 </p>
<p>(2)&lt;=1MTU(IPV6下为1350，IPV4下为1370):<br>IP层是没有超时重传机制的，如果IP层对一个数据包进行了分片，只要有一个分片丢失了，只能依赖于传输层进行重传。<br>结果是所有的分片都要重传一遍，这个代价有点大。<br>由此可见，IP分片会大大降低传输层传送数据的成功率，所以我们要避免IP分片。</p>
</blockquote>
<h3 id="加解密开销大"><a href="#加解密开销大" class="headerlink" title="加解密开销大"></a>加解密开销大</h3><p>谷歌fork的openssl分支：boringSSL（笑死）<br>具体原因不太清楚，可能是谷歌选择的加解密算法比较安全、计算开销比较大。<br>也有可能是开源实现里，选择密码编码学算法比较普通，没有给生产环境级别的优化。</p>
<p>解决方案：<br>如果在生产环境使用，需要相应修改加密套件。</p>
<h2 id="容易被拦截"><a href="#容易被拦截" class="headerlink" title="容易被拦截"></a>容易被拦截</h2><p>因为一些运营商不待见udp。<br>根据腾讯的文档：<a href="https://toutiao.io/posts/tixau8w/preview" target="_blank" rel="noopener">https://toutiao.io/posts/tixau8w/preview</a><br>QUIC失败率较高的三个省份为：贵州、广西和新疆；<br>失败率较高的运营商为：教育网和长城宽带。</p>
<p>解决方案：<br>需要支持降级到普通https。</p>
<h2 id="nginx支持不全"><a href="#nginx支持不全" class="headerlink" title="nginx支持不全"></a>nginx支持不全</h2><p>比如nginx reload会断开已建立的quic连接.(因为对ng来说是udp)</p>
<p>解决方案：<br>需要修改nginx内核。</p>
<ul>
<li>内核逻辑调试工具<br>systemtap 内核逻辑调试工具,查看内核调用栈<br>内核的timewait监控: /proc/net/netstat中 的 TCPTimeWaitOverflow<br>Broken pipe(32) tcp_max_tw_buckets</li>
</ul>
<h1 id="QUIC应用场景"><a href="#QUIC应用场景" class="headerlink" title="QUIC应用场景"></a>QUIC应用场景</h1><p>弱网环境：因为quic的拥塞控制算法bbr在丢包时性能更好；<br>        因为quic的重连、建连rtt少；<br>对安全重视的环境：因为tls1.3更安全；<br>移动端：因为连接迁移功能；<br>并发请求多的应用: 因为quic没有tcp层的队头阻塞，多路复用更彻底;</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>可以参考谷歌开源的chromium中的quic协议栈，以及相应的server demo。<br>谷歌浏览器内核支持quic，其他浏览器内核就不一定了。<br>谷歌: <a href="https://www.chromium.org/quic/" target="_blank" rel="noopener">https://www.chromium.org/quic/</a><br>腾讯：<a href="https://zhuanlan.zhihu.com/p/32560981" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/32560981</a><br>微博: <a href="https://www.infoq.cn/article/2018%2F03%2Fweibo-quic" target="_blank" rel="noopener">https://www.infoq.cn/article/2018%2F03%2Fweibo-quic</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://xiaoyue26.github.io/2022/02/17/2022-02/http3-quic%E4%BC%98%E7%BC%BA%E7%82%B9%E5%8F%8A%E5%8E%9F%E5%9B%A0/" data-id="ckzqp6ooc0000n2am93597kv9" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/http/" rel="tag">http</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/" rel="tag">java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/spring/" rel="tag">spring</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-2022-02/http-range" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/02/16/2022-02/http-range/" class="article-date">
  <time datetime="2022-02-16T09:27:26.000Z" itemprop="datePublished">2022-02-16</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/http/">http</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/02/16/2022-02/http-range/">http_range</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <h1 id="http协议header中的range相关"><a href="#http协议header中的range相关" class="headerlink" title="http协议header中的range相关"></a>http协议header中的range相关</h1><p>客户端可以在http请求的header中指定请求资源的范围(range)，如果服务端支持的话，就可以只返回部分数据，节约网络资源。<br>如果服务端实现了这部分协议，客户端就可以进行断点续传、多线程下载、在线播放视频修改进度等功能了。<br>应用场景：<br>1。在线播放视频：调整进度；（seek offset）<br>2。下载文件：多线程下载、断点续传。</p>
<h2 id="检查服务端是否支持"><a href="#检查服务端是否支持" class="headerlink" title="检查服务端是否支持"></a>检查服务端是否支持</h2><p>可以通过命令:</p>
<figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -I https://cdn.com/xxx.png</span><br></pre></td></tr></table></figure>
<p>来检查服务端是否支持。<br>如果支持,服务端的回复是bytes：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Accept-Ranges: bytes</span><br></pre></td></tr></table></figure>
<p>如果不支持，服务端的回复是none:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Accept-Ranges: none</span><br></pre></td></tr></table></figure>
<p>(<code>curl -I</code>只显示header; <code>curl -i</code>显示header和body)</p>
<h2 id="实际应用中的回复"><a href="#实际应用中的回复" class="headerlink" title="实际应用中的回复"></a>实际应用中的回复</h2><p>客户端发送:</p>
<figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -i -H "Range: bytes=0-1023" https://cdn.com/xxx.png</span><br></pre></td></tr></table></figure>
<p>服务端正常回复206(单个区间的话):</p>
<figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 206 Partial Content</span><br><span class="line">Content-Type: image/png</span><br><span class="line">Content-Length: 1024</span><br><span class="line">Connection: keep-alive</span><br><span class="line">ETag: "2F4AF992F06D75CA7BE353ED2A981C45"</span><br><span class="line">Date: Tue, 01 Feb 2022 15:54:43 GMT</span><br><span class="line">Last-Modified: Tue, 25 Jan 2022 15:54:42 GMT</span><br><span class="line">Expires: Tue, 08 Feb 2022 15:54:43 GMT</span><br><span class="line">Age: 579015</span><br><span class="line">Cache-Control: max-age=604800</span><br><span class="line">Content-Range: bytes 0-1023/9404</span><br><span class="line">Accept-Ranges: bytes</span><br></pre></td></tr></table></figure>

<p>如果range不合法的话，服务端回复:</p>
<figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 416 Requested Range Not Satisfiable</span><br></pre></td></tr></table></figure>
<p>如果服务端不支持range请求，会回复200，并且返回全部数据:</p>
<figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br></pre></td></tr></table></figure>

<p>其他Range相关的一些姿势可以参考：<br><a href="https://www.greenbytes.de/tech/webdav/draft-ietf-httpbis-p5-range-latest.html#rule.ranges-specifier" target="_blank" rel="noopener">https://www.greenbytes.de/tech/webdav/draft-ietf-httpbis-p5-range-latest.html#rule.ranges-specifier</a><br>实际还可以指定多区间，指定末尾100个字节（<code>Range: bytes=-100</code>），<br>还可以用<code>If-Range</code>避免文件发生变更的情况：<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/If-Range" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/If-Range</a><br>只有Last-Modified或者ETag字段验证通过的时候，才处理<code>Range</code>请求，否则返回200（整个文件）。</p>
<h1 id="实现：spring中"><a href="#实现：spring中" class="headerlink" title="实现：spring中"></a>实现：spring中</h1><h2 id="方案1，交给spring接管"><a href="#方案1，交给spring接管" class="headerlink" title="方案1，交给spring接管"></a>方案1，交给spring接管</h2><p>如果是本地机器中的资源，可以封装成<code>FileSystemResource</code>；<br>如果要从别的地方获取byte数组，可以封装成<code>ByteArrayResource</code>;<br>状态直接写200(OK),spring会自动转成206。<br>示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/v3/csc/center/range"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CscCenterRangeController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/load"</span>)</span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResponseEntity&lt;ByteArrayResource&gt; <span class="title">load</span><span class="params">(@RequestParam(value = <span class="string">"fileKey"</span>)</span> String fileKey) </span>&#123;</span><br><span class="line">        String res = <span class="string">"1234"</span>;</span><br><span class="line">        <span class="keyword">final</span> HttpHeaders responseHeaders = <span class="keyword">new</span> HttpHeaders();</span><br><span class="line">        <span class="comment">// responseHeaders.add("Content-Type", "video/mp4");</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ResponseEntity&lt;&gt;(<span class="keyword">new</span> ByteArrayResource(res.getBytes()), responseHeaders, HttpStatus.OK);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/load-file"</span>)</span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResponseEntity&lt;FileSystemResource&gt; <span class="title">loadFile</span><span class="params">(@RequestParam(value = <span class="string">"fileKey"</span>)</span> String fileKey) </span>&#123;</span><br><span class="line">        String filePathString = <span class="string">"/Users/fengmengqi/Documents/DH_scret.png"</span>;</span><br><span class="line">        <span class="keyword">final</span> HttpHeaders responseHeaders = <span class="keyword">new</span> HttpHeaders();</span><br><span class="line">        <span class="comment">// responseHeaders.add("Content-Type", "video/mp4");</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ResponseEntity&lt;&gt;(<span class="keyword">new</span> FileSystemResource(filePathString), responseHeaders, HttpStatus.OK);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>缺点是spring似乎没有实现Range协议中的<code>If-Range</code>头。</p>
<h2 id="方案2，在spring提供的HttpRange类基础上实现"><a href="#方案2，在spring提供的HttpRange类基础上实现" class="headerlink" title="方案2，在spring提供的HttpRange类基础上实现"></a>方案2，在spring提供的HttpRange类基础上实现</h2><p>可以参考<code>org.springframework.web.servlet.resource.ResourceHttpRequestHandler#handleRequest</code><br>在HttpRange类的基础上实现自定义的Range相关协议，这样可以增添<code>If-Range</code>的功能。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Range_requests" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Range_requests</a><br><a href="https://www.greenbytes.de/tech/webdav/draft-ietf-httpbis-p5-range-latest.html#rule.ranges-specifier" target="_blank" rel="noopener">https://www.greenbytes.de/tech/webdav/draft-ietf-httpbis-p5-range-latest.html#rule.ranges-specifier</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://xiaoyue26.github.io/2022/02/16/2022-02/http-range/" data-id="ckzpdkrwo000090am6k5w85je" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/http/" rel="tag">http</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/" rel="tag">java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/spring/" rel="tag">spring</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-2022-01/voip-rtc" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/01/21/2022-01/voip-rtc/" class="article-date">
  <time datetime="2022-01-21T06:14:50.000Z" itemprop="datePublished">2022-01-21</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/rtc/">rtc</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/01/21/2022-01/voip-rtc/">VoIP和RTC</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <h1 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h1><h2 id="VoIP"><a href="#VoIP" class="headerlink" title="VoIP"></a>VoIP</h2><p>VoIP: <code>Voice over Internet Protocol</code><br>基于IP的语音传输。只是概念，不对应具体协议栈、有不同实现。<br>别名：IP电话、互联网电话、宽带电话、宽带电话服务。<br>VoIP可用于包括VoIP电话、智能手机、个人计算机在内的诸多互联网接入设备，通过蜂窝网络、Wi-Fi进行通话及发送短信。</p>
<p>VoIP的实现迭代:<br>(1)DSL/cable调制解调器<br>(2)Wifi/3G<br>(3)LTE<br>(4)RCS</p>
<h2 id="V-VoIP"><a href="#V-VoIP" class="headerlink" title="V.VoIP"></a>V.VoIP</h2><p><code>Video over IP</code><br>一些V.VoIP的基本要素包括信令、媒体引擎、会话描述协议（SDP）、实时传输协议/实时控制协议（RTP/RTCP）、<br>网络地址转换（NAT）、安全协议、服务质量（QoS），以及其余电话组件。<br>V.VoIP实质上是封装了全部这一切，再加上用户界面，包括拨号、通信录/联系人列表和呼叫历史记录（未接/已接/已拨电话），<br>以提供一个完整的V.VoIP客户端。</p>
<h2 id="RTC"><a href="#RTC" class="headerlink" title="RTC"></a>RTC</h2><p>RTC: <code>Real-Time Communications</code><br>RTC也就是实时交流。一般是指音\视频。日常生活中的例子包括：微信通话、视频会议、直播PK连麦、在线教育。</p>
<p>上述两种概念，都看重”端到端延时”指标，大致定义如下:</p>
<img src="/images/2022-01/voip_transfer.png" class="" width="800" height="1200" title="transfer">
<p>从这个流程，可以看出相比于普通文本传输，主要是多了和音视频相关的”采集”、”处理”、”编码”等操作。<br>其中的”网络”部分，由于VoIP是从电话网络演化而来，主要侧重于原来的电话网到IP网络；<br>RTC则主要侧重于IP网络。</p>
<h2 id="SIP协议"><a href="#SIP协议" class="headerlink" title="SIP协议"></a>SIP协议</h2><p><code>Session initialization Protocol</code><br>一种信令协议。<br>VoIP的具体实现的其中一部分的协议，主要做控制层（信令），基于文本。（RFC 2543, RFC 3261~3265）大致开始于1999年。</p>
<h2 id="WebRTC"><a href="#WebRTC" class="headerlink" title="WebRTC"></a>WebRTC</h2><p>谷歌收购GIPS引擎，与GTalk通信库合并，2011年纳入Chrome体系并开源，命名为WebRTC。<br>2012年获各大浏览器厂商支持，纳入W3C标准。</p>
<img src="/images/2022-01/web_rtc_sip.png" class="" width="800" height="1200" title="web_rtc_sip.png">

<p>WebRTC的架构大致如下，主要是给前端提供了封装好的API，屏蔽底层硬件。：</p>
<img src="/images/2022-01/webrtc.png" class="" width="800" height="1200" title="webrtc">

<p>绝大部分浏览器的新版本都支持webRTC:</p>
<img src="/images/2022-01/webrtc_support.png" class="" width="800" height="1200" title="webrtc_support.png">

<h2 id="RTMP"><a href="#RTMP" class="headerlink" title="RTMP"></a>RTMP</h2><p>RTMP: 是Real Time Messaging Protocol的简称，<br>基于 <em>TCP</em> 协议，用来进⾏实时数据通信的⽹络协议，<br>推流到CDN即用的是RTMP;</p>
<h2 id="SRS"><a href="#SRS" class="headerlink" title="SRS"></a>SRS</h2><p><code>Simple Realtime Server</code><br>互联网直播服务器集群的开源框架;<br><a href="https://github.com/ossrs/srs/wiki/v2_CN_Home" target="_blank" rel="noopener">https://github.com/ossrs/srs/wiki/v2_CN_Home</a></p>
<h1 id="发展历史"><a href="#发展历史" class="headerlink" title="发展历史"></a>发展历史</h1><h2 id="1996～2004：H323"><a href="#1996～2004：H323" class="headerlink" title="1996～2004：H323"></a>1996～2004：H323</h2><p>电话线上网时代；</p>
<h3 id="H-323标准"><a href="#H-323标准" class="headerlink" title="H.323标准"></a>H.323标准</h3><p>ITU（国际电信联盟）推出，<br>基于传统 PSTN 架构（Public Switched Telephone Network，公共交换电话网）。<br>(MCU+RTP)<br>H.323标准的VOIP网络中：<br>用户呼叫021号码：先送到上海、再到目的地；<br>在SIP中：直接查，无短途长途之分。</p>
<p>场景：PC语音会议；<br>优点：达到了可通话的质量；<br>缺点：MCU是中心化的，拓展性有上限。有合流成本。</p>
<h2 id="2001～2007-P2P-Mesh"><a href="#2001～2007-P2P-Mesh" class="headerlink" title="2001～2007: P2P/Mesh"></a>2001～2007: P2P/Mesh</h2><p>IETF, SIP(UDP + HTTP) 软交换</p>
<p>Skype: 超级节点+P2P/Mesh通信， 通信质量接近PSTN网络;<br>GTalk: 谷歌山寨的Skype</p>
<p>瑞典GIPS公司：开发出3A算法；<br>GIPS被谷歌收购，GIPS与 GTalk 的libjingle合并成为早期WebRTC一部分。</p>
<p>场景：社交IM的1v1通信；<br>优点：轻量级、架构拓展性强；<br>缺点：跨运营商无法保证Qos，去中心化后无法监控、管控；</p>
<h2 id="2003～2012-SFU"><a href="#2003～2012-SFU" class="headerlink" title="2003～2012: SFU"></a>2003～2012: SFU</h2><p>MMO RPG游戏兴起；</p>
<p>场景：游戏频道语音沟通、直播聊天室。<br>优点：架构简洁、实时性强，无需中心化合流聚合；<br>缺点：客户端下行压力大，互动人数有最大上限；</p>
<h2 id="SFU-vs-MCU"><a href="#SFU-vs-MCU" class="headerlink" title="SFU vs MCU"></a>SFU vs MCU</h2><p>SFU : Selective Forwarding Unit, 上行一路流，下行N路流，服务端仅转发。客户端压力大。<br>MCU: MultiPoint Control Unit, 中心化，上行下行都一路流，服务端负责合流。服务端压力大。</p>
<img src="/images/2022-01/sfu_mcu.png" class="" width="800" height="1200" title="sfu_mcu.png">

<h1 id="基础评估指标"><a href="#基础评估指标" class="headerlink" title="基础评估指标"></a>基础评估指标</h1><h2 id="性能相关："><a href="#性能相关：" class="headerlink" title="性能相关："></a>性能相关：</h2><ul>
<li>功耗</li>
<li>cpu/gpu/内存占用</li>
<li>引发降频时间(手机)<h2 id="屏幕分享相关"><a href="#屏幕分享相关" class="headerlink" title="屏幕分享相关"></a>屏幕分享相关</h2></li>
<li>清晰度&amp;分辨率</li>
<li>色彩准确度</li>
<li>相对静止场景最低码率</li>
<li>相对运动场景流畅度（文档滚动、局部动画）<br>基础端到端延时(&lt;1s)<h2 id="音频相关"><a href="#音频相关" class="headerlink" title="音频相关"></a>音频相关</h2></li>
<li>频宽</li>
<li>基础音质（POLQA评分&gt;2.5）</li>
<li>基础端到端延时</li>
<li>3A(增益控制、噪声一直、回声抵消)<h2 id="视频相关"><a href="#视频相关" class="headerlink" title="视频相关"></a>视频相关</h2></li>
<li>基础画质</li>
<li>基础流畅度（帧率、帧间隔）</li>
<li>基础端到端延时</li>
<li>音画同步</li>
</ul>
<h1 id="直播过程"><a href="#直播过程" class="headerlink" title="直播过程"></a>直播过程</h1><h2 id="对于主播："><a href="#对于主播：" class="headerlink" title="对于主播："></a>对于主播：</h2><p>1。申请开始直播:http; // 返回ok<br>2。获取推流目标:信令服务器 -&gt; 创建房间-&gt; 获取当前位置合适的MCU节点；<br>3。KTP推流到MCU节点；（UDP）<br>4。MCU存到SRS(经过RTMP转码);</p>
<h2 id="对于用户-拉数据"><a href="#对于用户-拉数据" class="headerlink" title="对于用户,拉数据:"></a>对于用户,拉数据:</h2><p>用户 -(flv over http)-&gt; CDN -&gt; Router -&gt; SRS</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://segmentfault.com/a/1190000040760567" target="_blank" rel="noopener">https://segmentfault.com/a/1190000040760567</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://xiaoyue26.github.io/2022/01/21/2022-01/voip-rtc/" data-id="ckyo0y0pf0000sdamb78d2vl7" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/rtc/" rel="tag">rtc</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/voip/" rel="tag">voip</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-2021-07/metaspace笔记" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/07/26/2021-07/metaspace%E7%AC%94%E8%AE%B0/" class="article-date">
  <time datetime="2021-07-26T03:45:43.000Z" itemprop="datePublished">2021-07-26</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/java/">java</a>►<a class="article-category-link" href="/categories/java/jvm/">jvm</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/07/26/2021-07/metaspace%E7%AC%94%E8%AE%B0/">metaspace笔记</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <h1 id="metaspace内容"><a href="#metaspace内容" class="headerlink" title="metaspace内容"></a>metaspace内容</h1><p>Klass Metaspace+NoKlass Metaspace: </p>
<img src="/images/2021-07/metaspace.png" class="" width="800" height="1200" title="metaspace">

<h1 id="Klass-Metaspace"><a href="#Klass-Metaspace" class="headerlink" title="Klass Metaspace"></a>Klass Metaspace</h1><blockquote>
<p>如果关闭压缩指针，或者堆大于32G，这块儿会存到NoKlass Metaspace里。</p>
</blockquote>
<p>存class元数据，JVM对class的表示。<br>vtable: 类中的方法（我理解类似虚函数指针，指到NoKlass区域）<br>itable: 类实现的接口<br>oop map: 类引用的对象地址</p>
<h1 id="NoKlass-Metaspace"><a href="#NoKlass-Metaspace" class="headerlink" title="NoKlass Metaspace"></a>NoKlass Metaspace</h1><p>方法相关：</p>
<blockquote>
<p>方法的字节码<br>参数信息<br>局部变量表<br>异常表</p>
</blockquote>
<p>常量池<br>注解<br>方法计数器（JIT）</p>
<h1 id="相关参数"><a href="#相关参数" class="headerlink" title="相关参数"></a>相关参数</h1><p><code>-Xnoclassgc</code>: 让 JVM 在垃圾收集的时候不去卸载类.<br>尽量别开启这个选项。</p>
<p><code>–XX:+CMSClassUnloadingEnabled</code>: 如果使用CMS，需要开启这个选项。</p>
<p><code>CompressedClassSpaceSize</code>: Klass空间的大小。默认1G,可能要改大。<br>比如可以CompressedClassSpaceSize设置2G, MaxMetaspaceSize设置3G.(看klass和noklass的比例)</p>
<h1 id="jstat"><a href="#jstat" class="headerlink" title="jstat"></a>jstat</h1><p>主要看MC，MU，CCSC，CCSU：<br>MC: Klass+NoKlass Metaspace已committed的内存大小/KB<br>MU: Klass+NoKlass Metaspace已使用的内存大小<br>CCSC: Klass Metaspace已commit的内存大小/KB<br>CCSU: Klass Metaspace已使用的内存大小/KB</p>
<p>其他:<br>M: Klass+NoKlass总共使用率<br>CCS: CCSU/CCSC<br>MCMN和CCSMN: 0<br>MCMX: Klass+NoKlass Metaspace两者总共的reserved的内存大小<br>CCSMX: Klass Metaspace reserved的内存大小</p>
<h1 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h1><p>每个class loader都会有自己的metaspace，各自分配（metachunk,metablock），但是总和是公用的。</p>
<p>普通类metaspace: 基本不太可能卸载，因为需要等class loader卸载；<br>匿名类metaspace: 跟着匿名类的生命周期。lambda和method handler可以提前卸载，不等待class loader。</p>
<p>卸载以后内存是否会归还：</p>
<ol>
<li>Klass空间必不归还；</li>
<li>noKlass空间: 如果Node分配给同一个class loader，比较容易归还；<br>如果分配给了多个class loader，不释放空间。<br>一个Node多个chunk；<br>单个chunk整体属于一个class loader；<br>一个chunk多个block，每个block是最小分配单元（分配给调用者）。</li>
</ol>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://javadoop.com/post/metaspace" target="_blank" rel="noopener">https://javadoop.com/post/metaspace</a><br><a href="https://segmentfault.com/a/1190000023235677" target="_blank" rel="noopener">https://segmentfault.com/a/1190000023235677</a><br><a href="https://www.infoq.cn/article/troubleshooting-java-memory-issues" target="_blank" rel="noopener">https://www.infoq.cn/article/troubleshooting-java-memory-issues</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://xiaoyue26.github.io/2021/07/26/2021-07/metaspace%E7%AC%94%E8%AE%B0/" data-id="ckrk3gxn90000jiam5pquf1al" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/" rel="tag">java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/jvm/" rel="tag">jvm</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/metaspace/" rel="tag">metaspace</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-2021-06/网络安全笔记-1" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/06/01/2021-06/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E7%AC%94%E8%AE%B0-1/" class="article-date">
  <time datetime="2021-06-01T03:29:57.000Z" itemprop="datePublished">2021-06-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/06/01/2021-06/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E7%AC%94%E8%AE%B0-1/">网络安全笔记-1</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <h1 id="黑客一般如何行动"><a href="#黑客一般如何行动" class="headerlink" title="黑客一般如何行动"></a>黑客一般如何行动</h1><p>知己知彼百战百胜，正如我们安全人员试图了解黑客，黑客也试图了解我们安全人员是如何防守的。<br>所以大方向上，黑客一般是先观察再行动、整个过程中隐藏自己（确保了解了对方，但不被对方了解）。细化以后就是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1.踩点(Footprinting): 确定目标地址范围、查询名字空间，收集所有细节</span><br><span class="line">2.扫描(Scaning): 评估目标、识别监听服务，集中于最有希望攻克的</span><br><span class="line">3.查点(Enumeration): 识别合法用户账号、保护力度不够的共享资源</span><br><span class="line">4.访问(Gaining Access): 发送木马或链接</span><br><span class="line">5.提权(Escalating Privilege): 从普通用户提到特权用户(比如ROOT)</span><br><span class="line">6.窃取(Pilfering): 数据和文件，收集入侵机制和途径；</span><br><span class="line">7.灭迹(Covering tracks): 掩盖来访痕迹;(显然这个是最重要的，别的失败了都没关系)</span><br><span class="line">8.创建后门(create backdoor): 为下次入侵准备便利</span><br></pre></td></tr></table></figure>
<p>其中步骤6窃取了其他账号的话，可以跳到步骤4重新访问，从而以更高权限用户进行后续步骤。</p>
<p>此外还有一招就是拒绝服务(DDOS),步骤4访问失败的话可能会采用。（强行让目标系统无法正常提供服务）</p>
<h1 id="上述步骤的具体技术手段实现"><a href="#上述步骤的具体技术手段实现" class="headerlink" title="上述步骤的具体技术手段实现"></a>上述步骤的具体技术手段实现</h1><h2 id="1-踩点"><a href="#1-踩点" class="headerlink" title="1. 踩点"></a>1. 踩点</h2><p>打开源查询: Usenet,搜索引擎,Edgar,GooScan,FingerGoogle<br>whois: dig,nslookup ls -d,Sam spade,dnsmap<br>whois的web接口: <a href="http://www.networksolutions.com/whois" target="_blank" rel="noopener">www.networksolutions.com/whois</a><br>ARIN whois: <a href="http://www.arin.net/whois" target="_blank" rel="noopener">www.arin.net/whois</a></p>
<p>其他思路扩展：<br>1.谷歌搜索返回值为”it worked!”的网站，就能找到初始配置apache的服务；<br>// intitle:Test.Page.for.Apache “it worked!” “this Web site!”<br>2.从目标公司的招聘要求（比如5年xxx防火墙经验，使用过xxx安全系统）就能猜到目标公司的现有安全软件是什么(甚至是几年前的版本)；<br>3.从地理位置，翻垃圾桶；<br>4.从有目标公司工作经历的简历库，能收集相应信息；</p>
<p>如何防范踩点：<br>可以参考RFC2196(公众信息安全对策)</p>
<h1 id="2-扫描"><a href="#2-扫描" class="headerlink" title="2.扫描"></a>2.扫描</h1><p>Ping系列工具：fping,hping,nmap<br>TCP/UDP端口扫描: SuperScan,AutoScan,Scanline<br>OS检测: nmap,amap,SinFP,xprobe2</p>
<h1 id="3-查点-Enumeration"><a href="#3-查点-Enumeration" class="headerlink" title="3.查点(Enumeration)"></a>3.查点(Enumeration)</h1><p>列出用户账号：空会话、DumpSec,PSTools<br>列出共享文件: showmount,SMB-NAT,nmbscan<br>识别应用程序: telnet/netcat抓取旗标<br>SNMP: rpcinfo,amap,nmap,Cisco Torch</p>
<h1 id="4-访问"><a href="#4-访问" class="headerlink" title="4.访问"></a>4.访问</h1><p>密码嗅探: airsnarf,dsniff,Cain and Abel,phoss<br>蛮力攻击: hydra,medusa<br>渗透工具: SIPcrack, Metasploit Framework,Canvas</p>
<h1 id="5-提权"><a href="#5-提权" class="headerlink" title="5.提权"></a>5.提权</h1><p>破解密码: John The Ripper,L0phtcrack,rcr<br>利用漏洞: Metasploit Framework</p>
<h1 id="6-窃取"><a href="#6-窃取" class="headerlink" title="6.窃取"></a>6.窃取</h1><p>评估可信系统: rhots,LAS Secrets<br>搜索明文密码: 用户数据,配置文件,WINDOWS R</p>
<h1 id="7-灭迹"><a href="#7-灭迹" class="headerlink" title="7.灭迹"></a>7.灭迹</h1><p>清除日志记录: logclean-ng,wtmpclean<br>掩藏工具: rootkits,文件流</p>
<h1 id="8-创建后门"><a href="#8-创建后门" class="headerlink" title="8.创建后门"></a>8.创建后门</h1><p>创建流氓用户账号: members of wheel,Administrators<br>安排批处理作业: cron, AT<br>感染启动文件: rc,启动文件夹，注册表键<br>植入远程控制服务: netcat, psexec, VNC<br>安装监控机制: 键击记录器<br>用木马替换真实应用: login, fpnwclnt.dll,patched SSH version</p>
<h1 id="9-DDOS"><a href="#9-DDOS" class="headerlink" title="9. DDOS"></a>9. DDOS</h1><p>Syn泛洪: synk4<br>ICMP技术: ping of death, smurf, ICMP nuke<br>Overlapping fragment/offset bugs: teardrop,bonk,newtear<br>Out of bounds TCP options: supernuke.ext<br>(OOB)DDOS: trincoo/TFN/stacheldraht</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://xiaoyue26.github.io/2021/06/01/2021-06/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E7%AC%94%E8%AE%B0-1/" data-id="ckpdhht4e0000tnam77yth2yk" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%AE%89%E5%85%A8/" rel="tag">安全</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-2021-02/多项目共享代码之——git-subtree" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/02/22/2021-02/%E5%A4%9A%E9%A1%B9%E7%9B%AE%E5%85%B1%E4%BA%AB%E4%BB%A3%E7%A0%81%E4%B9%8B%E2%80%94%E2%80%94git-subtree/" class="article-date">
  <time datetime="2021-02-22T14:32:12.000Z" itemprop="datePublished">2021-02-22</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/">项目管理</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/02/22/2021-02/%E5%A4%9A%E9%A1%B9%E7%9B%AE%E5%85%B1%E4%BA%AB%E4%BB%A3%E7%A0%81%E4%B9%8B%E2%80%94%E2%80%94git-subtree/">多项目共享代码之——git subtree</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <h1 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h1><p>多个项目之间共享代码。<br>背景是前后端之间有一些protoc代码需要共享，避免互相发送文件（像某广东大厂这么山寨）。<br>由于protoc文件一般很小，因此首先考虑使用git subtree来建立子项目。</p>
<blockquote>
<p>如果需要共享的部分占的存储空间很大（比如是一个超大的分词字典，则应该考虑git submodule）。</p>
</blockquote>
<h1 id="WHY-为什么选择git-substree"><a href="#WHY-为什么选择git-substree" class="headerlink" title="WHY: 为什么选择git substree"></a>WHY: 为什么选择git substree</h1><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><p><strong>简单、不容易出错</strong><br>只有用到了这个子目录、子仓库的人才会需要使用git subtree相关命令去更新代码；也就是对于其他模块的开发人员，这就是一个普通目录，完全无感知，对无关人员完全透明。</p>
<h2 id="劣势"><a href="#劣势" class="headerlink" title="劣势"></a>劣势</h2><p><strong>性能</strong><br>由于git substree本质上是跟踪了子仓库的所有文件来实现的，因此如果子仓库的存储空间占用很大，父仓库的git性能就会受到影响。（这个时候就需要考虑用别的办法了，比如从外部存储读取、或者用git submodule。）</p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><h3 id="git-subtree"><a href="#git-subtree" class="headerlink" title="git subtree:"></a>git subtree:</h3><p>本质上是通过分支合并的方法模拟了一个子仓库，对于父仓库来说其实相当于从头到尾只有一个git。<br>首先git fetch就可以拉取任意git地址的代码，所以先用git fetch拉到某个目录，然后通过分支合并的方式把它们合并到当前分支。<br>因此本质上会跟踪子仓库所有文件。存储开销比较大。适用于子仓库全是纯代码的情况。</p>
<p>git subtree是由第三方开发者贡献的脚本，用git底层命令封装出来的。<br>从v1.5.2开始,git新增并推荐使用这个功能来管理子项目。</p>
<h3 id="git-submodule"><a href="#git-submodule" class="headerlink" title="git submodule:"></a>git submodule:</h3><p>本质上父仓库只记录子仓库的commit-id，因此存储开销很小。但是缺点就是直接git clone的时候只会拉父仓库的代码，子仓库是空的，需要每个开发人员都主动拉子仓库代码，或者用递归的参数去拉。开发过程中出错的概率很高、比较繁琐，除非万不得已最好别用。</p>
<h1 id="HOW-git-subtree使用"><a href="#HOW-git-subtree使用" class="headerlink" title="HOW: git subtree使用"></a>HOW: git subtree使用</h1><p>首先新建一个git项目，补充.gitignore文件。<br>然后在原有的项目中通过以下命令来引入该项目到某个子目录(不需要预先创建子目录):</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 首次下载</span></span><br><span class="line">git remote add -f &lt;子仓库名&gt; &lt;子仓库地址&gt;</span><br><span class="line">git subtree add --prefix=&lt;子目录名&gt; &lt;子仓库名&gt; &lt;分支&gt; --squash</span><br><span class="line">git fetch &lt;远程仓库名&gt; &lt;分支&gt;</span><br><span class="line">git subtree pull --prefix=&lt;子目录名&gt; &lt;远程仓库名&gt; &lt;分支&gt; --squash</span><br><span class="line"><span class="meta">#</span><span class="bash"> git push review</span></span><br></pre></td></tr></table></figure>
<p>其中的&lt;分支&gt;指的是子项目的分支。<br>以上前4个命令对应的操作就是：<br>1.给远程的某个xxx.git地址取个别名记录下来；<br>2.创建一个子目录专门跟踪子仓库；<br>3.拉取子仓库的某分支的代码；<br>4.把拉取的代码放到子目录。<br>建立关联以后，以后如果想要pull子项目代码，就只需要执行以下几步:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 非首次下载</span></span><br><span class="line">git fetch &lt;远程仓库名&gt; &lt;分支&gt;</span><br><span class="line">git subtree pull --prefix=&lt;子目录名&gt; &lt;远程仓库名&gt; &lt;分支&gt; --squash</span><br><span class="line"><span class="meta">#</span><span class="bash"> git push review</span></span><br></pre></td></tr></table></figure>
<p>以上就是一般情况下使用git subtree所需的所有命令了，非常得简单，新命令其实也只有两个git subtree命令。</p>
<blockquote>
<p>这里大家可能会疑惑为什么没有提到给子仓库提交\push的命令，<br>其实命令是有的，但是没有必要在父仓库里提交子仓库的代码；<br>如果想更新子仓库的代码，直接随便找个目录git clone，git add，git commit, git push就行了，没有必要多记1个非必要的命令。<br>不过如果只是出于收藏爱好，可以收藏一下这个非必要的命令：</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git subtree push --prefix=&lt;子目录名&gt; &lt;远程仓库名&gt; 分支</span><br></pre></td></tr></table></figure>




<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://my.oschina.net/jellypie/blog/487619" target="_blank" rel="noopener">https://my.oschina.net/jellypie/blog/487619</a><br><a href="https://zhuanlan.zhihu.com/p/100214931" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/100214931</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://xiaoyue26.github.io/2021/02/22/2021-02/%E5%A4%9A%E9%A1%B9%E7%9B%AE%E5%85%B1%E4%BA%AB%E4%BB%A3%E7%A0%81%E4%B9%8B%E2%80%94%E2%80%94git-subtree/" data-id="cklkmfo9y000hpdambromg3wk" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/git/" rel="tag">git</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/" rel="tag">项目管理</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-2020-12/跨域相关" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/12/27/2020-12/%E8%B7%A8%E5%9F%9F%E7%9B%B8%E5%85%B3/" class="article-date">
  <time datetime="2020-12-27T12:46:01.000Z" itemprop="datePublished">2020-12-27</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/http/">http</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/12/27/2020-12/%E8%B7%A8%E5%9F%9F%E7%9B%B8%E5%85%B3/">跨域相关</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <h1 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h1><p>部分url:<br>1.接受公司旗下域名跨域请求;<br>2.post请求+json返回值;</p>
<h1 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h1><h2 id="可选方案"><a href="#可选方案" class="headerlink" title="可选方案"></a>可选方案</h2><p>1.jsonp: 只支持GET, 否决；</p>
<p>2.nginx配置: 需要改配置上线，备选；</p>
<p>3.java配置注解<code>@CrossOrigin</code>: 经测试可行，新域名或新<code>url</code>需要重新打包上线，备选;</p>
<p>4.使用<code>filter</code>/<code>interceptor</code>统一配置，可方便得使用配置中心上线新域名、<code>url</code>，备选；</p>
<p>对于目标1，理想情况是使用配置中心来快速增加支持的域名，因此优先考虑方案4；</p>
<p>由于目标2，我们基本上用的都是post+json的接口，因此浏览器跨域前会用Options命令询问服务器的跨域权限配置。</p>
<p>这里需要注意的问题：</p>
<p>Options命令不带cookie，因此过不了鉴权，需要考虑放行或者不加鉴权;<br>1.多一次网络请求，考虑转化为简单请求避免Options命令。（如<code>text/plain</code>）<br>2.<code>Options</code>命令通过的结果缓存在浏览器的时间由<code>Access-Control-Max-Age</code>控制（秒）。</p>
<img src="/images/2020-12/cors.png" class="" width="800" height="1200" title="cors">


<h1 id="日志相关"><a href="#日志相关" class="headerlink" title="日志相关"></a>日志相关</h1><p>如果设置 <code>Access-Control-Allow-Credentials</code>：<code>true</code>;<br>则可以在日志打印cookie信息。（除options请求外的）</p>
<p>但如果没有鉴权需求这里应该不允许携带cookie，避免提权攻击。<br>比如后端有执行代码的漏洞，又允许别人带着cookie过来，就造成CSRF攻击。<br>参考: <a href="https://zhuanlan.zhihu.com/p/86626693" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/86626693</a><br>所以将allowCredentials设置成false。</p>
<h1 id="可能的坑"><a href="#可能的坑" class="headerlink" title="可能的坑"></a>可能的坑</h1><p>本质上是浏览器进行的同源控制提高安全性，需要服务器告诉浏览器哪些跨域是安全的，<br>因此最重要的是与浏览器相连的第一跳返回的header情况。<br>如果前面几跳(如SSR,nginx)都是直接透传Header的话，才能确保我们的后端配置生效。</p>
<p>chrome浏览器查看options请求可能需要修改配置，不属于XHR请求；<br>wireshard可以抓到不加密(vpn往往加密了)的options请求。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="http://www.ruanyifeng.com/blog/2016/04/cors.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2016/04/cors.html</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://xiaoyue26.github.io/2020/12/27/2020-12/%E8%B7%A8%E5%9F%9F%E7%9B%B8%E5%85%B3/" data-id="cklkmfo8t0000pdamd7knbv1s" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/http/" rel="tag">http</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/nginx/" rel="tag">nginx</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-2020-12/线上性能优化-查看方法级耗时" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/12/20/2020-12/%E7%BA%BF%E4%B8%8A%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-%E6%9F%A5%E7%9C%8B%E6%96%B9%E6%B3%95%E7%BA%A7%E8%80%97%E6%97%B6/" class="article-date">
  <time datetime="2020-12-20T12:36:32.000Z" itemprop="datePublished">2020-12-20</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/java/">java</a>►<a class="article-category-link" href="/categories/java/%E6%80%A7%E8%83%BD/">性能</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/12/20/2020-12/%E7%BA%BF%E4%B8%8A%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-%E6%9F%A5%E7%9C%8B%E6%96%B9%E6%B3%95%E7%BA%A7%E8%80%97%E6%97%B6/">线上性能debug-查看方法级耗时</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><p>可以手动挨个儿方法打debug日志；<br>可以用AOP集中拦截打日志；<br>可以用async-profiler查看火焰图；<br>可以用groovy动态执行benchmark;<br>可以用arthas的trace命令。</p>
<h1 id="目标-问题背景"><a href="#目标-问题背景" class="headerlink" title="目标(问题背景)"></a>目标(问题背景)</h1><p>背景是线上某个接口慢，需要优化。为了找到优化的方向，首先需要知道接口的各个部分的耗时，这样才能找到耗时比例最高的部分针对性地优化。<br>有些时候我们可以使用公司基础架构提供的<code>trace</code>\ <code>rpc monitor</code>来查看rpc调用粒度的耗时；（很多时候慢都是因为某个rpc服务调用慢）<br>但有些时候我们还是需要知道更细粒度、方法粒度的耗时或者耗时占比, 因为<code>trace</code>中的<code>span</code>一般粒度都是IO调用、如数据库访问、redis访问、rpc调用这种级别。</p>
<h1 id="实操"><a href="#实操" class="headerlink" title="实操"></a>实操</h1><h2 id="方法1：每个方法打日志"><a href="#方法1：每个方法打日志" class="headerlink" title="方法1：每个方法打日志"></a>方法1：每个方法打日志</h2><p>直接在每个方法开始结束的地方打上debug日志，然后在需要查看耗时的时候，运行时调整日志级别，用arthas:</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ognl <span class="string">'@com.xxx.spring.BeanFactory@getBean("xxxxServiceImpl").logger.setLevel(@ch.qos.logback.classic.Level@DEBUG)'</span></span><br></pre></td></tr></table></figure>

<p>这里不一定用<code>com.xxx.spring.BeanFactory</code>, 也可以用某个<code>applicationAware</code>、能拿到<code>applicatoinContext</code>的类，反正只要能用一行代码访问到logger就行。<br>如果logger所在的bean没有在<code>ApplicationContext</code>里(比如<code>interceptor</code>)，可以考虑把logger改成<code>static</code>的。 </p>
<h2 id="方法2：AOP集中拦截打日志"><a href="#方法2：AOP集中拦截打日志" class="headerlink" title="方法2：AOP集中拦截打日志"></a>方法2：AOP集中拦截打日志</h2><p>这个方法其实算是方法1的简单升级，毕竟每个方法都加上两行开始结束的日志代码量太大，实现上不可能做到。可以用AOP的表达式把所有需要监控的方法都覆盖进去。</p>
<p>这种方法也需要改动代码。</p>
<h2 id="方法3：用async-profiler查看火焰图"><a href="#方法3：用async-profiler查看火焰图" class="headerlink" title="方法3：用async-profiler查看火焰图"></a>方法3：用async-profiler查看火焰图</h2><p>前两种方法都需要改动代码，改造成本较高。一个很自然的思路查看耗时占比是我们手动疯狂jstack，统计一下最多次停留的方法，就是耗时占比最高的方法。</p>
<p>代替手动jstack的工具就是<a href="https://github.com/jvm-profiling-tools/async-profiler。" target="_blank" rel="noopener">https://github.com/jvm-profiling-tools/async-profiler。</a><br>可以使用命令(采样30秒)： </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./profiler.sh -d 30 -f time.svg &lt;pid&gt;</span><br></pre></td></tr></table></figure>
<p>有时候会发现意外的耗时瓶颈。（简单的过滤入口操作）<br>生成的svg文件可以直接用谷歌浏览器打开，可视化的结果，支持点击展开任意层级，非常得方便。</p>
<img src="/images/2020-12/svg.png" class="" width="800" height="1200" title="svg">


<h2 id="方法4：用groovy脚本动态执行benchmark"><a href="#方法4：用groovy脚本动态执行benchmark" class="headerlink" title="方法4：用groovy脚本动态执行benchmark"></a>方法4：用groovy脚本动态执行benchmark</h2><p>有时候线上接口有缓存，阻碍了我们收集p95耗时的瓶颈。这个时候我们可以用groovy脚本动态传入需要执行的java代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 某个bean中的预留方法:</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">debug</span><span class="params">(String code)</span></span>&#123;</span><br><span class="line">        String groovyStr = code; <span class="comment">// 需要执行的benchmark代码</span></span><br><span class="line">        Binding binding = <span class="keyword">new</span> Binding();</span><br><span class="line">        GroovyShell groovyShell = <span class="keyword">new</span> GroovyShell(binding);</span><br><span class="line">        Script script = groovyShell.parse(groovyStr);</span><br><span class="line">        <span class="keyword">return</span> script.run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里由于当做脚本语言来用了，安全隐患就是不能让我们以外的人调用，因此如果是内网业务可以鉴权后调用；<br>外网业务则让可以这个方法没有任何地方调用，需要用的时候我们自己登到机器上用arthas来调用。<br>(如果黑客入侵到这个程度的话，也无所谓有没有这个方法了)</p>
<h2 id="方法5：用arthas的trace命令"><a href="#方法5：用arthas的trace命令" class="headerlink" title="方法5：用arthas的trace命令"></a>方法5：用arthas的trace命令</h2><p>如果不仅需要知道耗时占比，还想知道耗时的具体大小，可以用arthas的trace命令:</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">trace --skipJDKMethod <span class="literal">false</span> com.xxx.service.impl.XXXXServiceImpl method1 <span class="string">'#cost &gt; 200'</span></span><br></pre></td></tr></table></figure>
<p>需要注意一定要加<code>--skipJDKMethod false</code>这个参数，因为我们很多时候用了java8的stream方法，如果跳过了jdk方法的统计，会发现各个子方法的耗时加起来不等于总耗时。</p>
<p>这个不像<code>async-profiler</code>一样能看到所有层级的调用，默认是一层，如果加了这个参数，能看到很多时候耗时最高的方法是 <code>collect</code>方法。</p>
<img src="/images/2020-12/trace.png" class="" width="800" height="1200" title="trace">



<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>方法3可以看到整个调用栈展开后的耗时占比；<br>方法4可以构造多次的调用；<br>方法5只能每次看一层，需要一层一层手动去找，而且官方给的通过listenId增强的方法需要用到telnet，而容器里往往根本没有telnet。因此实际上需要我们一层层去找。</p>
<p>实际工作上往往需要我们结合方法3、4、5。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://xiaoyue26.github.io/2020/12/20/2020-12/%E7%BA%BF%E4%B8%8A%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-%E6%9F%A5%E7%9C%8B%E6%96%B9%E6%B3%95%E7%BA%A7%E8%80%97%E6%97%B6/" data-id="cklkmfo8z0003pdam0q8a4i0z" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/arthas/" rel="tag">arthas</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/groovy/" rel="tag">groovy</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/" rel="tag">java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" rel="tag">性能优化</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-2020-12/升级HTTP2笔记" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/12/19/2020-12/%E5%8D%87%E7%BA%A7HTTP2%E7%AC%94%E8%AE%B0/" class="article-date">
  <time datetime="2020-12-19T07:45:17.000Z" itemprop="datePublished">2020-12-19</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/http/">http</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/12/19/2020-12/%E5%8D%87%E7%BA%A7HTTP2%E7%AC%94%E8%AE%B0/">升级HTTP2笔记</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <h1 id="已知的坑"><a href="#已知的坑" class="headerlink" title="已知的坑"></a>已知的坑</h1><h2 id="header大小写"><a href="#header大小写" class="headerlink" title="header大小写"></a>header大小写</h2><p>header names按http1.1协议是不区分大小写的，http2里全是小写，nginx反向代理会保留大小写，所以如果以前的代码依赖大写，就会挂掉。</p>
<p>(为啥h2里变小写了: HPACK算法, 解压的时候查表还原header names, 类似于哈夫曼算法)</p>
<h2 id="与websocket不能共用域名-只支持https"><a href="#与websocket不能共用域名-只支持https" class="headerlink" title="与websocket不能共用域名, 只支持https"></a>与websocket不能共用域名, 只支持https</h2><p>websocket和http2都是从http协议握手协商升级过去的，也就是起点是http1.1。 两种协商过程:</p>
<ul>
<li>http1.1 -Upgrade=&gt; websocket+ssl (wss)</li>
<li>http1.1 -Upgrade=&gt; http2</li>
</ul>
<p>H2是基于https的，因此如果某个域名切换到H2以后，就只能支持https的链接了，不再支持http;<br>如果硬要不加密、不安全，可以使用H2C，但是主流浏览器都声称不会支持H2C，因此这个选项其实并不实际。</p>
<p> (这个倒是不能算坑，只能算一个特性)</p>
<h1 id="Why-为什么要升级到H2"><a href="#Why-为什么要升级到H2" class="headerlink" title="Why: 为什么要升级到H2"></a>Why: 为什么要升级到H2</h1><p>主要是性能上的优化。</p>
<p>Http2的修改:</p>
<p>1.header压缩: HPACK算法;</p>
<p>2.服务器推送: server push，推送html里的css,js; </p>
<p>3.pipeline请求;</p>
<p>4.多路复用，同域名单个TCP连接，划分stream id;</p>
<p>5.二进制传输;</p>
<p>其中1、3、5肯定提升性能；</p>
<p>2则取决于缓存策略，因为可能服务器push了客户端已经缓存的资源，浪费带宽；</p>
<p>4取决于优先级策略，因为把以前前端手动控制的优先级策略，交给浏览器内核来自动实现，按<a href="https://blog.cloudflare.com/zh/better-http-2-prioritization-for-a-faster-web-zh/" target="_blank" rel="noopener">https://blog.cloudflare.com/zh/better-http-2-prioritization-for-a-faster-web-zh/</a> ， 谷歌内核是最接近最优策略的。但是由于以前可以多开TCP连接，现在是单开，因此如果有大图片，会阻塞后面的小图片。</p>
<p>谷歌的优先级处理逻辑如下：</p>
<img src="/images/2020-12/chrome_loading-1.gif" class="" width="800" height="1200" title="loading">

<p>此外，由于有了特性4，不再需要前端内联资源，因此一些针对http1.1的优化可以回滚，好处是可以简化代码，提高缓存效率，去掉重复建立连接的开销；</p>
<p>坏处就是不能再依赖多开TCP连接了，图片只能一张一张刷开。</p>
<h1 id="HOW-怎么升级到H2"><a href="#HOW-怎么升级到H2" class="headerlink" title="HOW:怎么升级到H2"></a>HOW:怎么升级到H2</h1><p>根据nginx官网的指导，没有必要全链路H2,只需要client到nginx是H2就够了(terminate protocol)。后端服务可以维持原来的协议。（类似于以前升级https）</p>
<p>因此只需要修改nginx配置即可，对后端服务无感知。(如下图)</p>
<img src="/images/2020-12/ng.png" class="" width="800" height="1200" title="ng">

<p>ng官网指导: <a href="https://www.nginx.com/blog/7-tips-for-faster-http2-performance/" target="_blank" rel="noopener">https://www.nginx.com/blog/7-tips-for-faster-http2-performance/</a></p>
<h2 id="为什么没必要全链路H2"><a href="#为什么没必要全链路H2" class="headerlink" title="为什么没必要全链路H2:"></a>为什么没必要全链路H2:</h2><p>按ng官网的说法，H2的主要优点是性能提高，对于内网网速来说，这点提升意义不大；</p>
<p>因此nginx只在服务端支持H2, 不支持客户端H2(转发的时候)。</p>
<p>如果想要全链路H2, 就不能用nginx了。</p>
<h1 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h1><p>1.<a href="https://zhuanlan.zhihu.com/p/276057825" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/276057825</a></p>
<p>2.<a href="https://www.cnblogs.com/confach/p/10141273.html" target="_blank" rel="noopener">https://www.cnblogs.com/confach/p/10141273.html</a></p>
<p>3.<a href="https://zhuanlan.zhihu.com/p/89471776" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/89471776</a></p>
<p>4.<a href="https://juejin.im/post/6844903745218674695" target="_blank" rel="noopener">https://juejin.im/post/6844903745218674695</a></p>
<p>5.<a href="https://blog.cloudflare.com/zh/better-http-2-prioritization-for-a-faster-web-zh/" target="_blank" rel="noopener">https://blog.cloudflare.com/zh/better-http-2-prioritization-for-a-faster-web-zh/</a></p>
<p>6.<a href="https://hpbn.co/http2/#stream-prioritization" target="_blank" rel="noopener">https://hpbn.co/http2/#stream-prioritization</a></p>
<p>7.<a href="https://calendar.perfplanet.com/2018/http2-prioritization/" target="_blank" rel="noopener">https://calendar.perfplanet.com/2018/http2-prioritization/</a></p>
<p>8.<a href="https://www.jianshu.com/p/e57ca4fec26f" target="_blank" rel="noopener">https://www.jianshu.com/p/e57ca4fec26f</a></p>
<p>9.<a href="https://zhuanlan.zhihu.com/p/26559480" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/26559480</a></p>
<p>10.<a href="https://www.cnblogs.com/ranFengHua/p/10816956.html" target="_blank" rel="noopener">https://www.cnblogs.com/ranFengHua/p/10816956.html</a></p>
<p>11.<a href="https://blog.csdn.net/liujiyong7/article/details/64478317" target="_blank" rel="noopener">https://blog.csdn.net/liujiyong7/article/details/64478317</a></p>
<p>12.<a href="https://www.nginx.com/blog/7-tips-for-faster-http2-performance/" target="_blank" rel="noopener">https://www.nginx.com/blog/7-tips-for-faster-http2-performance/</a></p>
<p>13.<a href="https://www.cnblogs.com/operationhome/p/12577540.html" target="_blank" rel="noopener">https://www.cnblogs.com/operationhome/p/12577540.html</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://xiaoyue26.github.io/2020/12/19/2020-12/%E5%8D%87%E7%BA%A7HTTP2%E7%AC%94%E8%AE%B0/" data-id="cklkmfo8y0001pdam8kzy25s3" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/http/" rel="tag">http</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/nginx/" rel="tag">nginx</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-2020-07/ES实战笔记" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/07/22/2020-07/ES%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0/" class="article-date">
  <time datetime="2020-07-22T10:58:58.000Z" itemprop="datePublished">2020-07-22</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/es/">es</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/07/22/2020-07/ES%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0/">ES实战笔记</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <h1 id="索引结构"><a href="#索引结构" class="headerlink" title="索引结构"></a>索引结构</h1><img src="/images/2020-07/lsm-tree.png" class="" width="800" height="1200" title="lsm-tree">
<p>ES底层的lucene引擎的分段，比较类似LSM tree的机制。<br>分段不可变，合并生成新的大的分段。<br>ES中的translog对应Hbase中的WAL日志，防止进程崩了丢数据;</p>
<h1 id="常用api"><a href="#常用api" class="headerlink" title="常用api"></a>常用api</h1><p>查看分析器对某段文本的结果:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -XPOST 'localhost:9200/get-together/_analyze?analyzer=myCustomAnalyzer' -d 'share your experience with NoSqlιbig data technologies'</span><br></pre></td></tr></table></figure>


<p>组合内置分词器和过滤器,空格分词、小写+反转:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -XPOST 'localhost:9200/_analyze?tokenizer=whitespace&amp;filters=lowercase,reverse' -d  'share your experience with NoSql big data technolog es'</span><br></pre></td></tr></table></figure>

<p>查看单文档的所有token信息:(get-together索引下、group类型、文档id为1):</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl 'localhost:9200/get-together/group/1/_termvector?pretty=true'</span><br></pre></td></tr></table></figure>

<h1 id="分析器"><a href="#分析器" class="headerlink" title="分析器"></a>分析器</h1><p>分析器 = 0到1个字符过滤器 + 1个单个分词器 + 0到n个分词过滤器;</p>
<h2 id="标准分析器-默认"><a href="#标准分析器-默认" class="headerlink" title="标准分析器(默认)"></a>标准分析器(默认)</h2><p><code>standard analyzer</code> = 标准分词器 + 标准分词过滤器 + 小写转换分词过滤器 + 停用词分词过滤器<br>（0字符过滤+1分词器+3分词过滤器）</p>
<h2 id="简单分析器"><a href="#简单分析器" class="headerlink" title="简单分析器"></a>简单分析器</h2><p><code>simple analyzer</code>: 在非字母处进行分词 + 转小写</p>
<h2 id="空白分析器"><a href="#空白分析器" class="headerlink" title="空白分析器"></a>空白分析器</h2><p><code>whitespace analyzer</code>: 根据空白分词 + 0分词过滤器</p>
<h2 id="停用词过滤器"><a href="#停用词过滤器" class="headerlink" title="停用词过滤器"></a>停用词过滤器</h2><p><code>stop analyzer</code>: 根据停用词分词 + 0分词过滤器；</p>
<h2 id="模式分析器"><a href="#模式分析器" class="headerlink" title="模式分析器"></a>模式分析器</h2><p><code>pattern analyzer</code>: 允许指定一个分词切分模式;</p>
<h2 id="语言分析器"><a href="#语言分析器" class="headerlink" title="语言分析器"></a>语言分析器</h2><p>包括汉语;</p>
<h2 id="雪球分析器"><a href="#雪球分析器" class="headerlink" title="雪球分析器"></a>雪球分析器</h2><p><code>snowball analyzer</code>: 标准分析器 + 雪球词干器; </p>
<h1 id="分词器"><a href="#分词器" class="headerlink" title="分词器"></a>分词器</h1><h2 id="标准分词器"><a href="#标准分词器" class="headerlink" title="标准分词器"></a>标准分词器</h2><p>主要处理欧洲语言,移除标点;</p>
<h2 id="关键词分词器"><a href="#关键词分词器" class="headerlink" title="关键词分词器"></a>关键词分词器</h2><p>整个文本提供给过滤器</p>
<h2 id="字母分词器"><a href="#字母分词器" class="headerlink" title="字母分词器"></a>字母分词器</h2><p>基于非字母分词</p>
<h2 id="小写分词器"><a href="#小写分词器" class="headerlink" title="小写分词器"></a>小写分词器</h2><p>非字母分词+转换成小写</p>
<h2 id="空白分词器"><a href="#空白分词器" class="headerlink" title="空白分词器"></a>空白分词器</h2><p>通过空白来分词</p>
<h2 id="模式分词器"><a href="#模式分词器" class="headerlink" title="模式分词器"></a>模式分词器</h2><p>例如可以在出现文本._.的地方分词:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">curl -XPOST 'localhost:9200/pattern' -d '&#123;</span><br><span class="line">"settngs": &#123;</span><br><span class="line">    ”index” : &#123;</span><br><span class="line">        ”analysis”: &#123;</span><br><span class="line">            ”tokenizer": &#123;</span><br><span class="line">                ”patternl”: &#123;</span><br><span class="line">                    ”type": ”pattern”,</span><br><span class="line">                    ”pattern”:”\\.-\\.”</span><br></pre></td></tr></table></figure>

<h2 id="UAX-URL电子邮件分词器"><a href="#UAX-URL电子邮件分词器" class="headerlink" title="UAX/URL电子邮件分词器"></a>UAX/URL电子邮件分词器</h2><p><a href="mailto:john.smith@example.com">john.smith@example.com</a> =&gt; 标准分词<br>=&gt;<br>john.smith<br>example.com</p>
<p><a href="http://example.com?q=foo" target="_blank" rel="noopener">http://example.com?q=foo</a> =&gt; 标准分词<br>http、example.com、q、foo</p>
<p>如果用UAX/URL电子邮件分词器，则可以保留:<br><a href="mailto:john.smith@example.com">john.smith@example.com</a>(type:&lt; EMAIL&gt;)<br><a href="http://example.com?q=bar" target="_blank" rel="noopener">http://example.com?q=bar</a>(type:&lt; URL&gt;)</p>
<h2 id="路径层次分词器"><a href="#路径层次分词器" class="headerlink" title="路径层次分词器"></a>路径层次分词器</h2><p><code>path hierarchy tokenizer</code><br>输入: /usr/local/var/log/es/log<br>分词结果: /usr、/usr/local、 …. /usr/local/var/log/es/log<br>因此有相同父目录的路径搜索(分词有相同部分)，能互相搜到。</p>
<h1 id="分词过滤器"><a href="#分词过滤器" class="headerlink" title="分词过滤器"></a>分词过滤器</h1><p>标准分词过滤器: 啥也不做;<br>小写过滤器、停用词过滤器、长度分词过滤器: 将最短和最长的单词过滤掉(自行设置min\max);<br>截断分词过滤器: 截断超出长度token;<br>修建分词过滤器: trim<br>限制分词数量分词过滤器: 限制最多多少个token被索引,比如设置max=8;<br>reverse分词过滤器: 把token反转，可以用于支持后缀索引;<br>唯一分词过滤器: 每个单词只保留第一次出现的位置(去重了)<br>ascii折叠分词过滤器: 尽量转ascii<br>同义词分词过滤器: 转成同义词<br>ngram过滤器: 略<br>滑动窗口分词过滤器: 略</p>
<h1 id="提取词干"><a href="#提取词干" class="headerlink" title="提取词干"></a>提取词干</h1><p>这个好像只是英文有用。把单词缩减到词根。<br>administrations -&gt; administr<br>词干提取器: snowball,porter_stem,kstem<br>字典提取词干: hunspell分词过滤器+字典</p>
<h1 id="打分相关"><a href="#打分相关" class="headerlink" title="打分相关"></a>打分相关</h1><ol>
<li>TF-IDF: 词频、逆文档频率<img src="/images/2020-07/tf-idf.png" class="" width="800" height="1200" title="tf-idf"></li>
<li>Okapi BM25;</li>
<li>随机性分歧: DFR相似度</li>
<li>IB相似度;</li>
<li>LM dirichlet相似度;</li>
<li>LM Jelinek Mercer相似度;</li>
</ol>
<h2 id="BM25"><a href="#BM25" class="headerlink" title="BM25"></a>BM25</h2><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">"mappings"</span>:&#123;</span><br><span class="line">    <span class="attr">"get-together"</span>: &#123;</span><br><span class="line">        <span class="attr">"properties"</span>: &#123;</span><br><span class="line">            <span class="attr">"title"</span>:&#123;</span><br><span class="line">                <span class="attr">"type"</span>:<span class="string">"string"</span></span><br><span class="line">                ,<span class="attr">"similarity"</span>: <span class="string">"BM25"</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>BM25的3个重要参数:<br>k1: 数值, 词频的重要性; (默认1.2)<br>b: 0~1数值, 篇幅对于得分的影响程度; (默认0.75)<br>discount_overlaps: 多个分词出现在同一位置，是否影响长度的标准化(默认true)</p>
<h2 id="boosting-加权"><a href="#boosting-加权" class="headerlink" title="boosting: 加权"></a>boosting: 加权</h2><p>可以用来修改文档相关性的程序。<br>包括:</p>
<ul>
<li>索引期boosting</li>
<li>查询期boosting</li>
</ul>
<p>一般使用查询期boosting(避免重新索引全部文档)</p>
<h1 id="相关性、语义搜索的一些方案"><a href="#相关性、语义搜索的一些方案" class="headerlink" title="相关性、语义搜索的一些方案"></a>相关性、语义搜索的一些方案</h1><p>首先所有的词向量模型都是基于分布假说的（distributional hypothesis）：拥有相似上下文的词，词义相似。</p>
<p>参考: <a href="https://zhuanlan.zhihu.com/p/80737146" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/80737146</a></p>
<ol>
<li>word embedding</li>
<li>sentence embedding: 更难训练;</li>
</ol>
<p>word embedding算法:<br>word2vec：Skip-gram模型训练神经网络以预测句子中单词周围的上下文单词。<br>GloVe：单词的相似性取决于它们与其他上下文单词出现的频率。该算法训练单词共现计数的简单线性模型。<br>Fasttext：Facebook的词向量模型，其训练速度比word2vec的训练速度更快，效果又不丢失。</p>
<p>网上现有的预训练模型：基于维基百科语料库.</p>
<p>性能更优的方案:</p>
<ol>
<li>粗排: ES;</li>
<li>精排: 语义模型计算相似度;</li>
</ol>
<p>工业界主流: 谷歌的bert模型</p>
<h1 id="中文分词IK相关"><a href="#中文分词IK相关" class="headerlink" title="中文分词IK相关"></a>中文分词IK相关</h1><p><a href="https://github.com/medcl/elasticsearch-analysis-ik" target="_blank" rel="noopener">https://github.com/medcl/elasticsearch-analysis-ik</a></p>
<p>索引时优先使用<code>analyzer</code>配置的分词器，对文档进行分词;<br>// 索引时用ik_max_word,尽量多分几个词出来;<br>查询时优先使用<code>search_analyzer</code>配置的分词器，对输入进行分词;<br>// 查询时使用ik_smark, 尽量用最长的token去查询;<br>//</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">curl -XPOST http://localhost:9200/index/_mapping -H 'Content-Type:application/json' -d'</span><br><span class="line">&#123;</span><br><span class="line">        "properties": &#123;</span><br><span class="line">            "content": &#123;</span><br><span class="line">                "type": "text",</span><br><span class="line">                "analyzer": "ik_max_word",</span><br><span class="line">                "search_analyzer": "ik_smart"</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;'</span><br></pre></td></tr></table></figure>

<h1 id="实践遇到的问题"><a href="#实践遇到的问题" class="headerlink" title="实践遇到的问题"></a>实践遇到的问题</h1><h2 id="分词查询和关键字查询同时使用"><a href="#分词查询和关键字查询同时使用" class="headerlink" title="分词查询和关键字查询同时使用"></a>分词查询和关键字查询同时使用</h2><p>分词查询的时候，切分是ik_max_word，最大只切到单词；<br>比如“工具”就是最小粒度了，因此如果查询的时候使用”工”则不会查询到结果。</p>
<p>如果是默认的标准分词器，则只会有单个字，不会有单词；</p>
<p>所以如果两个都要支持，可以用两个字段，（存两个字段）<br>一个字段用 ik_max_word， 一个字段用 standard;<br>查询的时候也是用bool or 连接，命中一个即可。</p>
<h3 id="可参考的解决方案"><a href="#可参考的解决方案" class="headerlink" title="可参考的解决方案"></a>可参考的解决方案</h3><p>用fields多加一个不分词的结果(name.raw)</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"properties"</span>:&#123;</span><br><span class="line">        <span class="attr">"name"</span>: &#123;</span><br><span class="line">                <span class="attr">"type"</span>: <span class="string">"string"</span>,</span><br><span class="line">                <span class="attr">"analyzer"</span>: <span class="string">"standard"</span>, </span><br><span class="line">                <span class="attr">"fields"</span>: &#123;</span><br><span class="line">                    <span class="attr">"raw"</span>: &#123;</span><br><span class="line">                        <span class="attr">"index"</span>: <span class="string">"not_analyzed"</span>,</span><br><span class="line">                        <span class="attr">"type"</span>: <span class="string">"string"</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    </span><br><span class="line">                &#125;</span><br><span class="line">        </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="整合网上的近义词库"><a href="#整合网上的近义词库" class="headerlink" title="整合网上的近义词库"></a>整合网上的近义词库</h1><p>思路1: 自定义一个分词过滤器；// 可复用程度高<br>思路2: 写入该字段前，先用网上的近义词库把文本解析成空格分割的token，然后用空白分词器索引；（查询时用分词器） // 灵活，不用跟版本<br>// 由于可以配置多个分词过滤器，所以可以同时配置空格分词过滤器和同义词分词过滤器</p>
<p>维基百科近义词库： 528MB<br><a href="http://licstar.net/archives/tag/wikipedia-extractor" target="_blank" rel="noopener">http://licstar.net/archives/tag/wikipedia-extractor</a></p>
<p>某个领域最好的词向量:<br><a href="http://licstar.net/archives/tag/%e8%af%8d%e5%90%91%e9%87%8f" target="_blank" rel="noopener">http://licstar.net/archives/tag/%e8%af%8d%e5%90%91%e9%87%8f</a></p>
<p>考虑用boost加入相似度因素；（加权）</p>
<p>词向量资料：<br><a href="http://licstar.net/archives/328" target="_blank" rel="noopener">http://licstar.net/archives/328</a></p>
<h1 id="聚集"><a href="#聚集" class="headerlink" title="聚集"></a>聚集</h1><p>聚集有几个选项:</p>
<h2 id="桶型聚集-group-by"><a href="#桶型聚集-group-by" class="headerlink" title="桶型聚集: (group by)"></a>桶型聚集: (group by)</h2><p>term: 词条聚集,就是统计文档数量;<br>significant_terms: 显著聚集<br>range: 范围聚集;<br>histogram: 直方图聚集;(类似范围，但是只需要提供间距即可)<br>嵌套聚集、反嵌套聚集、子聚集: 根据文档关系聚集;<br>地理距离聚集;</p>
<h2 id="度量型聚集-agg"><a href="#度量型聚集-agg" class="headerlink" title="度量型聚集: (agg)"></a>度量型聚集: (agg)</h2><p>stats: 就是统计min,max,avg,count,sum信息;<br>extended_stats: 就是加上标准差这种更冷门的统计信息;<br>percentile: 分位数(近似,可以用compress参数控制精度和内存消耗)<br>cardinatily: 基数,也就是uv;// 近似的，hyperLogLog++, precision_threshold控制精度</p>
<h2 id="过滤器和后过滤器"><a href="#过滤器和后过滤器" class="headerlink" title="过滤器和后过滤器"></a>过滤器和后过滤器</h2><h3 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h3><img src="/images/2020-07/es-filter.png" class="" width="800" height="1200" title="es-filter">
<h3 id="后过滤器"><a href="#后过滤器" class="headerlink" title="后过滤器:"></a>后过滤器:</h3><img src="/images/2020-07/es-post-filter.png" class="" width="800" height="1200" title="es-post-filter">

<p><em>两者区别</em></p>
<p>文档-&gt;过滤器-&gt;查询-&gt;后过滤器-&gt;查询结果<br>文档-&gt;过滤器-&gt;查询-&gt;filter聚集-&gt;聚集结果</p>
<p>换句话说就是后过滤器不影响聚集，过滤器则影响聚集结果。<br>filter聚集则只影响聚集。</p>
<p>有一个例外是使用globel聚集，这样即使符合查询的只有2条文档，聚集也会应用到所有的文档上。(聚集比查询结果的数据源大)</p>
<h1 id="文档间的关系"><a href="#文档间的关系" class="headerlink" title="文档间的关系"></a>文档间的关系</h1><h2 id="对象类型"><a href="#对象类型" class="headerlink" title="对象类型"></a>对象类型</h2><p>输入:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"name"</span>: <span class="string">"name1"</span></span><br><span class="line">    ,<span class="attr">"events"</span>: [</span><br><span class="line">        &#123;<span class="attr">"title"</span>: <span class="string">"hadoop"</span></span><br><span class="line">        ,"date”: "12月"</span><br><span class="line">        &#125;</span><br><span class="line">        ,&#123;"title": "es"</span><br><span class="line">        ,"date”: "6月"</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种数据实际索引的时候，会把各个字段分别组成数组:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">events.title: ["hadoop","es"]</span><br><span class="line">events.date: ["6月",“12月”]</span><br></pre></td></tr></table></figure>
<p>所以搜的时候如果想搜6月的hadoop, 也可以搜出12月hadoop的文档(name1).</p>
<h2 id="嵌套类型"><a href="#嵌套类型" class="headerlink" title="嵌套类型"></a>嵌套类型</h2><p>上面的情况可以用嵌套类型解决。<br>这个时候的索引:</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[events.title: hadoop</span><br><span class="line">events.date: <span class="number">12</span>月</span><br><span class="line">,</span><br><span class="line">events.title: es</span><br><span class="line">events.date: <span class="number">6</span>月</span><br><span class="line"></span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h2 id="父子关系和反规范化"><a href="#父子关系和反规范化" class="headerlink" title="父子关系和反规范化"></a>父子关系和反规范化</h2><p>父子关系的存储：<br>1.规范化：父文档和子文档分开存储，然后再存储一个映射关系；// 相关查询: has_parent/has_child<br>2.反规范化：子文档中存储父文档；（空间换时间）</p>
<h2 id="嵌套json的存储"><a href="#嵌套json的存储" class="headerlink" title="嵌套json的存储"></a>嵌套json的存储</h2><p>由于ES的底层Lucence只支持扁平结构，ES支持嵌套json的方法是通过强行打平,如：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">"title"</span>: <span class="string">"titl1"</span></span><br><span class="line">,<span class="attr">"location"</span>:&#123;</span><br><span class="line">    <span class="attr">"name"</span>: <span class="string">"name1"</span></span><br><span class="line">    ,<span class="attr">"geolocation"</span>: <span class="string">"51.52,-0.09"</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实际实施到Lucence层的时候是这样存的:</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">titile:</span> <span class="string">"title1"</span></span><br><span class="line"><span class="attr">location.name:</span> <span class="string">"name1"</span></span><br><span class="line"><span class="attr">location.geolocation:</span> <span class="string">"51.52,-0.09"</span></span><br></pre></td></tr></table></figure>
<p>因此我们设计的key一定不要有小数点符号。<br>而且最好是一对一关系（不是数组）。</p>
<p>父子关系的索引选项：<br>include_in_parent/include_in_root</p>
<h3 id="一对一"><a href="#一对一" class="headerlink" title="一对一"></a>一对一</h3><p>嵌套json/对象</p>
<h4 id="一对多"><a href="#一对多" class="headerlink" title="一对多"></a>一对多</h4><p>嵌套文档: 索引阶段进行join; // 同分片存储，保证本地连接<br>父子关系: 查询阶段进行join; // 不同分片,远程连接</p>
<h4 id="多对多"><a href="#多对多" class="headerlink" title="多对多"></a>多对多</h4><p>反规法化: 可以处理多对多关系</p>
<h1 id="ES扩展"><a href="#ES扩展" class="headerlink" title="ES扩展"></a>ES扩展</h1><p>ES集群使用master-slaver架构，master和slaver用心跳信息来判断彼此的存活；<br>（有点类似hadoop，不知道是不是也有hadoop的HA；hadoop在120个节点的时候namenode容易OOM，不知道ES有没有类似问题）<br>master\slaver互相ping应该会消耗一些带宽，可以考虑调节心跳频率调节性能。</p>
<p>节点下线：先停用（停止数据写入、迁移）</p>
<h2 id="集群升级"><a href="#集群升级" class="headerlink" title="集群升级"></a>集群升级</h2><h3 id="重启"><a href="#重启" class="headerlink" title="重启"></a>重启</h3><p>直接关闭整个集群，不可用。<br>然后升级所有节点，重启集群。<br>有一段时间不可用。</p>
<h3 id="轮流重启"><a href="#轮流重启" class="headerlink" title="轮流重启"></a>轮流重启</h3><p>不牺牲可用性的情况下，重启集群；<br>基本步骤是：关一个节点，升级一个节点，重启这个节点，重新加入集群。<br>这里有一个关键就是，关闭某个节点的期间，不需要集群自己做rebalance.<br>因此配置：<code>cluster.routing.allocation.enable</code>=<code>none</code><br>可以用curl发命令修改这个配置。<br>过后重新设置为<code>all</code>。</p>
<p>如果副本数&gt;1，上述操作期间服务依然可用。</p>
<h2 id="别名API"><a href="#别名API" class="headerlink" title="别名API"></a>别名API</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">curl -XPOST 'localhost:9200/_aliases' -d '</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"actions"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"add"</span>: &#123;</span><br><span class="line">                <span class="attr">"index"</span>: <span class="string">"get-together"</span>,</span><br><span class="line">                <span class="attr">"alias"</span>: <span class="string">"gt-alias"</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"remove"</span>: &#123;</span><br><span class="line">                <span class="attr">"index"</span>: <span class="string">"old-get-together"</span>,</span><br><span class="line">                <span class="attr">"alias"</span>: <span class="string">"gt-alias"</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;'</span><br></pre></td></tr></table></figure>
<p>可以分拆成两个命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -XPUT 'http://localhost:9200/get-together/_alias/gt-alias'</span><br><span class="line">curl -XDELETE 'http://localhost:9200/old-get-together/_alias/gt-alias'</span><br></pre></td></tr></table></figure>
<p>一个别名可以指向多个索引，甚至指向logs-开头的索引。<br>(类似于一个逻辑名称)<br>别名还可以附带一个过滤器。</p>
<h2 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h2><p>默认路由策略：文档id<br>可以手动指定routing=xxx来影响分片行为。</p>
<p>因此可以根据业务，把一起访问的文档路由到同一分片上。</p>
<h3 id="debug-api-查看搜索的分片"><a href="#debug-api-查看搜索的分片" class="headerlink" title="debug api: 查看搜索的分片"></a>debug api: 查看搜索的分片</h3><p>routing为xxx时，会搜索哪个分片:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -XGET 'localhost:9200/get-together/_search_shards&amp;routing=xxxx'</span><br></pre></td></tr></table></figure>


<p>可以在别名中配置路由，简化查询操作。</p>
<h1 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h1><h2 id="合并请求-bulk接口"><a href="#合并请求-bulk接口" class="headerlink" title="合并请求(bulk接口)"></a>合并请求(bulk接口)</h2><p>批量新增、批量更新、批量搜索</p>
<h2 id="IO配置优化"><a href="#IO配置优化" class="headerlink" title="IO配置优化"></a>IO配置优化</h2><p>segments: 分段;</p>
<p>ES接收到文档后:<br>分段的倒排索引</p>
<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>refresh: 刷新; 生效，重新打开索引;新建的索引生效, 以前的缓存失效;<br>flush: 冲刷; 刷盘，索引数据写入磁盘;<br>合并: 小分段合并成大分段; // 分段越多，查询越慢;<br>存储限流: 调节每秒写入的字节数;</p>
<h3 id="优化策略"><a href="#优化策略" class="headerlink" title="优化策略"></a>优化策略</h3><h4 id="刷新频率降低"><a href="#刷新频率降低" class="headerlink" title="刷新频率降低"></a>刷新频率降低</h4><p>缓存失效的频率降低，性能更高，新文档慢一些生效；<br>// 默认每秒刷新, index.refresh_interval</p>
<h4 id="刷盘频率降低"><a href="#刷盘频率降低" class="headerlink" title="刷盘频率降低"></a>刷盘频率降低</h4><p>IO消耗降低，性能更高，丢数据概率提高;<br>触发刷盘的时机:<br>1.内存缓存区已满;<br>2.固定间隔(定时器);<br>3.事务日志达到阈值;<br>因此调控的手段:<br>1.内存缓存区大小: indices.memory.index_buffer_size;<br>2.刷新间隔: index.translog.flush_threshold_period;<br>3.事务日志大小: index.translog.flush_threshold_size;</p>
<h3 id="合并策略优化"><a href="#合并策略优化" class="headerlink" title="合并策略优化"></a>合并策略优化</h3><p>合并的作用：</p>
<ol>
<li>真正删除文档;</li>
<li>分段越少，查询越快;</li>
</ol>
<p>触发合并的时机:</p>
<ol>
<li>索引文档;</li>
<li>更新、删除文档;</li>
</ol>
<p>合并相关配置:<br><code>index.merge.policy.segments_per_tier</code>:<br>每层的分段数量;<br>高=&gt;写性能越好，越低=&gt;读性能越好;<br><code>index.merge.policy.max_merge_at_once</code>:<br>每次合并多少分段; 设置为等于<code>segments_per_tier</code>即可;<br><code>index.merge.policy.max_merged_segment</code>:<br>分段的最大规模;<br>低=&gt;写性能好; 高=&gt;读性能好;<br><code>index.merge.scheduler.max_thread_count</code>:<br>合并用的最大线程数;</p>
<h3 id="存储限流"><a href="#存储限流" class="headerlink" title="存储限流"></a>存储限流</h3><p><code>indices.store.throttle.max_bytes_per_sec</code>:<br>最大IO吞吐量，默认20MB/s，默认只针对merge(合并分段);<br>(ssd的话，可以调大到100～200MB)</p>
<p><code>indices.store.throttle.type</code>:<br>限流类型；<code>none</code>: 不限流, <code>all</code>: 所有磁盘操作; 默认: <code>merge</code>。</p>
<h3 id="磁盘IO优化"><a href="#磁盘IO优化" class="headerlink" title="磁盘IO优化"></a>磁盘IO优化</h3><p>MMAPDirectory:<br>进程请求OS对磁盘文件进行内存映射(初始化开销);<br>也就是mmap，0拷贝，进程挂掉的话，内核会帮忙保存文件;</p>
<p>NIOFDirectory:<br>进程将磁盘文件复制到JVM堆中;<br>也就是常规文件访问，进程挂掉，则文件修改丢失;</p>
<p>相关配置:<br><code>index.store.type</code>: 默认<code>default</code>.<br>mmapfs: 只使用MMapDirectory, 静态索引，物理内存能放下索引时适用;<br>niofs: 只使用NIOFSDirectory,32位系统适用;</p>
<p>可以对单个索引配置，也可以配置成全局。</p>
<h2 id="缓存优化"><a href="#缓存优化" class="headerlink" title="缓存优化"></a>缓存优化</h2><p>ES的缓存分为:</p>
<ol>
<li>分片查询缓存: 缓存查询结果;</li>
<li>OS缓存: 缓存索引到内存;</li>
</ol>
<h2 id="过滤器缓存"><a href="#过滤器缓存" class="headerlink" title="过滤器缓存"></a>过滤器缓存</h2><p>过滤器缓存可以在query时，在filter用<code>_cache</code>:true/false配置。<br>过滤器缓存在各个节点上，内存占比配置:<br><code>indices.cache.filter.size</code>: 默认10%<br>缓存淘汰策略: LRU<br>缓存生存时间:<br><code>index.cache.filter.expire</code>: 30m  (表示30分钟过期)</p>
<p>比较简单的过滤器可以使用bitset来减少内存消耗；<br>比较复杂的过滤器则直接存储查询结果。<br>可以使用bitset的过滤器:<br>term,exists/missing,prefix</p>
<h2 id="字段过滤器"><a href="#字段过滤器" class="headerlink" title="字段过滤器"></a>字段过滤器</h2><p>索引：token -&gt; 文档 ; (又叫倒排索引)<br>字段: 文档 -&gt; 词条; (主要用于排序和聚集)</p>
<p>字段上可以用的过滤器:<br>terms过滤器<br>range过滤器</p>
<h2 id="预热器优化"><a href="#预热器优化" class="headerlink" title="预热器优化"></a>预热器优化</h2><p>可以在索引上定义预热器。<br>即将按日期倒序查询:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">curl -XPUT 'localhost:9200/get-together/event/_warmer/upcoming_events' -d '&#123;</span><br><span class="line">    "sort":[</span><br><span class="line">        &#123;</span><br><span class="line">            "date": &#123;"order":"desc"&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line">&#125;'</span><br></pre></td></tr></table></figure>
<p>即将查询热门分组:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">curl -XPUT 'localhost:9200/get-together/group/_warmer/top_tags' -d '&#123;</span><br><span class="line">    "aggs":&#123;</span><br><span class="line">        "top_tags":&#123;</span><br><span class="line">            "terms":&#123;</span><br><span class="line">                "field": "tags.verbatim"</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;'</span><br></pre></td></tr></table></figure>
<p>可以创建索引的时候直接定义预热器。</p>
<h2 id="脚本优化"><a href="#脚本优化" class="headerlink" title="脚本优化"></a>脚本优化</h2><p>如果只有数值型的操作，可以考虑用lucene表达式代替脚本；<br>性能：<br>不用脚本&gt;lucene表达式（js）&gt;java脚本&gt;其他脚本</p>
<h2 id="ES查询过程"><a href="#ES查询过程" class="headerlink" title="ES查询过程"></a>ES查询过程</h2><h3 id="topN查询"><a href="#topN查询" class="headerlink" title="topN查询"></a>topN查询</h3><p>比如取10个结果:<br>1.每个分片取得分前10的;<br>2.合并所有分片的结果(归并排序);</p>
<p>因此得分是在每个分片上算的（分片内得分）</p>
<h3 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h3><p>{<br>“from”: 400<br>,”size”: 100<br>}<br>这种需要400～500的结果，但实际会取前500个，然后扔掉前400个。</p>
<p>如果是顺序翻页需求，可以用scroll类型查询优化，查询的时候传递一个scroll=1m的参数，让ES等一分钟，以准备接收下一次翻页。这种情况下，每次ES都会返回一个scrollId。</p>
<h1 id="集群管理"><a href="#集群管理" class="headerlink" title="集群管理"></a>集群管理</h1><h2 id="模版"><a href="#模版" class="headerlink" title="模版"></a>模版</h2><p>可以配置某个前缀的索引都应用某个配置模版。<br>（比如模版里定义别名）</p>
<h3 id="多个模版的合并"><a href="#多个模版的合并" class="headerlink" title="多个模版的合并"></a>多个模版的合并</h3><p>多个模版可能匹配到同一个索引，这个时候多个模版的配置会合并。<br>合并的顺序按照order字段，0的先执行，然后1的覆盖0的，依此类推。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://xiaoyue26.github.io/2020/07/22/2020-07/ES%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0/" data-id="ckcy58mud0000msamcfgubxqi" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/elasticsearch/" rel="tag">elasticsearch</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/es/" rel="tag">es</a></li></ul>

    </footer>
  </div>
  
</article>
 


  


  <nav id="page-nav">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/22/">22</a><a class="extend next" rel="next" href="/page/2/">下一页&amp;raquo;</a>
  </nav>
</section>
           
    <aside id="sidebar">
  
    
  <div class="widget-wrap">
     
        <h3 class="follow-title ">Follow me</h3>
     
    <div class="widget follow">
      
              <a class="github" aria-hidden="true" href="https://github.com/xiaoyue26" target="_blank" title="Github"></a>
      
      
            <a class="weibo" aria-hidden="true"  href="http://weibo.com/3004306764" target="_blank" title="微博"></a>
      
      
      
            <a class="email" aria-hidden="true"  href="mailto:296671657@qq.com" target="_blank" title="邮箱"></a>
      
    </div>
  </div>


  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title categories">分类</h3>
    <div class="widget" id="categories">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/clickhouse/">clickhouse</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/es/">es</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/git/">git</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/gradle/">gradle</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/hadoop/">hadoop</a><span class="category-list-count">15</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/hadoop/hbase/">hbase</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/hadoop/hive/">hive</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/hadoop/pig/">pig</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/hadoop/sqoop/">sqoop</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/hadoop/%E8%BF%90%E7%BB%B4/">运维</a><span class="category-list-count">1</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/http/">http</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/java/">java</a><span class="category-list-count">79</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/java/Netty/">Netty</a><span class="category-list-count">14</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/java/jvm/">jvm</a><span class="category-list-count">10</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/java/spring/">spring</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/java/%E5%B9%B6%E5%8F%91/">并发</a><span class="category-list-count">21</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/java/%E6%80%A7%E8%83%BD/">性能</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a><span class="category-list-count">7</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/mysql/">mysql</a><span class="category-list-count">23</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/nginx/">nginx</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/orm/">orm</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/redis/">redis</a><span class="category-list-count">18</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/rtc/">rtc</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/rust/">rust</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/shell/">shell</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/spark/">spark</a><span class="category-list-count">11</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/spark/streaming/">streaming</a><span class="category-list-count">1</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/tcp/">tcp</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/">分布式</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%97%A5%E5%BF%97/">日志</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/">消息队列</a><span class="category-list-count">4</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/disruptor/">disruptor</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/kafka/">kafka</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/rabbitmq/">rabbitmq</a><span class="category-list-count">1</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BD%91%E7%BB%9C/">网络</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AE%BA%E6%96%87/">论文</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%85%8D%E7%BD%AE/">配置</a><span class="category-list-count">23</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/">项目管理</a><span class="category-list-count">1</span></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title tagcloud">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/2-3%E6%A0%91/" style="font-size: 14px; color: #00f">2-3树</a> <a href="/tags/AES/" style="font-size: 14px; color: #00f">AES</a> <a href="/tags/DDD/" style="font-size: 14.79px; color: #1109fe">DDD</a> <a href="/tags/HMAC/" style="font-size: 14px; color: #00f">HMAC</a> <a href="/tags/HTTP/" style="font-size: 14px; color: #00f">HTTP</a> <a href="/tags/JMX/" style="font-size: 14px; color: #00f">JMX</a> <a href="/tags/JNI/" style="font-size: 16.36px; color: #331cfb">JNI</a> <a href="/tags/NIO/" style="font-size: 14px; color: #00f">NIO</a> <a href="/tags/Netty/" style="font-size: 21.86px; color: #aa5df3">Netty</a> <a href="/tags/RSA/" style="font-size: 14px; color: #00f">RSA</a> <a href="/tags/RTP/" style="font-size: 14px; color: #00f">RTP</a> <a href="/tags/SIMD/" style="font-size: 14px; color: #00f">SIMD</a> <a href="/tags/SSL/" style="font-size: 14px; color: #00f">SSL</a> <a href="/tags/TLS/" style="font-size: 14px; color: #00f">TLS</a> <a href="/tags/arthas/" style="font-size: 14px; color: #00f">arthas</a> <a href="/tags/awk/" style="font-size: 14px; color: #00f">awk</a> <a href="/tags/clickhouse/" style="font-size: 14.79px; color: #1109fe">clickhouse</a> <a href="/tags/disruptor/" style="font-size: 14px; color: #00f">disruptor</a> <a href="/tags/elasticsearch/" style="font-size: 14px; color: #00f">elasticsearch</a> <a href="/tags/es/" style="font-size: 14px; color: #00f">es</a> <a href="/tags/flask/" style="font-size: 14px; color: #00f">flask</a> <a href="/tags/gc/" style="font-size: 14px; color: #00f">gc</a> <a href="/tags/git/" style="font-size: 14.79px; color: #1109fe">git</a> <a href="/tags/gradle/" style="font-size: 14.79px; color: #1109fe">gradle</a> <a href="/tags/groovy/" style="font-size: 14.79px; color: #1109fe">groovy</a> <a href="/tags/hadoop/" style="font-size: 16.36px; color: #331cfb">hadoop</a> <a href="/tags/hbase/" style="font-size: 14px; color: #00f">hbase</a> <a href="/tags/hdfs/" style="font-size: 14.79px; color: #1109fe">hdfs</a> <a href="/tags/hive/" style="font-size: 18.71px; color: #6638f8">hive</a> <a href="/tags/hll/" style="font-size: 14px; color: #00f">hll</a> <a href="/tags/http/" style="font-size: 17.14px; color: #4425fa">http</a> <a href="/tags/https/" style="font-size: 14px; color: #00f">https</a> <a href="/tags/hyperloglog/" style="font-size: 14px; color: #00f">hyperloglog</a> <a href="/tags/io/" style="font-size: 14px; color: #00f">io</a> <a href="/tags/java/" style="font-size: 25px; color: #ee82ee">java</a> <a href="/tags/jvm/" style="font-size: 20.29px; color: #884af5">jvm</a> <a href="/tags/kafka/" style="font-size: 15.57px; color: #2213fd">kafka</a> <a href="/tags/kylin/" style="font-size: 14px; color: #00f">kylin</a> <a href="/tags/log4j2/" style="font-size: 14px; color: #00f">log4j2</a> <a href="/tags/maven/" style="font-size: 14px; color: #00f">maven</a> <a href="/tags/metaspace/" style="font-size: 14px; color: #00f">metaspace</a> <a href="/tags/monad/" style="font-size: 14px; color: #00f">monad</a> <a href="/tags/mybatis/" style="font-size: 14.79px; color: #1109fe">mybatis</a> <a href="/tags/mysql/" style="font-size: 24.21px; color: #dd79ef">mysql</a> <a href="/tags/nginx/" style="font-size: 17.14px; color: #4425fa">nginx</a> <a href="/tags/paxos/" style="font-size: 14px; color: #00f">paxos</a> <a href="/tags/pig/" style="font-size: 14px; color: #00f">pig</a> <a href="/tags/python/" style="font-size: 14px; color: #00f">python</a> <a href="/tags/rabbitmq/" style="font-size: 14px; color: #00f">rabbitmq</a> <a href="/tags/redis/" style="font-size: 22.64px; color: #bb66f2">redis</a> <a href="/tags/restful/" style="font-size: 14px; color: #00f">restful</a> <a href="/tags/rtc/" style="font-size: 14px; color: #00f">rtc</a> <a href="/tags/rust/" style="font-size: 14.79px; color: #1109fe">rust</a> <a href="/tags/scala/" style="font-size: 16.36px; color: #331cfb">scala</a> <a href="/tags/shell/" style="font-size: 16.36px; color: #331cfb">shell</a> <a href="/tags/spark/" style="font-size: 19.5px; color: #7741f7">spark</a> <a href="/tags/spring/" style="font-size: 17.93px; color: #552ef9">spring</a> <a href="/tags/springboot/" style="font-size: 14px; color: #00f">springboot</a> <a href="/tags/springmvc/" style="font-size: 14px; color: #00f">springmvc</a> <a href="/tags/sql%E6%B3%A8%E5%85%A5/" style="font-size: 14px; color: #00f">sql注入</a> <a href="/tags/sqoop/" style="font-size: 14.79px; color: #1109fe">sqoop</a> <a href="/tags/ssl/" style="font-size: 14px; color: #00f">ssl</a> <a href="/tags/storage/" style="font-size: 14px; color: #00f">storage</a> <a href="/tags/streaming/" style="font-size: 14px; color: #00f">streaming</a> <a href="/tags/tcp/" style="font-size: 15.57px; color: #2213fd">tcp</a> <a href="/tags/utf8/" style="font-size: 14px; color: #00f">utf8</a> <a href="/tags/voip/" style="font-size: 14px; color: #00f">voip</a> <a href="/tags/%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C/" style="font-size: 14px; color: #00f">一致性哈希</a> <a href="/tags/%E5%87%BD%E6%95%B0%E5%BC%8F/" style="font-size: 14px; color: #00f">函数式</a> <a href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F/" style="font-size: 14.79px; color: #1109fe">分布式</a> <a href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/" style="font-size: 14px; color: #00f">分布式事务</a> <a href="/tags/%E5%AE%89%E5%85%A8/" style="font-size: 14px; color: #00f">安全</a> <a href="/tags/%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/" style="font-size: 14px; color: #00f">定时任务</a> <a href="/tags/%E5%B9%B6%E5%8F%91/" style="font-size: 21.07px; color: #9954f4">并发</a> <a href="/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" style="font-size: 14px; color: #00f">性能优化</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" style="font-size: 14px; color: #00f">数据结构与算法</a> <a href="/tags/%E6%97%A5%E5%BF%97/" style="font-size: 14.79px; color: #1109fe">日志</a> <a href="/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/" style="font-size: 14.79px; color: #1109fe">消息队列</a> <a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 14.79px; color: #1109fe">算法</a> <a href="/tags/%E7%BA%A2%E9%BB%91%E6%A0%91/" style="font-size: 14px; color: #00f">红黑树</a> <a href="/tags/%E7%BA%BF%E7%A8%8B/" style="font-size: 14px; color: #00f">线程</a> <a href="/tags/%E7%BC%96%E7%A0%81/" style="font-size: 14px; color: #00f">编码</a> <a href="/tags/%E8%AE%BA%E6%96%87/" style="font-size: 14.79px; color: #1109fe">论文</a> <a href="/tags/%E8%AE%BE%E8%AE%A1/" style="font-size: 14.79px; color: #1109fe">设计</a> <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 16.36px; color: #331cfb">设计模式</a> <a href="/tags/%E9%85%8D%E7%BD%AE/" style="font-size: 23.43px; color: #cc6ff0">配置</a> <a href="/tags/%E9%95%BF%E8%BF%9E%E6%8E%A5/" style="font-size: 14px; color: #00f">长连接</a> <a href="/tags/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/" style="font-size: 14px; color: #00f">项目管理</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title recent-posts">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/02/17/2022-02/http3-quic%E4%BC%98%E7%BC%BA%E7%82%B9%E5%8F%8A%E5%8E%9F%E5%9B%A0/">http3_quic优缺点及原因</a>
          </li>
        
          <li>
            <a href="/2022/02/16/2022-02/http-range/">http_range</a>
          </li>
        
          <li>
            <a href="/2022/01/21/2022-01/voip-rtc/">VoIP和RTC</a>
          </li>
        
          <li>
            <a href="/2021/07/26/2021-07/metaspace%E7%AC%94%E8%AE%B0/">metaspace笔记</a>
          </li>
        
          <li>
            <a href="/2021/06/01/2021-06/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E7%AC%94%E8%AE%B0-1/">网络安全笔记-1</a>
          </li>
        
      </ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title archive">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/02/">二月 2022</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/01/">一月 2022</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/07/">七月 2021</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/06/">六月 2021</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/02/">二月 2021</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/12/">十二月 2020</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">七月 2020</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">六月 2020</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">五月 2020</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">四月 2020</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">三月 2020</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/01/">一月 2020</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/12/">十二月 2019</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">十一月 2019</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">十月 2019</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">九月 2019</a><span class="archive-list-count">7</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">八月 2019</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">七月 2019</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">六月 2019</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">五月 2019</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">四月 2019</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">三月 2019</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">二月 2019</a><span class="archive-list-count">16</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">一月 2019</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">十二月 2018</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">十一月 2018</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/10/">十月 2018</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/09/">九月 2018</a><span class="archive-list-count">7</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">八月 2018</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">七月 2018</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">六月 2018</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">五月 2018</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">四月 2018</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">三月 2018</a><span class="archive-list-count">7</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">二月 2018</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">一月 2018</a><span class="archive-list-count">13</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/">十二月 2017</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/11/">十一月 2017</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/10/">十月 2017</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/09/">九月 2017</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">五月 2017</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/04/">四月 2017</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">三月 2017</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/02/">二月 2017</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/01/">一月 2017</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/12/">十二月 2016</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/09/">九月 2016</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/04/">四月 2016</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/03/">三月 2016</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/02/">二月 2016</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/01/">一月 2016</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/10/">十月 2015</a><span class="archive-list-count">12</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/09/">九月 2015</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/07/">七月 2015</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/03/">三月 2015</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/01/">一月 2015</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/12/">十二月 2014</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/11/">十一月 2014</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/10/">十月 2014</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/03/">三月 2014</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/11/">十一月 2013</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/09/">九月 2013</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/08/">八月 2013</a><span class="archive-list-count">2</span></li></ul>
    </div>
  </div>


  
</aside>

      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-left">
      &copy; 2014 - 2022 风梦七&nbsp;|&nbsp;
      主题 <a href="https://github.com/giscafer/hexo-theme-cafe/" target="_blank">Cafe</a>
    </div>
     <div id="footer-right">
      联系方式&nbsp;|&nbsp;296671657@qq.com
    </div>
  </div>
</footer>
 
<script src="/jquery/jquery.min.js"></script>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">首页</a>
  
    <a href="/archives" class="mobile-nav-link">归档</a>
  
    <a href="/about" class="mobile-nav-link">关于</a>
  
</nav>
    <img class="back-to-top-btn" src="/images/fly-to-top.png"/>
<script>
// Elevator script included on the page, already.
window.onload = function() {
  var elevator = new Elevator({
    selector:'.back-to-top-btn',
    element: document.querySelector('.back-to-top-btn'),
    duration: 1000 // milliseconds
  });
}
</script>
      

  
    <script>
      var cloudTieConfig = {
        url: document.location.href, 
        sourceId: "",
        productKey: "e2fb4051c49842688ce669e634bc983f",
        target: "cloud-tie-wrapper"
      };
    </script>
    <script src="https://img1.ws.126.net/f2e/tie/yun/sdk/loader.js"></script>
    

  







<!-- author:forvoid begin -->
<!-- author:forvoid begin -->

<!-- author:forvoid end -->

<!-- author:forvoid end -->


  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      })
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      })
    </script>
    <script type="text/javascript" src="https://cdn.rawgit.com/mathjax/MathJax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


 
<script src="/js/is.js"></script>



  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>


<script src="/js/elevator.js"></script>

  </div>
</body>
</html>