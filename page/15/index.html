<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>笔记本</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="笔记本">
<meta property="og:url" content="http://xiaoyue26.github.io/page/15/index.html">
<meta property="og:site_name" content="笔记本">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="风梦七">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="笔记本" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    
  
  
<link rel="stylesheet" href="/css/style.css">

  

<meta name="generator" content="Hexo 4.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    
    <div id="header-inner" class="inner">
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://xiaoyue26.github.io"></form>
      </div>
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">首页</a>
        
          <a class="main-nav-link" href="/archives">归档</a>
        
          <a class="main-nav-link" href="/about">关于</a>
        
      </nav>
      
    </div>
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">笔记本</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">风梦七</a>
        </h2>
      
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-2018-01/java并发编程的艺术笔记-第三章" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/01/21/2018-01/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%B8%89%E7%AB%A0/" class="article-date">
  <time datetime="2018-01-21T14:10:41.000Z" itemprop="datePublished">2018-01-21</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/java/">java</a>►<a class="article-category-link" href="/categories/java/%E5%B9%B6%E5%8F%91/">并发</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/01/21/2018-01/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%B8%89%E7%AB%A0/">java并发编程的艺术笔记-第三章</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <h1 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h1><p>内容有4个部分:</p>
<ol>
<li>基本概念</li>
<li>顺序一致性</li>
<li>同步原语的内存语义</li>
<li>内存模型的设计原理</li>
</ol>
<h2 id="3-1-基本概念"><a href="#3-1-基本概念" class="headerlink" title="3.1 基本概念"></a>3.1 基本概念</h2><p>并发编程的两个关键问题:</p>
<ol>
<li>线程之间通信: 何种机制交换数据,包括共享内存和消息传递;</li>
<li>线程之间同步: 不同线程的操作发生的顺序. </li>
</ol>
<p>JAVA的线程通信: 共享内存(隐式). </p>
<p>JAVA的内存:</p>
<ol>
<li>堆内存(共享):   实例域,静态域,数组元素;</li>
<li>栈内存(不共享): 局部变量,方法参数,异常参数.</li>
</ol>
<p>线程A,B通信流程:</p>
<ol>
<li>线程A把自己内存中更新过的共享变量刷新到主内存中;(把cpu缓存刷到内存)</li>
<li>线程B把到主内存中读取A更新后的共享变量. (把内存刷新到cpu缓存)</li>
</ol>
<h2 id="3-1-3-源代码到指令序列的重排序"><a href="#3-1-3-源代码到指令序列的重排序" class="headerlink" title="3.1.3 源代码到指令序列的重排序"></a>3.1.3 源代码到指令序列的重排序</h2><p>3种重排类型:</p>
<ol>
<li>编译器优化的重排序: 单线程程序语义不改变;</li>
<li>指令级并行的重排序: 多线程的指令重排并行执行;</li>
<li>内存系统的重排序: 指令实际执行的时候,由于缓存/缓冲的存在,加载和存储可能看起来是乱序执行.</li>
</ol>
<p>2和3属于处理器重排序.</p>
<p>JAVA内存模型约束:</p>
<ol>
<li>禁止某些编译器优化;</li>
<li>插入某些特定类型内存屏障(Memory Fence指令),禁止特定类型处理器重排序.</li>
</ol>
<h2 id="3-1-4-并发编程模型的分类"><a href="#3-1-4-并发编程模型的分类" class="headerlink" title="3.1.4 并发编程模型的分类"></a>3.1.4 并发编程模型的分类</h2><p>写缓冲区: 临时保存向内存写入的数据. (避免cpu等待io)<br>仅对该cpu可见. </p>
<p>内存屏障指令:<br><strong>1.LoadLoad Barries</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Load1;LoadLoad;Load2</span><br><span class="line">&#x2F;&#x2F; 确保Load1的装载先于Load2及后续Load指令</span><br></pre></td></tr></table></figure>

<p><strong>2.StoreStore Barries:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Store1;StoreStore;Store2</span><br><span class="line">&#x2F;&#x2F; 确保Store1的数据先于Store2及后续Store指令</span><br><span class="line">&#x2F;&#x2F; 刷新到内存</span><br></pre></td></tr></table></figure>

<p><strong>3.LoadStore Barries:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Load1;LoadStore;Store2</span><br><span class="line">&#x2F;&#x2F; 确保Load1的装载先于Store2及后续Store指令</span><br></pre></td></tr></table></figure>

<p><strong>4.StoreLoad Barries:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Store1;StoreLoad;Load2</span><br><span class="line">&#x2F;&#x2F; 确保Store1的装载先于Load2及后续Load指令</span><br><span class="line">&#x2F;&#x2F; 刷新到内存.</span><br><span class="line">&#x2F;&#x2F; 且会使它之前的所有内存访问指令(Load和Store)都完成后,才执行之后的.</span><br></pre></td></tr></table></figure>

<p>其中第四个,StoreLoad屏障最严格,会把写缓冲区刷新到内存,开销最大,大部分cpu都支持.</p>
<h3 id="3-1-5-Happens-before规则"><a href="#3-1-5-Happens-before规则" class="headerlink" title="3.1.5 Happens-before规则"></a>3.1.5 Happens-before规则</h3><ol>
<li>程序顺序规则: 单线程内顺序一致性; // 有数据依赖的指令不重排. 保证结果和顺序执行一致即可.</li>
<li>锁规则:  解锁先于获得锁;</li>
<li>volidate,原子变量: 写before读; </li>
<li>线程启动. Thread.start之后才会有run等其他操作发生.</li>
<li>中断. (1)A线程中断B线程;(2)B检测到中断. 保证(1)在(2)前面.</li>
<li>终结器. 构造函数在终结器之前执行完成.</li>
<li>传递性: 上述规则可以传递.</li>
</ol>
<p>上述规则被JVM翻译成各种约束(具体来说就是在指令里加一些内存屏障),影响了编译器重排序和处理器重排序.</p>
<h2 id="3-2-顺序一致性"><a href="#3-2-顺序一致性" class="headerlink" title="3.2 顺序一致性"></a>3.2 顺序一致性</h2><h3 id="顺序一致性"><a href="#顺序一致性" class="headerlink" title="顺序一致性"></a>顺序一致性</h3><p>顺序一致性: 所有线程看到的执行顺序一致.<br>正确使用了同步机制,才能达到顺序一致性.<br>主要解决的是以下两者的矛盾:<br>(1) 程序员希望指令重排的约束越多越好, 保证执行结果好理解;<br>(2) 编译器/cpu希望约束越少越好,执行可以快一些.<br>顺序一致性: 约束的数量够用,让程序运行的结果与完全约束(顺序执行)一致. </p>
<h3 id="3-2-1-数据依赖性"><a href="#3-2-1-数据依赖性" class="headerlink" title="3.2.1 数据依赖性"></a>3.2.1 数据依赖性</h3><p>编译器和处理器: </p>
<ol>
<li>单线程: 考虑数据依赖性; (写后读,写后写,读后写)</li>
<li>不同线程\不同处理器: 不考虑数据依赖性.</li>
</ol>
<h3 id="3-2-2-as-if-serial语义"><a href="#3-2-2-as-if-serial语义" class="headerlink" title="3.2.2 as-if-serial语义"></a>3.2.2 as-if-serial语义</h3><p>编译器和处理器: 单线程语义不变.<br>// 约束够用,执行结果和串行执行结果一致.</p>
<hr>
<h2 id="一些约束的具体实现方案"><a href="#一些约束的具体实现方案" class="headerlink" title="一些约束的具体实现方案:"></a>一些约束的具体实现方案:</h2><h3 id="volatile变量"><a href="#volatile变量" class="headerlink" title="volatile变量"></a>volatile变量</h3><p>读: 读取最新的内存值(不一定是CPU缓存值); (有原子性)<br>写: 写入cpu缓存后,刷新到内存; (有原子性)<br>自增: 相当于先读后写两个操作, 不具有原子性. </p>
<p>用<code>volatile</code>代替锁.(从内存语义上说,由于它与锁有相同内存效果,可以实现)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">boolean</span> flag=<span class="keyword">false</span>;</span><br><span class="line">A:</span><br><span class="line">a=<span class="number">10</span>;</span><br><span class="line">flag=<span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">B:</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(flag)&#123;</span><br><span class="line">i=a;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>对A来说,由于单线程的语义符合程序顺序规则,flag=true发生在a=10之后;</li>
<li>对B来说,由于flag是volatile变量,flag=true之后才能取到i. 因此达到了通信的效果,B中能正确取到A中的a的10.</li>
</ol>
<h3 id="3-4-4-volatile内存语义的实现"><a href="#3-4-4-volatile内存语义的实现" class="headerlink" title="3.4.4 volatile内存语义的实现"></a>3.4.4 volatile内存语义的实现</h3><p>内存屏障:(JMM内存模型采用的是保守策略,保证在所有cpu上都能正确)</p>
<ol>
<li>volatile写前面插入StoreStore屏障;</li>
<li>volatile写后面插入StoreLoad屏障;</li>
<li>volatile读后面插入LoadLoad屏障;</li>
<li>volatile读后面插入LoadStore屏障.</li>
</ol>
<p>volatile写指令序列:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">普通读写</span><br><span class="line">StoreStore屏障&#x2F;&#x2F; 先把前面的Store刷新到内存,再执行volatile写.(其实没必要,只是新版本赋予了volatile锁的内存语义)</span><br><span class="line">volatile写</span><br><span class="line">StoreLoad屏障 &#x2F;&#x2F; 先把volatie写的store刷新到内存,再执行读.(免得读到污染值)</span><br><span class="line">volatile读</span><br></pre></td></tr></table></figure>

<p>volatile读指令序列:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">volatile读</span><br><span class="line">LoadLoad屏障 &#x2F;&#x2F; 禁止下面的读越过volatile</span><br><span class="line">LoadStore屏障&#x2F;&#x2F; 禁止下面的写越过volatile</span><br><span class="line">普通读写</span><br></pre></td></tr></table></figure>
<p>这俩屏障x86里没有.因为x86只有写-读重排序,没必要有.<br>此外,个人理解这俩屏障也没啥意义,唯一能想到的用处还是让<code>voldatile</code>具有锁的功能. 毕竟是JSR-133之后才加的.</p>
<h2 id="3-5-锁的内存语义"><a href="#3-5-锁的内存语义" class="headerlink" title="3.5 锁的内存语义"></a>3.5 锁的内存语义</h2><p><code>ReentrantLock</code>的实现依赖于:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FariSync</span><br><span class="line">NonfaiSync</span><br><span class="line">Sync</span><br><span class="line">AQS(AbstrackQueuedSynchronizer)</span><br></pre></td></tr></table></figure>
<p>其中AQS里头有个<code>volatile</code>变量:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;</span><br></pre></td></tr></table></figure>
<p>锁的内存语义基本就靠这个<code>volatile</code>变量和CAS操作.</p>
<p>1.加锁流程:(公平锁)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">获取volatile变量state;</span><br><span class="line">CAS操作更改state变量的值.</span><br><span class="line">若更改成功则获取锁成功.</span><br></pre></td></tr></table></figure>
<p>2.解锁流程:(公平锁)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">一些操作...</span><br><span class="line">写state变量. </span><br><span class="line">其他线程立刻发现了state变化,可以竞争这个锁了.</span><br></pre></td></tr></table></figure>


<p>CAS操作能保证(读-改-写)操作原子执行.<br>CAS操作的底层实现:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LOCK总线;</span><br><span class="line">禁止该指令与前后读写指令重排;</span><br><span class="line">将写缓冲区数据刷新到内存.</span><br></pre></td></tr></table></figure>

<h3 id="3-5-4-concurrent包的实现"><a href="#3-5-4-concurrent包的实现" class="headerlink" title="3.5.4 concurrent包的实现"></a>3.5.4 concurrent包的实现</h3><p>实现层次如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LOCK,同步器,阻塞队列,Executor,并发容器</span><br><span class="line">AQS,非阻塞数据结构,原子变量类</span><br><span class="line">volatile变量的读写,CAS</span><br></pre></td></tr></table></figure>

<h2 id="3-6-final域的内存语义"><a href="#3-6-final域的内存语义" class="headerlink" title="3.6 final域的内存语义"></a>3.6 final域的内存语义</h2><h3 id="3-6-1-final域的重排序规则"><a href="#3-6-1-final域的重排序规则" class="headerlink" title="3.6.1 final域的重排序规则"></a>3.6.1 final域的重排序规则</h3><ol>
<li>在构造函数内对一个final域的写入,与随和把这个对象的引用赋值给一个引用变量,这俩操作不能重排;</li>
<li>初次读包含final域的对象,初次读这个final域,这俩操作不能重排.</li>
</ol>
<p>规则1的实现(构造函数中):</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">final域的写</span><br><span class="line">StoreStore屏障 &#x2F;&#x2F; 先把上述写(Store)的结果刷新到内存. 再写引用. </span><br><span class="line">构造函数return &#x2F;&#x2F; 把对象地址赋值给引用</span><br></pre></td></tr></table></figure>

<p>示例代码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FinalObj obj=inputObj; <span class="comment">// 别的线程负责创建的对象</span></span><br><span class="line"><span class="keyword">int</span> a=obj.i;<span class="comment">// 如果i是final的,那一定能读到初始化以后的值; </span></span><br><span class="line"><span class="keyword">int</span> b=obj.j;<span class="comment">// 如果j不是final的,那可能读到还没初始化的值.</span></span><br></pre></td></tr></table></figure>

<p>规则2的实现:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LoadLoad屏障&#x2F;&#x2F; 保证先Load到引用. (明明有数据依赖)</span><br><span class="line">final域的读</span><br></pre></td></tr></table></figure>
<p>大多数cpu不需要这个规则也能正确进行final读,但还是有少部分cpu会无视间接依赖,因此需要这个规则.(需要加入这个屏障)<br>示例代码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FinalObj obj=inputObj; <span class="comment">// 别的线程负责创建的对象</span></span><br><span class="line"><span class="keyword">int</span> a=obj.i;<span class="comment">// 如果i是final的,那会等obj读到对象引用后再去读i;</span></span><br><span class="line"><span class="keyword">int</span> b=obj.j;<span class="comment">// 如果j不是final的,那可能没等到读到对象obj,就直接取读j了,读取错误.</span></span><br></pre></td></tr></table></figure>


<p>最后,由于x86处理器很多重排并不会做,所以其实final域的内存屏障都不需要加,会被省略.</p>
<h3 id="3-8-4-类初始化中的约束"><a href="#3-8-4-类初始化中的约束" class="headerlink" title="3.8.4 类初始化中的约束"></a>3.8.4 类初始化中的约束</h3><p>类的初始化是啥:</p>
<blockquote>
<p>Class加载=&gt;连接=&gt;初始化=&gt;使用=&gt;卸载;<br>其中连接分为:<br>验证=&gt;准备=&gt;解析. </p>
</blockquote>
<p>具体来说:</p>
<ul>
<li>加载</li>
</ul>
<ol>
<li>通过类全名获取二进制字节流;</li>
<li>将字节流中的静态存储(常量)转换为方法区的运行时数据;</li>
<li>JAVA堆中生成代表类的Class对象,指向方法区的数据.</li>
</ol>
<ul>
<li><p>验证: 格式/元数据/访问验证;</p>
</li>
<li><p>准备: 类变量(非常量)分配到堆,赋予初值;</p>
</li>
<li><p>解析 </p>
<blockquote>
<p>4类符号引用的解析: 类/接口,字段,类方法,接口方法. 把这些引用解析到实际的目标对象.<br>这个和初始化过程可能混在一起.</p>
</blockquote>
</li>
<li><p>初始化</p>
<blockquote>
<ol>
<li>分配对象的内存空间</li>
<li>初始化对象</li>
<li>设置instance指向内存空间</li>
</ol>
</blockquote>
</li>
<li><p>初始化发生的时机:// <code>T</code>是一个类</p>
<blockquote>
<ol>
<li>T的实例被创建;// 如<code>new</code></li>
<li>T的静态方法被调用;// <code>static</code></li>
<li>T的静态字段(非常量)被使用/赋值; // <code>static</code>成员被读写.<br>// 对于第3点,如果是类常量,加载阶段已经完成了.</li>
</ol>
</blockquote>
</li>
</ul>
<p>还有一个时机:</p>
<p>4.T是一个顶级类,而且一个断言语句嵌套在T内部被执行.// TODO<br>// 这个没懂.= = || </p>
<p>小结:</p>
<blockquote>
<p>static常量: 加载期完成,存储在方法区,从堆区Class对象指过去;<br>static变量: 准备期分配到堆,初始化阶段赋值.<br>成员变量: 初始化阶段完成.</p>
</blockquote>
<p><strong>类初始化存在竞态条件</strong><br>多个线程可能同时对一个类进行初始化,因此需要锁.<br>JVM对于每一个类或接口都有唯一的初始化锁<code>LC</code>.(放在<code>Class</code>对象中)<br>初始化流程:</p>
<ol>
<li>获取<code>Class</code>对象中的<code>LC</code>锁;</li>
<li>读取<code>Class</code>对象的state,发现是<code>noInitialization</code>,设置为<code>initializing</code>;// 表示从<code>未初始化</code>改成<code>正在初始化</code>,以便别的线程知道;</li>
<li>释放<code>LC</code>锁.  // 这个时候别的线程可以获取到锁,然后知道有人正在初始化,于是等待.</li>
<li>初始化类的static变量;</li>
<li>分配实例对象内存空间,初始化对象,赋值地址给引用(解析);</li>
<li>设置state=<code>initializated</code>. // 初始化结束. 唤醒等待的线程.</li>
</ol>
<p>基于上述过程的单例如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123; </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> C c=<span class="function">New <span class="title">C</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> C <span class="title">getC</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> B.c; <span class="comment">// 导致B类初始化.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用时:</span></span><br><span class="line">C c=A.getC(); <span class="comment">// 导致A被初始化.</span></span><br></pre></td></tr></table></figure>
<p>相比于双检,利用了<code>Class</code>对象的初始化锁<code>LC</code>. 达到线程安全的目的.<br>上述初始化流程的第5,6步顺序不会重排,因此可以不用<code>volatile</code>来保证引用的解析晚于对象的构建;</p>
<p>之所以使用内部类B: 想达到懒汉的目的.<br>如果不用内部类, 可以这么写:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123; </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> C c=<span class="keyword">new</span> C();</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">A</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> C <span class="title">getC</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用:</span></span><br><span class="line">C c=A.getC(); <span class="comment">// 导致A被初始化.</span></span><br></pre></td></tr></table></figure>
<p>区别在于导致A被初始化的途径多,而上一个方法中导致B被初始化的途径少(只有getC一个途径,毕竟B是private).<br>对于第一个方法:</p>
<blockquote>
<p>A被初始化=&gt;没关系;<br>调用getC()方法=&gt;B被初始化=&gt; c对象构建. </p>
</blockquote>
<p>对于第二个方法:</p>
<blockquote>
<p>A被初始化=&gt; c对象构建.</p>
</blockquote>
<p>A被初始化的途径很多,(A的静态方法被访问,A的静态变量被访问,A被创建实例,A中有断言执行),如果要让第二个方法达到足够懒,需要额外做的事情:</p>
<ol>
<li>只有getC()一个静态方法;</li>
<li>只有C一个静态变量;</li>
<li>不让创建对象(private构造函数)</li>
<li>没有断言执行嵌套在内部.</li>
</ol>
<p>不过两种方法都不能抵挡序列化.(得用枚举才行)</p>
<h2 id="3-9-JAVA内存模型综述"><a href="#3-9-JAVA内存模型综述" class="headerlink" title="3.9 JAVA内存模型综述"></a>3.9 JAVA内存模型综述</h2><h3 id="3-9-1-CPU内存模型"><a href="#3-9-1-CPU内存模型" class="headerlink" title="3.9.1 CPU内存模型"></a>3.9.1 CPU内存模型</h3><p>根据重排的剧烈程度,或者说约束的强弱,可以把CPU划分为几种类型:<br>(性能由低到高,约束逐渐减少)</p>
<ol>
<li>TSO模型(Total Store Order). 写-读顺序会进行重排;// 因为要使用写缓冲区</li>
<li>PSO模型(Partial Store Order). 写-读,写-写都会进行重排. </li>
<li>RMO模型(Relaxed Memory Order). 写-读,写-写,读-读,读-写都会进行重排.<br>(PowerPC内存模型也是)</li>
</ol>
<p>上述重排都在遵守数据依赖的前提下,不然连单线程程序的正确性都无法保证了.<br>所有CPU都起码是TSO模型,因为都需要写缓冲区. </p>
<h3 id="3-9-2-各种内存模型之间的关系"><a href="#3-9-2-各种内存模型之间的关系" class="headerlink" title="3.9.2 各种内存模型之间的关系"></a>3.9.2 各种内存模型之间的关系</h3><p>JAVA内存模型: JMM. 是语言级内存模型, 把底层的CPU的内存模型进行封装, 通过加入内存屏障, 让底层对于程序员来说变成一致的JMM. (平台无关) </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://xiaoyue26.github.io/2018/01/21/2018-01/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%B8%89%E7%AB%A0/" data-id="ck96cxpnr009zmaam3ftybqax" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/" rel="tag">java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%B9%B6%E5%8F%91/" rel="tag">并发</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-2018-01/hive抽样" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/01/20/2018-01/hive%E6%8A%BD%E6%A0%B7/" class="article-date">
  <time datetime="2018-01-20T11:25:01.000Z" itemprop="datePublished">2018-01-20</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/hadoop/">hadoop</a>►<a class="article-category-link" href="/categories/hadoop/hive/">hive</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/01/20/2018-01/hive%E6%8A%BD%E6%A0%B7/">hive抽样</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <p>有时候需要快速估计值,可以借助抽样.Hive中抽样的方法:</p>
<h1 id="抽取指定比例-如10"><a href="#抽取指定比例-如10" class="headerlink" title="抽取指定比例(如10%):"></a>抽取指定比例(如10%):</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t_name <span class="keyword">TABLESAMPLE</span>(<span class="number">0.1</span> <span class="keyword">PERCENT</span>) s</span><br></pre></td></tr></table></figure>
<h1 id="抽取指定大小-如30M"><a href="#抽取指定大小-如30M" class="headerlink" title="抽取指定大小(如30M):"></a>抽取指定大小(如30M):</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t_name <span class="keyword">TABLESAMPLE</span> (<span class="number">30</span>M)</span><br></pre></td></tr></table></figure>
<h1 id="块抽样-每个InputSplit抽取10行"><a href="#块抽样-每个InputSplit抽取10行" class="headerlink" title="块抽样,每个InputSplit抽取10行:"></a>块抽样,每个InputSplit抽取10行:</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t_name <span class="keyword">TABLESAMPLE</span>(<span class="number">10</span> <span class="keyword">ROWS</span>) s</span><br></pre></td></tr></table></figure>
<h1 id="桶抽样-要求原表是分桶表"><a href="#桶抽样-要求原表是分桶表" class="headerlink" title="桶抽样:(要求原表是分桶表)"></a>桶抽样:(要求原表是分桶表)</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t_name_2 <span class="keyword">TABLESAMPLE</span>(<span class="keyword">BUCKET</span> <span class="number">1</span> <span class="keyword">OUT</span> <span class="keyword">OF</span> <span class="number">10</span> <span class="keyword">ON</span> pcid);</span><br></pre></td></tr></table></figure>
<h1 id="一致性抽样"><a href="#一致性抽样" class="headerlink" title="一致性抽样:"></a>一致性抽样:</h1><p>上述抽样每次运行都是随机选取,所以结果每次都不同.<br>如果要求每次抽样的结果是一样的,可以使用随机数发生器的伪随机性,进行系统抽样:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t_name</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">rand</span>(<span class="keyword">unix_timestamp</span>(<span class="keyword">concat</span>(fdate,<span class="string">' '</span>,ftime)))&lt;=<span class="number">0.1</span> <span class="comment">-- 抽取10%</span></span><br></pre></td></tr></table></figure>
<p>上述代码中将表中的两列(fdate,ftime)转化为随机数发生器的种子.<br>如果想让每次抽样的结果不同,也可以将种子换成当前的时间戳,比较灵活.</p>
<p>抽样后,可以对样本进行计算,估计总体的相应统计量.<br>如果是均值,可以用t检验获取总体的置信区间:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">u±S&#x2F;√n*t(1-0.5a,n-1)</span><br></pre></td></tr></table></figure>
<p>如果是中位数,相应的置信区间公式如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">上界位次: S1&#x3D;(n-Z(a)*√n)&#x2F;2</span><br><span class="line">下界位次: n-floor(S1)+1</span><br></pre></td></tr></table></figure>

<p>其他统计量的置信区间可以自行搜索,例如次序统计量: <a href="https://wenku.baidu.com/view/6526f76a7e21af45b307a861.html" target="_blank" rel="noopener">https://wenku.baidu.com/view/6526f76a7e21af45b307a861.html</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://xiaoyue26.github.io/2018/01/20/2018-01/hive%E6%8A%BD%E6%A0%B7/" data-id="ck96cxpno009gmaam8mba5oxi" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hive/" rel="tag">hive</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-2018-01/高性能Mysql笔记-全文索引" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/01/14/2018-01/%E9%AB%98%E6%80%A7%E8%83%BDMysql%E7%AC%94%E8%AE%B0-%E5%85%A8%E6%96%87%E7%B4%A2%E5%BC%95/" class="article-date">
  <time datetime="2018-01-14T11:33:44.000Z" itemprop="datePublished">2018-01-14</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/mysql/">mysql</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/01/14/2018-01/%E9%AB%98%E6%80%A7%E8%83%BDMysql%E7%AC%94%E8%AE%B0-%E5%85%A8%E6%96%87%E7%B4%A2%E5%BC%95/">高性能Mysql笔记-全文索引</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <h1 id="MyISAM的全文索引-第七章"><a href="#MyISAM的全文索引-第七章" class="headerlink" title="MyISAM的全文索引(第七章)"></a>MyISAM的全文索引(第七章)</h1><p>有很多限制,比较弱.</p>
<ul>
<li><p>作用对象:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">全文集合: 将需要索引的列全部拼接成一个字符串,然后进行索引.</span><br></pre></td></tr></table></figure>
<p>由于是对列进行拼接,因此无法设置哪一列更重要.(没有权重)</p>
</li>
<li><p>实现:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">B-Tree索引,两层.</span><br><span class="line">第一层: 所有关键字;</span><br><span class="line">第二层: 一组相关的文档指针.</span><br></pre></td></tr></table></figure>
<p>全文索引不会索引文档对象中的所有词语,过滤规则如下:</p>
</li>
</ul>
<ol>
<li>停用词. 默认按通用英语的使用,可以通过参数ft_stopword_file指定;</li>
<li>长度条件. ft_min_word_len &lt;=len &lt;= ft_max_word_len. </li>
</ol>
<h2 id="7-10-1-自然语言的全文索引"><a href="#7-10-1-自然语言的全文索引" class="headerlink" title="7.10.1 自然语言的全文索引"></a>7.10.1 自然语言的全文索引</h2><p>文档对象和查询的相关度.<br>相关度= f(匹配的关键词个数,关键词在文档中出现的次数)</p>
<p>原理:<br>索引中出现次数越少=&gt;相关度越高<br>常见单词=&gt;相关度低.</p>
<p>创建全文索引语法:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE film_text ADD FULLTEXT INDEX fulltext_article(title,description);</span><br></pre></td></tr></table></figure>


<p>自然语言搜索的查询语法:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select film_id,title,Right(description,25)</span><br><span class="line">,Match(title,description) against (&#39;factor casualties&#39;) as relevance -- 相关度</span><br><span class="line">FROM film_text</span><br><span class="line">WHERE  Match(title,description) against (&#39;factor casualties&#39;)</span><br></pre></td></tr></table></figure>
<p>执行计划:<br>Mysql将搜索词语分为两个独立的关键词进行搜索. (<code>factory</code>和<code>casualties</code>)<br>搜索对象: <code>title</code>和<code>description</code>组成的列的全文索引.</p>
<h2 id="7-10-2-布尔全文索引"><a href="#7-10-2-布尔全文索引" class="headerlink" title="7.10.2 布尔全文索引"></a>7.10.2 布尔全文索引</h2><p>编写布尔搜索查询时,可以通过一些前缀修饰符来定制搜索.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">dino: 包含dino的行rank更高;</span><br><span class="line">~dino: 包含dino的行rank更低;</span><br><span class="line">+dino: 行记录必须包含dino;</span><br><span class="line">-dino: 行记录不能包含dino;</span><br><span class="line">dino*: 以dino开头的行rank更高.</span><br><span class="line">本例中dino作为搜索词可能太短,其实太短的词并不会被全文索引,查询优化器也可能要求搜索词&gt;&#x3D;ft_min_word_len.</span><br></pre></td></tr></table></figure>

<p>查询语法:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select film_id,title,right(description,25)</span><br><span class="line">FROM film_text</span><br><span class="line">where match(title,description)</span><br><span class="line">Against(&#39;+factory +casualties&#39; In Boolean Mode);</span><br><span class="line">-- title拼接description后必须同时包含factory和casualties</span><br></pre></td></tr></table></figure>

<h2 id="7-10-3-插件和限制"><a href="#7-10-3-插件和限制" class="headerlink" title="7.10.3 插件和限制"></a>7.10.3 插件和限制</h2><p>可以加入插件改变:</p>
<ol>
<li>分词方式(如C++);</li>
<li>预处理(如PDF).</li>
</ol>
<p>Mysql全文索引判断相关性的方法: 词频;<br>限制: </p>
<ol>
<li>全文索引能全部load到内存时,才能快.</li>
<li>判断相关性只有词频,没有顺序;</li>
<li>优化器会优先使用全文索引,而不管是否有其他更优索引, 并且全文索引会在其他索引之前使用. </li>
<li>碎片多.</li>
</ol>
<h1 id="Sphinx-Mysql-SphinxSE-附录F"><a href="#Sphinx-Mysql-SphinxSE-附录F" class="headerlink" title="Sphinx + Mysql + SphinxSE (附录F)"></a>Sphinx + Mysql + SphinxSE (附录F)</h1><p>Sphinx: 开源全文搜索引擎. 可将数据源配置为Mysql查询的结果. 可水平扩展.<br>SphinxSE: Mysql的Sphinx插件,以便支持将Sphinx的搜索结果和Mysql的表进行join. </p>
<p>Sphinx性能:</p>
<ol>
<li>查询1GB时间:  10~100ms;</li>
<li>单CPU处理能力:10~100GB. </li>
</ol>
<p>分布式搜索工作流程:</p>
<ol>
<li>向所有服务器发送远程查询;</li>
<li>执行本地索引搜索;</li>
<li>从每个服务器读取部分搜索结果;</li>
<li>合并结果返回客户端.</li>
</ol>
<h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><ul>
<li>Indexed<br>从不同数据源创建全文索引.作为后台任务,一般定时运行;</li>
<li>Searchd<br>运行时服务于客户端,查询创建好的索引.</li>
</ul>
<h2 id="SphinxSE可插拔存储引擎"><a href="#SphinxSE可插拔存储引擎" class="headerlink" title="SphinxSE可插拔存储引擎"></a>SphinxSE可插拔存储引擎</h2><p>建表语法:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">create table search_table</span><br><span class="line">(id int not null</span><br><span class="line">,weight int not null</span><br><span class="line">,query varchar(3070) not null</span><br><span class="line">,group_id int</span><br><span class="line">,INDEX(query)</span><br><span class="line">) engine&#x3D;Spinx conncet&#x3D;&quot;sphinx:&#x2F;&#x2F;localhost:3312&#x2F;test&quot;</span><br></pre></td></tr></table></figure>
<p>查询语法:(把查询藏在query里,传递给sphinx)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from search_table where query&#x3D;&#39;test;mode&#x3D;all&#39;;</span><br></pre></td></tr></table></figure>
<p><code>Searchd</code>服务返回查询结果,存储引擎把数据转换成mysql表.</p>
<p>与<code>ElasticSearch</code>比较:<br><a href="https://zhuanlan.zhihu.com/p/21334385" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/21334385</a></p>
<p>决定倒向<code>ElasticSearch</code>社区.XD</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://xiaoyue26.github.io/2018/01/14/2018-01/%E9%AB%98%E6%80%A7%E8%83%BDMysql%E7%AC%94%E8%AE%B0-%E5%85%A8%E6%96%87%E7%B4%A2%E5%BC%95/" data-id="ck96cxpnt00aamaam99xke1w8" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/mysql/" rel="tag">mysql</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-2018-01/高性能Mysql笔记-第1章" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/01/14/2018-01/%E9%AB%98%E6%80%A7%E8%83%BDMysql%E7%AC%94%E8%AE%B0-%E7%AC%AC1%E7%AB%A0/" class="article-date">
  <time datetime="2018-01-14T10:16:46.000Z" itemprop="datePublished">2018-01-14</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/mysql/">mysql</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/01/14/2018-01/%E9%AB%98%E6%80%A7%E8%83%BDMysql%E7%AC%94%E8%AE%B0-%E7%AC%AC1%E7%AB%A0/">高性能Mysql笔记-第1章</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <h1 id="第一章-架构与历史"><a href="#第一章-架构与历史" class="headerlink" title="第一章 架构与历史"></a>第一章 架构与历史</h1><p>逻辑架构:<br>客户端<br>=&gt;连接/线程处理<br>=&gt;查询缓存/解析器<br>=&gt;优化器<br>=&gt;存储引擎. </p>
<p>其中只有innodb引擎会解析SQL中的外键定义.其他引擎不会解析SQL.<br>所有内容都应该同时关注两个层面的实现: 服务器层和存储引擎层.</p>
<h2 id="1-1-1-连接管理"><a href="#1-1-1-连接管理" class="headerlink" title="1.1.1 连接管理"></a>1.1.1 连接管理</h2><p>每个客户端连接都会在服务器进程中拥有一个线程,这个连接的查询只会在这个单独的线程中执行. 服务器会负责缓存线程,因此不需要为每个新连接创建或销毁线程.</p>
<h2 id="1-1-2-优化与执行"><a href="#1-1-2-优化与执行" class="headerlink" title="1.1.2 优化与执行"></a>1.1.2 优化与执行</h2><p>首先查询缓存中有没有,如果没有:</p>
<p>Mysql会解析查询,并创建内部数据结构(解析树),然后进行优化,包括重写查询,决定表的读取顺序以及选择合适的索引.</p>
<p>用户可以使用hint指令指导优化.</p>
<p>优化器并不关心底层存储引擎的具体实现,但会向底层存储引擎请求一些数据.</p>
<h2 id="1-2-并发控制"><a href="#1-2-并发控制" class="headerlink" title="1.2 并发控制"></a>1.2 并发控制</h2><h3 id="1-2-1-读写锁"><a href="#1-2-1-读写锁" class="headerlink" title="1.2.1 读写锁"></a>1.2.1 读写锁</h3><p>读锁: 共享锁,不干扰其他锁.<br>写锁: 排他锁,排除其他读写锁.</p>
<h3 id="1-2-2-锁粒度"><a href="#1-2-2-锁粒度" class="headerlink" title="1.2.2 锁粒度"></a>1.2.2 锁粒度</h3><ul>
<li><p>表锁<br>开销最小,但并发度低.<br>// ALTER TABLE语句都会使用表锁,不管底层引擎是什么.</p>
</li>
<li><p>行锁<br>最大程度的并发,但也有最大的锁开销. 由存储引擎各自实现.</p>
</li>
</ul>
<h2 id="1-3-事务"><a href="#1-3-事务" class="headerlink" title="1.3 事务"></a>1.3 事务</h2><p>基本流程:</p>
<ol>
<li>Start transaction;</li>
<li>执行一组SQL</li>
<li>commit. </li>
</ol>
<p>事务的4个指标(ACID):</p>
<ol>
<li>原子性: 要么全部成功,要么全部回滚.</li>
<li>一致性: 事务中间状态的修改不会保存到数据库中.(感觉和原子性有重合)</li>
<li>隔离性: 事务在最终提交之前,对其他事务是不可见的.</li>
<li>持久性: 一旦事务提交,修改就会永久保存到数据库中. </li>
</ol>
<h3 id="1-3-1-隔离级别"><a href="#1-3-1-隔离级别" class="headerlink" title="1.3.1 隔离级别"></a>1.3.1 隔离级别</h3><p>4种隔离级别(由低到高):<br><strong>1.Read uncommitted:</strong></p>
<blockquote>
<p>未提交读. 有脏读. 能读到别的事务还没commit的修改. 太弱, 基本不用.</p>
</blockquote>
<p><strong>2.Read committed</strong>  (Mysql以外的数据库默认级别)</p>
<blockquote>
<p>提交读. 一个事务的修改,提交前对其他事务不可见.<br>存在不可重复读问题.<br>比如如下流程:</p>
</blockquote>
<ol>
<li>A事务读V; </li>
<li>B事务提交V;</li>
<li>A事务读V.<br>由于B事务中间提交了一次,A事务两次读到的值不一样,也就是不可重复读.</li>
</ol>
<p><strong>3.Repeatable Read</strong> (Mysql默认级别)</p>
<blockquote>
<p>可重复读. 可以重复读单条记录. (方法,InnoDb增加多版本并发控制MVCC)<br>存在幻读问题.<br>比如如下流程:</p>
</blockquote>
<ol>
<li>A事务读范围行Vs;</li>
<li>B事务插入v到Vs中;</li>
<li>A事务读范围行Vs.<br>由于B事务中交提交了一次,A事务两次读到的范围行不一样,也就是幻读.<br>(可以用MVCC+间隙锁解决.)</li>
</ol>
<p><strong>4.Serialable</strong></p>
<blockquote>
<p>可串行化. 解决了幻读.<br>强制事务串行执行. 增加了每一行锁.</p>
</blockquote>
<p>总结问题:</p>
<blockquote>
<ol>
<li>未提交读: 脏读,不可重复读,幻读.</li>
<li>提交读:        不可重复读,幻读.</li>
<li>可重复读:                 幻读.</li>
<li>可串行:   慢.</li>
</ol>
</blockquote>
<p>mysql默认是可重复读,解决正确使用的幻读，使用MVCC+间隙锁;<br>MVCC:  解决两次快照读的幻读; (两次快照读一定一样)<br>间隙锁: 解决两次当前读的幻读; (两次当前读一定一样)</p>
<p>而，快照读和当前读的结果对于mysql的<code>可重复读</code>级别来说，可能结果不一样。<br>因此我们定义的正确使用: 程序￿员不应假设”快照读”和”当前读”的结果一样。</p>
<blockquote>
<p>快照读: select xxx<br>当前读: select xxx for update; 或者update/insert语句中隐含的读(基于当前数据库的数据状态)</p>
</blockquote>
<p>如果在最高隔离级别(串行)下，事务中的所有读都会被加上间歇锁，<br>因此保证了快照读和当前读的结果。// 也就是即使程序员不懂这方面知识、不正确使用，也能得到正确的结果。</p>
<h3 id="1-3-2-事务死锁"><a href="#1-3-2-事务死锁" class="headerlink" title="1.3.2 事务死锁"></a>1.3.2 事务死锁</h3><p>Innodb:<br>检查到死锁的循环依赖<br>=&gt;立即返回错误.</p>
<ul>
<li>处理死锁:<br>将持有最少行级写锁(排他锁)的事务进行回滚.</li>
</ul>
<h3 id="1-3-3-事务日志"><a href="#1-3-3-事务日志" class="headerlink" title="1.3.3 事务日志"></a>1.3.3 事务日志</h3><p><code>WAL(Write-Ahead Logging) 异步刷盘</code>.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. 数据追加写到日志里(顺序IO);</span><br><span class="line">2. 数据修改到原数据里. (随机IO).</span><br></pre></td></tr></table></figure>

<p>第二步如果失败崩溃,可以利用第一步的日志修复.</p>
<h3 id="1-3-4-Mysql中的事务"><a href="#1-3-4-Mysql中的事务" class="headerlink" title="1.3.4 Mysql中的事务"></a>1.3.4 Mysql中的事务</h3><p>Mysql事务型引擎: InnoDB, NDB Cluster. (MyIsam不支持事务)<br>第三方引擎: XtraDB,PBXT<br>InnoDb支持所有4个隔离级别.</p>
<p><strong>自动提交</strong><br>Mysql默认使用自动提交. 如果不显式得开始一个事务,每个查询都被当成一个独立的事务.</p>
<p>可能导致强制提交事务的命令:</p>
<ol>
<li>Alter Table</li>
<li>Lock Tables</li>
<li>其他导致大量数据更改的语句…</li>
</ol>
<p><strong>在事务中混合使用存储引擎(不推荐)</strong></p>
<ul>
<li>服务层: 不管理事务;</li>
<li>存储引擎: 具体实现事务.</li>
</ul>
<p>混合使用InnoDb,MyISAM: (事务型表+非事务型表)</p>
<blockquote>
<p>回滚时,非事务型表上的变更无法撤销, 导致数据库处于不一致状态.</p>
</blockquote>
<p><strong>隐式和显式锁定</strong><br>InnoDb采用两阶段锁定协议. </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">加锁: 事务执行过程中随时加锁;</span><br><span class="line">解锁: 仅当Commit或RollBack时.</span><br></pre></td></tr></table></figure>

<blockquote>
<p>隐式加锁: 存储引擎自动加锁<br>显式加锁: 明确指定语句: <code>Select ... Lock In Share Mode</code></p>
</blockquote>
<ul>
<li>tip<blockquote>
<p>尽量不要显式加锁,而是交给Innodb实现. 以避免无法预料的错误.<br>(除非研究得很深了.)</p>
</blockquote>
</li>
</ul>
<h2 id="1-4-多版本并发控制-MVCC"><a href="#1-4-多版本并发控制-MVCC" class="headerlink" title="1.4 多版本并发控制 MVCC"></a>1.4 多版本并发控制 MVCC</h2><p>MVCC: 行级锁的一个变种. 在很多情况下避免了加锁操作, 开销更低.<br>大多实现了非阻塞的读操作, 写操作只锁定必要的行.</p>
<ul>
<li>实现<br>每个事务开始的时候保存数据在某个时间点的快照.</li>
</ul>
<p><strong>InnoDb的MVCC</strong>(空间换时间,少加锁)</p>
<blockquote>
<p>每行记录后保存两个隐藏列: </p>
</blockquote>
<ol>
<li>行的创建系统版本号;</li>
<li>行的删除系统版本号.</li>
</ol>
<p>系统版本号反映了时间.<br>每开始一个新的事务,系统版本号都会递增.<br>事务开始时刻的系统版本号会作为事务的版本号,<br>用来和查询到的每行记录的版本号比较.</p>
<p>##Innodb的可重复读级别下<br><strong>Select</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. 创建版本号&lt;&#x3D;当前事务版本的数据;</span><br><span class="line">2. 删除版本号&gt;当前事务版本的数据 (或者没有删除).</span><br></pre></td></tr></table></figure>

<p><strong>Insert</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1. 插入新行,创建版本号&#x3D;当前事务版本号.</span><br></pre></td></tr></table></figure>

<p><strong>Delete</strong>(标记删)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. 删除的行,删除版本号&#x3D;当前事务版本号.</span><br><span class="line">(打标记,而不是真的删)</span><br></pre></td></tr></table></figure>

<p><strong>Update</strong>(标记删+插入新)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. 插入新行,创建版本号&#x3D;当前事务版本号.</span><br><span class="line">2. 原来的行,删除版本号&#x3D;当前事务版本号.</span><br></pre></td></tr></table></figure>

<h2 id="底层原理"><a href="#底层原理" class="headerlink" title="底层原理"></a>底层原理</h2><p>实际实现参见: <a href="https://liuzhengyang.github.io/2017/04/18/innodb-mvcc/" target="_blank" rel="noopener">https://liuzhengyang.github.io/2017/04/18/innodb-mvcc/</a><br>是将旧版本的行存在undo log中，如果没有依赖这部分undo log的事务结束了(提交或者回滚),<br>这部分undo log是会销毁的，因此不会造成永久的存储负担。</p>
<p>MVCC与隔离级别:</p>
<blockquote>
<ol>
<li>读未提交: 不使用MVCC;</li>
<li>读已提交: 使用MVCC; // 可能版本号条件不同</li>
<li>可重复读: 使用MVCC+当前读间隙锁; // 解决正确使用情况下的幻读 </li>
<li>可串行读: MVCC+快照读和当前读都有间隙锁. // 解决所有情况下的幻读</li>
</ol>
</blockquote>
<p>MVCC相当于乐观锁或者无锁、空间换时间；<br>间隙锁相当于悲观锁。真实地锁了索引。</p>
<h2 id="1-5-Mysql的存储引擎"><a href="#1-5-Mysql的存储引擎" class="headerlink" title="1.5 Mysql的存储引擎"></a>1.5 Mysql的存储引擎</h2><ul>
<li><p>每个数据库: 一个目录</p>
</li>
<li><p>每个数据表: </p>
</li>
</ul>
<ol>
<li><code>元数据</code>(表定义): 表同名的<code>.frm</code>文件; (服务层统一实现)</li>
<li><code>数据</code>;  (存储引擎分别实现)</li>
<li><code>索引</code>.  (存储引擎分别实现)</li>
</ol>
<h3 id="元数据-表定义具体内容"><a href="#元数据-表定义具体内容" class="headerlink" title="元数据(表定义具体内容)"></a>元数据(表定义具体内容)</h3><p>表的相关属性:</p>
<ul>
<li>Name</li>
<li>Engine</li>
<li>Row_format: </li>
</ul>
<ol>
<li>Dynamic: 行长度可变,包含Varchar或Blob的行.</li>
<li>Fixed: 只包含固定长度列.</li>
<li>Compressed: 压缩表.</li>
</ol>
<ul>
<li>Rows: 行数. Innodb:估算值. MyISAM: 精确值;</li>
<li>Index_length: 索引长度</li>
<li>Collcation: 默认字符集和字符排序规则.</li>
<li>其他信息…</li>
</ul>
<h3 id="1-5-1-InnoDB存储引擎"><a href="#1-5-1-InnoDB存储引擎" class="headerlink" title="1.5.1 InnoDB存储引擎"></a>1.5.1 InnoDB存储引擎</h3><p>设计目标: 大量短期事务.<br>Mysql主推引擎.</p>
<p><strong>存储</strong><br>数据: 表空间中,一系列数据文件组成.<br>索引: 表空间中,独立的索引文件.</p>
<p>隔离级别的实现:</p>
<ol>
<li>MVCC;</li>
<li>间隙锁: 不仅锁定查询涉及的行,还锁定索引中的间隙,防止幻读. </li>
</ol>
<p>存储格式:(跨平台)</p>
<ol>
<li>主键: 指向物理地址;</li>
<li>二级索引: 非主键索引,指向主键,所以主键应尽可能小. </li>
</ol>
<h2 id="MyISam"><a href="#MyISam" class="headerlink" title="MyISam"></a>MyISam</h2><p><strong>存储</strong></p>
<ol>
<li>数据: <code>.MYD</code></li>
<li>索引: <code>.MYI</code></li>
</ol>
<p>变长行: 默认最大数据量256TB,因为指向数据记录的指针长度是6B.<br>可以修改Max_Rows和Avg_row_length的值,来改变指针长度.<br>(两者相乘=表最大容量)</p>
<p><strong>并发</strong><br>整张表加锁.</p>
<p><strong>索引</strong><br>支持全文索引,基于分词创建的索引.</p>
<p><strong>压缩表</strong><br>不再修改的表可以进行压缩,提高查询性能,减少磁盘空间.</p>
<h3 id="1-5-3-其他引擎"><a href="#1-5-3-其他引擎" class="headerlink" title="1.5.3 其他引擎"></a>1.5.3 其他引擎</h3><p>Archive: 只支持插入和查询,不支持修改和删除.<br>BlackHole: 丢弃所有插入的数据,只记录日志. 有很多问题.<br>CSV: 存储CSV文件. (这个场景应该考虑使用Sql Server)<br>Federated: 访问其他Mysql服务器的代理,默认禁用.</p>
<ul>
<li>Memory: 磁盘只保存结构,数据在内存,重启后丢失数据.<br>使用场景: </li>
</ul>
<ol>
<li>查找或映射表;// 邮编和州名的映射表;</li>
<li>缓存周期性聚合数据;</li>
<li>保存数据分析中产生的中间数据.</li>
</ol>
<p>限制: </p>
<ol>
<li>表级锁;</li>
<li>只支持定长列, 如果指定了varchar,会转换成char. </li>
</ol>
<p>Merge引擎:<br>多个MyIsam表合并的虚拟表;<br>引入分区功能后弃用.</p>
<p>NDB引擎:<br>Mysql集群版.</p>
<h3 id="1-5-5-选择合适的引擎"><a href="#1-5-5-选择合适的引擎" class="headerlink" title="1.5.5 选择合适的引擎"></a>1.5.5 选择合适的引擎</h3><p>场景:</p>
<ol>
<li>全文索引: InnoDB + Sphinx</li>
<li>在线热备份: InnoDB</li>
<li>记录日志: MyISAM,Archive</li>
<li>10TB以下: InnoDB</li>
<li>10TB以上: InfoBright.</li>
<li>大部分情况优先考虑: Innodb</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://xiaoyue26.github.io/2018/01/14/2018-01/%E9%AB%98%E6%80%A7%E8%83%BDMysql%E7%AC%94%E8%AE%B0-%E7%AC%AC1%E7%AB%A0/" data-id="ck96cxpnv00ahmaam9sch1mtq" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/mysql/" rel="tag">mysql</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-2018-01/Netty-in-action笔记-第1-2章" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/01/13/2018-01/Netty-in-action%E7%AC%94%E8%AE%B0-%E7%AC%AC1-2%E7%AB%A0/" class="article-date">
  <time datetime="2018-01-13T14:16:24.000Z" itemprop="datePublished">2018-01-13</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/java/">java</a>►<a class="article-category-link" href="/categories/java/Netty/">Netty</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/01/13/2018-01/Netty-in-action%E7%AC%94%E8%AE%B0-%E7%AC%AC1-2%E7%AB%A0/">Netty in action笔记-第1-2章</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <p>Hadoop中用了Netty3,所以得看看这一块.<br>中文版的代码链接:<br><a href="https://github.com/ReactivePlatform/netty-in-action-cn" target="_blank" rel="noopener">https://github.com/ReactivePlatform/netty-in-action-cn</a></p>
<h1 id="第一章-Netty介绍"><a href="#第一章-Netty介绍" class="headerlink" title="第一章 Netty介绍"></a>第一章 Netty介绍</h1><p>这一章主要介绍了一下Netty.<br>Netty封装了Java NIO中的一些复杂的细节和坑.</p>
<h2 id="1-1-为什么使用Netty"><a href="#1-1-为什么使用Netty" class="headerlink" title="1.1 为什么使用Netty"></a>1.1 为什么使用Netty</h2><ol>
<li>Netty提供了高层次抽象来简化TCP/UDP服务器的编程.<br>用Netty可以实现FTP,SMTP,HTTP,WebSocket,SPDY.</li>
<li>Netty社区很活跃.</li>
</ol>
<h3 id="1-1-2-Netty框架的组成"><a href="#1-1-2-Netty框架的组成" class="headerlink" title="1.1.2 Netty框架的组成"></a>1.1.2 Netty框架的组成</h3><img src="/images/netty-chapter1.png" class="" width="400" height="600" title="Netty框架">

<h2 id="1-2-异步设计"><a href="#1-2-异步设计" class="headerlink" title="1.2 异步设计"></a>1.2 异步设计</h2><p>Netty中主要使用了回调+Future. </p>
<h3 id="1-2-1-回调"><a href="#1-2-1-回调" class="headerlink" title="1.2.1 回调"></a>1.2.1 回调</h3><p>异步处理的一种技术是回调. 就是在一些关心的事件上注册回调函数.<br>// 个人理解,回调应该是同步非阻塞.<br>// 同步: 客户端等待注册完成;<br>// 非阻塞: 服务端只是注册事件,返回得很快.</p>
<h3 id="1-2-2-Future"><a href="#1-2-2-Future" class="headerlink" title="1.2.2 Future"></a>1.2.2 Future</h3><p><code>java.util.concurrent</code>包中附带的Future接口.使用<code>Executor</code>异步执行.<br>每传递一个Runnable对象到<code>ExecutorService.submit()</code>方法就会得到一个回调的Future,能使用它检测是否执行完成.<br>// 个人理解,Future其实是异步阻塞.<br>// 异步: 客户端不等待服务端执行结束,拿到Future后,需要自己轮询结果.<br>// 阻塞: 服务端不会主动回调,只是提供一个查询接口.</p>
<h3 id="1-4-Netty相比NIO优点"><a href="#1-4-Netty相比NIO优点" class="headerlink" title="1.4 Netty相比NIO优点"></a>1.4 Netty相比NIO优点</h3><ol>
<li>兼容性和跨平台性进一步提高;</li>
<li>扩展ByteBuffer.<br><code>ByteBuffer</code>允许包装一个<code>byte[]</code>来获得一个实例,可以尽量减少内存拷贝.</li>
<li>消除NIO的内存泄漏(jdk1.7以上)<br>NIO对于缓存区的聚合和分散操作可能造成内存泄漏.</li>
</ol>
<ul>
<li><p>分散(Scatter)</p>
<blockquote>
<p>将<code>ScatteringByteBuffer</code>中的数据分散到多个<code>ByteBuffer</code>中.</p>
</blockquote>
</li>
<li><p>聚合(Gather)</p>
<blockquote>
<p>将多个<code>ByteBuffer</code>的数据聚合到<code>GatheringByteChannel</code>中.</p>
</blockquote>
</li>
</ul>
<ol start="4">
<li>解决epoll缺陷导致的100%cpu问题.</li>
</ol>
<h1 id="第二章-Netty核心概念-简单示例"><a href="#第二章-Netty核心概念-简单示例" class="headerlink" title="第二章 Netty核心概念,简单示例"></a>第二章 Netty核心概念,简单示例</h1><p>这章用的是Netty4.(但愿和Netty3同理)<br>上来先整了几段代码,而没有先说概念.<br>代码如下:<br><a href="https://github.com/xiaoyue26/netty-in-action-cn/blob/ChineseVersion/chapter2/Server/src/main/java/nia/chapter2/echoserver/EchoServer.java" target="_blank" rel="noopener">https://github.com/xiaoyue26/netty-in-action-cn/blob/ChineseVersion/chapter2/Server/src/main/java/nia/chapter2/echoserver/EchoServer.java</a></p>
<p>可以看出服务端和客户端代码很类似,大致套路是:</p>
<ol>
<li>创建一个EventLoopGroup;//类似于召集一群干活的(线程池)</li>
<li>创建一个Bootstrap(ServerBootstrap);// 类似于管家/控制面板</li>
<li>Bootstrap配置上eventGroup,channel用的类,端口地址,处理链.</li>
<li>绑定到端口开始工作. </li>
</ol>
<p>值得注意的是,所有涉及到Future的方法都是异步的,可以通过主动调用<code>sync</code>方法来进行同步等待.(当然也可以轮询)</p>
<ul>
<li>设计思想</li>
</ul>
<ol>
<li>在Bootstrap上使用Future;</li>
<li>在处理链上使用回调.</li>
</ol>
<ul>
<li>具体细节</li>
</ul>
<ol>
<li><code>ChannelInboundHandlerAdapter</code>:<br>处理完消息后需要释放资源;(<code>ByteBuf.release()</code>)</li>
<li><code>SimpleChannelInboundHandler</code>:<br>完成channelRead0后自动释放消息.</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://xiaoyue26.github.io/2018/01/13/2018-01/Netty-in-action%E7%AC%94%E8%AE%B0-%E7%AC%AC1-2%E7%AB%A0/" data-id="ck96cxpnm009cmaamc7dc0r1n" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/NIO/" rel="tag">NIO</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Netty/" rel="tag">Netty</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/" rel="tag">java</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-2018-01/java并发编程的艺术笔记-第二章" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/01/13/2018-01/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E7%AB%A0/" class="article-date">
  <time datetime="2018-01-13T13:29:19.000Z" itemprop="datePublished">2018-01-13</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/java/">java</a>►<a class="article-category-link" href="/categories/java/%E5%B9%B6%E5%8F%91/">并发</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/01/13/2018-01/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E7%AB%A0/">java并发编程的艺术笔记-第二章</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <h1 id="第二章-java并发机制的底层实现原理"><a href="#第二章-java并发机制的底层实现原理" class="headerlink" title="第二章 java并发机制的底层实现原理"></a>第二章 java并发机制的底层实现原理</h1><ul>
<li>java代码执行流程</li>
</ul>
<ol>
<li>java代码编译成class文件(字节码);</li>
<li>class被类加载器加载到JVM中;</li>
<li>JVM执行class,生成汇编码;</li>
<li>汇编码(转化成机器码/cpu指令)在cpu上执行.</li>
</ol>
<p>因此java并发机制的底层实现依赖于两个层面:</p>
<ol>
<li>class=&gt;汇编码过程中增加的指令;</li>
<li>并发相关cpu指令的具体执行过程. </li>
</ol>
<h2 id="2-1-volatile"><a href="#2-1-volatile" class="headerlink" title="2.1 volatile"></a>2.1 volatile</h2><ul>
<li><p>定义<br>可见性. 对于volatile变量,所有线程看到的值是一致的.<br>换句话说,某个线程对于volatile的修改能立即生效.</p>
</li>
<li><p>实现</p>
</li>
</ul>
<ol>
<li>class=&gt;指令: 增加Lock指令</li>
<li>Lock指令具体执行:<br>(1) 将当前cpu包含该值的缓存行写回内存;<br>(2) 在总线上通知其他cpu这个地址已发生更改,需要刷新缓存.<br>(缓存一致性协议)</li>
</ol>
<ul>
<li>相关优化<br>由于上述实现中的2(1)为:”将当前cpu包含该值的缓存行写回内存”,<br>换句话说,如果这个值跨行了,就会影响两行的数据,也就会导致两行的缓存失效,<br>其他cpu刷新缓存的数据量变成两倍.<br>因此尽量要把数据对齐到一行. (比如32位,64位)</li>
</ul>
<h2 id="2-2-synchronized"><a href="#2-2-synchronized" class="headerlink" title="2.2 synchronized"></a>2.2 synchronized</h2><p>内置锁,锁某个对象.(可以是当前实例对象或当前类对象)</p>
<ul>
<li>实现</li>
</ul>
<ol>
<li><p>class=&gt;指令:<br>增加:<br>进入同步块: monitorenter<br>离开同步块: monitorexit (正常离开或者异常)</p>
</li>
<li><p>cpu对这俩指令的执行书里没有细讲,只说了对象头里相关数据是怎么存的.</p>
</li>
</ol>
<h3 id="2-2-1-对象头中锁相关数据"><a href="#2-2-1-对象头中锁相关数据" class="headerlink" title="2.2.1 对象头中锁相关数据"></a>2.2.1 对象头中锁相关数据</h3><ul>
<li>对象头内容</li>
</ul>
<ol>
<li>Mark Word: hashCode/分代年龄/锁信息. </li>
<li>类元数据地址;</li>
<li>数组长度. // 如果是数组</li>
</ol>
<ul>
<li>不同锁标志的信息</li>
</ul>
<ol>
<li>轻量级锁: 指向栈中锁记录的指针;   // 锁标志00</li>
<li>重量级锁: 指向互斥量的指针    ;   // 锁标志10</li>
<li>GC标记  : 空;                     // 锁标志11</li>
<li>偏向锁  : 线程ID,epoch,分代年龄,1; // 锁标志01</li>
</ol>
<p>锁的4种状态: (锁只能升级,不能降级)</p>
<ol>
<li>无锁;</li>
<li>偏向锁: 一个线程使用该对象;</li>
<li>轻量级锁: 多个线程交替使用该对象;</li>
<li>重量级锁: 多个线程同时竞争该对象. </li>
</ol>
<p><strong>偏向锁</strong><br>HotSpot作者:<br>大多数情况下不存在多个线程竞争一个对象,这个时候可以优化让线程获得锁的代价更低.</p>
<ul>
<li>获取偏向锁流程</li>
</ul>
<ol>
<li>检查对象头里线程ID是不是自己或者是否无锁状态;</li>
<li>复制对象头中Mark Word到栈中;</li>
<li>在副本上写线程ID为自己ID;</li>
<li>CAS,用副本替换Mark Word,获得偏向锁. </li>
</ol>
<p>如果成功的话,下次进入同步块的时候,只要第1步能成功,就不再需要CAS操作了.<br>换句话说,这种场景下, 同一个线程可以重入同一个对象的锁,只有第一次需要CAS操作(代价比较大的操作).</p>
<ul>
<li>偏向锁的撤销(也就是对象头中存储的线程ID改掉)</li>
</ul>
<ol>
<li>别的线程也申请这个锁;</li>
<li>之前拥有锁的线程不存活=&gt; 对象头设置成无锁;</li>
<li>之前拥有锁的线程存活 =&gt; 锁升级.</li>
</ol>
<p><strong>轻量级锁</strong></p>
<ul>
<li>获取轻量级锁流程</li>
</ul>
<ol>
<li>检查</li>
<li>复制对象头中Mark word到栈中;</li>
<li>副本中写指向自己锁记录的指针;</li>
<li>CAS,用副本替换Mark word,获得偏向锁. </li>
</ol>
<p>如果第4步失败,尝试先不阻塞,使用自旋获取锁.(有可能已经拥有这个锁,试试看)<br>如果又失败,膨胀(升级)为重量级锁.</p>
<ul>
<li>轻量级锁的解锁</li>
</ul>
<ol>
<li>CAS还原复制的对象头.</li>
</ol>
<p>如果成功,就解锁;<br>如果失败,说明除了自己还有别人也改过对象头.膨胀为重量级锁.</p>
<p>对比:</p>
<ol>
<li>偏向锁: 打个自己的标记;</li>
<li>轻量级锁: 不阻塞,自旋重试;</li>
<li>重量级锁: 阻塞,等待唤醒.</li>
</ol>
<h2 id="2-3-原子操作实现原理"><a href="#2-3-原子操作实现原理" class="headerlink" title="2.3 原子操作实现原理"></a>2.3 原子操作实现原理</h2><ol>
<li>总线锁: 某个cpu用Lock指令锁总线,独占内存; // 开销大</li>
<li>缓存锁: 某个cpu修改内存地址,使其他cpu缓存无效.//开销小</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://xiaoyue26.github.io/2018/01/13/2018-01/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E7%AB%A0/" data-id="ck96cxpnt00a6maamda4y0a46" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/" rel="tag">java</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-2018-01/谷歌的一致性哈希算法" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/01/13/2018-01/%E8%B0%B7%E6%AD%8C%E7%9A%84%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95/" class="article-date">
  <time datetime="2018-01-13T03:18:36.000Z" itemprop="datePublished">2018-01-13</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/01/13/2018-01/%E8%B0%B7%E6%AD%8C%E7%9A%84%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95/">谷歌的一致性哈希算法</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <h1 id="jump-consistent-hash"><a href="#jump-consistent-hash" class="headerlink" title="jump consistent hash"></a>jump consistent hash</h1><p><code>jump consistent hash</code>是谷歌发表的一种一致性哈希算法.<br>空间复杂度: O(1);<br>时间复杂度: O(lgn).</p>
<h2 id="设计目标："><a href="#设计目标：" class="headerlink" title="设计目标："></a>设计目标：</h2><p>1.平衡性，把对象均匀地分布在所有桶中。(这个大部分哈希算法都能做到)<br>2.单调性，当桶的数量变化时，只需要把最少量的对象从旧桶移动到新桶，不需要做更多移动。比如原来是10个桶,增加了10个桶,只需要移动一半的对象就好了.<br>(更改算法的输入参数n,会有一半的对象依然映射到原来的桶里,有一半的对象映射到新的桶里.)</p>
<h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><p>记 <code>ch(key,num_buckets)</code> 为桶数量为<code>num_buckets</code>时的<code>hash</code>函数,返回分配的桶下标。</p>
<ul>
<li><p>num_buckets=1时:<br>由于只有1个桶，显而易见，对任意k，有<code>ch(k,1)==0</code>。</p>
</li>
<li><p>num_buckets=2时:<br>为了使hash的结果保持均匀，ch(k,2)的结果应该有占比1/2的结果保持为0，有1/2跳变为1。</p>
</li>
</ul>
<p>由此可以归纳，一般规律是：</p>
<blockquote>
<p><code>num_buckets</code>从<code>n</code>变化到<code>n+1</code>后，<br><code>ch(k,n+1)</code> 的结果中，应该有占比 <code>n/(n+1)</code> 的结果保持不变，<br>而有 <code>1/(n+1)</code> 跳变为 <code>n+1</code>。</p>
</blockquote>
<p>因此，我们可以用一个随机数生成器，来决定每次要不要跳变，并且让这个随机数生成器的状态仅仅依赖于<code>key</code>。所以就得到下面这个初步代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ch</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> num_buckets)</span> </span>&#123;</span><br><span class="line">    random.seed(key) ;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; num_buckets; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (random.next() &lt; <span class="number">1.0</span>/(j+<span class="number">1</span>) ) &#123;</span><br><span class="line">            b = j ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="算法正确性"><a href="#算法正确性" class="headerlink" title="算法正确性"></a>算法正确性</h2><p>(0-based)<br>n个桶,从0开始往n-2跳变(n-2次)，每次跳变的概率依次是<code>1/2</code>,<code>1/3</code>,<code>1/4</code>…<code>1/n</code>。<br>从而保证keys在每个桶分布的概率均匀。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">P(b&#x3D;0(初始值)) &#x3D;每次都不变&#x3D;1&#x2F;2*2&#x2F;3*3&#x2F;4...(n-2)&#x2F;(n-1)*(n-1)&#x2F;n&#x3D;1&#x2F;n;</span><br><span class="line">P(b&#x3D;1) &#x3D;1&#x2F;2(变)*2&#x2F;3(不变)*....&#x3D;1&#x2F;n;</span><br><span class="line">P(b&#x3D;2) &#x3D;1(变或者不变)*1&#x2F;3(变)*3&#x2F;4*...(n-1)&#x2F;n&#x3D;1&#x2F;n;</span><br><span class="line">P(b&#x3D;3) &#x3D;1(变或者不变)*1(变或者不变)*1&#x2F;4*4&#x2F;5...*(n-1)&#x2F;n&#x3D;1&#x2F;n;</span><br><span class="line">P(b&#x3D;k) &#x3D;1*1....1&#x2F;k(变)*k&#x2F;(k+1)...(n-1)&#x2F;n&#x3D;1&#x2F;n;</span><br><span class="line">P(b&#x3D;n-2) &#x3D;1&#x2F;n;</span><br><span class="line">P(b&#x3D;n-1) &#x3D;1- (上述所有的和)&#x3D;1-(n-1)&#x2F;(n-2)&#x3D;1&#x2F;n.</span><br></pre></td></tr></table></figure>

<h2 id="算法复杂度"><a href="#算法复杂度" class="headerlink" title="算法复杂度"></a>算法复杂度</h2><p>n为桶的数量的话,进行n-1次跳变判断,算法复杂度是O(n).</p>
<h1 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h1><h2 id="改进的思路"><a href="#改进的思路" class="headerlink" title="改进的思路"></a>改进的思路</h2><p>通过随机数，确定下一个跳变的j，而不是对每一个位置进行跳变判断。<br>因为跳变的概率从1/2开始一直在减少，所以依概率来说每次跳变的间隔大于1,所以计算下一个跳变值的次数少于n-1.</p>
<blockquote>
<p>定义P(b,j&gt;=i)的含义为: 当前跳变值为b时,下一个跳变值为j,j&gt;=i的概率. </p>
</blockquote>
<p>假设我们使用0-base的数组,则下标i位置不变的概率为: <code>(i+1)/(i+2)</code><br>下一个跳变值j&gt;=i时,也就是[b+1,i-2]区间内保持不变,因此有:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">P(b,j&gt;&#x3D;b)&#x3D;1 &#x2F;&#x2F;(显然下一个跳变值&gt;b)</span><br><span class="line">P(b,j&gt;&#x3D;b+1)&#x3D;1 &#x2F;&#x2F;(显然下一个跳变值&gt;&#x3D;b+1)</span><br><span class="line">P(b,j&gt;&#x3D;b+2)&#x3D;1*(b+1&#x2F;b+2)</span><br><span class="line">...</span><br><span class="line">P(b,j&gt;&#x3D;i)&#x3D; 1*(b+1&#x2F;b+2)*(b+2)&#x2F;(b+3)...(i-1)&#x2F;i &#x3D; (b+1)&#x2F;i</span><br></pre></td></tr></table></figure>

<p>假设有一个在[0,1]区间均匀分布的随机变量R,由于均匀分布的特性,R &lt; k的概率为 k.<br>(例如R&lt; 0.3的概率为0.3),P(R&lt;(b+1)/i)= (b+1)/i = P(j&gt;=i);</p>
<p>因此可以生成一个[0,1]范围的随机数r,规定r&lt;(b+1)/i的时候,就有j&gt;=i;<br>因此 i&lt;(b+1)/r. 由于对于任意的i都有j&gt;=i,因此:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">j&#x3D;floor( (b+1)&#x2F;r)，</span><br></pre></td></tr></table></figure>
<p>这样我们用一个随机数r得到了j。</p>
<p>改进后代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ch</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> num_buckets)</span> </span>&#123;</span><br><span class="line">    random.seed(key) ;</span><br><span class="line">    <span class="keyword">int</span> b = -<span class="number">1</span>; <span class="comment">//  上次跳变值</span></span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>; <span class="comment">// 这次跳变值</span></span><br><span class="line">    <span class="keyword">while</span>(j&lt;num_buckets)&#123;<span class="comment">// j不能超出范围</span></span><br><span class="line">        b=j; </span><br><span class="line">        <span class="keyword">double</span> r=random.next(); <span class="comment">//  0&lt;r&lt;1.0</span></span><br><span class="line">        j = floor( (b+<span class="number">1</span>) /r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中r为<code>[0,1]</code>区间的随机数(均匀分布)。<br>算法中使用了一个64位的线性同余随机数生成器。<br>结果分布的均匀性与输入<code>key</code>的分布无关，由伪随机数生成器的均匀性保证。<br>由于用的是伪随机数,生成器由<code>key</code>进行seed,因此能保证一致性.</p>
<h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>根据概率计算.<br>由于r平均为0.5,因此j平均来说是成倍增长的,因此改进后算法的平均时间复杂度为：<code>O(log(n))</code></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://xiaoyue26.github.io/2018/01/13/2018-01/%E8%B0%B7%E6%AD%8C%E7%9A%84%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95/" data-id="ck96cxpns00a2maam6rh0b1uq" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C/" rel="tag">一致性哈希</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-2018-01/java并发编程实战笔记-15-16章" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/01/07/2018-01/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0-15-16%E7%AB%A0/" class="article-date">
  <time datetime="2018-01-07T12:15:33.000Z" itemprop="datePublished">2018-01-07</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/java/">java</a>►<a class="article-category-link" href="/categories/java/%E5%B9%B6%E5%8F%91/">并发</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/01/07/2018-01/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0-15-16%E7%AB%A0/">java并发编程实战-15-16章</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <h1 id="第十五章-原子变量与非阻塞同步机制"><a href="#第十五章-原子变量与非阻塞同步机制" class="headerlink" title="第十五章 原子变量与非阻塞同步机制"></a>第十五章 原子变量与非阻塞同步机制</h1><p>并发包里的工具(如信号量<code>Semaphore</code>和<code>ConcurrentLinkedQueue</code>)<br>比<code>synchronized</code>性能更好,伸缩性更好.<br>原因是使用了<code>原子变量与非阻塞同步机制</code>.</p>
<p>非阻塞的底层: CAS操作. (compare and swap)<br>没有锁,<code>Lock free</code>,因此更接近完美.<br>因此没有活跃性问题.</p>
<h2 id="15-1-锁的劣势"><a href="#15-1-锁的劣势" class="headerlink" title="15.1 锁的劣势"></a>15.1 锁的劣势</h2><p>性能不行.</p>
<h2 id="15-2-硬件对并发的支持"><a href="#15-2-硬件对并发的支持" class="headerlink" title="15.2 硬件对并发的支持"></a>15.2 硬件对并发的支持</h2><p>独占锁: 基于悲观假设,不互斥的话会出事.(悲观锁)<br>乐观方法: 特殊指令: 包括, Test And Set , Fetch and Increment, CAS, 条件存储.</p>
<h2 id="15-2-CAS-比较并交换"><a href="#15-2-CAS-比较并交换" class="headerlink" title="15.2 CAS 比较并交换"></a>15.2 CAS 比较并交换</h2><p><code>CAS</code>包括三个操作数: 内存位置,旧值,新值.<br>//类似对应java中<code>map</code>的<code>replace</code>操作的三个操作数: key,旧值,新值.</p>
<p>CAS操作失败的线程不会挂,会获得失败信息.(同步非阻塞)<br>可以反复重试. (类似于<code>poll</code>的轮询)</p>
<p>CAS的缺点:<br>需要调用者自己处理竞争问题.// 重试,回退,放弃.<br>CAS实现的非阻塞算法通常比用锁写复杂一些.</p>
<h2 id="15-3-原子变量类"><a href="#15-3-原子变量类" class="headerlink" title="15.3 原子变量类"></a>15.3 原子变量类</h2><p>包括<code>AtomicInteger</code>等等.提供各种原子操作,如CAS,自增等.<br>它和一样保证写后读,但还保证内容是原子更新的.(比如两块内存看似一起更新)</p>
<ul>
<li>tip:<blockquote>
<p>原子变量类不适合作为容器的Key.<br>容器的Key一般要是Immutable对象.(如Integer,String)</p>
</blockquote>
</li>
</ul>
<h2 id="15-4-具体案例"><a href="#15-4-具体案例" class="headerlink" title="15.4 具体案例"></a>15.4 具体案例</h2><p>这一节用CAS实现了链表,栈,原子的域更新器.<br>需要看着源码学习.</p>
<h3 id="15-4-4-ABA问题"><a href="#15-4-4-ABA问题" class="headerlink" title="15.4.4 ABA问题"></a>15.4.4 ABA问题</h3><p>CAS(V,A,B)需要判断V位置是否为A,然后替换为B.<br>但如果V位置发生变化: A-&gt;B-&gt;A.<br>这样其实和我们希望的条件已经不同了,本质上是变化了,只不过值没变,版本号变了.<br>实例来说,就是链表节点引用没变,引用的值已经变了.</p>
<p>解决方案:<br>使用<code>AtomicStampedReference</code>(以及<code>AtomicMarkableReference</code>)支持在两个变量上执行原子的条件更新. </p>
<ul>
<li><p><code>AtomicStampedReference</code><br>[对象,引用]二元组,在引用上加上版本号. </p>
</li>
<li><p><code>AtomicMarkableReference</code><br>[对象引用,布尔值]二元组,可标记节点为已删除的节点.</p>
</li>
</ul>
<h1 id="第十六章-java内存模型"><a href="#第十六章-java内存模型" class="headerlink" title="第十六章 java内存模型"></a>第十六章 java内存模型</h1><h2 id="16-1-概念"><a href="#16-1-概念" class="headerlink" title="16.1 概念"></a>16.1 概念</h2><p>为了性能,会进行指令重排,预测执行等等.<br>内存模型: <code>JMM</code>.<br>内存模型规定,优化(重排)时应该遵守哪些约束.</p>
<ul>
<li>串行一致性:<br>如果约束够用,执行结果就会和串行一样.</li>
</ul>
<h2 id="16-1-1-平台的内存模型"><a href="#16-1-1-平台的内存模型" class="headerlink" title="16.1.1 平台的内存模型"></a>16.1.1 平台的内存模型</h2><p>平台给出内存模型,约束自己,向外界保证xx条件下会发生什么.<br>提供接口/指令: 如内存栅栏,提供协调存储的接口.</p>
<h2 id="16-1-3-JAVA内存模型"><a href="#16-1-3-JAVA内存模型" class="headerlink" title="16.1.3 JAVA内存模型"></a>16.1.3 JAVA内存模型</h2><ol>
<li>程序顺序: 同一个线程里按源码顺序执行;</li>
<li>监视器锁: 解锁会在加锁之前;(A线程释放了,B线程才能获得锁)</li>
<li>volatile: 写后读. (原子变量也是)</li>
<li>线程启动: Thread.start之后才会有run等其他操作发生.</li>
<li>中断规则: (1)A线程中断B线程;(2)B检测到中断. 保证(1)在(2)前面. </li>
<li>终结器:   构造函数在终结器之前执行完成.</li>
<li>传递性:   上述规则可以传递.</li>
</ol>
<p>1是针对单一线程的,2-7都是针对多个线程之间的代码顺序.<br>口诀: 程锁原线中终传. </p>
<h2 id="16-1-4-借助同步"><a href="#16-1-4-借助同步" class="headerlink" title="16.1.4 借助同步"></a>16.1.4 借助同步</h2><p>也就是借助上述7个已有的约束设计代码,达到同步效果.<br>比如我们平时用的锁,就是利用用了第二条,监视器锁规则.</p>
<p>类库中提供的约束:</p>
<ol>
<li>线程安全容器: 写后读. </li>
<li><code>CountDownLatch</code>: 倒数操作在await返回之前.</li>
<li><code>Semaphore</code>: PV操作,V释放在P获得之前. (别人释放了,你才能获得)</li>
<li><code>Future</code>: get返回之前,任务的代码会执行完.</li>
<li><code>Executor</code>: 提交任务操作,将在执行任务操作之前.</li>
<li><code>CyclicBarrier</code>: (1)线程A到达栅栏;(2)其他线程离开栅栏. (1)会在(2)前面.换句话说,大家伙会等线程A到了才离开.<br>… </li>
</ol>
<h2 id="16-2-发布"><a href="#16-2-发布" class="headerlink" title="16.2 发布"></a>16.2 发布</h2><p>错误示例:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@NotThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Resource resource;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Resource <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(resource==<span class="keyword">null</span>)&#123;<span class="comment">// 显然多个线程会在这里冲突.</span></span><br><span class="line">            resource=<span class="keyword">new</span> Resource();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> resource;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>安全但是慢:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Resource resource;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> Resource <span class="title">getInstance</span><span class="params">()</span></span>&#123;<span class="comment">// 方法级同步</span></span><br><span class="line">        <span class="keyword">if</span>(resource==<span class="keyword">null</span>)&#123;</span><br><span class="line">            resource=<span class="keyword">new</span> Resource();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> resource;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>直接静态初始化:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">C</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Resource resource=<span class="keyword">new</span> Resource();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Resource <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> resource;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>占位符技术: 延迟静态初始化:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">D</span></span>&#123; </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ResourceHolder</span></span>&#123; <span class="comment">// 懒汉,完美. </span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> Resource resource=<span class="keyword">new</span> Resource();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Resource <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ResourceHolder.resource;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>双检(DCL): 不推荐. 慢,繁琐. </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">E</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Resource resource; <span class="comment">// volatile</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Resource <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(resource==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(E<span class="class">.<span class="keyword">class</span>)</span>&#123; <span class="comment">// Class对象锁.</span></span><br><span class="line">                <span class="keyword">if</span>(resource==<span class="keyword">null</span>)&#123;</span><br><span class="line">                    resource=<span class="keyword">new</span> Resource();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> resource;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 之所以需要volatile,是为了保证resource变量的写操作立即刷新到内存,起码在读之前. (StoreLoad屏障)</span></span><br></pre></td></tr></table></figure>



<h2 id="初始化安全域"><a href="#初始化安全域" class="headerlink" title="初始化安全域:"></a>初始化安全域:</h2><p>对象的初始引用不会被重排序到构造函数之前.</p>
<ul>
<li><code>final</code>:<br><code>final</code>域能够安全发布,通过<code>final</code>域可达的变量\容器的写入操作安全发布.</li>
</ul>
<p>示例:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SafeStates</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String,String&gt;States;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SafeStates</span><span class="params">()</span></span>&#123;</span><br><span class="line">        states= <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        states.put(<span class="string">"alaska"</span>,<span class="string">"AK"</span>);</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getV</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> states.get(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>线程A创建的SafeStates对象,线程B能安全得访问getV方法.</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://xiaoyue26.github.io/2018/01/07/2018-01/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0-15-16%E7%AB%A0/" data-id="ck96cxpnp009omaam6pwnfbf3" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/" rel="tag">java</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-2018-01/java并发编程实战笔记-10-11章" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/01/04/2018-01/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0-10-11%E7%AB%A0/" class="article-date">
  <time datetime="2018-01-04T14:28:55.000Z" itemprop="datePublished">2018-01-04</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/java/">java</a>►<a class="article-category-link" href="/categories/java/%E5%B9%B6%E5%8F%91/">并发</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/01/04/2018-01/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0-10-11%E7%AB%A0/">java并发编程实战笔记-10-11章</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <p>第十章主要介绍活跃性危险,也就是安全性和活跃性的权衡.锁不多不少.<br>安全性: 就是正确性.锁要够多,不然数据并发访问就错了.<br>活跃性: 就是性能.  锁不能太多,死锁了,或者太卡了.  </p>
<h1 id="10-1-死锁"><a href="#10-1-死锁" class="headerlink" title="10.1 死锁"></a>10.1 死锁</h1><p>哲学家问题: 循环等待死锁.<br>数据库服务器如何解决事务死锁:</p>
<blockquote>
<ol>
<li>检测到等待关系有向图有环;</li>
<li>选一个牺牲者kill了. </li>
<li>应用程序自己重试被kill的事务.</li>
</ol>
</blockquote>
<h2 id="10-1-1-锁顺序死锁"><a href="#10-1-1-锁顺序死锁" class="headerlink" title="10.1.1 锁顺序死锁"></a>10.1.1 锁顺序死锁</h2><p>避免死锁的手段1:</p>
<blockquote>
<p>控制获取锁的顺序.</p>
</blockquote>
<p>如果所有线程获取锁(资源)的顺序一样,就不会死锁. </p>
<h2 id="10-1-2-动态的锁顺序死锁"><a href="#10-1-2-动态的锁顺序死锁" class="headerlink" title="10.1.2 动态的锁顺序死锁"></a>10.1.2 动态的锁顺序死锁</h2><p>锁顺序很难处理. 比如两个账户转账.<br>一种方法是使用俩账户的hash码,比较顺序.<br>当遇到hash码冲突的时候,使用加时赛:</p>
<blockquote>
<ol>
<li>定义一个新的锁;</li>
<li>冲突的线程轮流申请这个锁,然后再申请账户锁.</li>
</ol>
</blockquote>
<p>相当于冲突的线程串行执行.</p>
<p>(其实我觉得对于这个问题,账户肯定有唯一id,用id排序就好了.)</p>
<h2 id="10-1-3-协作对象之间的死锁"><a href="#10-1-3-协作对象之间的死锁" class="headerlink" title="10.1.3 协作对象之间的死锁"></a>10.1.3 协作对象之间的死锁</h2><p>如果获取多个锁的操作不在唯一的同一个方法里, 问题变得麻烦.<br>成因:<br>方法1: 持有锁时调用外部方法,而外部方法请求了另一个锁.<br>方法2: 同上.</p>
<p>方法1,方法2获取锁的顺序相反时,可能死锁.</p>
<p>解决方法:<br>收缩<code>synchronized</code>的范围从方法级缩小到块级.</p>
<h2 id="10-1-4-开放调用"><a href="#10-1-4-开放调用" class="headerlink" title="10.1.4 开放调用"></a>10.1.4 开放调用</h2><p>开放调用: 调用方法时不需要持有锁.<br>也就是方法上没有加<code>synchronized</code>,而是在里头某一个块里用了.</p>
<h2 id="10-1-5-资源死锁"><a href="#10-1-5-资源死锁" class="headerlink" title="10.1.5 资源死锁"></a>10.1.5 资源死锁</h2><p>资源不够死锁. 如线程资源\数据库连接资源.</p>
<ul>
<li>解决方案:<br>书里没写, 我觉得可以考虑前文说的”选取牺牲者”方法.</li>
</ul>
<h1 id="10-2-死锁的避免与诊断"><a href="#10-2-死锁的避免与诊断" class="headerlink" title="10.2 死锁的避免与诊断"></a>10.2 死锁的避免与诊断</h1><ol>
<li>每个线程只获取一个锁. //比较不现实,涉及原子性的实现.</li>
<li>顺序获取.</li>
<li>支持定时的锁. // 代替内置锁</li>
</ol>
<h2 id="10-2-2-死锁的诊断"><a href="#10-2-2-死锁的诊断" class="headerlink" title="10.2.2 死锁的诊断"></a>10.2.2 死锁的诊断</h2><p>通过Thread Dump信息.<br>方法: 向JVM发送SIGQUIT信号.<br>命令行:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kill -3 [id]</span><br></pre></td></tr></table></figure>
<p>jdk1.5: 有内置锁信息, 无显式锁信息;<br>jdk1.6: 有内置锁信息, 少量显式锁信息.<br>(?那岂不是意味着尽量不要使用显式锁?)</p>
<h1 id="10-3-其他活跃性危险"><a href="#10-3-其他活跃性危险" class="headerlink" title="10.3 其他活跃性危险"></a>10.3 其他活跃性危险</h1><p>活跃性危险: 太卡<br>包括: 死锁,饥饿,丢失信号,活锁.</p>
<h2 id="10-3-1-饥饿"><a href="#10-3-1-饥饿" class="headerlink" title="10.3.1 饥饿"></a>10.3.1 饥饿</h2><p>如短作业优先调度的时候,长作业就会饥饿.</p>
<h2 id="10-3-2-糟糕的响应性"><a href="#10-3-2-糟糕的响应性" class="headerlink" title="10.3.2 糟糕的响应性"></a>10.3.2 糟糕的响应性</h2><p>GUI线程优先级太低, 响应性就会差.</p>
<h2 id="10-3-3-活锁"><a href="#10-3-3-活锁" class="headerlink" title="10.3.3 活锁"></a>10.3.3 活锁</h2><p>重复的失败.<br>如线程不停得获取锁,释放锁,似乎能完成,但其实总也完成不了,无间地狱,死循环.</p>
<ul>
<li>案例1: 华龙道<br>发数据包碰撞. 重试算法一样,总是在相同的路口再碰撞.<br>解决方法:<br>增加随机性. 重试时间加一个随机参数.</li>
</ul>
<ul>
<li>案例2:<br>过度的错误恢复.<br>解决方法:<br>不过度.</li>
</ul>
<h1 id="第十一章-性能与可伸缩性"><a href="#第十一章-性能与可伸缩性" class="headerlink" title="第十一章 性能与可伸缩性"></a>第十一章 性能与可伸缩性</h1><p>线程的使用<br>目的: 提高性能.<br>缺陷: 提高复杂性.<br>场景: 多cpu系统,任务不是cpu密集的.<br>衡量手段: 看cpu使用情况图.</p>
<h2 id="11-1-1-可伸缩性"><a href="#11-1-1-可伸缩性" class="headerlink" title="11.1.1 可伸缩性"></a>11.1.1 可伸缩性</h2><p>可伸缩性: 当增加资源时(cpu,内存等等),程序吞吐量/处理能力增加比例适中.</p>
<p>可伸缩性与性能往往矛盾.<br>单线程的性能优化方法 往往导致=&gt; 可伸缩性下降. </p>
<h2 id="11-2-Amdahl定律"><a href="#11-2-Amdahl定律" class="headerlink" title="11.2 Amdahl定律"></a>11.2 Amdahl定律</h2><p>增加计算资源时,程序理论上能实现的最高加速比.</p>
<p>Speedup &lt;= 1/ ( F + (1-F)/N )<br>N: N个处理器<br>F: 必须串行的任务比例. </p>
<p>N趋近于无穷大时,加速比为 1/F.<br>(F为50%时,加速比最大为2.)</p>
<p>提高可伸缩性方法总结:</p>
<ol>
<li>缩小锁的粒度;</li>
<li>减少锁的持有时间(好像和上一条差不多);</li>
<li>尽量使用非独占锁. </li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://xiaoyue26.github.io/2018/01/04/2018-01/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0-10-11%E7%AB%A0/" data-id="ck96cxpnr009wmaam63sqf43c" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/" rel="tag">java</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-2018-01/java并发编程实战笔记-8章" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/01/01/2018-01/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0-8%E7%AB%A0/" class="article-date">
  <time datetime="2018-01-01T07:34:18.000Z" itemprop="datePublished">2018-01-01</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/java/">java</a>►<a class="article-category-link" href="/categories/java/%E5%B9%B6%E5%8F%91/">并发</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/01/01/2018-01/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0-8%E7%AB%A0/">java并发编程实战笔记-8章</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <h1 id="线程池的使用"><a href="#线程池的使用" class="headerlink" title="线程池的使用"></a>线程池的使用</h1><p>这章介绍实际应用中配置调优的一些高级选项. 以及各种坑.</p>
<h1 id="8-1-任务与执行策略的隐形耦合"><a href="#8-1-任务与执行策略的隐形耦合" class="headerlink" title="8.1  任务与执行策略的隐形耦合"></a>8.1  任务与执行策略的隐形耦合</h1><p>有些任务需要指定执行策略:</p>
<ol>
<li>依赖性任务: 就是任务之间不独立</li>
<li>线程不封闭的: 就是只能单线程跑的.</li>
<li>对响应时间敏感的: 如GUI. </li>
<li>使用ThreadLocal的: 线程池会重用线程. 因此可能有风险.</li>
</ol>
<h2 id="8-1-1-死锁"><a href="#8-1-1-死锁" class="headerlink" title="8.1.1 死锁"></a>8.1.1 死锁</h2><p>有界线程池不能无限提交. 如果里头的任务都死锁了,线程池也死锁了.</p>
<h2 id="8-1-2-响应时间"><a href="#8-1-2-响应时间" class="headerlink" title="8.1.2 响应时间"></a>8.1.2 响应时间</h2><p>如果任务都很慢,线程池的响应时间自然也慢.<br>可以限时或者增大线程池容量.</p>
<h1 id="8-2-线程池大小公式"><a href="#8-2-线程池大小公式" class="headerlink" title="8.2 线程池大小公式"></a>8.2 线程池大小公式</h1><p>N = cpu数量 = Runtime.getRuntime().availableProcessors();<br>U = 目标cpu利用率<br>W/C= 等待时间和执行时间的比率 (响应度)<br>SIZE = N*U/(1+W/C) </p>
<h1 id="8-3-配置ThreadPoolExecutor"><a href="#8-3-配置ThreadPoolExecutor" class="headerlink" title="8.3 配置ThreadPoolExecutor"></a>8.3 配置ThreadPoolExecutor</h1><p>可以通过Executors获取jdk设计好的一些线程池实现.</p>
<h2 id="8-3-1-线程的创建与取消"><a href="#8-3-1-线程的创建与取消" class="headerlink" title="8.3.1 线程的创建与取消"></a>8.3.1 线程的创建与取消</h2><p>基本大小: 没有任务时候的线程大小.<br>最大大小: 上限.<br>存活时间: 线程空闲时间达到存活时间,则被回收.</p>
<h2 id="8-3-2-管理队列任务"><a href="#8-3-2-管理队列任务" class="headerlink" title="8.3.2 管理队列任务"></a>8.3.2 管理队列任务</h2><p>线程池满了以后,提交的任务进入等待队列.<br>newFixedThreadPool: 无界等待队列 LinkedBlockingQueue<br>newSingleThreadExecutor: 无界等待队列 LinkedBlockingQueue</p>
<p>有界等待队列的话,需要饱和策略. </p>
<h2 id="8-3-3-饱和策略"><a href="#8-3-3-饱和策略" class="headerlink" title="8.3.3 饱和策略"></a>8.3.3 饱和策略</h2><ol>
<li>中止(默认): abort. 抛异常.</li>
<li>调用者运行: 让主线程自己干. 拥塞会外延到TCP层. </li>
<li>丢弃: 抛弃该任务. 不抛异常.</li>
<li>丢弃最老: 丢弃下一个将要执行的.(如果用了优先级队列,就是抛弃优先级最高的,会造成错误.)</li>
</ol>
<h1 id="8-4-扩展ThreadPoolExecutor"><a href="#8-4-扩展ThreadPoolExecutor" class="headerlink" title="8.4 扩展ThreadPoolExecutor"></a>8.4 扩展ThreadPoolExecutor</h1><p>需要实际需求和应用案例才能学会. </p>
<h1 id="8-5-递归算法的并行化"><a href="#8-5-递归算法的并行化" class="headerlink" title="8.5 递归算法的并行化"></a>8.5 递归算法的并行化</h1><p>首先循环可以并行化:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">final</span> Ele e: eles)&#123;</span><br><span class="line">    exec.execute(</span><br><span class="line">    <span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;process(e);&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>递归也一样, 遍历依然是递归的, 但把每一个节点的计算收集到线程池中,异步计算.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dfs(node,exec,results)&#123;</span><br><span class="line"> exec.execute(...);</span><br><span class="line"> dfs(node.children());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>第九章是图形界面,略过.</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://xiaoyue26.github.io/2018/01/01/2018-01/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0-8%E7%AB%A0/" data-id="ck96cxpnu00aemaam6euicert" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/" rel="tag">java</a></li></ul>

    </footer>
  </div>
  
</article>
 


  


  <nav id="page-nav">
    <a class="extend prev" rel="prev" href="/page/14/">&amp;laquo; 上一页</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/13/">13</a><a class="page-number" href="/page/14/">14</a><span class="page-number current">15</span><a class="page-number" href="/page/16/">16</a><a class="page-number" href="/page/17/">17</a><span class="space">&hellip;</span><a class="page-number" href="/page/23/">23</a><a class="extend next" rel="next" href="/page/16/">下一页&amp;raquo;</a>
  </nav>
</section>
           
    <aside id="sidebar">
  
    

  
    
  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title recent-posts">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/09/25/2022-09/%E8%B0%83%E4%BC%98-%E8%A7%A3%E5%86%B3%E7%BA%BF%E7%A8%8B%E6%B1%A0%E9%80%A0%E6%88%90%E7%9A%84%E8%BF%9B%E7%A8%8B%E5%8D%A1%E9%A1%BF%E3%80%81cpu%E6%AF%9B%E5%88%BA%E9%97%AE%E9%A2%98/">调优-解决线程池造成的进程卡顿、cpu毛刺问题</a>
          </li>
        
          <li>
            <a href="/2022/08/30/2022-08/%E8%B0%83%E4%BC%98-cpu%E6%AF%9B%E5%88%BA%E9%97%AE%E9%A2%98/">调优-cpu毛刺问题</a>
          </li>
        
          <li>
            <a href="/2022/05/31/2022-05/w-tinylfu%E7%BC%93%E5%AD%98%E7%AE%97%E6%B3%95/">w-tinylfu缓存算法</a>
          </li>
        
          <li>
            <a href="/2022/03/25/2022-03/G1%E8%B0%83%E4%BC%98-%E5%A4%8D%E6%9D%82%E4%B8%9A%E5%8A%A1%E6%B2%BB%E7%90%86%E5%B0%8F%E8%AE%B0/">G1调优-复杂业务治理小记</a>
          </li>
        
          <li>
            <a href="/2022/03/16/2022-03/cms%E7%9A%84gc%E8%A7%A6%E5%8F%91%E6%9D%A1%E4%BB%B6/">cms的gc触发条件</a>
          </li>
        
      </ul>
    </div>
  </div>

  
    

  
</aside>

      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-left">
      &copy; 2014 - 2022 风梦七&nbsp;|&nbsp;
      主题 <a href="https://github.com/giscafer/hexo-theme-cafe/" target="_blank">Cafe</a>
    </div>
     <div id="footer-right">
      联系方式&nbsp;|&nbsp;296671657@qq.com
    </div>
  </div>
</footer>
 
<script src="/jquery/jquery.min.js"></script>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">首页</a>
  
    <a href="/archives" class="mobile-nav-link">归档</a>
  
    <a href="/about" class="mobile-nav-link">关于</a>
  
</nav>
    <img class="back-to-top-btn" src="/images/fly-to-top.png"/>
<script>
// Elevator script included on the page, already.
window.onload = function() {
  var elevator = new Elevator({
    selector:'.back-to-top-btn',
    element: document.querySelector('.back-to-top-btn'),
    duration: 1000 // milliseconds
  });
}
</script>
      

  
    <script>
      var cloudTieConfig = {
        url: document.location.href, 
        sourceId: "",
        productKey: "e2fb4051c49842688ce669e634bc983f",
        target: "cloud-tie-wrapper"
      };
    </script>
    <script src="https://img1.ws.126.net/f2e/tie/yun/sdk/loader.js"></script>
    

  







<!-- author:forvoid begin -->
<!-- author:forvoid begin -->

<!-- author:forvoid end -->

<!-- author:forvoid end -->


  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      })
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      })
    </script>
    <script type="text/javascript" src="https://cdn.rawgit.com/mathjax/MathJax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


 
<script src="/js/is.js"></script>



  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>


<script src="/js/elevator.js"></script>

  </div>
</body>
</html>