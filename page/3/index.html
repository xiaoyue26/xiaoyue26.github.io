<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>笔记本</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="笔记本">
<meta property="og:url" content="http://xiaoyue26.github.io/page/3/index.html">
<meta property="og:site_name" content="笔记本">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="风梦七">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="笔记本" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    
  
  
<link rel="stylesheet" href="/css/style.css">

  

<meta name="generator" content="Hexo 4.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    
    <div id="header-inner" class="inner">
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://xiaoyue26.github.io"></form>
      </div>
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">首页</a>
        
          <a class="main-nav-link" href="/archives">归档</a>
        
          <a class="main-nav-link" href="/about">关于</a>
        
      </nav>
      
    </div>
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">笔记本</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">风梦七</a>
        </h2>
      
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-2019-09/程序计算加速之SIMD相关概念" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/09/01/2019-09/%E7%A8%8B%E5%BA%8F%E8%AE%A1%E7%AE%97%E5%8A%A0%E9%80%9F%E4%B9%8BSIMD%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/" class="article-date">
  <time datetime="2019-09-01T08:27:04.000Z" itemprop="datePublished">2019-09-01</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/java/">java</a>►<a class="article-category-link" href="/categories/java/%E6%80%A7%E8%83%BD/">性能</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/09/01/2019-09/%E7%A8%8B%E5%BA%8F%E8%AE%A1%E7%AE%97%E5%8A%A0%E9%80%9F%E4%B9%8BSIMD%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/">程序计算加速之SIMD相关概念</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <h1 id="What-什么是SIMD"><a href="#What-什么是SIMD" class="headerlink" title="What: 什么是SIMD"></a>What: 什么是SIMD</h1><p>SIMD全称<code>Single Instruction Multiple Data</code>，单指令多数据流，是一种采用一个控制器来控制多个处理器，同时对一组数据（又称“数据向量”）中的每一个分别执行相同的操作从而实现空间上的并行性的技术。</p>
<p>也就是说SIMD需要CPU指令集的支持，才能用一条指令就同时并行计算多个数据。当然了，这里同时计算时运用的是同一种运算，比如都是加法。</p>
<h1 id="WHY-为什么要使用SIMD"><a href="#WHY-为什么要使用SIMD" class="headerlink" title="WHY: 为什么要使用SIMD"></a>WHY: 为什么要使用SIMD</h1><p>能并行计算肯定是要比串行计算快的。<br>SIMD是cpu层面的加速，当然还有gpu层面的加速比如cuda编程。<br>如果需要大量浮点数计算、矩阵计算，比如游戏场景、机器学习场景下都是需要这些加速技术的。</p>
<h1 id="不同版本和历史"><a href="#不同版本和历史" class="headerlink" title="不同版本和历史"></a>不同版本和历史</h1><p>既然说到cpu，肯定绕不开intel和AMD。<br>最早是intel推出的，利用了多余的寄存器来加速多媒体运算，后来逐渐标准化：</p>
<h2 id="缩写"><a href="#缩写" class="headerlink" title="缩写:"></a>缩写:</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MMX(可能是MultiMedia eXtension的缩写)</span><br><span class="line">SSE(Streaming SIMD Extensions)</span><br><span class="line">AVX(Advanced Vcetor Extension) : 对SSE的后续扩展，主要分为AVX、AVX2、AVX512三种。在目前常见的机器上，大多只支持到AVX系列。</span><br></pre></td></tr></table></figure>
<h2 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">MMX: intel, Pentium;</span><br><span class="line">SSE: intel, Pentium 3;</span><br><span class="line">SSE2: intel, Pentium 4;</span><br><span class="line">SSE3: intel, Pentium 4;</span><br><span class="line">SSE4: intel, Core 2 Duo; 128位。</span><br><span class="line">SSE5: AMD;</span><br><span class="line">AVX:  intel, 因为SSE5被AMD抢先出了,intel恼羞成怒改名叫AVX了; 支持256位。</span><br><span class="line">AVX2: intel, 加入了整形支持。支持256位。</span><br><span class="line">AVX512: intel, 支持521位。</span><br></pre></td></tr></table></figure>

<h1 id="HOW：-如何使用SIMD"><a href="#HOW：-如何使用SIMD" class="headerlink" title="HOW： 如何使用SIMD"></a>HOW： 如何使用SIMD</h1><h2 id="JAVA中使用"><a href="#JAVA中使用" class="headerlink" title="JAVA中使用"></a>JAVA中使用</h2><p>jdk8的话，可以<code>jinfo -flag &lt;pid&gt;</code>一下，这三个其实是默认配置(java8):</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-XX:UseAVX&#x3D;2</span><br><span class="line">-XX:UseSSE&#x3D;5</span><br><span class="line">-XX:+UseSSE42Intrinsics</span><br></pre></td></tr></table></figure>

<p>可以受益的操作：<br>加减乘除、乘累加。<br>所以jvm是默认会对一些代码进行SIMD优化，具体方法是自己构造数组，比如本来只是要统计一个数组的总和，用一个局部变量即可，可以改成用一个长度为8的局部数组（或者16、具体长度需要benchmark才知道最优，要符合cpu的SIMD支持长度），然后在8个位置上分别求和，最后把局部数组求和得到答案，这种代码会比直接求和快1倍。</p>
<p>上述trick自然是非常间接地使用了，直接使用SIMD的库还在开发中：<br><a href="https://openjdk.java.net/jeps/338" target="_blank" rel="noopener">https://openjdk.java.net/jeps/338</a><br>估计要等到java10以后才能用上了。<br>也有一些国外的scala库(LMS)： <a href="https://astojanov.github.io/blog/2017/12/20/scala-simd.html?tdsourcetag=s_pcqq_aiomsg" target="_blank" rel="noopener">https://astojanov.github.io/blog/2017/12/20/scala-simd.html?tdsourcetag=s_pcqq_aiomsg</a><br>但不知道靠谱不靠谱。</p>
<p>直接使用的库在C语言中是有的，叫做<code>SIMD Intrinsics</code>：<br><a href="https://software.intel.com/sites/landingpage/IntrinsicsGuide/#techs=MMX,SSE,SSE2,SSE3,SSSE3,SSE4_1,SSE4_2,AVX,AVX2,FMA,AVX_512" target="_blank" rel="noopener">https://software.intel.com/sites/landingpage/IntrinsicsGuide/#techs=MMX,SSE,SSE2,SSE3,SSSE3,SSE4_1,SSE4_2,AVX,AVX2,FMA,AVX_512</a><br>比如<code>_mm_set_ps1</code>函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">???-ss后缀的操作: 4个操作数中有一个参加运算；</span><br><span class="line">???-ps后缀的操作：4个操作数都参加运算。</span><br></pre></td></tr></table></figure>
<p>因此我们可以用JNI调用来使用SIMD。<br>为了一定程度上减少JNI开销的话，可以使用<code>CriticalNative</code>。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://www.cnblogs.com/lgxZJ/p/8688430.html" target="_blank" rel="noopener">https://www.cnblogs.com/lgxZJ/p/8688430.html</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://xiaoyue26.github.io/2019/09/01/2019-09/%E7%A8%8B%E5%BA%8F%E8%AE%A1%E7%AE%97%E5%8A%A0%E9%80%9F%E4%B9%8BSIMD%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/" data-id="ck96cxpq900k1maam7l1r7igy" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/SIMD/" rel="tag">SIMD</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/" rel="tag">java</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-2019-08/clickhouse实战之jdbc接入" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/08/25/2019-08/clickhouse%E5%AE%9E%E6%88%98%E4%B9%8Bjdbc%E6%8E%A5%E5%85%A5/" class="article-date">
  <time datetime="2019-08-25T10:29:55.000Z" itemprop="datePublished">2019-08-25</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/clickhouse/">clickhouse</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/08/25/2019-08/clickhouse%E5%AE%9E%E6%88%98%E4%B9%8Bjdbc%E6%8E%A5%E5%85%A5/">clickhouse实战之jdbc接入</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><p>安装好clickhouse后有几个关键的配置需要调整。<br><code>clickhouse</code>的配置文件主要有两个:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/clickhouse-server/config.xml # 服务器配置 </span><br><span class="line">vi /etc/clickhouse-server/users.xml #  客户端连接的默认配置</span><br></pre></td></tr></table></figure>
<p><code>config.xml</code>里需要调整的主要是数据文件的目录、http端口、监听地址:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">http_port</span>&gt;</span>8080<span class="tag">&lt;/<span class="name">http_port</span>&gt;</span> <span class="comment">&lt;!-- 默认是8123--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">listen_host</span>&gt;</span>0.0.0.0<span class="tag">&lt;/<span class="name">listen_host</span>&gt;</span> <span class="comment">&lt;!-- 默认只监听本地127.0.0.1--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">path</span>&gt;</span>/var/lib/clickhouse/<span class="tag">&lt;/<span class="name">path</span>&gt;</span> <span class="comment">&lt;!-- 需要chown -R clickhouse:clickhouse这个目录 如果后续要修改，也可以停服后通过软链接移动到别的目录--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">uncompressed_cache_size</span>&gt;</span>8589934592<span class="tag">&lt;/<span class="name">uncompressed_cache_size</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mark_cache_size</span>&gt;</span>5368709120<span class="tag">&lt;/<span class="name">mark_cache_size</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>此外也能通过配置文件发现默认的tcp端口是9000,interserver_http_port是9009。</p>
<p><code>users.xml</code>里需要调整的主要是:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">max_memory_usage</span>&gt;</span>20000000000<span class="tag">&lt;/<span class="name">max_memory_usage</span>&gt;</span><span class="comment">&lt;!-- 单个查询的最大内存使用bytes--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">password</span>&gt;</span><span class="tag">&lt;/<span class="name">password</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="启动命令"><a href="#启动命令" class="headerlink" title="启动命令"></a>启动命令</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 服务端:</span></span><br><span class="line">sudo service clickhouse-server start </span><br><span class="line"><span class="meta">#</span><span class="bash"> 客户端(多行模式):</span></span><br><span class="line">clickhouse-client -m </span><br><span class="line"><span class="meta">#</span><span class="bash"> 客户端执行sql文件:</span></span><br><span class="line">clickhouse-client -mn &lt; 1.sql</span><br></pre></td></tr></table></figure>

<h1 id="jdbc"><a href="#jdbc" class="headerlink" title="jdbc"></a>jdbc</h1><p>首先是引入依赖:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/ru.yandex.clickhouse/clickhouse-jdbc --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>ru.yandex.clickhouse<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>clickhouse-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.1.54<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>*<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这里我项目里其他地方用fasterxml，有版本冲突，因此这里exclude掉了。</p>
<p>然后配置yml:</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring.clickhouse.hikari:</span></span><br><span class="line">  <span class="attr">idle-timeout:</span> <span class="number">1000</span></span><br><span class="line">  <span class="attr">jdbc-url:</span> <span class="string">jdbc:clickhouse://&lt;your_host_or_ip_address&gt;:8080/default</span></span><br><span class="line">  <span class="attr">driverClassName:</span> <span class="string">ru.yandex.clickhouse.ClickHouseDriver</span></span><br><span class="line">  <span class="attr">maximumPoolSize:</span> <span class="number">10</span></span><br><span class="line">  <span class="attr">rewriteBatchedStatements:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>最后像普通jdbc一样使用即可:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 配置：</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"spring.clickhouse.hikari"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClickhouseDSConfig</span> <span class="keyword">extends</span> <span class="title">HikariConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span>(name=<span class="string">"chds"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">dataSource</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HikariDataSource(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 存储层:</span></span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChDao</span> <span class="keyword">extends</span> <span class="title">JdbcDaoSupport</span> <span class="keyword">implements</span> <span class="title">IChDao</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ChDao</span><span class="params">(@Qualifier(<span class="string">"chds"</span>)</span> DataSource ds) </span>&#123;</span><br><span class="line">        setDataSource(ds);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title">query</span><span class="params">(String sql, Object... args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.getJdbcTemplate().queryForMap(sql, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Map&lt;String, Object&gt;&gt; queryForList(String sql, Object... args) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.getJdbcTemplate().queryForList(sql, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 使用: </span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">IChDao dao;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"begin~~~"</span>);</span><br><span class="line">    String sqlDB = <span class="string">"show databases"</span>;<span class="comment">//查询数据库</span></span><br><span class="line">    System.out.println(dao.queryForList(sqlDB));</span><br><span class="line">    System.out.println(dao.queryForList(<span class="string">"show tables;"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://xiaoyue26.github.io/2019/08/25/2019-08/clickhouse%E5%AE%9E%E6%88%98%E4%B9%8Bjdbc%E6%8E%A5%E5%85%A5/" data-id="ck96cxpq100jamaam88yifok3" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/clickhouse/" rel="tag">clickhouse</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/" rel="tag">java</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-2019-08/神秘的monad——函数式编程" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/08/23/2019-08/%E7%A5%9E%E7%A7%98%E7%9A%84monad%E2%80%94%E2%80%94%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/" class="article-date">
  <time datetime="2019-08-23T01:20:21.000Z" itemprop="datePublished">2019-08-23</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/java/">java</a>►<a class="article-category-link" href="/categories/java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/08/23/2019-08/%E7%A5%9E%E7%A7%98%E7%9A%84monad%E2%80%94%E2%80%94%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/">神秘的monad——函数式编程</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <p>monad确实比较难理解，我认真翻了一个星期资料才理解。</p>
<p>讲得比较好的参考资料：<br><a href="http://josephguan.github.io/2016/06/25/monad-in-scala/" target="_blank" rel="noopener">http://josephguan.github.io/2016/06/25/monad-in-scala/</a><br>比较形象的、有图的：<br><a href="http://blog.forec.cn/2017/03/02/translation-adit-faamip/" target="_blank" rel="noopener">http://blog.forec.cn/2017/03/02/translation-adit-faamip/</a><br>数学上讲得比较多的：(scala版代码可用)<br><a href="https://segmentfault.com/a/1190000008000905" target="_blank" rel="noopener">https://segmentfault.com/a/1190000008000905</a></p>
<p>参考资料3中的scala版代码:</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 半群:</span></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">SemiGroup</span>[<span class="type">A</span>] </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">op</span></span>(a1: <span class="type">A</span>, a2: <span class="type">A</span>): <span class="type">A</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. monoid: (还不是monad) 比半群多一个零元</span></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Monoid</span>[<span class="type">A</span>] <span class="keyword">extends</span> <span class="title">SemiGroup</span>[<span class="type">A</span>] </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">zero</span></span>: <span class="type">A</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函子: (有map函数就是Functor)</span></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Functor</span>[<span class="type">F</span>[_]] </span>&#123;</span><br><span class="line">  <span class="comment">// 输入一个A的容器F[A],输入一个A类型=&gt;B类型的变化</span></span><br><span class="line">  <span class="comment">// 输出B类型的容器F[B]</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">map</span></span>[<span class="type">A</span>, <span class="type">B</span>](a: <span class="type">F</span>[<span class="type">A</span>])(f: <span class="type">A</span> =&gt; <span class="type">B</span>): <span class="type">F</span>[<span class="type">B</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">MonadTest</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> stringMonoid = <span class="keyword">new</span> <span class="type">Monoid</span>[<span class="type">String</span>] &#123;</span><br><span class="line">      <span class="function"><span class="keyword">def</span> <span class="title">op</span></span>(a1: <span class="type">String</span>, a2: <span class="type">String</span>) = a1 + a2</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">def</span> <span class="title">zero</span> </span>= <span class="string">""</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">listMonoid</span></span>[<span class="type">A</span>] = <span class="keyword">new</span> <span class="type">Monoid</span>[<span class="type">List</span>[<span class="type">A</span>]] &#123;</span><br><span class="line">      <span class="function"><span class="keyword">def</span> <span class="title">op</span></span>(a1: <span class="type">List</span>[<span class="type">A</span>], a2: <span class="type">List</span>[<span class="type">A</span>]) = a1 ++ a2</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">def</span> <span class="title">zero</span> </span>= <span class="type">Nil</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">optionMonoid</span></span>[<span class="type">A</span>] = <span class="keyword">new</span> <span class="type">Monoid</span>[<span class="type">Option</span>[<span class="type">A</span>]] &#123;</span><br><span class="line">      <span class="function"><span class="keyword">def</span> <span class="title">op</span></span>(a1: <span class="type">Option</span>[<span class="type">A</span>], a2: <span class="type">Option</span>[<span class="type">A</span>]) = a1 orElse a2</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">def</span> <span class="title">zero</span> </span>= <span class="type">None</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">listFunctor</span> </span>= <span class="keyword">new</span> <span class="type">Functor</span>[<span class="type">List</span>] &#123;</span><br><span class="line">      <span class="function"><span class="keyword">def</span> <span class="title">map</span></span>[<span class="type">A</span>, <span class="type">B</span>](a: <span class="type">List</span>[<span class="type">A</span>])(f: (<span class="type">A</span>) =&gt; <span class="type">B</span>) = a.map(f)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*trait Monad[M[_]] &#123;</span></span><br><span class="line"><span class="comment">  def unit[A](a: A): M[A]   //identity</span></span><br><span class="line"><span class="comment">  def join[A](mma: M[M[A]]): M[A]</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"><span class="comment">// Monad: (有unit和flatmap就是monad)</span></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Monad</span>[<span class="type">M</span>[_]] </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">unit</span></span>[<span class="type">A</span>](a: <span class="type">A</span>): <span class="type">M</span>[<span class="type">A</span>]</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">flatMap</span></span>[<span class="type">A</span>, <span class="type">B</span>](fa: <span class="type">M</span>[<span class="type">A</span>])(f: <span class="type">A</span> =&gt; <span class="type">M</span>[<span class="type">B</span>]): <span class="type">M</span>[<span class="type">B</span>]</span><br><span class="line"></span><br><span class="line">  <span class="comment">// def join[A](mma: M[M[A]]): M[A] = flatMap(mma)(ma =&gt; ma)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>附抄scala版的monad(参考资料1):</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Monad</span>[+<span class="type">T</span>] </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">flatMap</span></span>[<span class="type">U</span>]( f : (<span class="type">T</span>) =&gt; <span class="type">Monad</span>[<span class="type">U</span>] ) : <span class="type">Monad</span>[<span class="type">U</span>]</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">unit</span></span>(value : <span class="type">B</span>) : <span class="type">Monad</span>[<span class="type">B</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// map可以理解为flatmap的特化:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">map</span></span>[<span class="type">U</span>](f : (<span class="type">T</span>) =&gt; <span class="type">U</span>) : <span class="type">Monad</span>[<span class="type">U</span>] = flatMap(v =&gt; unit(f(v)))</span><br><span class="line"></span><br><span class="line"><span class="comment">// Try类型monad:</span></span><br><span class="line"><span class="keyword">val</span> result:<span class="type">Try</span>[<span class="type">Int</span>] = <span class="type">Try</span>(<span class="string">"5"</span>.toInt).flatMap&#123;a =&gt;</span><br><span class="line">                      <span class="type">Try</span>(<span class="string">"6a"</span>.toInt).flatMap&#123;b =&gt;</span><br><span class="line">                      <span class="type">Try</span>(<span class="string">"9"</span>.toInt).flatMap&#123;c =&gt; <span class="type">Try</span>(a + b +c )&#125;&#125;&#125;</span><br><span class="line"><span class="comment">// for是flatmap的语法糖:</span></span><br><span class="line"><span class="keyword">val</span> result: <span class="type">Try</span>[<span class="type">Int</span>] = <span class="keyword">for</span> (</span><br><span class="line">    a &lt;- <span class="type">Try</span>(<span class="string">"5"</span>.toInt);</span><br><span class="line">    b &lt;- <span class="type">Try</span>(<span class="string">"6a"</span>.toInt);</span><br><span class="line">    c &lt;- <span class="type">Try</span>(<span class="string">"9"</span>.toInt)</span><br><span class="line">  ) <span class="keyword">yield</span>( a + b + c)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.1含幺半群G: </span></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Monad</span>[+<span class="type">T</span>]</span></span><br><span class="line"><span class="class"><span class="title">//</span> 1.2<span class="title">二元封闭、结合运算</span></span>:</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">flatMap</span></span>[<span class="type">U</span>]( f : (<span class="type">T</span>) =&gt; <span class="type">Monad</span>[<span class="type">U</span>] ) : <span class="type">Monad</span>[<span class="type">U</span>]</span><br><span class="line"><span class="comment">// 1.3幺元:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">unit</span></span>(value : <span class="type">B</span>) : <span class="type">Monad</span>[<span class="type">B</span>] </span><br><span class="line"><span class="comment">// 2.1结合律/封闭:</span></span><br><span class="line">monad.flatMap(f).flatMap(g) == monad.flatMap(v =&gt; f(v).flatMap(g)) <span class="comment">// associativity</span></span><br><span class="line"><span class="comment">// 案例:</span></span><br><span class="line"><span class="keyword">val</span> multiplier : <span class="type">Int</span> =&gt; <span class="type">Option</span>[<span class="type">Int</span>] = v =&gt; <span class="type">Some</span>(v * v)</span><br><span class="line"><span class="keyword">val</span> divider : <span class="type">Int</span> =&gt; <span class="type">Option</span>[<span class="type">Int</span>] = v =&gt; <span class="type">Some</span>(v/<span class="number">2</span>)</span><br><span class="line"><span class="keyword">val</span> original = <span class="type">Some</span>(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">original.flatMap(multiplier).flatMap(divider) ===</span><br><span class="line">original.flatMap(v =&gt; multiplier(v).flatMap(divider))</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 2.2 左幺元</span></span><br><span class="line">unit(x).flatMap(f) == f(x)</span><br><span class="line"><span class="comment">// 案例:</span></span><br><span class="line"><span class="keyword">val</span> multiplier : <span class="type">Int</span> =&gt; <span class="type">Option</span>[<span class="type">Int</span>] = v =&gt; <span class="type">Some</span>(v * v)</span><br><span class="line"><span class="keyword">val</span> item = <span class="type">Some</span>(<span class="number">10</span>).flatMap(multiplier)</span><br><span class="line">item === multiplier(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.3 右幺元</span></span><br><span class="line">monad.flatMap(unit) == monad</span><br><span class="line"><span class="comment">// 案例:</span></span><br><span class="line"><span class="keyword">val</span> value = <span class="type">Some</span>(<span class="number">50</span>).flatMap(v =&gt; <span class="type">Some</span>(v))</span><br><span class="line">value === <span class="type">Some</span>(<span class="number">50</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 范畴</span></span><br><span class="line">高阶类型（如<span class="type">List</span>[<span class="type">T</span>+]）</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 函子(Functor)</span></span><br><span class="line"><span class="comment">// 函数， Int =&gt; String</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span></span>(i:<span class="type">Int</span>): <span class="type">String</span> = i.toString</span><br><span class="line"><span class="comment">// 函子， List[T] =&gt; Set[T]</span></span><br><span class="line">scala&gt; <span class="function"><span class="keyword">def</span> <span class="title">baz</span></span>[<span class="type">T</span>](l:<span class="type">List</span>[<span class="type">T</span>]): <span class="type">Set</span>[<span class="type">T</span>] = l.toSet</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5. 自函子(Endofunctor)：</span></span><br><span class="line">把一个类型映射到自身类型，比如<span class="type">Int</span>=&gt;<span class="type">Int</span>, <span class="type">String</span>=&gt;<span class="type">String</span> </span><br><span class="line">例如flatmap:</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">flatMap</span></span>[<span class="type">U</span>]( f : (<span class="type">T</span>) =&gt; <span class="type">Monad</span>[<span class="type">U</span>] ) : <span class="type">Monad</span>[<span class="type">U</span>]</span><br></pre></td></tr></table></figure>



<blockquote>
<p>下面开始是我个人的理解</p>
</blockquote>
<h2 id="函数式语言"><a href="#函数式语言" class="headerlink" title="函数式语言"></a>函数式语言</h2><blockquote>
<p>函数是一等公民。<br>无函数副作用。</p>
</blockquote>
<p>（学校里教的）<br>函数可以像普通变量一样使用。（比c里的函数指针更进一步）</p>
<h3 id="更函数式一点"><a href="#更函数式一点" class="headerlink" title="更函数式一点"></a>更函数式一点</h3><p>尽量无状态，最好都像lambda演算一样，有很深的递归。<br>用递归代替循环。</p>
<p>Monad就是这个思想的一个具体实现。</p>
<h2 id="代码层面理解"><a href="#代码层面理解" class="headerlink" title="代码层面理解"></a>代码层面理解</h2><p>Monad在scala中就是一个有flatmap的容器，可以把函数fmap的输出收集起来打平回原来的Monad类型。<br>比较好理解的Monad类型是容器类型：List,Option. </p>
<h2 id="形象上理解"><a href="#形象上理解" class="headerlink" title="形象上理解"></a>形象上理解</h2><p>Monad形象上理解类似于有管道操作的容器，可以把函数fmap的输出适配回Monad类型，方便投入下一个函数中。</p>
<h2 id="比较严密的定义上理解："><a href="#比较严密的定义上理解：" class="headerlink" title="比较严密的定义上理解："></a>比较严密的定义上理解：</h2><p>（去掉范畴学的数学术语，简化理解）<br>Monad是一个我们定义的集合，它上面有零元（如Option中的None\List中的nil），它上面还有一种二元操作op，op(A,B)的结果依然属于Monad(封闭性)，并且运算满足结合律(可以随意加括号)。<br>所以如果有unit函数(生成零元)，flatmap函数（把二元操作打平回集合元素类型，满足封闭性），就可以成为一个Monad了。至于结合律，由于函数都满足结合律，因此可以忽略。</p>
<p>总结:<br>有map函数: Functor、函子<br>有ap函数（参数为函数的map）: Applicative、应用<br>有flatmap函数: Monad</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://xiaoyue26.github.io/2019/08/23/2019-08/%E7%A5%9E%E7%A7%98%E7%9A%84monad%E2%80%94%E2%80%94%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/" data-id="ck96cxpq200jdmaamd4kn4fpv" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/monad/" rel="tag">monad</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/scala/" rel="tag">scala</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%87%BD%E6%95%B0%E5%BC%8F/" rel="tag">函数式</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-2019-07/disruptor笔记" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/27/2019-07/disruptor%E7%AC%94%E8%AE%B0/" class="article-date">
  <time datetime="2019-07-27T07:49:48.000Z" itemprop="datePublished">2019-07-27</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/">消息队列</a>►<a class="article-category-link" href="/categories/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/disruptor/">disruptor</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/27/2019-07/disruptor%E7%AC%94%E8%AE%B0/">disruptor笔记——代替blockingQueue和java9flowAPI</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>blockingQueue缺点:</p>
<ol>
<li>竞态严重: producer\consumer;</li>
<li>cache不友好: 线程a结束后，线程b的所有缓存都污染。</li>
</ol>
<h1 id="discruptor方案"><a href="#discruptor方案" class="headerlink" title="discruptor方案"></a>discruptor方案</h1><p>理想适用场景：<br>1个producer,多个consumer.</p>
<p>循环队列：<br>producer: 存储自己的游标(cursor);<br>consumer: 存储自己的消费offset。 </p>
<ol>
<li>循环队列: 降低竞态,分离了多个游标;(当然还是有竞态，用内存屏障)</li>
<li>cursor中加入padding: 避免cursor缓存污染;（填充上7个long）</li>
<li>用CAS和忙等(busy spin)代替锁。(资源换性能)</li>
<li>预先申请了一大片内存：避免gc干扰。</li>
</ol>
<ul>
<li>优化</li>
</ul>
<ol>
<li>batch commit; // 避免竞态次数 比如消费者不是每次只读1个，它直接询问生产进度seqK，保存下来，然后一直消费到seqK之前都不用再询问cursor. （询问需要穿过consumer barrier）</li>
<li>多个producer时: CAS写入; </li>
<li>支持复杂dag优化。</li>
</ol>
<p>附:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// padding:</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileLong</span></span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">long</span> value = <span class="number">0L</span>;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">long</span> p1, p2, p3, p4, p5, p6; <span class="comment">// comment out</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="信息交流"><a href="#信息交流" class="headerlink" title="信息交流"></a>信息交流</h2><h3 id="consumer获取producer信息"><a href="#consumer获取producer信息" class="headerlink" title="consumer获取producer信息"></a>consumer获取producer信息</h3><img src="/images/2019-07/consumer_barrier.png" class="" width="400" height="600" title="consumer_barrier">
<p>通过consumer barrier从获取cursor信息： 最新生产sequence number;<br>这种策略下，消费者不需要知道其他消费者的情况(独立offset)</p>
<h2 id="producer获取信息"><a href="#producer获取信息" class="headerlink" title="producer获取信息"></a>producer获取信息</h2><img src="/images/2019-07/producer_barrier.png" class="" width="400" height="600" title="producer_barrier">
<p>通过producer barrier获取ring buffer和消费者信息。<br>等待最慢的消费者释放空间：获取最慢的消费者的offset。以便获得更多可读的节点空间。（这里也可以批处理，同时获得多个空间，同时写）</p>
<p>两阶段提交：</p>
<ol>
<li>数据写入节点;</li>
<li>commit. </li>
</ol>
<h1 id="复杂dag支持"><a href="#复杂dag支持" class="headerlink" title="复杂dag支持"></a>复杂dag支持</h1><img src="/images/2019-07/disruptor_dag.png" class="" width="400" height="600" title="disruptor_dag">
<p>如上图所示的菱形结构可能在实际业务中会出现。<br>producer进度: 22<br>c1进度: 21<br>c2进度: 18<br>c3进度: 15<br>此时producer想要继续写的时候卡住，因为15的位置还不可用。<br>也就是生产者的速度受制于叶子节点的消费者。</p>
<p>c1,c2的处理结果一般是原地写入entry的不同字段，避免冲突。<br>(entry节点的定义可以有多个值字段)</p>
<p>更多详情直接参见：<br><a href="http://wiki.jikexueyuan.com/project/disruptor-getting-started/write-ringbuffer.html" target="_blank" rel="noopener">http://wiki.jikexueyuan.com/project/disruptor-getting-started/write-ringbuffer.html</a></p>
<p>maven依赖：<br><a href="https://mvnrepository.com/artifact/com.lmax/disruptor/3.4.2" target="_blank" rel="noopener">https://mvnrepository.com/artifact/com.lmax/disruptor/3.4.2</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://xiaoyue26.github.io/2019/07/27/2019-07/disruptor%E7%AC%94%E8%AE%B0/" data-id="ck96cxppv00iqmaamalhkb5aj" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/disruptor/" rel="tag">disruptor</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/" rel="tag">java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/" rel="tag">消息队列</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-2019-07/领域驱动设计-第7-17章笔记" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/22/2019-07/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1-%E7%AC%AC7-17%E7%AB%A0%E7%AC%94%E8%AE%B0/" class="article-date">
  <time datetime="2019-07-22T02:09:04.000Z" itemprop="datePublished">2019-07-22</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/java/">java</a>►<a class="article-category-link" href="/categories/java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/22/2019-07/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1-%E7%AC%AC7-17%E7%AB%A0%E7%AC%94%E8%AE%B0/">领域驱动设计-第7~17章笔记</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <h1 id="第七章-实例：货物运输系统"><a href="#第七章-实例：货物运输系统" class="headerlink" title="第七章 实例：货物运输系统"></a>第七章 实例：货物运输系统</h1><h2 id="1-需求"><a href="#1-需求" class="headerlink" title="1. 需求"></a>1. 需求</h2><ol>
<li>跟踪货物的主要处理部署；</li>
<li>预约货物；</li>
<li>货物到达某一处理步骤时自动发送发票。</li>
</ol>
<h2 id="领域语言"><a href="#领域语言" class="headerlink" title="领域语言"></a>领域语言</h2><p>货物: cargo<br>客户: customer<br>规格: specification<br>运输动作: carrier movement</p>
<ol>
<li>一个cargo(货物)涉及到多个customer(客户)，每个customer承担不同角色。</li>
<li>cargo的运送目标已指定；</li>
<li>由一系列满足specification(规格)的carrier movement(运输动作)来完成运送目标。</li>
</ol>
<img src="/images/2019-07/chapter7_class.png" class="" width="800" height="1200" title="chapter7_class">
<p>上述类图中Customer包括托运人、收货人、快递员等角色。<br>（都是我们软件要服务的客户）<br>Handling Event可以细分为不同种类的事件（装货、卸货、提货…）</p>
<h2 id="隔离领域"><a href="#隔离领域" class="headerlink" title="隔离领域"></a>隔离领域</h2><p>要把领域层划分出来，首先识别出3个用户层的应用程序功能：</p>
<ol>
<li>跟踪查询: 访问某个cargo过去、现在的处理情况;(Delivery History)</li>
<li>预定: 注册一个cargo；</li>
<li>事件日志记录: 为1准备信息。<br>三个应用层类：<br>Tracking Query,Booking Application,Incident Logging Applicatoin。<br>这三个应用层类只是协调者，负责向领域层提问。</li>
</ol>
<h2 id="区分Entity和Value-Object"><a href="#区分Entity和Value-Object" class="headerlink" title="区分Entity和Value Object"></a>区分Entity和Value Object</h2><p>看对象是必须被跟踪的实体还是仅表示一个基本值。</p>
<p><code>Customer</code>: Entity<br><code>Cargo</code>: Entity<br><code>Handling Event</code>和<code>Carrier Movement</code>: Entity<br><code>Delivery History</code>: Entity<br><code>Delivery Specification</code>: Value Object: 可替换，货物满足的规则只要等效即可，并不一定需要是某一个id的规则。<br><code>Role</code>: Value Object.</p>
<h2 id="设计关联"><a href="#设计关联" class="headerlink" title="设计关联"></a>设计关联</h2><p>双向关联往往会产生问题，因此要研究把双向关联转换成单向关联。<br>好处：</p>
<ol>
<li>双向关联=&gt;单向关联：降低出错概率；</li>
<li>研究遍历方向过程中：让领域更加清晰。</li>
</ol>
<p>把低频需求的遍历方向交给数据库实现；<br>留下的单向遍历作为领域层的单向引用。</p>
<h2 id="Aggregate边界"><a href="#Aggregate边界" class="headerlink" title="Aggregate边界"></a>Aggregate边界</h2><p>Customer: 根<br>Location: 根<br>Carrier Movement: 根<br>Cargo: 根,它的边界可以囊括所有因它才存在的弱实体: <code>Delivery History</code>,<code>Delivery Specification</code>。<br>(分发历史、分发规则(VO)、处理事件)</p>
<p><code>Handling Event</code>： </p>
<ol>
<li>查找某个<code>Delivery History</code>中的<code>Handling Event</code>;</li>
<li>查找某次<code>Carrier Movement</code>的操作，需要<code>Handling Event</code>的id，需要<code>Handling Event</code>作为根。</li>
</ol>
<h2 id="创建Repository"><a href="#创建Repository" class="headerlink" title="创建Repository"></a>创建Repository</h2><p>作为根的Entity创建repository.<br>（其他就不创建了，精简类的数量）</p>
<img src="/images/2019-07/agg_root.png" class="" width="800" height="1200" title="agg_root">

<p>如图有7个Entity,5个根。<br>应对的需求:</p>
<ol>
<li>用户选择承担不同角色：发货方、收货人；Customer;</li>
<li>货物目的地需要Location;</li>
<li>用户需要查找装货的Carrier Movement;</li>
<li>用户需要输入系统哪个Cargo完成了装货: Cargo;</li>
<li>Handling Event的需求待定。<br>如下图是加上了repository后：<img src="/images/2019-07/repository.png" class="" width="800" height="1200" title="repository">

</li>
</ol>
<h2 id="用例"><a href="#用例" class="headerlink" title="用例"></a>用例</h2><h3 id="1-更改目的地"><a href="#1-更改目的地" class="headerlink" title="1. 更改目的地"></a>1. 更改目的地</h3><p><code>Delivery Specification</code>是个VO，可以直接创建一个新的，替换旧的即可。</p>
<h2 id="2-重复预订"><a href="#2-重复预订" class="headerlink" title="2. 重复预订"></a>2. 重复预订</h2><p>常常会需要基于旧的cargo作为原型创建新的cargo。<br>（重复下单同一种商品）</p>
<ol>
<li>Delivery History: 应创建新、空的；（其他弱实体同）</li>
<li>Customer Roles: 和原来的cargo引用同样的运输角色Customer。</li>
<li>Tracking ID: 新增。</li>
</ol>
<p>总结三类：</p>
<ol>
<li>弱实体、边界内：创建新的、空的。</li>
<li>边界外：可以引用相同的。</li>
<li>根：新增（自增id）。</li>
</ol>
<h2 id="从需求频次出发简化设计"><a href="#从需求频次出发简化设计" class="headerlink" title="从需求频次出发简化设计"></a>从需求频次出发简化设计</h2><img src="/images/2019-07/handling_event.png" class="" width="800" height="1200" title="handling_event">
<p>Handling Event相关需求的频次：<br>创建、新增：高频<br>查询： 低频</p>
<p>由于查询<code>Delivery History</code>中的<code>Handling Event</code>是低频需求，因此可以考虑不在<code>Delivery History</code>中直接存储<code>Handling Event</code>数组，这样节省了存储开销，也降低了维护一致性的成本。这里创建、新增<code>Handling Event</code>是高频的，因此如果<code>Delivery History</code>中是存储数组，要频繁维护一致性，而且是Agg边界外的改动引起Agg边界内的变动，属于不合理设计。</p>
<p>综上：可将<code>Delivery History</code>中的<code>Handling Event</code>改为即时查询接口，而不是直接存储数组。</p>
<p>优点：使Handling Event的新建变得简单，不会与Cargo Agg发生争用。</p>
<blockquote>
<p>换句话说，类似于我们平时设计表字段的时候，高频查询的字段直接放到同一个表里头（可能有时候会反三范式），低频的抽出来扔另一张表(弱实体)里。原文这里是对象级的讨论。</p>
</blockquote>
<h2 id="Module：模块化"><a href="#Module：模块化" class="headerlink" title="Module：模块化"></a>Module：模块化</h2><img src="/images/2019-07/module.png" class="" width="800" height="1200" title="module">
<p>将紧密关联的实体封装到一个模块。</p>
<h2 id="引入新特性：-配额检查"><a href="#引入新特性：-配额检查" class="headerlink" title="引入新特性： 配额检查"></a>引入新特性： 配额检查</h2><p><code>Allocation Checker</code>: 确保高利润的商品能够运输完，确保大部分商品不会因为运力不足退单毁约。</p>
<ul>
<li>输入：</li>
</ul>
<ol>
<li>某cargo: 已经预订了多少; （或这个分类已经预订了多少）</li>
<li>某cargo: 最大预订配额。（或这个分类最大配额）</li>
</ol>
<ul>
<li>输出:<br>是否能继续预订。</li>
</ul>
<h3 id="实现1"><a href="#实现1" class="headerlink" title="实现1"></a>实现1</h3><p>如小猿的做法: 配额是存储在商品信息里头的。<br>(参见warehouse)</p>
<h3 id="实现2"><a href="#实现2" class="headerlink" title="实现2:"></a>实现2:</h3><p>配额是由另一个系统提供的。<br>同一个商品可以属于不同的类别，影响不同层面的配额。<br>这样配额相关属性抽离出来变成一类弱实体。</p>
<h1 id="第三部分-通过重构来加深理解"><a href="#第三部分-通过重构来加深理解" class="headerlink" title="第三部分 通过重构来加深理解"></a>第三部分 通过重构来加深理解</h1><p>目标：巧妙的领域模型<br>手段：不断重构，加深对领域的理解</p>
<h2 id="重构"><a href="#重构" class="headerlink" title="重构"></a>重构</h2><p>重构的定义是在不改变功能的前提下重新设计它。</p>
<p>重构的层次:</p>
<ol>
<li>微重构；（累积成更深层次重构）；// 参见《重构》一书</li>
<li>源于对领域的新认知；</li>
<li>设计模式重构。</li>
</ol>
<h2 id="深层模型"><a href="#深层模型" class="headerlink" title="深层模型"></a>深层模型</h2><p>浅层模型： 在需求文档中确定名词和动词，初始建模；（不够成熟深入）（只有具体元素）<br>深层模型： 穿过领域表象，清楚表达领域专家主要关注点以及最相关知识。（恰当的抽象元素和具体元素）</p>
<h2 id="深层模型与柔性设计"><a href="#深层模型与柔性设计" class="headerlink" title="深层模型与柔性设计"></a>深层模型与柔性设计</h2><p>（柔性设计详见第10章）<br>好的深层模型能方便地支持柔性设计。</p>
<h2 id="发现过程"><a href="#发现过程" class="headerlink" title="发现过程"></a>发现过程</h2><p>（发现过程、捕捉领域核心概念详见第9章）<br>第11章: 分析模式<br>第12章: 设计模式</p>
<h1 id="第八章-突破"><a href="#第八章-突破" class="headerlink" title="第八章 突破"></a>第八章 突破</h1><img src="/images/2019-07/breakthrough.png" class="" width="800" height="1200" title="breakthrough">
<p>如上图所示，重构在某个节点的投入可能会有很大的回报。<br>（如果突然孵化了对项目的最重要理解，会给项目带来重大冲击）<br>即使是小的改进也可以防止系统退化。</p>
<h2 id="突破案例"><a href="#突破案例" class="headerlink" title="突破案例"></a>突破案例</h2><p>背景：<br>管理银团贷款的程序。<br>基本需求：<br>跟踪支持整个贷款过程。</p>
<h3 id="大致过程"><a href="#大致过程" class="headerlink" title="大致过程"></a>大致过程</h3><p>原先的设计绑定了放贷股份和信贷股份，错误的理解。<br>突然有一天明白了两者基本无关联，重新设计了模型，得到突破，快速迭代。</p>
<p>总结： 好的模型能让无技术背景的业务方也能快速理解。（而不是抱怨专业性太强看不懂）</p>
<h1 id="第九章-深层模型"><a href="#第九章-深层模型" class="headerlink" title="第九章 深层模型"></a>第九章 深层模型</h1><h2 id="倾听语言"><a href="#倾听语言" class="headerlink" title="倾听语言"></a>倾听语言</h2><p>线索：</p>
<ol>
<li>用户长期抱怨、频繁查询的场景，可能是遗漏了重要领域对象。</li>
<li>领域专家试图纠正你的术语；</li>
<li>用户感到困惑的名词。</li>
<li>始终无法形成DSL。(讨论中的术语经常超出DSL范围)</li>
</ol>
<h2 id="会计示例"><a href="#会计示例" class="headerlink" title="会计示例"></a>会计示例</h2><p>主要讲的是学了会计学以后模型更合理，深层。</p>
<h2 id="约束的提炼"><a href="#约束的提炼" class="headerlink" title="约束的提炼"></a>约束的提炼</h2><p>约束包括显式规则、隐式规则。<br>遇到如下情况时，应将隐式规则提炼到显式对象(显式规则)：</p>
<ol>
<li>计算约束所需数据从定义上不属于这个对象；</li>
<li>相关规则在多个对象出现，代码重复；</li>
<li>设计和需求围绕着这些规则，而这些约束却分散在过程代码中。</li>
</ol>
<h3 id="将规则显式提炼的案例：超订策略"><a href="#将规则显式提炼的案例：超订策略" class="headerlink" title="将规则显式提炼的案例：超订策略"></a>将规则显式提炼的案例：超订策略</h3><img src="/images/2019-07/overbook.png" class="" width="800" height="1200" title="overbook">
<p>如上图voyage表示实际座席、cargo表示售出货物。<br>同时引入overbooking policy来显式封装超订的规则约束。</p>
<p>两个矛盾的点：</p>
<ol>
<li>不希望过程变成模型的主要部分；</li>
<li>重要的过程则必须显露在模型中。<br>把握这个边界的诀窍：<br>这个过程是否经常被领域专家提起，或者仅作为程序机制的一部分。</li>
</ol>
<h2 id="模式：-Specification"><a href="#模式：-Specification" class="headerlink" title="模式： Specification"></a>模式： Specification</h2><img src="/images/2019-07/specification.png" class="" width="800" height="1200" title="specification">
<p>一般性的，可以将约束、规则提取出来，作为领域层的Value Object。<br>用途包括：</p>
<ul>
<li>选择</li>
<li>过滤</li>
<li>按规格创建/生成对象。</li>
</ul>
<h1 id="第十章-柔性设计"><a href="#第十章-柔性设计" class="headerlink" title="第十章 柔性设计"></a>第十章 柔性设计</h1><p>柔性设计是深层模型的补充。<br>当我们把隐式概念抽离显式表达出来以后，就有原料来进行柔性设计了。</p>
<p>过多抽象层、间接设计=&gt;过度设计<br>适当抽象层、间接设计=&gt;柔性设计</p>
<p>简单并不容易做到。<br>柔性设计需要揭示深层次的底层模型，把它潜在的部分明确展示出来。</p>
<p>具体方法包括如下：</p>
<h2 id="1-模式：表现意图的接口-Intention-Revealing-Interface"><a href="#1-模式：表现意图的接口-Intention-Revealing-Interface" class="headerlink" title="1. 模式：表现意图的接口(Intention-Revealing Interface)"></a>1. 模式：表现意图的接口(Intention-Revealing Interface)</h2><img src="/images/2019-07/deep_model.png" class="" width="800" height="1200" title="deep_model">
<p>Intention-Revealing Interface: 表现意图的接口<br>有了它以后能够区分出：<br>Side-Effect-Freefunction: 无副作用的函数<br>StandAloneClass: 松耦合对象<br>Conceptual Contours: 概念边界\概念轮廓<br>Closeure of Operation: 闭合操作<br>甚至能基于接口直接编写单元测试中的断言。<br>（有时候可能无法达到这么理想，需要在单元测试中写Assert来进一步注释）</p>
<p>设计人员的客户包括其他合作开发人员。<br>接口中包含更多信息时，开发人员可以更有效地使用对象。<br>（否则就必须深入研究对象的内部机制、理解细节，失去了封装的价值）</p>
<p>接口设计重点：<br>给出意图、副作用、作用；<br>但无需给出具体实现细节。</p>
<h2 id="2-模式：无副作用函数（Size-Effect-free-function）"><a href="#2-模式：无副作用函数（Size-Effect-free-function）" class="headerlink" title="2. 模式：无副作用函数（Size-Effect-free function）"></a>2. 模式：无副作用函数（Size-Effect-free function）</h2><p>通过区分有无副作用，可以进一步降低查看底层实现的开销。<br>常见的无副作用操作：查询。<br>可以通过VO对象把一些操作也转化成无副作用。</p>
<p>一些复杂操作可以进一步分解成：有副作用、无副作用的两个操作。</p>
<p>挖掘深层模型案例：<br>油漆：</p>
<img src="/images/2019-07/paint1.png" class="" width="800" height="1200" title="paint1">
<p>第一步：把接口意图明确（混合两种油漆）</p>
<img src="/images/2019-07/paint2.png" class="" width="800" height="1200" title="paint2">
<p>第二步：原来的方法只修改paint1，不改paint2；不符合常识，后继开发人员也无法理解。改成深层模型，原来的paint改为不可变（Stock Paint），单独引入被混合后的油漆(Mixed Paint)。</p>
<h2 id="3-模式：-Assertion"><a href="#3-模式：-Assertion" class="headerlink" title="3. 模式： Assertion"></a>3. 模式： Assertion</h2><p>用断言把副作用明确表示出来。</p>
<h2 id="4-概念轮廓、概念边界"><a href="#4-概念轮廓、概念边界" class="headerlink" title="4. 概念轮廓、概念边界"></a>4. 概念轮廓、概念边界</h2><p>我们应该对每个依赖关系提出质疑，直到证实它确实表示对象的基本概念。<br>尽量把模块之间的依赖重构为模块内依赖；<br>模块内依赖重构为尽量少的对象之间的依赖。</p>
<h2 id="5-低耦合的对象"><a href="#5-低耦合的对象" class="headerlink" title="5. 低耦合的对象"></a>5. 低耦合的对象</h2><h2 id="6-模式：闭合操作-Closure-of-Operation"><a href="#6-模式：闭合操作-Closure-of-Operation" class="headerlink" title="6. 模式：闭合操作 Closure of Operation"></a>6. 模式：闭合操作 Closure of Operation</h2><p>实数集合上进行加减乘除后结果仍在实数集合中，这就是闭合操作。<br>像刚才油漆的混合操作之后得到的仍然是油漆，这就极大降低了依赖。</p>
<h2 id="7-声明式设计"><a href="#7-声明式设计" class="headerlink" title="7. 声明式设计"></a>7. 声明式设计</h2><p>声明式语言常见的有sql、各种配置文件。<br>比如把nginx的配置文件nginx.conf看作一种语言，则它是声明式的。(无法限定过程细节)<br>声明式设计就是写一段DSL，然后生成一份满足声明的约束条件的代码。比如mybatis里头用工具(jar包)+xml配置生成orm相关java代码。</p>
<ul>
<li>好处: 避免开发人员去写单调乏味容易出错的代码；</li>
<li>坏处: 生成的代码不灵活,声明可能不足以表达一切。</li>
</ul>
<h2 id="8-声明式设计风格"><a href="#8-声明式设计风格" class="headerlink" title="8. 声明式设计风格"></a>8. 声明式设计风格</h2><p>将上述几个模式组合以后，可以使用声明式设计风格。</p>
<h3 id="声明式风格的Specification"><a href="#声明式风格的Specification" class="headerlink" title="声明式风格的Specification"></a>声明式风格的Specification</h3><h4 id="1-用逻辑运算组合Specification-闭包操作模式"><a href="#1-用逻辑运算组合Specification-闭包操作模式" class="headerlink" title="1.用逻辑运算组合Specification (闭包操作模式)"></a>1.用逻辑运算组合Specification (闭包操作模式)</h4><p>运算组合结果还是Specification</p>
<img src="/images/2019-07/and_spec.png" class="" width="800" height="1200" title="and_spec">
<p>如图,可以通过子类的方法实现这种设计。（开销很大）</p>
<img src="/images/2019-07/cheap_spec.png" class="" width="800" height="1200" title="cheap_spec">
<p>如图，还可以通过逻辑算法来实现这种设计，这个栈的含义是:<br><code>and ( not (armored) , not(ventilated))</code><br>这种实现的优点: 对象个数少,内存使用效率高;<br>这种实现的缺点: 需要更高级的开发人员。</p>
<h2 id="9-切入问题的角度-（如何优化设计）"><a href="#9-切入问题的角度-（如何优化设计）" class="headerlink" title="9. 切入问题的角度 （如何优化设计）"></a>9. 切入问题的角度 （如何优化设计）</h2><h3 id="1-分割子领域"><a href="#1-分割子领域" class="headerlink" title="1. 分割子领域"></a>1. 分割子领域</h3><h3 id="2-尽可能利用已有的形式"><a href="#2-尽可能利用已有的形式" class="headerlink" title="2. 尽可能利用已有的形式"></a>2. 尽可能利用已有的形式</h3><p>从头创建一个严密的概念框架不能作为一项日常工作。<br>因此我们经常需要对建立已久的概念系统加以修改和利用。</p>
<h3 id="示例：-股份数学"><a href="#示例：-股份数学" class="headerlink" title="示例： 股份数学"></a>示例： 股份数学</h3><p>还钱=&gt;钱的分配按放贷股份</p>
<p>首先第一步: 把有无副作用的函数分离；(查归查，改归改)<br>3个函数:<br>计算分配方案;<br>执行(分配方案);<br>查询余额。</p>
<h4 id="第二步：把隐式概念变成显式概念"><a href="#第二步：把隐式概念变成显式概念" class="headerlink" title="第二步：把隐式概念变成显式概念"></a>第二步：把隐式概念变成显式概念</h4><img src="/images/2019-07/share_pie.png" class="" width="800" height="1200" title="share_pie">
<p>显式引入股份份额的概念(share_pie)。<br>然后把分配方案的计算委托给share_pie，这样简化了loan对象,可以进行复杂的计算。<br>share_pie可以作为VO（因为计算是无副作用而且通用的）</p>
<h4 id="第三步-引入闭合操作-运算"><a href="#第三步-引入闭合操作-运算" class="headerlink" title="第三步: 引入闭合操作(运算)"></a>第三步: 引入闭合操作(运算)</h4><img src="/images/2019-07/share_pie_vo.png" class="" width="800" height="1200" title="share_pie_vo">
<p>股份的份额运算变成闭合操作，并且由于是VO（不可变），每次返回新的Share pie.</p>
<p>最后把上层调用代码用声明式的风格改写即可。</p>
<p>核心思想： 把复杂计算封装到无状态的VO中。看情况引入闭合逻辑运算，进一步扩充计算能力。</p>
<h1 id="第11章-分析模式的应用"><a href="#第11章-分析模式的应用" class="headerlink" title="第11章 分析模式的应用"></a>第11章 分析模式的应用</h1><h2 id="案例：-账户的利息计算"><a href="#案例：-账户的利息计算" class="headerlink" title="案例： 账户的利息计算"></a>案例： 账户的利息计算</h2><p>需求：</p>
<ol>
<li>计算利息；</li>
<li>跟踪借款、付款、手续费；<br>（两种过账）<br>初始类图:<img src="/images/2019-07/class11_1.png" class="" width="800" height="1200" title="class11_1">

</li>
</ol>
<h3 id="引入复式记账-简化平账的并发问题"><a href="#引入复式记账-简化平账的并发问题" class="headerlink" title="引入复式记账(简化平账的并发问题)"></a>引入复式记账(简化平账的并发问题)</h3><p>加入每次的交易记录(不可变条目)，类似于所有快照都记录。<br>(Transaction)</p>
<h3 id="进一步挖掘需求"><a href="#进一步挖掘需求" class="headerlink" title="进一步挖掘需求"></a>进一步挖掘需求</h3><p>区分“应计项目”(accrual)和实际过账；<br>应记项目：立即发生；<br>实际过账：可以延迟。<br>例如利息可以每天计算，但只在月末过账。（例如夜间批量过账）<br>新的类图:</p>
<img src="/images/2019-07/class11_7.png" class="" width="800" height="1200" title="class11_7">
<p>注意到图中获取利息和费用的函数都是无副作用的。</p>
<h3 id="进一步考察过账需求"><a href="#进一步考察过账需求" class="headerlink" title="进一步考察过账需求"></a>进一步考察过账需求</h3><p>过账的触发时机：</p>
<ol>
<li>立即触发: 每次新增交易(Entry被插入)都触发，进行所有更新；</li>
<li>手动触发：向Account发送命令来触发过账规则；（进行更新）</li>
<li>基于规则触发：由代理驱动。<br>实际实现中可能根据过账的类型来决定触发时机（是否实时到账）。</li>
</ol>
<h1 id="第12章-将设计模式应用于模型"><a href="#第12章-将设计模式应用于模型" class="headerlink" title="第12章 将设计模式应用于模型"></a>第12章 将设计模式应用于模型</h1><p>有些设计模式可以用作领域模式：</p>
<h2 id="Strategy-Policy-模式"><a href="#Strategy-Policy-模式" class="headerlink" title="Strategy(Policy)模式"></a>Strategy(Policy)模式</h2><img src="/images/2019-07/policy.png" class="" width="800" height="1200" title="policy">
<p>模式中有一些可以灵活更换的策略(无状态)。<br>如路径查找中，可以选择时间最短或者成本最低等等策略。</p>
<h2 id="Composite模式"><a href="#Composite模式" class="headerlink" title="Composite模式"></a>Composite模式</h2><img src="/images/2019-07/composite.png" class="" width="800" height="1200" title="composite">
<p>复杂领域建模时，会遇到多个部分组成的重要对象。(可能继续嵌套)<br>例如航线可能由多个航段组成。航段可以进一步划分。</p>
<p>原文: 其他可用的设计模式不再一一列举</p>
<h1 id="第13章-通过重构得到更深层的理解"><a href="#第13章-通过重构得到更深层的理解" class="headerlink" title="第13章 通过重构得到更深层的理解"></a>第13章 通过重构得到更深层的理解</h1><p>(1)以领域为本;<br>(2)用不同的方式看待事物；<br>(3)坚持与领域专家对话。</p>
<h2 id="开始重构"><a href="#开始重构" class="headerlink" title="开始重构"></a>开始重构</h2><p>一段复杂或笨拙的代码：<br>问题的根源在于领域模型中的概念或者关系发生了错误。</p>
<p>另一种例外就是代码很整洁，但是与领域专家的语言不一致，这可能会埋下隐患，因此依然需要重构。</p>
<p>方法：</p>
<ul>
<li>请教领域专家：寻找灵感；</li>
<li>借鉴已有的经验、案例。</li>
<li>不用完全证明修改的合理性后再修改，应该掌握一个度然后持续重构。<br>(类似于物种进化过程中的爆发变化和间断平衡)</li>
</ul>
<h1 id="第四部分：-战略设计"><a href="#第四部分：-战略设计" class="headerlink" title="第四部分： 战略设计"></a>第四部分： 战略设计</h1><p>三个主题：</p>
<ol>
<li>上下文：ContextMap,也就是模块化；(Bounded Context)</li>
<li>精炼: 重点关心项目中最有价值、特殊的方面，其他组件外包；(Core Domain)</li>
<li>大比例结构: 大分层。(4个左右)(Responsibility Layer)</li>
</ol>
<h1 id="第14章-上下文-保持模型的完整性"><a href="#第14章-上下文-保持模型的完整性" class="headerlink" title="第14章 上下文: 保持模型的完整性"></a>第14章 上下文: 保持模型的完整性</h1><p>需要保证模型的内部统一性，不要有模棱两可的意义、规则的冲突。<br>（举个案例两个团队使用同一个模型出错，最后分开成两个不同场景的模型了）</p>
<p>Bounded context: 限界上下文，定义每个模型的应用范围；<br>Context Map: 上下文图，给出项目上下文和它们之间关系的总体视图；</p>
<img src="/images/2019-07/context_map.png" class="" width="800" height="1200" title="ContextMap">
<p>Continuous Integration: 持续集成,小项目使用,模型统一;<br>Shared Kernel: 共享内核;平等团队合作；<br>Customer/Supplier Teams: 上下游合作,有共同的直接上级；<br>Conformist: 跟随者，沿用类似内核；（上游写得不错，直接拿过来增强即可）<br>Open Host Service: 支持多个客户；(与多个外部系统集成时)<br>Seperate Ways: 团队自由工作(没有共同直接上级)；或者上游写得太烂，直接抛弃重写。<br>Anticorruption Layer: 隔离层，单向转换。（与遗留系统集成时）或者上游写得太烂，一边重构一边用。</p>
<h2 id="Bounded-Context"><a href="#Bounded-Context" class="headerlink" title="Bounded Context"></a>Bounded Context</h2><p>类似于细胞膜一样，缩小模型的命名空间、覆盖范围。<br>降低成员之间沟通的成本（DSL中术语太多记不住，洪泛了）</p>
<p>一个模型只在一个上下文中使用。</p>
<p>// Bounded Context和Module还是有所区别。一个是逻辑上的，一个是物理上的。</p>
<p>识别不一致:</p>
<ol>
<li>场景发生变化后：接口不匹配了。</li>
<li>重复的概念和假同源: 使用相同的术语，但其实是不同的模型。</li>
</ol>
<h2 id="Continuous-Integration-持续集成"><a href="#Continuous-Integration-持续集成" class="headerlink" title="Continuous Integration: 持续集成"></a>Continuous Integration: 持续集成</h2><p>在一个Bounded Context中的模型应该持续集成，保持一致性。<br>（小团队、高频交流）</p>
<h2 id="Context-Map-全局视图"><a href="#Context-Map-全局视图" class="headerlink" title="Context Map: 全局视图"></a>Context Map: 全局视图</h2><p>ContextMap同时服务于项目管理和软件设计。<br>甚至要按照它来安排办公室的物理位置。</p>
<h3 id="案例：预订context和运输context"><a href="#案例：预订context和运输context" class="headerlink" title="案例：预订context和运输context"></a>案例：预订context和运输context</h3><img src="/images/2019-07/bounded_context.png" class="" width="800" height="1200" title="bounded_context">
<p>预订Context: 完成Route Specification=&gt;地点代码的转换；<br>运输Context: 完成Node标识=&gt;行程表、航程安排的转换。<br>两个上下文之间的接口非常小，可以由Side_Effect_free function构成，由于<br>同时使用两个上下文，因此可以应用有效的路线安排算法。</p>
<h3 id="其他要点"><a href="#其他要点" class="headerlink" title="其他要点"></a>其他要点</h3><ol>
<li>确定Context的边界；(每个人都知道)</li>
<li>每个上下文应当有名字，方便讨论；(加入DSL)</li>
</ol>
<p>将这两点文档化。</p>
<h3 id="Context-Map中一些常见的模式"><a href="#Context-Map中一些常见的模式" class="headerlink" title="Context Map中一些常见的模式"></a>Context Map中一些常见的模式</h3><p>持续集成模式：<br>紧密集成产品的优秀团队：大的统一的模型</p>
<p>Shared Kernel（共享内核）/Customer-supplier(客户供应商)：</p>
<ul>
<li>团队协调能力有限;</li>
<li>为不同的用户群提供服务;</li>
</ul>
<p>Separate Way(独立自主)模式:</p>
<ul>
<li>集成并不重要时;</li>
</ul>
<p>Open Host Service(开放主机服务)/Anticorruption Layer(防护层)：</p>
<ul>
<li>与遗留系统或外部系统进行一定程度集成时。</li>
</ul>
<h2 id="Shared-Kernel-共享内核"><a href="#Shared-Kernel-共享内核" class="headerlink" title="Shared Kernel (共享内核)"></a>Shared Kernel (共享内核)</h2><p>持续集成是开销最大的，开销稍微小一点的是共享内核。<br>（仅持续集成内核部分）</p>
<p>从领域模型中选出两个团队都同意共享的一个子集。<br>一个团队在没与另一个团队商量之前不应擅自更改它。</p>
<p><strong>测试</strong><br>需要自动测试套件</p>
<p>可以每周进行一次内核的合并。</p>
<p>Shared Kernel通常是Core Domain(参见精炼部分，Core Domain就是精炼出来的项目需要解决的最核心逻辑)，或者一组Generic Subdomain(通用子领域)。</p>
<h2 id="Customer-Supplier-Development-Team-客户-供应商模式"><a href="#Customer-Supplier-Development-Team-客户-供应商模式" class="headerlink" title="Customer/Supplier Development Team(客户/供应商模式)"></a>Customer/Supplier Development Team(客户/供应商模式)</h2><p>适用情况：</p>
<ol>
<li>一个子系统服务于另一个子系统；</li>
<li>下游很少向上游反馈信息，单向依赖；</li>
<li>两个子系统为完全不同的用户群服务。 </li>
</ol>
<p>上下游很自然得分割到两个Bounded Context中。</p>
<p>注意事项：</p>
<ul>
<li>上下游负责的两个团队的行政关系：最好有共同的直接上级；<br>原因：需要正式规定团队之间的关系、责任。<br>两者有工作依赖关系，相互制约，如果无法互相推动可能导致交付delay。 </li>
</ul>
<p><strong>测试</strong><br>两个团队一起开发自动验收测试，验证预期的接口。<br>降低耦合性。上游团队做出修改时不必担心对下游团队产生副作用。<br>(接力赛时前面的选手不能一直回头看，他需要相信队友能把棒准确交到他手中，否则整个团队的速度都会慢下来)</p>
<h2 id="Conformist-跟随者模式"><a href="#Conformist-跟随者模式" class="headerlink" title="Conformist(跟随者模式)"></a>Conformist(跟随者模式)</h2><p>适用情况：<br>依然是上下游关系，但没有共同直接上级。<br>(管理层次相隔很远，无法推动)</p>
<p>此时下游团队只能靠自己了，3种选择：</p>
<ol>
<li>放弃对上游的利用: Separete Way(独立自主模式)</li>
<li>Anticorruption Layer: (防护层模式)上游写得很烂，一边重构一边用；</li>
<li>Conformist: (跟随者模式)上游写得不错，拿过来进行增强即可。</li>
</ol>
<p>Conformist与Shared Kernel类似都是用了相同内核，但是Conformist中另一个团队对合作没有兴趣。</p>
<h2 id="Anticorruption-Layer-防护层模式"><a href="#Anticorruption-Layer-防护层模式" class="headerlink" title="Anticorruption Layer(防护层模式)"></a>Anticorruption Layer(防护层模式)</h2><p>适用情况：<br>遗留代码写得烂，或上游写得不行但重写代价太高时，只能一边写一边重构。</p>
<p>一般重构不要直接全盘否定，这样工作量太大不可能立即完成。</p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>Facade: 外观模式: 子系统可供替换的接口，方便切换新老实现；<br>Adapter: 适配器：把新老系统转换成相同的接口。</p>
<p>个人思考：<br>微服务级别的隔离，部分请求发给新服务（一切都要灰度测试）</p>
<h2 id="Separate-Way-独立自主模式"><a href="#Separate-Way-独立自主模式" class="headerlink" title="Separate Way(独立自主模式)"></a>Separate Way(独立自主模式)</h2><p>如果集成的收益很小，代价很高，可以考虑不集成。</p>
<h2 id="Open-Host-Service（开放主机服务）"><a href="#Open-Host-Service（开放主机服务）" class="headerlink" title="Open Host Service（开放主机服务）"></a>Open Host Service（开放主机服务）</h2><p>适用情况：<br>需要和大量其他系统集成时。</p>
<p>定义一个协议，使我们的系统可以作为一组Service供其它系统访问。<br>开放这个协议，让所有需要与我们系统集成的人都可以使用它。<br>当有新的集成需求时，增强并扩展这个协议。<br>（如果只是特殊需求，可以写个一次性的转换器，共享协议应该简单而且内聚）</p>
<h2 id="Published-Language-公共语言"><a href="#Published-Language-公共语言" class="headerlink" title="Published Language(公共语言)"></a>Published Language(公共语言)</h2><p>两个Bounded Context之间模型转换的时候，<br>交换信息时如果有共同语言(无歧义)能简化转换。<br>如Open Host Service模式中，如果能发明一种简单好理解的共享协议，别的系统就能快速接入。</p>
<p>公共语言可能是： XML,JSON…</p>
<h2 id="模型的集成统一"><a href="#模型的集成统一" class="headerlink" title="模型的集成统一"></a>模型的集成统一</h2><p>集成的过程中往往会出现互相冲突的领域模型。<br>因此要适当简化，宁可缺少喷水功能，也不要包含不正确的特性。</p>
<h2 id="Context的边界选择："><a href="#Context的边界选择：" class="headerlink" title="Context的边界选择："></a>Context的边界选择：</h2><p>大的Context适用情况:</p>
<ol>
<li>用一个统一的模型来处理时，用户任务之间流动更顺畅；</li>
<li>一个内聚模型比两个更容易理解；</li>
<li>两个模型转换很难；</li>
<li>共享语言可以使团队沟通起来更清楚。 </li>
</ol>
<p>小的Context适用情况：</p>
<ol>
<li>降低了开发之间的沟通开销；</li>
<li>降低规模后：持续集成更容易了；</li>
<li>太大的上下文需要更高级的抽象模型：相关技巧人员短缺；</li>
<li>不同模型满足一些特殊需求。</li>
</ol>
<h2 id="集成外部系统的经验"><a href="#集成外部系统的经验" class="headerlink" title="集成外部系统的经验"></a>集成外部系统的经验</h2><ol>
<li>首先考虑不集成：Seperate Way模式；</li>
<li>外部系统写得好：Conformist模式：</li>
<li>外部系统写得烂：Anticorruption Layer。</li>
</ol>
<img src="/images/2019-07/context_map2.png" class="" width="800" height="1200" title="context_map2">

<h1 id="第15章-精炼-Core-Domain"><a href="#第15章-精炼-Core-Domain" class="headerlink" title="第15章 精炼 (Core Domain)"></a>第15章 精炼 (Core Domain)</h1><p>领域驱动的核心是把领域层提取出来；<br>还可以进一步把领域层中最核心要解决的问题（项目的立项根因）提取出来：<br>Core Domain。 </p>
<p>核心思想：专注于核心问题，而不被大量次要问题所淹没。</p>
<p>精炼包括：</p>
<ol>
<li>帮助成员掌握系统的总体设计及协调；</li>
<li>找到一个适度规模的核心模型，加入到通用语言，促进沟通；</li>
<li>指导重构；</li>
<li>专注于模型中最有价值的部分；</li>
<li>指导外包、现成组件的使用以及任务委派。</li>
</ol>
<img src="/images/2019-07/refine.png" class="" width="800" height="1200" title="refine">

<h2 id="Core-Domain模式"><a href="#Core-Domain模式" class="headerlink" title="Core Domain模式"></a>Core Domain模式</h2><p>尽量压缩Core Domain，在Core Domain中努力开发深层模型和柔性设计。<br>(让最有才能的人来开发Core Domain，自主开发的软件的最大价值在于对Core Domain的完全控制。应该让最有才能的人+领域专家长期合作开发)</p>
<p>Domain Vision Statement: 领域前景说明<br>Highlighted Core : 突出的核心<br>Generic Subdomain: 通用子领域：模型中最普通不特别的部分；<br>Cohesive Mechanism: 内聚机制<br>Seperated Core: 隔离的核心：核心外的实现可替换<br>Abstract Core: 抽象内核：连核心的实现也是可替换的。</p>
<h2 id="Generic-Subdomain"><a href="#Generic-Subdomain" class="headerlink" title="Generic Subdomain"></a>Generic Subdomain</h2><p>通用子领域：与项目目标无直接联系，增加复杂性，不限于仅在本项目可以使用。（如数据库连接池这种纯技术的部分、带时区的日期和时间功能）</p>
<p>它们的解决方案：</p>
<ol>
<li>购买现成的；</li>
<li>使用开源的；</li>
<li>把实现外包出去；</li>
<li>内部实现它。</li>
</ol>
<h2 id="Domain-Vision-Statement领域前景说明-1页"><a href="#Domain-Vision-Statement领域前景说明-1页" class="headerlink" title="Domain Vision Statement领域前景说明(1页)"></a>Domain Vision Statement领域前景说明(1页)</h2><p>不涉及技术指标，但要把项目和其他项目区分开来。<br>描述支持的功能和目标。<br>（区别于某个版本的技术规格）</p>
<h2 id="Highlighted-Core-3-7页"><a href="#Highlighted-Core-3-7页" class="headerlink" title="Highlighted Core(3~7页)"></a>Highlighted Core(3~7页)</h2><p>在代码级完成Core Domain前，可以先文档级描述Core Domain。<br>描述Core Domain及内部元素的主要交互。<br>尽量精简。</p>
<h2 id="Cohesive-Mechanism-内聚机制"><a href="#Cohesive-Mechanism-内聚机制" class="headerlink" title="Cohesive Mechanism(内聚机制)"></a>Cohesive Mechanism(内聚机制)</h2><p>分离出去的代码要内聚，用Intention-revealing接口来公开功能。<br>从而留下更小的Core Domain。<br>（例如可以分离Specification对象(规格)）</p>
<p>Generic Subdomain与Cohesize Mechanism都是为Core domain减负。</p>
<h2 id="Segregated-Core-分离内核"><a href="#Segregated-Core-分离内核" class="headerlink" title="Segregated Core(分离内核)"></a>Segregated Core(分离内核)</h2><p>等到上述步骤完成，内核逐渐与其他部分分离开。<br>进一步重构，彻底去掉代码耦合，把内核分离出来。</p>
<h2 id="Abstract-Core-抽象内核"><a href="#Abstract-Core-抽象内核" class="headerlink" title="Abstract Core(抽象内核)"></a>Abstract Core(抽象内核)</h2><p>把模型中最基本的概念识别出来，分离到不同的类、抽象类、接口中。<br>详细的实现留在子领域定义的module中。</p>
<p><strong>综上</strong><br>重构时也应当优先重构Core Domain。</p>
<h1 id="第16章-大比例结构"><a href="#第16章-大比例结构" class="headerlink" title="第16章 大比例结构"></a>第16章 大比例结构</h1><p>前文：上下文（Bounded Context）,精炼(Core Domain/Generic Subdomain)<br>分离出很多Module后，要找一个类非常困难。<br>这个时候为了便于管理： 大比例结构(约4层)</p>
<img src="/images/2019-07/layer_struct.png" class="" width="800" height="1200" title="layer_struct">

<p>Evolving Order: 逐步进化演化。<br>System Metaphor: 隐喻思维；（用一些比喻、如防火墙）<br>Responsibility layer: 职责模式<br>Knowlege level: 知识级别模式；<br>Plugggable Component Framework: 解耦组件；</p>
<h2 id="System-Metaphor模式"><a href="#System-Metaphor模式" class="headerlink" title="System Metaphor模式"></a>System Metaphor模式</h2><p>隐喻模式。<br>例如核和外层的比喻，防火墙的比喻。<br>用比喻来分层。（但是宁缺毋滥）</p>
<h2 id="Responsibility-Layer职责分层模式"><a href="#Responsibility-Layer职责分层模式" class="headerlink" title="Responsibility Layer职责分层模式"></a>Responsibility Layer职责分层模式</h2><p>类似于MVC中Repository等，上层可以访问下层，下层则不能访问上层。<br>还可以根据访问频率、状态变化频率分层。</p>
<h2 id="运输系统-投资银行案例"><a href="#运输系统-投资银行案例" class="headerlink" title="运输系统/投资银行案例"></a>运输系统/投资银行案例</h2><p>作业层<br>能力层<br>决策支持层<br>潜能层<br>承诺层</p>
<img src="/images/2019-07/layer1.png" class="" width="800" height="1200" title="layer1">
<img src="/images/2019-07/layer2.png" class="" width="800" height="1200" title="layer2">
<p>（类似于Controller,logic,repository层等等）</p>
<h2 id="Knowledge-level知识级别模式"><a href="#Knowledge-level知识级别模式" class="headerlink" title="Knowledge level知识级别模式"></a>Knowledge level知识级别模式</h2><img src="/images/2019-07/knowledge_level.png" class="" width="800" height="1200" title="knowledge_level">
<p>与Reponsibily layer的区别在于两个层之间互相依赖。<br>案例用的是养老金分配的知识级别模式。<br>某些模型能根据元数据来工作，知识级别较高。</p>
<h2 id="Pluggable-Component-Framework"><a href="#Pluggable-Component-Framework" class="headerlink" title="Pluggable Component Framework"></a>Pluggable Component Framework</h2><p>一个中央hub上支持所需的协议，可以灵活替换组件。<br>这种模式一般是经过很长时间演变后产生。<br>（起码在Abstract Core之后）</p>
<h2 id="最小化"><a href="#最小化" class="headerlink" title="最小化"></a>最小化</h2><p>一开始使用最松散的System metaphor隐喻模式，逐渐深化。</p>
<h1 id="第17章-领域驱动设计的综合运用"><a href="#第17章-领域驱动设计的综合运用" class="headerlink" title="第17章 领域驱动设计的综合运用"></a>第17章 领域驱动设计的综合运用</h1><img src="/images/2019-07/domain_all.png" class="" width="800" height="1200" title="domain_all">
<p>综合使用前面的三点：<br>上下文、精炼、大比例结构。</p>
<h2 id="大比例结合上下文-bounded-context"><a href="#大比例结合上下文-bounded-context" class="headerlink" title="大比例结合上下文(bounded context)"></a>大比例结合上下文(bounded context)</h2><p>把不同bounded context放到不同层</p>
<h2 id="大比例结合精炼"><a href="#大比例结合精炼" class="headerlink" title="大比例结合精炼"></a>大比例结合精炼</h2><p>帮助理清Core Domain内部关系和Generic subdomain之间关系。<br>（放到不同层）</p>
<img src="/images/2019-07/layer_all2.png" class="" width="800" height="1200" title="layer_all2">
<p>大比例结合上下文后的图如上所示。</p>
<h2 id="战略设计决策的6个要点"><a href="#战略设计决策的6个要点" class="headerlink" title="战略设计决策的6个要点"></a>战略设计决策的6个要点</h2><ol>
<li>决策传达到整个团队；</li>
<li>决策过程收集反馈；</li>
<li>计划允许演变；</li>
<li>架构团队和开发团队都需要聪明人；</li>
<li>简约、谦逊原则；（不要对开发形成障碍）</li>
<li>对象职责专一而开发人员是多面手。</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://xiaoyue26.github.io/2019/07/22/2019-07/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1-%E7%AC%AC7-17%E7%AB%A0%E7%AC%94%E8%AE%B0/" data-id="ck96cxpq000j5maambbi918wj" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/DDD/" rel="tag">DDD</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AE%BE%E8%AE%A1/" rel="tag">设计</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-2019-07/hll算法原理" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/06/2019-07/hll%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86/" class="article-date">
  <time datetime="2019-07-06T09:19:23.000Z" itemprop="datePublished">2019-07-06</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/06/2019-07/hll%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86/">hll算法原理</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <h1 id="What-HLL-HyperLogLog是啥"><a href="#What-HLL-HyperLogLog是啥" class="headerlink" title="What: HLL/HyperLogLog是啥"></a>What: HLL/HyperLogLog是啥</h1><p>近似计算uv的算法,每一千万错误率0.5%.<br>谷歌改进后的算法为HLL++/HyperLogLog plus算法，改进了一些边界和精度问题（分类处理了稀疏和稠密的数据集情况，稀疏转化成稠密）。HLL++在边界条件下从1.5%优化到0.5%。而且不会出现突变高的错误率情况。</p>
<img src="/images/2019-07/hll_plus.png" class="" width="800" height="1200" title="hll_plus">

<p>论文:<br><a href="http://static.googleusercontent.com/media/research.google.com/en/us/pubs/archive/40671.pdf" target="_blank" rel="noopener">http://static.googleusercontent.com/media/research.google.com/en/us/pubs/archive/40671.pdf</a></p>
<h1 id="How-HLL原理"><a href="#How-HLL原理" class="headerlink" title="How: HLL原理"></a>How: HLL原理</h1><h2 id="n次伯努利"><a href="#n次伯努利" class="headerlink" title="n次伯努利"></a>n次伯努利</h2><p>进行了n次进行抛硬币实验，每次分别记录下第一次抛到正面的抛掷次数K1~Kn，那么可以用n次实验中最大的抛掷次数Kmax;<br>则可以预估实验组数量为n的预估值=2^Kmax.<br>参考:<br><a href="http://www.rainybowe.com/blog/2017/07/13/%E7%A5%9E%E5%A5%87%E7%9A%84HyperLogLog%E7%AE%97%E6%B3%95/index.html" target="_blank" rel="noopener">http://www.rainybowe.com/blog/2017/07/13/%E7%A5%9E%E5%A5%87%E7%9A%84HyperLogLog%E7%AE%97%E6%B3%95/index.html</a></p>
<h2 id="LC算法"><a href="#LC算法" class="headerlink" title="LC算法"></a>LC算法</h2><p>所有数据hash以后，从低位开始第一个1的位置K。<br>预估值为2^K.</p>
<h2 id="HLL算法"><a href="#HLL算法" class="headerlink" title="HLL算法"></a>HLL算法</h2><p>分桶后求调和平均，概率上减少异常。</p>
<h2 id="redis中的实现"><a href="#redis中的实现" class="headerlink" title="redis中的实现"></a>redis中的实现</h2><p>代码：<a href="https://github.com/antirez/redis/blob/unstable/src/hyperloglog.c" target="_blank" rel="noopener">https://github.com/antirez/redis/blob/unstable/src/hyperloglog.c</a><br>内存: 2^14个桶,每个桶6bit。(实际作为一个大数组12KB。)</p>
<ol>
<li>每个输入通过hash算法得出64bit哈希值x；</li>
<li>x的低14位,用来选择桶号(0-2^14-1号)Mi;</li>
<li>x的高50位,用来找K(也就是第一次出现1的位置，或者说0后缀的长度)，把K存入Mi。</li>
</ol>
<p>这样处理完所有用户输入后，用公式算出n的估计值:</p>
<img src="/images/2019-07/hll.png" class="" width="800" height="1200" title="hll">

<blockquote>
<p>对于第三点中的K,(也就是n次伯努利里的Kmax) (对于每个用户id的Kmax值存入桶的6位中)<br>高位剩下50位,第一个1的位置最大是50,而2^6=64，所以能够存下50这个数字(以及其他所有Kmax)。</p>
</blockquote>
<p>HLL++的话还要加入更多的边界调整。</p>
<h2 id="可视化模拟"><a href="#可视化模拟" class="headerlink" title="可视化模拟"></a>可视化模拟</h2><p><a href="http://content.research.neustar.biz/blog/hll.html" target="_blank" rel="noopener">http://content.research.neustar.biz/blog/hll.html</a><br>上述链接中是m=64个桶(4*16的方阵)，每个格子中存放一个十进制数，实际最大是2^6也就是64，如果新来了K值，则会和原来的K值做逻辑交运算。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://xiaoyue26.github.io/2019/07/06/2019-07/hll%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86/" data-id="ck96cxppy00ixmaam5scrc2mc" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hll/" rel="tag">hll</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hyperloglog/" rel="tag">hyperloglog</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-2019-07/粗俗理解clickhouse" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/06/2019-07/%E7%B2%97%E4%BF%97%E7%90%86%E8%A7%A3clickhouse/" class="article-date">
  <time datetime="2019-07-06T09:06:37.000Z" itemprop="datePublished">2019-07-06</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/clickhouse/">clickhouse</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/06/2019-07/%E7%B2%97%E4%BF%97%E7%90%86%E8%A7%A3clickhouse/">粗俗理解clickhouse</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <h1 id="what-clickhouse是啥"><a href="#what-clickhouse是啥" class="headerlink" title="what: clickhouse是啥?"></a>what: clickhouse是啥?</h1><p>clickhouse是俄罗斯开源的一个用于OLAP分析的核心引擎，它可以基于海量的日志数据接受类sql查询，以秒~分钟量级的延迟返回查询结果。<br>它目前应用在了俄罗斯的搜索引擎Yandex.Metrica中、欧洲核子研究中心: PB级存储、统计分析查询，以及我国各大互联网公司的BI后台引擎中。</p>
<h2 id="应用：-Yandex-Metrica"><a href="#应用：-Yandex-Metrica" class="headerlink" title="应用： Yandex.Metrica"></a>应用： Yandex.Metrica</h2><p>2014年: 每天120亿个事件。（点击、浏览）<br>374台服务器，20.3万亿行数据。<br>压缩后: 2PB<br>压缩前: 17PB</p>
<p>详细介绍官网:<br><a href="https://clickhouse.yandex/docs/zh/" target="_blank" rel="noopener">https://clickhouse.yandex/docs/zh/</a><br>开源代码:<br><a href="https://github.com/yandex/ClickHouse" target="_blank" rel="noopener">https://github.com/yandex/ClickHouse</a><br>中文文档:<br><a href="https://github.com/yandex/ClickHouse/tree/master/docs/zh" target="_blank" rel="noopener">https://github.com/yandex/ClickHouse/tree/master/docs/zh</a></p>
<h1 id="why-为啥选择clickhouse"><a href="#why-为啥选择clickhouse" class="headerlink" title="why: 为啥选择clickhouse?"></a>why: 为啥选择clickhouse?</h1><p>主要原因有: 性能高、跑分高、功能多、可用性高。</p>
<h2 id="性能高、跑分高"><a href="#性能高、跑分高" class="headerlink" title="性能高、跑分高"></a>性能高、跑分高</h2><p>// 俄罗斯的程序员在算法方面的活跃度排名世界第一<br>// C++实现、老毛子轻易不开源,参见nginx</p>
<blockquote>
<p>摘自知乎: <a href="https://zhuanlan.zhihu.com/p/22165241" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/22165241</a><br>1亿数据:<br>比Vertica快5倍,比Hive快279倍,比Mysql快801倍;<br>10亿数据:<br>比Vertica快5倍,mysql无法完成。</p>
</blockquote>
<h3 id="单机性能"><a href="#单机性能" class="headerlink" title="单机性能"></a>单机性能</h3><p>有page cache: 2-10GB／s（未压缩），上限30GB/s<br>无page cache: 1.2G/s(压缩率3)<br>(磁盘400MB/s)如果是10B的列，就是1-2亿行/s。 </p>
<h2 id="功能多"><a href="#功能多" class="headerlink" title="功能多"></a>功能多</h2><p>最重要的是有<code>AggregatingMergeTree</code>表引擎，专门优化了三个数据分析最实用的查询:（海量数据快速计算）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">uniq: 计算uv</span><br><span class="line">any: 抽样统计</span><br><span class="line">quantiles: 分位数</span><br></pre></td></tr></table></figure>
<p>上述几个功能如果用sparkSql/hive,一般耗时都是15分钟以上。(甚至到半小时、1小时)<br>如果用mysql的话,则由于维度爆炸的问题可能存不下这么多数据，并且无法灵活新增维度。<br>clickhouse对于海量数据处理没有spark/hive那么灵活,但是特化了OLAP的即时查询性能,本质上是处在不同领域的工具。<br>从数据仓库的角度来看:<br>ods层: 用spark/hive进行ETL后产生;<br>dw层: ods载入clickhouse后直接产生预聚合的数仓,支持即时查询;<br>dm层: mysql</p>
<h3 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h3><p>hbase/ES:一般用来支持海量数据点查询;<br>mysql: 用来支持无聚合的点查询;<br>clickhouse: 用来支持海量数据的聚合查询。<br>kylin: 比较接近clickhouse，底层是hbase+星型模型</p>
<p>其他引擎:</p>
<h4 id="ReplcingMergeTree"><a href="#ReplcingMergeTree" class="headerlink" title="ReplcingMergeTree"></a>ReplcingMergeTree</h4><p>删除相同主键的重复项(去重)</p>
<h3 id="SummingMergeTree"><a href="#SummingMergeTree" class="headerlink" title="SummingMergeTree"></a>SummingMergeTree</h3><p>将一个part中，相同主键的所有行聚合成一行，包含一系列聚合函数状态。</p>
<h3 id="CollapsingMergeTree"><a href="#CollapsingMergeTree" class="headerlink" title="CollapsingMergeTree"></a>CollapsingMergeTree</h3><p>提供折叠行功能： 把同主键的数据行去重到最多两行。（再次强调所有聚合都在part内）<br>场景: 用户访问状态记录、频繁变化的数据</p>
<p>前面说的clickhouse不支持update数据，所以用这个引擎可以近似达到一部分update的效果。<br>本质上就是类似于git的revert、银行系统里的冲正、mysql的MVCC。</p>
<p>比如我们要记录用户访问情况，先插入一条:<br><code>userid_0,5,146,1</code> 表示0号用户访问了5个页面，停留146秒(最后一列的1暂时忽略)。<br>然后过了一会儿想改成它访问了6个页面，停留185秒，那就插入:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">userid_0,5,146,-1</span><br><span class="line">userid_0,6,185,1</span><br></pre></td></tr></table></figure>
<p>首先把原来的取消掉，标记列-1。然后插入最新的状态数据，标记列1.</p>
<blockquote>
<p>应当注意这些成对的1,-1会异步地被删除，所以不能查到状态变化历史,仅用于查最新。</p>
</blockquote>
<p>这种引擎的建表语句:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> UAct</span><br><span class="line">(</span><br><span class="line">    UserID UInt64,</span><br><span class="line">    PageViews UInt8,</span><br><span class="line">    <span class="keyword">Duration</span> UInt8,</span><br><span class="line">    <span class="keyword">Sign</span> <span class="built_in">Int8</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">ENGINE</span> = CollapsingMergeTree(<span class="keyword">Sign</span>)</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> UserID</span><br></pre></td></tr></table></figure>
<p>查询的时候的语法:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    UserID,</span><br><span class="line">    <span class="keyword">sum</span>(PageViews * <span class="keyword">Sign</span>) <span class="keyword">AS</span> PageViews,</span><br><span class="line">    <span class="keyword">sum</span>(<span class="keyword">Duration</span> * <span class="keyword">Sign</span>) <span class="keyword">AS</span> <span class="keyword">Duration</span></span><br><span class="line"><span class="keyword">FROM</span> UAct</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> UserID</span><br><span class="line"><span class="keyword">HAVING</span> <span class="keyword">sum</span>(<span class="keyword">Sign</span>) &gt; <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p><code>CollapsingMergeTree</code>要求插入的顺序不能乱来，要按状态的变化顺序。<br>如果顺序无法保证，可以使用<code>VersionedCollapsingMergeTree</code>,它的算法也很简单,就是要求用户多传一个version字段。</p>
<h3 id="GraphiteMergeTree"><a href="#GraphiteMergeTree" class="headerlink" title="GraphiteMergeTree"></a>GraphiteMergeTree</h3><p>直接接到日志收集。<br>可以存metrics指标可视化系统Graphite的rollup数据。<br>如果不rollup，可以用别的引擎。</p>
<h3 id="Log系列的引擎-非主打"><a href="#Log系列的引擎-非主打" class="headerlink" title="Log系列的引擎(非主打)"></a>Log系列的引擎(非主打)</h3><p>用于小数据量(&lt; 100w)的表。<br>包括: StripeLog,Log,TinyLog三个引擎。</p>
<p>特性:</p>
<ul>
<li>追加写,不支持改</li>
<li>不支持索引</li>
<li>非原子写入(可能有损坏的数据)</li>
</ul>
<p>TinyLog：最简单的表引擎，适合一次写入即终身、多次查询的小数据，不支持并发数据访问，不支持同时写入同时读取。<br>Log：比TinyLog多一个偏移量优化.<br>Memory：以直接形式存储在内存中，读写变态快，但是记住是临时的，关机数据消失。<br>Buffer：缓冲，可以理解为将数据存储在内存中，然后达到一定阈值限制条件，那么先前的数据会自动写入设定的表格中。这样可以将部分热数据放在内存中缓存，快速访问和读取，而时间较为久远的数据写入表中释放内存，应该比较好理解。（可以实时盯数据）<br>External data：从字面理解，就是可以将文件数据等引入query语句中利用了。比如你想查找一些在你所给的名单中的用户的消费数据，那么你可以免除复制粘贴，直接将这个名单文件引入并使用，clickhouse会自动给这个文件建立一个临时表。</p>
<h3 id="其他功能"><a href="#其他功能" class="headerlink" title="其他功能:"></a>其他功能:</h3><ul>
<li>支持类SQL查询，相应的库函数很多：ip转换、数组、map、url转换、近似<br>计算uv、近似计算分位数、抽样统计等等；<br><a href="https://clickhouse.yandex/docs/zh/query_language/select/" target="_blank" rel="noopener">https://clickhouse.yandex/docs/zh/query_language/select/</a></li>
<li>数据源支持繁多，可以是以kafka、tcp、jdbc、文件等等直接作为表。</li>
<li>webUI支持: <a href="https://tabix.io/" target="_blank" rel="noopener">https://tabix.io/</a></li>
<li>IDE支持: jetbrain打造的datagrip插件: <a href="https://blog.jetbrains.com/datagrip/tag/clickhouse/" target="_blank" rel="noopener">https://blog.jetbrains.com/datagrip/tag/clickhouse/</a><br><a href="http://www.clickhouse.com.cn/topic/5b6ce6359d28dfde2ddc6229" target="_blank" rel="noopener">http://www.clickhouse.com.cn/topic/5b6ce6359d28dfde2ddc6229</a></li>
</ul>
<h2 id="可用性高"><a href="#可用性高" class="headerlink" title="可用性高"></a>可用性高</h2><p>任何时候随时可以给表添加字段、属性、维度，不会拖慢或影响集群运行速度。<br>BI系统很大的一个痛点是维度的<strong>组合爆炸</strong>，而且经常需要新增，clickhouse针对性地优化了这一点。(如果是mysql要新增维度列,需要重做整个表,即使是mysql8的瞬加字段也不行)</p>
<p>流水线式的数据处理流程，数据一旦进入系统，那么立即处于可以使用的状态，边读（查询）边写没有任何压力。</p>
<h1 id="How-clickhouse的底层实现原理"><a href="#How-clickhouse的底层实现原理" class="headerlink" title="How: clickhouse的底层实现原理"></a>How: clickhouse的底层实现原理</h1><p>主要思想是根据OLAP的特征舍弃了一部分功能，然后针对性地优化了一部分功能。主要方法包括LSM（MergeTree系列表引擎）、稀疏索引（缓存友好）、列式存储+数据压缩、VectorWise、用概率算法进行近似等等。</p>
<h2 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h2><h3 id="OLAP应用的特点"><a href="#OLAP应用的特点" class="headerlink" title="OLAP应用的特点:"></a>OLAP应用的特点:</h3><ol>
<li>大多数是读请求</li>
<li>数据总是以相当大的批(&gt; 1000 rows)进行写入</li>
<li>不修改已添加的数据</li>
<li>每次查询都从数据库中读取大量的行，但是同时又仅需要少量的列</li>
<li>宽表，即每个表包含着大量的列</li>
<li>较少的查询(通常每台服务器每秒数百个查询或更少)</li>
<li>对于简单查询，允许延迟大约50毫秒</li>
<li>列中的数据相对较小： 数字和短字符串(例如，每个URL 60个字节)</li>
<li>处理单个查询时需要高吞吐量（每个服务器每秒高达数十亿行）</li>
<li>事务不是必须的</li>
<li>对数据一致性要求低</li>
<li>每一个查询除了一个大表外都很小</li>
<li>查询结果明显小于源数据，换句话说，数据被过滤或聚合后能够被盛放在单台服务器的内存中</li>
</ol>
<h3 id="面临的困难："><a href="#面临的困难：" class="headerlink" title="面临的困难："></a>面临的困难：</h3><ol>
<li>维度组合爆炸；</li>
<li>聚合数据后,如果有修改很蛋疼.</li>
<li>URL这种无法预聚合.</li>
</ol>
<h3 id="需求洞察"><a href="#需求洞察" class="headerlink" title="需求洞察:"></a>需求洞察:</h3><p>用户只关心聚合后中极小一部分</p>
<p>市场上的备胎: sparkSQL,Impala,Drill都不好用。</p>
<h3 id="舍弃的功能"><a href="#舍弃的功能" class="headerlink" title="舍弃的功能"></a>舍弃的功能</h3><ol>
<li>事务支持</li>
<li>快速修改、删除数据。 (可以低速批量删除、修改)</li>
<li>点查询(检索单行): 因为用的是稀疏索引。<br>(好处是稀疏所以索引能完全放入内存，范围查询很快)</li>
<li>高并发查询: 只支持100/s量级查询,对于内网应用、分析型业务足够。 </li>
<li>窗口函数。</li>
</ol>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>基于上述几点需求分析的优化:</p>
<ol>
<li>cpu: VectorWise方法,将压缩的列数据整理成现代CPU容易处理的Vector模式。利用现代CPU的多线程。 SIMD: 每次处理一批Vector数据。</li>
<li>提高内存利用率: 稀疏索引;</li>
<li>硬盘: MergeTree系列表引擎(LSM算法),批量合并写入,提高IO吞吐率;</li>
<li>算法: 近似算法/概率算法。</li>
</ol>
<p>架构: 表=&gt;shard=&gt;replica=&gt;partiton=&gt;part</p>
<h2 id="稀疏索引"><a href="#稀疏索引" class="headerlink" title="稀疏索引"></a>稀疏索引</h2><p>对应<code>index_granularity</code>参数:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">M(SettingUInt64, index_granularity, <span class="number">8192</span>, <span class="string">"How many rows correspond to one primary key value."</span>) \</span><br></pre></td></tr></table></figure>
<p>索引中相邻mark之间的数据行数,默认8192.<br>借助稀疏索引，它能存更多的索引在内存中。（相当于存了B树的前几层或二级索引）。</p>
<p>其他配置:<br><a href="https://github.com/yandex/ClickHouse/blob/master/dbms/src/Storages/MergeTree/MergeTreeSettings.h" target="_blank" rel="noopener">https://github.com/yandex/ClickHouse/blob/master/dbms/src/Storages/MergeTree/MergeTreeSettings.h</a></p>
<p>比如io配置:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">M(SettingUInt64, min_merge_bytes_to_use_direct_io, <span class="number">10U</span>LL * <span class="number">1024</span> * <span class="number">1024</span> * <span class="number">1024</span>, <span class="string">"Minimal amount of bytes to enable O_DIRECT in merge (0 - disabled)."</span>) \</span><br></pre></td></tr></table></figure>
<p>超过多少Bytes以后绕过内核缓冲，进行直接IO。(节省内存开销、数据复制开销)</p>
<p>其他配置的分三大块:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Merge settings. */</span> \    合并时的配置</span><br><span class="line"><span class="comment">/** Inserts settings. */</span> \  插入时的配置</span><br><span class="line"><span class="comment">/** Replication settings. */</span> \ 副本的配置</span><br><span class="line"><span class="comment">/** Check delay of replicas settings. */</span> \ 副本检查延迟配置</span><br><span class="line"><span class="comment">/** Compatibility settings */</span> \   兼容性配置</span><br></pre></td></tr></table></figure>

<h3 id="稀疏索引示例"><a href="#稀疏索引示例" class="headerlink" title="稀疏索引示例"></a>稀疏索引示例</h3><p>数据存储:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">全部数据  :     [-------------------------------------------------------------------------]</span><br><span class="line">CounterID:      [aaaaaaaaaaaaaaaaaabbbbcdeeeeeeeeeeeeefgggggggghhhhhhhhhiiiiiiiiikllllllll]</span><br><span class="line">Date:           [1111111222222233331233211111222222333211111112122222223111112223311122333]</span><br><span class="line">标记:            |      |      |      |      |      |      |      |      |      |      |</span><br><span class="line">                a,1    a,2    a,3    b,3    e,2    e,3    g,1    h,2    i,1    i,3    l,3</span><br><span class="line">标记号:          0      1      2      3      4      5      6      7      8      9      10</span><br></pre></td></tr></table></figure>
<ol>
<li>CounterID in (‘a’, ‘h’): [0, 3) 和 [6, 8) 区间</li>
<li>CounterID IN (‘a’, ‘h’) AND Date = 3 : [1, 3) 和 [7, 8) 区间</li>
<li>Date = 3: 扫全表。</li>
</ol>
<p>表由按主键排序的数据 <code>part</code> 组成。<br>当数据被插入到表中时，会分成<code>part</code>并按主键的字典序排序。例如，主键是 (CounterID, Date) 时，part中数据按 CounterID 排序，具有相同 CounterID 的部分按 Date 排序。</p>
<p>不会合并来自不同分区的数据片段。（性能考虑）<br>不保证相同主键的所有行都会合并到同一个数据片段中。(没有必要)</p>
<p>索引文件： 每个part创建一个<br>每隔index_granularity一个索引行号(mark)；<br>对于每列，跟主键相同的索引行处也会写入mark。这些mark让你可以直接找到数据所在的列。</p>
<h2 id="表引擎：MergeTree族引擎"><a href="#表引擎：MergeTree族引擎" class="headerlink" title="表引擎：MergeTree族引擎"></a>表引擎：MergeTree族引擎</h2><p>表引擎（即表的类型）决定了：</p>
<blockquote>
<p>数据的存储方式和位置，写到哪里以及从哪里读取数据<br>支持哪些查询以及如何支持。<br>并发数据访问。<br>索引的使用（如果存在）。<br>是否可以执行多线程请求。<br>数据复制参数。</p>
</blockquote>
<p>clickhouse中最强大的都是合并树引擎系列。</p>
<ul>
<li><p>理念:<br>批量写入,后台合并;</p>
</li>
<li><p>特点:</p>
</li>
</ul>
<ol>
<li>数据按主键排序; (类似于聚簇)</li>
<li>允许使用主键分区; (类似于Hive)</li>
<li>ReplicatedMergeTree系列支持副本(类似于hdfs)</li>
<li>支持数据采样;(类似于Mysql performanceSchema)</li>
</ol>
<p>建表语句:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> [<span class="keyword">IF</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span>] [db.]table_name [<span class="keyword">ON</span> CLUSTER cluster]</span><br><span class="line">(</span><br><span class="line">    name1 [type1] [<span class="keyword">DEFAULT</span>|<span class="keyword">MATERIALIZED</span>|<span class="keyword">ALIAS</span> expr1],</span><br><span class="line">    name2 [type2] [<span class="keyword">DEFAULT</span>|<span class="keyword">MATERIALIZED</span>|<span class="keyword">ALIAS</span> expr2],</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">INDEX</span> index_name1 expr1 <span class="keyword">TYPE</span> type1(...) GRANULARITY value1,</span><br><span class="line">    <span class="keyword">INDEX</span> index_name2 expr2 <span class="keyword">TYPE</span> type2(...) GRANULARITY value2</span><br><span class="line">) <span class="keyword">ENGINE</span> = MergeTree()</span><br><span class="line">[<span class="keyword">PARTITION</span> <span class="keyword">BY</span> expr]</span><br><span class="line">[<span class="keyword">ORDER</span> <span class="keyword">BY</span> expr]</span><br><span class="line">[PRIMARY <span class="keyword">KEY</span> expr]</span><br><span class="line">[<span class="keyword">SAMPLE</span> <span class="keyword">BY</span> expr]</span><br><span class="line">[<span class="keyword">SETTINGS</span> <span class="keyword">name</span>=<span class="keyword">value</span>, ...]</span><br></pre></td></tr></table></figure>
<p>示例语句:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ENGINE MergeTree() </span><br><span class="line">PARTITION BY toYYYYMM(EventDate) </span><br><span class="line">ORDER BY (CounterID, EventDate, intHash32(UserID)) </span><br><span class="line">SAMPLE BY intHash32(UserID) </span><br><span class="line">SETTINGS index_granularity=8192</span><br></pre></td></tr></table></figure>
<p>默认情况下主键跟排序键（由 ORDER BY 子句指定）相同。<br>这里可以看出它不支持唯一索引,重复是很自然的。由上层自己保证。</p>
<p>SummingMergeTree 和 AggregatingMergeTree 引擎中<br>列分为两种:</p>
<ul>
<li>维度</li>
<li>度量 (各种pv,uv等等)</li>
</ul>
<p>Mysql的做法是把所有维度作为主键; (每次新增维度很痛)<br>clickhouse的推荐做法是把旧的维度作为主键(保留少量),所有维度(旧维度+新维度)作为排序列。<br>这里排序列的修改是轻量级的:<br>旧的维度是整体排序列的前缀(已然有序)，仅需排序新加的行。</p>
<p>推荐使用方案:<br>原始数据=&gt; MergeTree （确保原始数据不丢失）<br>原始数据=&gt; SummingMergeTree/AggregatingMergeTree (得到预聚合数据)</p>
<blockquote>
<p>引擎会定期合并相同主键的数据进行聚合。最终结果中多半还是有重复主键，但是同一个part中不会有。</p>
</blockquote>
<p>具体来说：<br><code>SummingMergeTree</code>: 把相同排序列的行聚合。<br>被聚合的列在建表语句中通过<code>columns</code>指定。（数值、非主键）<br>(如果<code>columns</code>为空会聚合所有非排序列)</p>
<p>特殊情况:</p>
<ol>
<li>某行所有度量列值都是0，直接删除该行;(sum优化)</li>
<li>非数值(无法汇总): 随机选一个值.</li>
<li>支持sumMap函数: 某列是map结构。</li>
</ol>
<h4 id="AggregatingMergeTree引擎"><a href="#AggregatingMergeTree引擎" class="headerlink" title="AggregatingMergeTree引擎"></a>AggregatingMergeTree引擎</h4><p><code>SummingMergeTree</code>只支持算pv,<code>AggregatingMergeTree</code>能支持算uv,分位数,抽样,三个函数:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">uniq</span><br><span class="line">anyIf (any+If)</span><br><span class="line">quantiles</span><br></pre></td></tr></table></figure>

<p><strong>创建:</strong>(物化视图)</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">MATERIALIZED</span> <span class="keyword">VIEW</span> test.basic</span><br><span class="line"><span class="keyword">ENGINE</span> = AggregatingMergeTree() <span class="keyword">PARTITION</span> <span class="keyword">BY</span> toYYYYMM(StartDate) </span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> (CounterID, StartDate)</span><br><span class="line"><span class="keyword">AS</span> <span class="keyword">SELECT</span></span><br><span class="line">    CounterID,</span><br><span class="line">    StartDate,</span><br><span class="line">    sumState(<span class="keyword">Sign</span>)    <span class="keyword">AS</span> Visits, <span class="comment">-- 聚合1: pv</span></span><br><span class="line">    uniqState(UserID) <span class="keyword">AS</span> <span class="keyword">Users</span>  <span class="comment">-- 聚合2: uv 注意是记录了状态(特定的二进制表示法)</span></span><br><span class="line"><span class="keyword">FROM</span> test.visits</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> CounterID, StartDate;</span><br></pre></td></tr></table></figure>
<p>插入数据的时候只需要插入到<code>test.visits</code>.<br>视图中也会有数据，并且会聚合。</p>
<p><strong>查询:</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    StartDate,</span><br><span class="line">    sumMerge(Visits) <span class="keyword">AS</span> Visits, <span class="comment">-- 注意都变成了merge后缀</span></span><br><span class="line">    uniqMerge(<span class="keyword">Users</span>) <span class="keyword">AS</span> <span class="keyword">Users</span></span><br><span class="line"><span class="keyword">FROM</span> test.basic</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> StartDate</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> StartDate;</span><br></pre></td></tr></table></figure>

<h2 id="算法-uniq"><a href="#算法-uniq" class="headerlink" title="算法: uniq"></a>算法: uniq</h2><p>上一节中<code>AggregatingMergeTree</code>的uniq求uv,其实有三个函数:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">uniq: 用UniquesHashSet近似求uv（BJKST算法）</span><br><span class="line">uniqHLL12: 用HLL近似求uv </span><br><span class="line">uniqExact: 用HashSet精确求uv</span><br></pre></td></tr></table></figure>

<p>源码见:<br><a href="https://github.com/yandex/ClickHouse/blob/master/dbms/src/AggregateFunctions/AggregateFunctionUniq.cpp" target="_blank" rel="noopener">https://github.com/yandex/ClickHouse/blob/master/dbms/src/AggregateFunctions/AggregateFunctionUniq.cpp</a></p>
<p>其中HLL就是HyperLogLog算法。</p>
<p>而第一个<code>UniquesHashSet</code>(<a href="https://github.com/yandex/ClickHouse/blob/ef50601b5ceeeaf5763eab6c0013954c12eb00b1/dbms/src/AggregateFunctions/UniquesHashSet.h" target="_blank" rel="noopener">https://github.com/yandex/ClickHouse/blob/ef50601b5ceeeaf5763eab6c0013954c12eb00b1/dbms/src/AggregateFunctions/UniquesHashSet.h</a>)<br>两者的思想都是uv越大,不同的hash值越多。</p>
<p><code>UniquesHashSet</code>的特点是内存消耗小,性能高。<br>具体实现是将输入hash到UInt32,然后插入到数组中,如果遇到碰撞则进行线性探测. (原始输入丢弃,只存hash值)随着插入进行达到阈值<code>UNIQUES_HASH_MAX_SIZE</code>时，则将当前存的值丢弃一半,只保留能整除2的值,提高<code>skip_degree</code>值,然后开始只接受能整除2的输入。依此类推,后续就是只接受整除4，8，16的值。最后获取结果:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (<span class="number">0</span> == skip_degree)</span><br><span class="line">           <span class="keyword">return</span> m_size;</span><br><span class="line">       <span class="keyword">size_t</span> res = m_size * (<span class="number">1U</span>LL &lt;&lt; skip_degree);</span><br><span class="line">       <span class="comment">/** Pseudo-random remainder - in order to be not visible,</span></span><br><span class="line"><span class="comment">         * that the number is divided by the power of two.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">       res += (intHashCRC32(m_size) &amp; ((<span class="number">1U</span>LL &lt;&lt; skip_degree) - <span class="number">1</span>));</span><br><span class="line">       <span class="comment">/** Correction of a systematic error due to collisions during hashing in UInt32.</span></span><br><span class="line"><span class="comment">         * `fixed_res(res)` formula</span></span><br><span class="line"><span class="comment">         * - with how many different elements of fixed_res,</span></span><br><span class="line"><span class="comment">         *   when randomly scattered across 2^32 buckets,</span></span><br><span class="line"><span class="comment">         *   filled buckets with average of res is obtained.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">       <span class="keyword">size_t</span> p32 = <span class="number">1U</span>LL &lt;&lt; <span class="number">32</span>;</span><br><span class="line">       <span class="keyword">size_t</span> fixed_res = round(p32 * (<span class="built_in">log</span>(p32) - <span class="built_in">log</span>(p32 - res)));</span><br><span class="line">       <span class="keyword">return</span> fixed_res;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>rehash的实现:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rehash</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; buf_size(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (buf[i] &amp;&amp; !good(buf[i]))</span><br><span class="line">            &#123;</span><br><span class="line">                buf[i] = <span class="number">0</span>;</span><br><span class="line">                --m_size;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/** After removing the elements, there may have been room for items,</span></span><br><span class="line"><span class="comment">          * which were placed further than necessary, due to a collision.</span></span><br><span class="line"><span class="comment">          * You need to move them.</span></span><br><span class="line"><span class="comment">          */</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; buf_size(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (unlikely(buf[i] &amp;&amp; i != place(buf[i])))</span><br><span class="line">            &#123;</span><br><span class="line">                HashValue x = buf[i];</span><br><span class="line">                buf[i] = <span class="number">0</span>;</span><br><span class="line">                reinsertImpl(x);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>其中good函数含义就是能否被2^skip_degree整除。</p>
<ul>
<li>线性探测：<br>为了加快速度，增加了一个假设: 所有数据只插入Key/更新Key，不删除Key。<br>(这个假设在大数据处理/统计的场景下，大多都是成立的，spark中openHashSet也是线性探测)<br>有了这个假设它可以去掉拉链表，使用线性探测来实现哈希表。</li>
<li>内存利用率高: 去掉了8B指针结构，能够创建更大的哈希表，冲突减少；</li>
<li>内存紧凑: 位图操作快，一个内存page就能放下很多位图，8B就能放64个位置，缓存友好(while循环pos++)。</li>
</ul>
<h2 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h2><p>假如表结构是:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> test.mergetree1 </span><br><span class="line">(sdt  <span class="built_in">Date</span></span><br><span class="line">, <span class="keyword">id</span> UInt16</span><br><span class="line">, <span class="keyword">name</span> <span class="keyword">String</span></span><br><span class="line">, cnt UInt16) </span><br><span class="line"><span class="keyword">ENGINE</span>=MergeTree(sdt, (<span class="keyword">id</span>, <span class="keyword">name</span>), <span class="number">10</span>);</span><br></pre></td></tr></table></figure>
<p>分区字段是日期sdt.<br>对应的目录结构:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">├── 20180601_20180601_1_1_0</span><br><span class="line">│   ├── checksums.txt</span><br><span class="line">│   ├── columns.txt <span class="comment">-- 元数据</span></span><br><span class="line">│   ├── id.bin <span class="comment">-- 压缩列</span></span><br><span class="line">│   ├── id.mrk <span class="comment">-- 索引mark</span></span><br><span class="line">│   ├── name.bin</span><br><span class="line">│   ├── name.mrk</span><br><span class="line">│   ├── cnt.bin</span><br><span class="line">│   ├── cnt.mrk </span><br><span class="line">│   ├── cnt.idx</span><br><span class="line">│   ├── primary.idx <span class="comment">-- 主键</span></span><br><span class="line">│   ├── sdt.bin</span><br><span class="line">│   └── sdt.mrk <span class="comment">-- 保存一下块偏移量</span></span><br><span class="line">├── 20180602_20180602_2_2_0</span><br><span class="line">│   └── ...</span><br><span class="line">├── 20180603_20180603_3_3_0</span><br><span class="line">│   └── ...</span><br><span class="line">├── format_version.txt</span><br><span class="line">└── detached <span class="comment">-- 破损数据</span></span><br></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>clickhouse为啥比hive/spark快:</p>
<ul>
<li>7*24小时都在后台预聚合.hive/spark计算的时候才申请资源,平时只占一点点;</li>
<li>可以用星型模型缩减数据类型、压缩友好;</li>
<li>计算过程没有hive/spark中的shuffle概念,全是mapAgg;</li>
</ul>
<p>clickhouse为啥比mysql快:(仅限clickhouse擅长的查询)</p>
<ul>
<li>预聚合</li>
<li>多核优化、vector优化更彻底</li>
<li>分区+稀疏索引,整个索引能放内存,然后并发查part(这点还是要结合多核优化)</li>
<li>根据排序键排序存放 </li>
</ul>
<p>优化的方面:</p>
<ol>
<li>cpu: VectorWise方法,将压缩的列数据整理成现代CPU容易处理的Vector模式。利用现代CPU的多线程。 SIMD: 每次处理一批Vector数据。</li>
<li>提高内存利用率: 稀疏索引;</li>
<li>硬盘: MergeTree系列表引擎(LSM算法),批量合并写入,提高IO吞吐率,牺牲随机读能力;</li>
<li>算法: 近似算法/概率算法,HLL\BJKST算法等。</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://xiaoyue26.github.io/2019/07/06/2019-07/%E7%B2%97%E4%BF%97%E7%90%86%E8%A7%A3clickhouse/" data-id="ck96cxppz00j2maamamimdlei" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/clickhouse/" rel="tag">clickhouse</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-2019-06/io中的缓冲" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/06/22/2019-06/io%E4%B8%AD%E7%9A%84%E7%BC%93%E5%86%B2/" class="article-date">
  <time datetime="2019-06-22T02:56:52.000Z" itemprop="datePublished">2019-06-22</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/java/">java</a>►<a class="article-category-link" href="/categories/java/Netty/">Netty</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/06/22/2019-06/io%E4%B8%AD%E7%9A%84%E7%BC%93%E5%86%B2/">io中的缓冲——如何理解O_Direct</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <p>IO缓冲主要有4层:<br>1.用户自己的缓冲;<br>2.库缓冲;<br>3.内核缓冲;<br>4.磁盘缓冲。</p>
<img src="/images/2019-06/io_layer.gif" class="" width="400" height="600" title="io_layer">
<p>=== 应用层: (进程挂丢数据) 看到文件句柄<br><code>application buffer</code>: 比如我们代码中写的int[]arrayData;<br><code>clib buffer</code>: <code>fwrite</code>以后到这层。这里写的是c库(<code>IObuffer</code>)，也可能是java库中的缓冲(<code>BufferedOutputStream</code>)。<br>如果数据才到这一层库缓冲，还没系统调用，此时程序core dump的话，数据就丢了。<br>=== 内核层: (内核挂丢数据)  看到inode和数据块<br><code>page cache</code>: 内核层的缓冲。fflush以后到这里, fclose先到这里然后继续到磁盘。<br><code>driver</code>: 具体设备的驱动软件<br>=== 设备层: （断电丢数据） 看到扇区<br><code>disk cache</code>: 磁盘缓冲。fsync/fclose至少到这里。fsync是同步会完全等返回。</p>
<h2 id="为啥要有库缓冲"><a href="#为啥要有库缓冲" class="headerlink" title="为啥要有库缓冲"></a>为啥要有库缓冲</h2><p>（比如<code>clib buffer</code>）<br>因为从应用层到内核层需要系统调用、内核态切换，开销比较大，为了减少这件事发生的次数，没有必要因为1个字节的改动发生系统调用。</p>
<h3 id="绕过库缓冲的方案"><a href="#绕过库缓冲的方案" class="headerlink" title="绕过库缓冲的方案:"></a>绕过库缓冲的方案:</h3><p>用mmap(内存映射文件),把内核空间的page cache映射到用户空间。</p>
<h2 id="为啥要有内核缓冲"><a href="#为啥要有内核缓冲" class="headerlink" title="为啥要有内核缓冲"></a>为啥要有内核缓冲</h2><p>内核用pdflush线程循环检测脏页,判断是否写回磁盘。<br>由于磁盘是单向旋转,重新排布写操作顺序可以减少旋转次数。(合并写入)<br>plus:<br><code>O_SYNC</code>参数: 访问内核缓冲时是异步还是同步。<code>O_SYNC</code>表示同步。</p>
<h3 id="绕过内核缓冲的方案"><a href="#绕过内核缓冲的方案" class="headerlink" title="绕过内核缓冲的方案"></a>绕过内核缓冲的方案</h3><p>用<code>O_Direct</code>参数，直接怼Disk cache。</p>
<h2 id="为啥要有磁盘缓冲"><a href="#为啥要有磁盘缓冲" class="headerlink" title="为啥要有磁盘缓冲"></a>为啥要有磁盘缓冲</h2><p>驱动通过DMA，将数据写入磁盘cache。<br>磁盘缓冲主要是保护磁盘不被cpu写坏。是与外部总线交换数据的场所。（断电丢数据）</p>
<h4 id="绕过磁盘缓冲的方案"><a href="#绕过磁盘缓冲的方案" class="headerlink" title="绕过磁盘缓冲的方案"></a>绕过磁盘缓冲的方案</h4><p>用<code>RAW设备写</code>,直接写扇区: fdisk,dd,cpio工具。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://xiaoyue26.github.io/2019/06/22/2019-06/io%E4%B8%AD%E7%9A%84%E7%BC%93%E5%86%B2/" data-id="ck96cxppt00inmaam0iy74lrn" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/io/" rel="tag">io</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-2019-06/领域驱动设计-第一-六章笔记" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/06/08/2019-06/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1-%E7%AC%AC%E4%B8%80-%E5%85%AD%E7%AB%A0%E7%AC%94%E8%AE%B0/" class="article-date">
  <time datetime="2019-06-08T02:25:04.000Z" itemprop="datePublished">2019-06-08</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/java/">java</a>►<a class="article-category-link" href="/categories/java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/06/08/2019-06/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1-%E7%AC%AC%E4%B8%80-%E5%85%AD%E7%AB%A0%E7%AC%94%E8%AE%B0/">领域驱动设计-第一~六章笔记</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <p>领域驱动设计(DDD)这本书主要是讲抽象概念、理念、思想，具体可以有不同的实现，具体明确一些尺度或者细节。</p>
<h1 id="第一章-消化知识"><a href="#第一章-消化知识" class="headerlink" title="第一章 消化知识"></a>第一章 消化知识</h1><p>这一节主要讲了作者开发一个用于印刷电路板(PCB)的软件工具的过程。<br>他请教了相关专家，逐步建模。</p>
<h2 id="涉及到的角色："><a href="#涉及到的角色：" class="headerlink" title="涉及到的角色："></a>涉及到的角色：</h2><p>软件开发工程师、业务方</p>
<h2 id="涉及到的过程："><a href="#涉及到的过程：" class="headerlink" title="涉及到的过程："></a>涉及到的过程：</h2><p>需求分析、提炼模型<br>消化PCB相关的业务知识、<br>形成业务方和开发工程师都能看懂的共同语言/名词（类似于DSL）</p>
<p>我的理解是相当于产品做需求分析的那步，由程序员直接参与，快速迭代讨论形成DSL，省得吃产品理解的二手需求经常出错。</p>
<h2 id="DSL相关"><a href="#DSL相关" class="headerlink" title="DSL相关:"></a>DSL相关:</h2><p>1.4节还提到用策略设计模式来写代码，让需求方也能看懂代码中运用的策略（可读性），让DSL范围扩散到架构图和顶层代码。</p>
<h1 id="第二章-语言的使用"><a href="#第二章-语言的使用" class="headerlink" title="第二章 语言的使用"></a>第二章 语言的使用</h1><p>按我理解还是要形成DSL，图简略。<br>语言精简程度=&gt;大量使用短语。</p>
<h1 id="第三章-绑定模型和实现"><a href="#第三章-绑定模型和实现" class="headerlink" title="第三章 绑定模型和实现"></a>第三章 绑定模型和实现</h1><p>模型和实现要对应，不然就难以维护实现，模型失去意义。<br>推荐了一下面向对象编程。<br>建模与代码实现不能完全分离。</p>
<h1 id="第二部分-模型驱动设计的构造块"><a href="#第二部分-模型驱动设计的构造块" class="headerlink" title="第二部分 模型驱动设计的构造块"></a>第二部分 模型驱动设计的构造块</h1><p>设计原则：职责驱动<br>（SOLID原则）</p>
<img src="/images/2019-06/vo.png" class="" width="800" height="1200" title="vo">

<p>模型驱动涉及到的几个构造块的概念：<br><code>Service</code>: 服务;<br><code>Entity</code>: 实体,可以理解成数据库中的一张表;<br><code>Value Object</code>: 值对象,传输中的不可变对象,为了明确不可变的特性;<br><code>Factory</code>: 工厂;<br><code>Reposity</code>: 负责隐藏存储层细节;<br><code>Aggregate</code>: 负责封装多组VO/实体，聚合;(有说法这个不是某个类，而是一个虚拟概念)<br><code>Aggregate Root</code>: 一个实体，作为网关服务，修改生成Aggregate，服务给外界.（我理解就是粗粒度封装entity,减少整个领域的接口数量、暴露在外的引用数量）</p>
<p>领域外的术语:<br><code>DTO</code>: 和VO太像了; 但不在领域驱动的语境里；<br><code>POJO</code>: 纯粹属于语法语境了;</p>
<h1 id="第四章-分离领域"><a href="#第四章-分离领域" class="headerlink" title="第四章 分离领域"></a>第四章 分离领域</h1><img src="/images/2019-06/ddd_layer.png" class="" width="800" height="1200" title="ddd_layer">

<p>分离领域，也就是分层架构，然后重点是把领域层分离出来。<br>ddd的四个概念层:</p>
<ul>
<li>UI层/表示层: view</li>
<li>应用层: 尽量薄,按我理解就是controller</li>
<li>领域层/模型层: 业务概念、状态、规则（按我理解就是logic）</li>
<li>基础设施层：持久化、消息传递、UI渲染</li>
</ul>
<p>层之间松散连接、单向依赖。<br>如果下层要调用上层: 回调、观察者模式。</p>
<p>不要把所有东西都放到<code>applicationContext</code>里头，只放助于解耦的部分。<br>这个是出于性能考虑，毕竟spring是用一个<code>concurrentHashMap</code>作为Ioc容器的。啥都往里头奔放了。<br>(可以只放大粒度对象。</p>
<p>smartUI: 就是在UI代码里写很多逻辑,巨复杂不好维护。不推荐。</p>
<h1 id="第五章-软件中所表示的模型"><a href="#第五章-软件中所表示的模型" class="headerlink" title="第五章 软件中所表示的模型"></a>第五章 软件中所表示的模型</h1><p><code>Entity</code>: 实体,可以跨实现跟踪,(可以在数据库中查到).<br><code>Value Object</code>: <code>VO</code>, 仅用于传输，是某个状态的镜像，不可变。<br><code>Service</code>: 服务，只封装方法,无状态，可以放心调用。粒度中等为好。</p>
<h2 id="简化关系"><a href="#简化关系" class="headerlink" title="简化关系"></a>简化关系</h2><p>遇到多对多、双向关联关系，可以寻找自然偏向，从而把它简化为：1对多，单向关联。</p>
<p>例子:<br>一般问美国1790年的总统是谁，而比较少问<code>华盛顿</code>是哪个国家的总统。<br>所以国家和总统的关系可以简化为单向。</p>
<h1 id="第六章-领域对象的生命周期"><a href="#第六章-领域对象的生命周期" class="headerlink" title="第六章 领域对象的生命周期"></a>第六章 领域对象的生命周期</h1><h2 id="Aggregate"><a href="#Aggregate" class="headerlink" title="Aggregate"></a>Aggregate</h2><p> 根/<code>Aggregate Root</code>: 汽车Entity<br> 边界内实体/<code>Entity</code>: 轮胎</p>
<p> <code>Aggregate</code>外部只引用根。(利于垃圾收集)<br> 边界内其他实体以<code>Value Object</code>形式交付给外部。(不可变，利于修改可控,修改由根控制，保证一致性)</p>
<h2 id="Factory"><a href="#Factory" class="headerlink" title="Factory"></a>Factory</h2><p> 创建对象或Aggregate工作很复杂的时候，可以引入Factory来封装。<br> Factory的设计模式包括:</p>
<ul>
<li><p>简单工厂: 对字符串switch case;或传入类名,反射创建对象;</p>
</li>
<li><p>工厂: 不把所有创建放一个类,每个类有自己的工厂,巨啰嗦;(符合开闭原则,用冗余来获取简单)</p>
</li>
<li><p>抽象工厂</p>
</li>
<li><p>Builder模式</p>
<p>Factory的作用:</p>
<ol>
<li>把和运行时工作无关的复杂创建逻辑抽离到别的地方；</li>
<li>解耦两个类的关联：(跨Agg边界的两个类) 比如需要用账号类创建交易对象，但是本质上账号对象和交易对象关系比较弱，可以用工厂来创建，这样耦合度低一些。</li>
</ol>
</li>
</ul>
<p>防止Factory的滥用导致类膨胀，正常情况直接用构造函数。<br>Factory还可以负责反序列化，重建对象。</p>
<h2 id="Repository"><a href="#Repository" class="headerlink" title="Repository"></a>Repository</h2><p>封装对数据的访问,方便随时切换底层实现(内存哑实现、缓存)</p>
<h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><p><code>repository</code>不封装事务，事务的决定权留给调用方。</p>
<h2 id="Factory-vs-Repository"><a href="#Factory-vs-Repository" class="headerlink" title="Factory vs Repository"></a>Factory vs Repository</h2><p><code>Factory</code>: 生命周期的开始(Entity的创建);<br><code>Repository</code>: 生命周期的中间和结束(从数据库查出数据重建Entity不算新建).</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://xiaoyue26.github.io/2019/06/08/2019-06/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1-%E7%AC%AC%E4%B8%80-%E5%85%AD%E7%AB%A0%E7%AC%94%E8%AE%B0/" data-id="ck96cxppw00iumaam2vgl7oiv" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/DDD/" rel="tag">DDD</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AE%BE%E8%AE%A1/" rel="tag">设计</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-2019-05/spark-sql中的分位数算法" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/05/26/2019-05/spark-sql%E4%B8%AD%E7%9A%84%E5%88%86%E4%BD%8D%E6%95%B0%E7%AE%97%E6%B3%95/" class="article-date">
  <time datetime="2019-05-26T12:36:51.000Z" itemprop="datePublished">2019-05-26</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/spark/">spark</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/05/26/2019-05/spark-sql%E4%B8%AD%E7%9A%84%E5%88%86%E4%BD%8D%E6%95%B0%E7%AE%97%E6%B3%95/">spark-sql中的分位数算法</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <p>spark有两个分位数算法:</p>
<ol>
<li><code>percentile</code>: 接受Int,Long,精确计算。底层用OpenHashMap,计数，然后排序key;</li>
<li><code>percentile_approx</code>：接受Int,Long,Double,近似计算。用的GK算法。论文参见《Space-efficient Online Computation of Quantile Summaries》(<a href="http://dx.doi.org/10.1145/375663.375670" target="_blank" rel="noopener">http://dx.doi.org/10.1145/375663.375670</a>)<br>基本思想是以最小空间完成分位数统计，比如把相邻的1w个数压缩成(平均数,个数)元组。如果空间够用，就不进行这种压缩。（所以如果如果统计90分位数，传入的精度参数至少应为10，如果统计999分位数，传入的精度参数至少为1000，默认精度是10000。）</li>
</ol>
<p>俩算法和Hive版本的基本是一样的。<br>区别: </p>
<ol>
<li>spark的percentile多了一个频次参数,也就是可以接受分阶段聚合；(percentile_approx木有)</li>
<li>spark底层用的openHashMap,速度快5倍,内存消耗更少。</li>
</ol>
<h2 id="为啥OpenHashMap性能优于HashMap"><a href="#为啥OpenHashMap性能优于HashMap" class="headerlink" title="为啥OpenHashMap性能优于HashMap?"></a>为啥OpenHashMap性能优于HashMap?</h2><p><a href="https://github.com/apache/spark/blob/master/core/src/main/scala/org/apache/spark/util/collection/OpenHashMap.scala" target="_blank" rel="noopener">https://github.com/apache/spark/blob/master/core/src/main/scala/org/apache/spark/util/collection/OpenHashMap.scala</a><br><a href="https://github.com/apache/spark/blob/master/core/src/main/scala/org/apache/spark/util/collection/OpenHashSet.scala" target="_blank" rel="noopener">https://github.com/apache/spark/blob/master/core/src/main/scala/org/apache/spark/util/collection/OpenHashSet.scala</a><br>OpenHashMap为了加快速度，增加了一个假设: 所有数据只插入Key/更新Key，不删除Key。<br>(这个假设在大数据处理/统计的场景下，大多都是成立的)<br>有了这个假设它可以去掉拉链表，使用线性探测的开放定址法来实现哈希表。</p>
<p>OpenHashMap底层数据委托给了OpenHashSet，所以本质上是看OpenHashSet为啥快。<br><code>OpenHashSet</code>用BitSet(位图)来存储在不在集合中(位运算，很快)，另开一个数组存储实际数据：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">var</span> _bitset = <span class="keyword">new</span> <span class="type">BitSet</span>(_capacity)</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">var</span> _data: <span class="type">Array</span>[<span class="type">T</span>] = _</span><br><span class="line">  _data = <span class="keyword">new</span> <span class="type">Array</span>[<span class="type">T</span>](_capacity)</span><br></pre></td></tr></table></figure>
<p>这俩成员始终保持等长，_bitset的下标x位置为1时，_data的下标x位置为中就有实际数据。(手动维持联动)<br>插入数据时，hash一下key生成pos，看看_bitset中对应位置有没有被占用，有的话就死循环++pos：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">addWithoutResize</span></span>(k: <span class="type">T</span>): <span class="type">Int</span> = &#123;</span><br><span class="line">    <span class="keyword">var</span> pos = hashcode(hasher.hash(k)) &amp; _mask</span><br><span class="line">    <span class="keyword">var</span> delta = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!_bitset.get(pos)) &#123;</span><br><span class="line">        <span class="comment">// This is a new key.</span></span><br><span class="line">        _data(pos) = k</span><br><span class="line">        _bitset.set(pos)</span><br><span class="line">        _size += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> pos | <span class="type">NONEXISTENCE_MASK</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (_data(pos) == k) &#123;</span><br><span class="line">        <span class="comment">// Found an existing key.</span></span><br><span class="line">        <span class="keyword">return</span> pos</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// quadratic probing with values increase by 1, 2, 3, ...</span></span><br><span class="line">        pos = (pos + delta) &amp; _mask</span><br><span class="line">        delta += <span class="number">1</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">RuntimeException</span>(<span class="string">"Should never reach here."</span>)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>逻辑很简单，由于假设了不会删除key,线性探测法变得实用。</p>
<h3 id="小结一下OpenHashSet快的原因"><a href="#小结一下OpenHashSet快的原因" class="headerlink" title="小结一下OpenHashSet快的原因:"></a>小结一下OpenHashSet快的原因:</h3><ol>
<li>内存利用率高: 去掉了8B指针结构，能够创建更大的哈希表，冲突减少；</li>
<li>内存紧凑: 位图操作快，一个内存page就能放下很多位图，8B就能放64个位置，缓存友好(while循环pos++)。</li>
</ol>
<h1 id="percentile实现"><a href="#percentile实现" class="headerlink" title="percentile实现:"></a>percentile实现:</h1><p><code>Percentile.scala</code>文件:<br><a href="https://github.com/apache/spark/blob/master/sql/catalyst/src/main/scala/org/apache/spark/sql/catalyst/expressions/aggregate/Percentile.scala" target="_blank" rel="noopener">https://github.com/apache/spark/blob/master/sql/catalyst/src/main/scala/org/apache/spark/sql/catalyst/expressions/aggregate/Percentile.scala</a><br>首先看注释:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* Because the number of elements and their partial order cannot be determined in advance.</span><br><span class="line"> * Therefore we have to store all the elements in memory, and so notice that too many elements can</span><br><span class="line"> * cause GC paused and eventually OutOfMemory Errors.</span><br><span class="line">&#x2F;</span><br></pre></td></tr></table></figure>
<p>基本思想是把所有元素保存在内存中。<br>因此它其实支持两阶段聚合:<br><code>_FUNC_(col, percentage [, frequency])</code><br>可以传入一个参数frequency表示频次.<br>// 2017-02-07加上的特性，比我写hive版本的分阶段聚合udaf早了10个月。</p>
<h1 id="percentile-approx实现"><a href="#percentile-approx实现" class="headerlink" title="percentile_approx实现"></a>percentile_approx实现</h1><p>代码:<br><a href="https://github.com/apache/spark/blob/master/sql/catalyst/src/main/scala/org/apache/spark/sql/catalyst/expressions/aggregate/ApproximatePercentile.scala" target="_blank" rel="noopener">https://github.com/apache/spark/blob/master/sql/catalyst/src/main/scala/org/apache/spark/sql/catalyst/expressions/aggregate/ApproximatePercentile.scala</a><br><a href="https://github.com/apache/spark/blob/master/sql/catalyst/src/main/scala/org/apache/spark/sql/catalyst/util/QuantileSummaries.scala" target="_blank" rel="noopener">https://github.com/apache/spark/blob/master/sql/catalyst/src/main/scala/org/apache/spark/sql/catalyst/util/QuantileSummaries.scala</a><br>底层委托给<code>QuantileSummaries</code>实现的。<br>主要有俩个成员变量：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sample: Array[Stat] : 存放桶，超过1000个桶的时候就压缩（生成新的三元组）；</span><br><span class="line">headSampled: ArrayBuffer[Double]：缓冲区，每次达到5000个，就排序后更新到sample.</span><br></pre></td></tr></table></figure>
<p>主要思想是减少空间占用，因此很多排序，spark的实现merge sample的时候甚至都没有管俩sample已经有序了，直接sort了：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// <span class="doctag">TODO:</span> could replace full sort by ordered merge, the two lists are known to be sorted already.</span></span><br><span class="line"> <span class="keyword">val</span> res = (sampled ++ other.sampled).sortBy(_.value)</span><br><span class="line">  <span class="keyword">val</span> comp = compressImmut(res, mergeThreshold = <span class="number">2</span> * relativeError * count)</span><br><span class="line">  <span class="keyword">new</span> <span class="type">QuantileSummaries</span>(</span><br><span class="line">    other.compressThreshold, other.relativeError, comp, other.count + count)</span><br></pre></td></tr></table></figure>
<p>Stat的定义:</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Statistics from the Greenwald-Khanna paper.</span></span><br><span class="line"><span class="comment">  * @param value the sampled value</span></span><br><span class="line"><span class="comment">  * @param g the minimum rank jump from the previous value's minimum rank</span></span><br><span class="line"><span class="comment">  * @param delta the maximum span of the rank.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Stats</span>(<span class="params">value: <span class="type">Double</span>, g: <span class="type">Int</span>, delta: <span class="type">Int</span></span>)</span></span><br></pre></td></tr></table></figure>
<p>插入的函数:(每N个数，排序至少1次(merge还有1次)，因此是O(NlogN))</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insert</span></span>(x: <span class="type">Double</span>): <span class="type">QuantileSummaries</span> = &#123;</span><br><span class="line">    headSampled += x</span><br><span class="line">    <span class="keyword">if</span> (headSampled.size &gt;= defaultHeadSize) &#123;</span><br><span class="line">      <span class="keyword">val</span> result = <span class="keyword">this</span>.withHeadBufferInserted</span><br><span class="line">      <span class="keyword">if</span> (result.sampled.length &gt;= compressThreshold) &#123;</span><br><span class="line">        result.compress()</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        result</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">this</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>插入数据的其中一个步骤:</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">withHeadBufferInserted</span></span>: <span class="type">QuantileSummaries</span> = &#123;</span><br><span class="line">    <span class="keyword">if</span> (headSampled.isEmpty) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> currentCount = count</span><br><span class="line">    <span class="keyword">val</span> sorted = headSampled.toArray.sorted</span><br><span class="line">    <span class="keyword">val</span> newSamples: <span class="type">ArrayBuffer</span>[<span class="type">Stats</span>] = <span class="keyword">new</span> <span class="type">ArrayBuffer</span>[<span class="type">Stats</span>]()</span><br><span class="line">    <span class="comment">// The index of the next element to insert</span></span><br><span class="line">    <span class="keyword">var</span> sampleIdx = <span class="number">0</span></span><br><span class="line">    <span class="comment">// The index of the sample currently being inserted.</span></span><br><span class="line">    <span class="keyword">var</span> opsIdx: <span class="type">Int</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> (opsIdx &lt; sorted.length) &#123;</span><br><span class="line">      <span class="keyword">val</span> currentSample = sorted(opsIdx)</span><br><span class="line">      <span class="comment">// Add all the samples before the next observation.</span></span><br><span class="line">      <span class="keyword">while</span> (sampleIdx &lt; sampled.length &amp;&amp; sampled(sampleIdx).value &lt;= currentSample) &#123;</span><br><span class="line">        newSamples += sampled(sampleIdx)</span><br><span class="line">        sampleIdx += <span class="number">1</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// If it is the first one to insert, of if it is the last one</span></span><br><span class="line">      currentCount += <span class="number">1</span></span><br><span class="line">      <span class="keyword">val</span> delta =</span><br><span class="line">        <span class="keyword">if</span> (newSamples.isEmpty || (sampleIdx == sampled.length &amp;&amp; opsIdx == sorted.length - <span class="number">1</span>)) &#123;</span><br><span class="line">          <span class="number">0</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          math.floor(<span class="number">2</span> * relativeError * currentCount).toInt</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">val</span> tuple = <span class="type">Stats</span>(currentSample, <span class="number">1</span>, delta)</span><br><span class="line">      newSamples += tuple</span><br><span class="line">      opsIdx += <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Add all the remaining existing samples</span></span><br><span class="line">    <span class="keyword">while</span> (sampleIdx &lt; sampled.length) &#123;</span><br><span class="line">      newSamples += sampled(sampleIdx)</span><br><span class="line">      sampleIdx += <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">new</span> <span class="type">QuantileSummaries</span>(compressThreshold, relativeError, newSamples.toArray, currentCount)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>获取结果:O(n)</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Target rank</span></span><br><span class="line">    <span class="keyword">val</span> rank = math.ceil(quantile * count).toInt</span><br><span class="line">    <span class="keyword">val</span> targetError = math.ceil(relativeError * count)</span><br><span class="line">    <span class="comment">// Minimum rank at current sample</span></span><br><span class="line">    <span class="keyword">var</span> minRank = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> i = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; sampled.length - <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">val</span> curSample = sampled(i)</span><br><span class="line">      minRank += curSample.g</span><br><span class="line">      <span class="keyword">val</span> maxRank = minRank + curSample.delta</span><br><span class="line">      <span class="keyword">if</span> (maxRank - targetError &lt;= rank &amp;&amp; rank &lt;= minRank + targetError) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">Some</span>(curSample.value)</span><br><span class="line">      &#125;</span><br><span class="line">      i += <span class="number">1</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h1 id="优化思路"><a href="#优化思路" class="headerlink" title="优化思路"></a>优化思路</h1><p>结合yuange在微博/km上分享的思路，用计数器区代替密集数据区的hashmap(其实也是GK算法的精确版)。逼近O(N)复杂度。<br>// TODO benchmark、优化算法</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://xiaoyue26.github.io/2019/05/26/2019-05/spark-sql%E4%B8%AD%E7%9A%84%E5%88%86%E4%BD%8D%E6%95%B0%E7%AE%97%E6%B3%95/" data-id="ck96cxppq00icmaamdg6zaf5x" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/spark/" rel="tag">spark</a></li></ul>

    </footer>
  </div>
  
</article>
 


  


  <nav id="page-nav">
    <a class="extend prev" rel="prev" href="/page/2/">&amp;laquo; 上一页</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><span class="space">&hellip;</span><a class="page-number" href="/page/21/">21</a><a class="extend next" rel="next" href="/page/4/">下一页&amp;raquo;</a>
  </nav>
</section>
           
    <aside id="sidebar">
  
    

  
    
  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title recent-posts">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/05/05/2020-05/BeanCopier%E6%B5%8B%E8%AF%84%E6%8A%A5%E5%91%8A/">BeanCopier测评报告</a>
          </li>
        
          <li>
            <a href="/2020/04/19/2020-04/spring%E6%8B%BE%E9%81%97/">spring拾遗</a>
          </li>
        
          <li>
            <a href="/2020/03/26/2020-03/%E5%88%A9%E7%94%A8UTF-8%E7%BC%96%E7%A0%81%E7%9A%84%E7%89%B9%E6%80%A7%E8%BF%9B%E8%A1%8C%E4%BC%98%E5%8C%96/">利用UTF-8编码的特性进行优化</a>
          </li>
        
          <li>
            <a href="/2020/03/24/2020-03/linux%E8%87%AA%E8%BF%9E%E6%8E%A5/">linux自连接</a>
          </li>
        
          <li>
            <a href="/2020/03/23/2020-03/redis%E5%A4%A7key%E9%97%AE%E9%A2%98/">redis大key问题</a>
          </li>
        
      </ul>
    </div>
  </div>

  
    

  
</aside>

      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-left">
      &copy; 2014 - 2020 风梦七&nbsp;|&nbsp;
      主题 <a href="https://github.com/giscafer/hexo-theme-cafe/" target="_blank">Cafe</a>
    </div>
     <div id="footer-right">
      联系方式&nbsp;|&nbsp;296671657@qq.com
    </div>
  </div>
</footer>
 
<script src="/jquery/jquery.min.js"></script>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">首页</a>
  
    <a href="/archives" class="mobile-nav-link">归档</a>
  
    <a href="/about" class="mobile-nav-link">关于</a>
  
</nav>
    <img class="back-to-top-btn" src="/images/fly-to-top.png"/>
<script>
// Elevator script included on the page, already.
window.onload = function() {
  var elevator = new Elevator({
    selector:'.back-to-top-btn',
    element: document.querySelector('.back-to-top-btn'),
    duration: 1000 // milliseconds
  });
}
</script>
      

  
    <script>
      var cloudTieConfig = {
        url: document.location.href, 
        sourceId: "",
        productKey: "e2fb4051c49842688ce669e634bc983f",
        target: "cloud-tie-wrapper"
      };
    </script>
    <script src="https://img1.ws.126.net/f2e/tie/yun/sdk/loader.js"></script>
    

  







<!-- author:forvoid begin -->
<!-- author:forvoid begin -->

<!-- author:forvoid end -->

<!-- author:forvoid end -->


  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      })
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      })
    </script>
    <script type="text/javascript" src="https://cdn.rawgit.com/mathjax/MathJax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


 
<script src="/js/is.js"></script>



  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>


<script src="/js/elevator.js"></script>

  </div>
</body>
</html>