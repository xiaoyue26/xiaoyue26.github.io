<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>笔记本</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="笔记本">
<meta property="og:url" content="http://xiaoyue26.github.io/page/5/index.html">
<meta property="og:site_name" content="笔记本">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="风梦七">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="笔记本" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    
  
  
<link rel="stylesheet" href="/css/style.css">

  

<meta name="generator" content="Hexo 4.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    
    <div id="header-inner" class="inner">
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://xiaoyue26.github.io"></form>
      </div>
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">首页</a>
        
          <a class="main-nav-link" href="/archives">归档</a>
        
          <a class="main-nav-link" href="/about">关于</a>
        
      </nav>
      
    </div>
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">笔记本</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">风梦七</a>
        </h2>
      
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-2019-10/rust入门笔记-2" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/10/06/2019-10/rust%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0-2/" class="article-date">
  <time datetime="2019-10-06T10:58:26.000Z" itemprop="datePublished">2019-10-06</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/rust/">rust</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/10/06/2019-10/rust%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0-2/">rust入门笔记_2</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <h1 id="解引用强制多态（deref-coercions）"><a href="#解引用强制多态（deref-coercions）" class="headerlink" title="解引用强制多态（deref coercions）"></a>解引用强制多态（<code>deref coercions</code>）</h1><p><code>coercions</code>的意思就是强制多态。<br>解引用强制多态的意思通俗来说就是，编译器根据目标类型，自动调用<code>deref</code>方法解引用，搜索路径来达到目标类型，最终达到节省程序员编写成本，但最后运行时开销维持最小的目标。(语法糖成本为0)</p>
<h2 id="背景知识-智能指针的解引用"><a href="#背景知识-智能指针的解引用" class="headerlink" title="背景知识: 智能指针的解引用"></a>背景知识: 智能指针的解引用</h2><p>自定义的智能指针，实现<code>Deref trait</code>(解引用特性)后，就可以使用<code>*</code>操作符来解引用了。<br>例如:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::ops::Deref;</span><br><span class="line"></span><br><span class="line"># <span class="class"><span class="keyword">struct</span> <span class="title">MyBox</span></span>&lt;T&gt;(T);</span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; Deref <span class="keyword">for</span> MyBox&lt;T&gt; &#123;</span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">Target</span></span> = T;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">deref</span></span>(&amp;<span class="keyword">self</span>) -&gt; &amp;T &#123; <span class="comment">// 注意这里的返回值需要是引用,以便维持所有权</span></span><br><span class="line">        &amp;<span class="keyword">self</span>.<span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译器每次遇到<code>*</code>操作符，都会尝试调用复杂类型的<code>deref</code>方法来获得基本类型的引用，以便进行解引用，也就是代码等效于:<code>*(y.deref())</code>。</p>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> m = MyBox::new(<span class="built_in">String</span>::from(<span class="string">"Rust"</span>));</span><br><span class="line">hello(&amp;m); <span class="comment">// 这里hello的形参是&amp;str,实参是&amp;MyBox</span></span><br><span class="line"><span class="comment">// 强制解引用多态后，等效于调用了: hello(&amp;(*m)[..]);</span></span><br><span class="line"><span class="comment">// &amp;MyBox =通过deref=&gt; String =通过slice=&gt; &amp;str</span></span><br></pre></td></tr></table></figure>

<h2 id="更多解引用多态规则"><a href="#更多解引用多态规则" class="headerlink" title="更多解引用多态规则"></a>更多解引用多态规则</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>. 当 T: Deref&lt;Target=U&gt; 时从 &amp;T 到 &amp;U。 <span class="comment">// 不可变=&gt;不可变</span></span><br><span class="line"><span class="number">2</span>. 当 T: DerefMut&lt;Target=U&gt; 时从 &amp;<span class="keyword">mut</span> T 到 &amp;<span class="keyword">mut</span> U。 <span class="comment">// 可变=&gt;可变</span></span><br><span class="line"><span class="number">3</span>. 当 T: Deref&lt;Target=U&gt; 时从 &amp;<span class="keyword">mut</span> T 到 &amp;U。 <span class="comment">// 可变=&gt;不可变</span></span><br></pre></td></tr></table></figure>
<p>只会发生安全的转换，而<code>不可变=&gt;可变</code>这种属于不安全，因此不支持自动转换。</p>
<p>(上面的实例属于第一种。)</p>
<h1 id="析构函数-std-mem-drop"><a href="#析构函数-std-mem-drop" class="headerlink" title="(析构函数) std::mem::drop"></a>(析构函数) std::mem::drop</h1><p>自定义Drop trait:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="built_in">Drop</span> <span class="keyword">for</span> CustomSmartPointer &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">drop</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"Dropping CustomSmartPointer with data `&#123;&#125;`!"</span>, <span class="keyword">self</span>.data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定义以后drop函数不能显式调用，也不能禁用。<br>只能在离开作用域的时候自动调用。<br>如果要显式调用，只能使用标准库的函数<code>std::mem::drop</code>.<br>(默认预引入，可以直接调用drop)</p>
<h1 id="智能指针汇总"><a href="#智能指针汇总" class="headerlink" title="智能指针汇总"></a>智能指针汇总</h1><p>Box: 没有特殊功能,类似于java中的普通引用,让编译器能确定分配空间大小;<br>Rc: 多所有权、单线程、引用计数;<br>RefCell: 单所有权、单线程、引用计数、内部可变性;<br>Arc: 多所有权、多线程、引用计数;<br>Mutex: 单所有权、多线程、引用计数、内部可变性;<br>Week: 弱引用。</p>
<h1 id="多所有权、单线程、不可变：引用计数-gt-Rc"><a href="#多所有权、单线程、不可变：引用计数-gt-Rc" class="headerlink" title="多所有权、单线程、不可变：引用计数=&gt;Rc"></a>多所有权、单线程、不可变：引用计数=&gt;Rc<T></h1><p>多所有权示例: b,c都拥有a的所有权。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">List</span></span> &#123;</span><br><span class="line">    Cons(<span class="built_in">i32</span>, Rc&lt;List&gt;),</span><br><span class="line">    Nil,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> List::&#123;Cons, Nil&#125;;</span><br><span class="line"><span class="keyword">use</span> std::rc::Rc;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> a = Rc::new(Cons(<span class="number">5</span>, Rc::new(Cons(<span class="number">10</span>, Rc::new(Nil)))));</span><br><span class="line">    <span class="keyword">let</span> b = Cons(<span class="number">3</span>, Rc::clone(&amp;a));</span><br><span class="line">    <span class="keyword">let</span> c = Cons(<span class="number">4</span>, Rc::clone(&amp;a));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每次调用<code>Rc::clone</code>，都将引用计数加1.// 这里是浅拷贝<br>b: 3-&gt;5-&gt;10-&gt;Nil<br>c: 4-&gt;5-&gt;10-&gt;Nil</p>
<p>打印引用数:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> a = Rc::new(Cons(<span class="number">5</span>, Rc::new(Cons(<span class="number">10</span>, Rc::new(Nil)))));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"count after creating a = &#123;&#125;"</span>, Rc::strong_count(&amp;a));</span><br><span class="line">    <span class="keyword">let</span> b = Cons(<span class="number">3</span>, Rc::clone(&amp;a));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"count after creating b = &#123;&#125;"</span>, Rc::strong_count(&amp;a));</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> c = Cons(<span class="number">4</span>, Rc::clone(&amp;a));</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"count after creating c = &#123;&#125;"</span>, Rc::strong_count(&amp;a));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"count after c goes out of scope = &#123;&#125;"</span>, Rc::strong_count(&amp;a));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="单一所有权、单线程、内部可变：引用计数-gt-RefCell"><a href="#单一所有权、单线程、内部可变：引用计数-gt-RefCell" class="headerlink" title="单一所有权、单线程、内部可变：引用计数=&gt;RefCell"></a>单一所有权、单线程、内部可变：引用计数=&gt;RefCell<T></h1><h2 id="借用规则"><a href="#借用规则" class="headerlink" title="借用规则"></a>借用规则</h2><ol>
<li>每时每刻，要么有一个可变引用;要么有n个不可变引用；(这两者互斥)</li>
<li>引用必须总是有效的。</li>
</ol>
<p>对于引用和<code>Box&lt;T&gt;</code>: <code>编译时</code>进行借用规则检查；(编译错误)<br>对于<code>RefCell&lt;T&gt;</code>:   <code>运行时</code>进行借用规则检查；(<code>panic</code>)</p>
<p>引用和<code>Box&lt;T&gt;</code>: 第一级指针不可变，则级联得每一级都不可变。<br><code>RefCell</code>: 第一级指针不可变，第二级可以借用可变引用，然后修改；</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[cfg(test)]</span></span><br><span class="line"><span class="keyword">mod</span> tests &#123;</span><br><span class="line">    <span class="keyword">use</span> super::*;</span><br><span class="line">    <span class="keyword">use</span> std::cell::RefCell;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">MockMessenger</span></span> &#123;</span><br><span class="line">        sent_messages: RefCell&lt;<span class="built_in">Vec</span>&lt;<span class="built_in">String</span>&gt;&gt;,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">impl</span> MockMessenger &#123;</span><br><span class="line">        <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>() -&gt; MockMessenger &#123;</span><br><span class="line">            MockMessenger &#123; sent_messages: RefCell::new(<span class="built_in">vec!</span>[]) &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">impl</span> Messenger <span class="keyword">for</span> MockMessenger &#123;</span><br><span class="line">        <span class="function"><span class="keyword">fn</span> <span class="title">send</span></span>(&amp;<span class="keyword">self</span>, message: &amp;<span class="built_in">str</span>) &#123;</span><br><span class="line">        <span class="comment">// 注意这里的borrow_mut，借出可变:</span></span><br><span class="line">            <span class="keyword">self</span>.sent_messages.borrow_mut().push(<span class="built_in">String</span>::from(message));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">it_sends_an_over_75_percent_warning_message</span></span>() &#123;</span><br><span class="line">        <span class="comment">// --snip--</span></span><br><span class="line">#         <span class="keyword">let</span> mock_messenger = MockMessenger::new();</span><br><span class="line">#         <span class="keyword">let</span> <span class="keyword">mut</span> limit_tracker = LimitTracker::new(&amp;mock_messenger, <span class="number">100</span>);</span><br><span class="line">#         limit_tracker.set_value(<span class="number">75</span>);</span><br><span class="line">        <span class="comment">// 注意这里的borrow，借出不可变:</span></span><br><span class="line">        <span class="built_in">assert_eq!</span>(mock_messenger.sent_messages.borrow().len(), <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>borrow</code> 方法返回 <code>Ref</code> 类型的智能指针；<br><code>borrow_mut</code> 方法返回 <code>RefMut</code> 类型的智能指针。</p>
<p>这两个类型都实现了 <code>Deref</code> 所以可以当作常规引用对待。<br>借用规则在运行时检查，例如同时借出两个可变引用将会panic:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> one_borrow = <span class="keyword">self</span>.sent_messages.borrow_mut();</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> two_borrow = <span class="keyword">self</span>.sent_messages.borrow_mut();</span><br></pre></td></tr></table></figure>
<p>底层原理依然是引用计数。</p>
<h2 id="结合Rc和RefCell"><a href="#结合Rc和RefCell" class="headerlink" title="结合Rc和RefCell"></a>结合Rc和RefCell</h2><p>结合Rc和RefCell的话，就可以结合多所有权和单所有权，不可变和可变:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">List</span></span> &#123;</span><br><span class="line">    Cons(Rc&lt;RefCell&lt;<span class="built_in">i32</span>&gt;&gt;, Rc&lt;List&gt;),<span class="comment">// 注意这里</span></span><br><span class="line">    Nil,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> List::&#123;Cons, Nil&#125;;</span><br><span class="line"><span class="keyword">use</span> std::rc::Rc;</span><br><span class="line"><span class="keyword">use</span> std::cell::RefCell;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> value = Rc::new(RefCell::new(<span class="number">5</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> a = Rc::new(Cons(Rc::clone(&amp;value), Rc::new(Nil)));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> b = Cons(Rc::new(RefCell::new(<span class="number">6</span>)), Rc::clone(&amp;a));</span><br><span class="line">    <span class="keyword">let</span> c = Cons(Rc::new(RefCell::new(<span class="number">10</span>)), Rc::clone(&amp;a));</span><br><span class="line"></span><br><span class="line">    *value.borrow_mut() += <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"a after = &#123;:?&#125;"</span>, a);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"b after = &#123;:?&#125;"</span>, b);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"c after = &#123;:?&#125;"</span>, c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>混合使用<code>Rc</code>和<code>RefCell</code>可以构造循环引用，造成内存泄露。<br>可以用弱引用来消除这一隐患: 将 <code>Rc&lt;T&gt;</code> 变为 <code>Weak&lt;T&gt;</code>。</p>
<h1 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h1><p><a href="https://rustlang-cn.org/office/rust/book/smart-pointers/ch15-06-reference-cycles.html" target="_blank" rel="noopener">https://rustlang-cn.org/office/rust/book/smart-pointers/ch15-06-reference-cycles.html</a></p>
<h1 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h1><h2 id="线程模型"><a href="#线程模型" class="headerlink" title="线程模型"></a>线程模型</h2><p>rust标准库提供1:1线程，有其他第三方库提供M:N的。<br>创建线程: <code>thread::spawn</code>+闭包：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"><span class="keyword">use</span> std::time::Duration;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> handle = thread::spawn(|| &#123;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span>..<span class="number">10</span> &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">"hi number &#123;&#125; from the spawned thread!"</span>, i);</span><br><span class="line">            thread::sleep(Duration::from_millis(<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span>..<span class="number">5</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"hi number &#123;&#125; from the main thread!"</span>, i);</span><br><span class="line">        thread::sleep(Duration::from_millis(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    handle.join().unwrap();<span class="comment">// 阻塞等待子线程</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>子线程中可以捕获主线程的变量，获得所有权. 使用<code>move</code>，以免主线程把它drop了：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> v = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> handle = thread::spawn(<span class="keyword">move</span> || &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"Here's a vector: &#123;:?&#125;"</span>, v);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    handle.join().unwrap();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="消息传递-channel"><a href="#消息传递-channel" class="headerlink" title="消息传递: channel"></a>消息传递: channel</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"><span class="keyword">use</span> std::sync::mpsc;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> (tx, rx) = mpsc::channel();</span><br><span class="line">    <span class="comment">// tx: 发送者</span></span><br><span class="line">    <span class="comment">// rx: 接收者</span></span><br><span class="line">    thread::spawn(<span class="keyword">move</span> || &#123;</span><br><span class="line">        <span class="keyword">let</span> val = <span class="built_in">String</span>::from(<span class="string">"hi"</span>);</span><br><span class="line">        tx.send(val).unwrap();<span class="comment">// 单所有权,发送后不能再使用val</span></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> received = rx.recv().unwrap();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Got: &#123;&#125;"</span>, received);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>mpsc： 多生产者、单消费者<br>recv： 阻塞接收<br>try_recv: 非阻塞接收，立即返回</p>
<p>这里之所以是多生产者，是因为可以把生产者无限克隆出去，然后发送消息：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> tx1 = mpsc::Sender::clone(&amp;tx);</span><br></pre></td></tr></table></figure>

<h2 id="共享状态并发"><a href="#共享状态并发" class="headerlink" title="共享状态并发"></a>共享状态并发</h2><h2 id="互斥器-mutex"><a href="#互斥器-mutex" class="headerlink" title="互斥器(mutex)"></a>互斥器(mutex)</h2><p>rust中的锁是一种特殊的智能指针，通过重载drop trait来确保离开作用域的时候释放锁。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::sync::Mutex;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> m = Mutex::new(<span class="number">5</span>);</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> num = m.lock().unwrap();</span><br><span class="line">        *num = <span class="number">6</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"m = &#123;:?&#125;"</span>, m);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于多个线程都需要访问同一个锁，因此需要多所有权的智能指针，并且能够并发使用：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Rc&lt;T&gt;: 单线程，多所有权；</span><br><span class="line">Arc&lt;T&gt;: 多线程，多所有权。</span><br></pre></td></tr></table></figure>
<p>并发访问的例子:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::sync::&#123;Mutex, Arc&#125;;</span><br><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> counter = Arc::new(Mutex::new(<span class="number">0</span>));<span class="comment">// 智能指针包装</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> handles = <span class="built_in">vec!</span>[];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="number">0</span>..<span class="number">10</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> counter = Arc::clone(&amp;counter);<span class="comment">// 克隆来增加引用计数</span></span><br><span class="line">        <span class="keyword">let</span> handle = thread::spawn(<span class="keyword">move</span> || &#123; </span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut</span> num = counter.lock().unwrap();</span><br><span class="line"></span><br><span class="line">            *num += <span class="number">1</span>; <span class="comment">// move+离开作用域,引用-1</span></span><br><span class="line">        &#125;);</span><br><span class="line">        handles.push(handle);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> handle <span class="keyword">in</span> handles &#123;</span><br><span class="line">        handle.join().unwrap();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Result: &#123;&#125;"</span>, *counter.lock().unwrap());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里可以看出Mutex具有内部可变性。同时可以用Mutex构造死锁(循环依赖)。</p>
<h2 id="Send与Sync的trait"><a href="#Send与Sync的trait" class="headerlink" title="Send与Sync的trait"></a>Send与Sync的trait</h2><p>rust中用两个trait来标记所有权在线程中的转移以及引用的多线程访问: </p>
<blockquote>
<p><code>Send trait</code>:  支持多线程<code>所有权</code>转移,所有权在线程之间转移; 除Rc<T>以外的大部分类型是Send trait;<br><code>Sync trait</code>:  支持多线程访问, 线程之间可以共享值的<code>引用</code>；<br>除Rc<T>以外的大部分类型是Sync trait;</p>
</blockquote>
<p><code>unsafe rust</code>中的裸指针也没有实现这两个trait.</p>
<p>绝大部分情况不需要手动实现send与sync的trait。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://xiaoyue26.github.io/2019/10/06/2019-10/rust%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0-2/" data-id="ck96cxpqb00k9maamb1qe6pmi" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/rust/" rel="tag">rust</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-2019-09/rust入门笔记-1" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/09/22/2019-09/rust%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0-1/" class="article-date">
  <time datetime="2019-09-22T11:20:21.000Z" itemprop="datePublished">2019-09-22</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/rust/">rust</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/09/22/2019-09/rust%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0-1/">rust入门笔记_1</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <p>周末无事看看tidb开发者说很好用的rust，觉得很有趣，原来现代编程语言就是这种感觉，有一些细节上的简化。</p>
<p>文档参见: <a href="https://rustlang-cn.org/office/rust/book/getting-started/ch01-03-hello-cargo.html" target="_blank" rel="noopener">https://rustlang-cn.org/office/rust/book/getting-started/ch01-03-hello-cargo.html</a></p>
<p>源码:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Hello, world!"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译和运行:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rustc main.rs</span><br><span class="line">./main</span><br></pre></td></tr></table></figure>

<p>用<code>cargo</code>(类似于<code>maven</code>)</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cargo new hello_cargo # 创建项目</span><br><span class="line">cargo build # 生成debug程序</span><br><span class="line">cargo run # 运行debug程序, 会自动build</span><br><span class="line">cargo check # 仅检查语法</span><br><span class="line"></span><br><span class="line">cargo build --release # 生成优化后的程序(release)</span><br><span class="line"><span class="meta">#</span><span class="bash"> 类似的可以猜到run release程序的命令:</span></span><br><span class="line">cargo run --rebase # 运行relase，会自动检测改动重新编译</span><br></pre></td></tr></table></figure>
<p>可以看到专门提供了一个<code>cargo check</code>命令来避免编译、只是检查语法，看来网上大家说rust编译慢很可能是真的。</p>
<h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> foo = <span class="number">5</span>; <span class="comment">// 不可变</span></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> bar = <span class="number">5</span>; <span class="comment">// 可变</span></span><br></pre></td></tr></table></figure>

<p>类方法/静态函数: 在rust中叫<code>关联函数</code>（associated function）;</p>
<h1 id="crate-库"><a href="#crate-库" class="headerlink" title="crate: 库"></a>crate: 库</h1><p>类似于mvn的中央仓库: <a href="https://crates.io/" target="_blank" rel="noopener">https://crates.io/</a><br><code>crate</code>不是创建的意思，差了一个字母，是rust的库的意思。</p>
<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><p><code>i32</code>: 32位数字；<br><code>u32</code>: 32位无符号数字；<br><code>i64</code>: 64位数字等等。</p>
<p><code>Rust</code>默认使用<code>i32</code>.<br>但是如果你用<code>u32</code>类型和一个变量<code>a</code>比较,Rust会推断出a也是<code>u32</code>类型.</p>
<h1 id="let关键字"><a href="#let关键字" class="headerlink" title="let关键字"></a>let关键字</h1><p><code>let</code>类似于js里的<code>let</code>，用来定义一个变量，而且支持<code>shadowing</code>。<br>比如一开始定义了一个string类型的a;<br>后来转换成数字以后，可以直接</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a:<span class="built_in">u32</span> = a.guess.trim().parse()</span><br><span class="line">        .expect(<span class="string">"Please type a number!"</span>);</span><br></pre></td></tr></table></figure>
<p>新的定义会覆盖以前的，这样就不用定义两个变量了（一个string_a,一个u32_a）。<br>原理上其实底层是生成了两个变量，因此可以把<code>let mut</code>覆盖成<code>let</code>，或者把不可变的覆盖成可变的。实测了一下确实也是可以的。</p>
<h1 id="match关键字"><a href="#match关键字" class="headerlink" title="match关键字"></a>match关键字</h1><p>match和scala里的一样</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">match</span> xxx &#123;</span><br><span class="line">        Ordering::Less =&gt; <span class="built_in">println!</span>(<span class="string">"Too small!"</span>),</span><br><span class="line">        Ordering::Greater =&gt; <span class="built_in">println!</span>(<span class="string">"Too big!"</span>),</span><br><span class="line">        Ordering::Equal =&gt; <span class="built_in">println!</span>(<span class="string">"You win!"</span>),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="通用概念-与其他编程语言核心对应的"><a href="#通用概念-与其他编程语言核心对应的" class="headerlink" title="通用概念(与其他编程语言核心对应的)"></a>通用概念(与其他编程语言核心对应的)</h1><h2 id="关键字转义"><a href="#关键字转义" class="headerlink" title="关键字转义"></a>关键字转义</h2><p>比如<code>match</code>在rust中是一个关键字,所以如果恰好有一个函数叫这个名字，需要转义以后才能调用：(用<code>r#</code>前缀)</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">r#<span class="keyword">match</span>(); <span class="comment">// 调用名为 'match' 的函数</span></span><br></pre></td></tr></table></figure>

<h2 id="不可变"><a href="#不可变" class="headerlink" title="不可变"></a>不可变</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> MAX_POINTS: <span class="built_in">u32</span> = <span class="number">100_000</span>; <span class="comment">// 不可变,直接赋值;</span></span><br><span class="line"><span class="keyword">let</span> a = get_val(); <span class="comment">// 不可变,可以运行时赋值;</span></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> a = xxx;   <span class="comment">// 可变。</span></span><br></pre></td></tr></table></figure>

<h2 id="数据类型-1"><a href="#数据类型-1" class="headerlink" title="数据类型"></a>数据类型</h2><p>rust会尝试推断数据类型，推断不出来则会报错；</p>
<p>标量: 整型、浮点型、布尔类型和字符类型;</p>
<table>
<thead>
<tr>
<th>长度</th>
<th>有符号</th>
<th>无符号</th>
</tr>
</thead>
<tbody><tr>
<td>8-bit</td>
<td>i8</td>
<td>u8</td>
</tr>
<tr>
<td>16-bit</td>
<td>i16</td>
<td>u16</td>
</tr>
<tr>
<td>32-bit</td>
<td>i32</td>
<td>u32</td>
</tr>
<tr>
<td>64-bit</td>
<td>i64</td>
<td>u64</td>
</tr>
<tr>
<td>arch</td>
<td>isize</td>
<td>usize</td>
</tr>
</tbody></table>
<p>这里的<code>arch</code>: 64 位架构上它们是 64 位的， 32 位架构上它们是 32 位的。<br><code>isize</code>和<code>usize</code>主要作为索引类型。</p>
<p>赋值的时候: (还能在中间随意加横杠<code>_</code>):</p>
<table>
<thead>
<tr>
<th>数字字面值</th>
<th>例子</th>
</tr>
</thead>
<tbody><tr>
<td>Decimal</td>
<td>98_222</td>
</tr>
<tr>
<td>Hex</td>
<td>0xff</td>
</tr>
<tr>
<td>Octal</td>
<td>0o77</td>
</tr>
<tr>
<td>Binary</td>
<td>0b1111_0000</td>
</tr>
<tr>
<td>Byte (u8 only)</td>
<td>b’A’</td>
</tr>
</tbody></table>
<p><code>57u8</code>表示57，数据类型是<code>u8</code>；</p>
<p>数字溢出: debug版检查溢出并报错；<br>release版会进行溢出。<br>可以用<code>Wrapping</code>类型来使用溢出特性，以免被debug版本报错。</p>
<p><code>f32</code>: 32位浮点数;<br><code>f64</code>: 64位浮点数. (默认类型,现代cpu下性能与f32几乎一样)<br><code>bool</code>: 布尔值。<br><code>char</code>: Unicode字符。</p>
<h2 id="元组和数组"><a href="#元组和数组" class="headerlink" title="元组和数组"></a>元组和数组</h2><p>元组下标从0开始(和scala不同,scala从1开始)</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> tup: (<span class="built_in">i32</span>, <span class="built_in">f64</span>, <span class="built_in">u8</span>) = (<span class="number">500</span>, <span class="number">6.4</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">let</span> five_hundred = x.<span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>数组:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="comment">// 或:</span></span><br><span class="line"><span class="keyword">let</span> a: [<span class="built_in">i32</span>; <span class="number">5</span>] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br></pre></td></tr></table></figure>


<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>用fn声明. </p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    another_function(<span class="number">5</span>, <span class="number">6</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">another_function</span></span>(x: <span class="built_in">i32</span>, y: <span class="built_in">i32</span>) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"The value of x is: &#123;&#125;"</span>, x);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"The value of y is: &#123;&#125;"</span>, y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">five</span></span>() -&gt; <span class="built_in">i32</span> &#123; <span class="comment">// 返回i32类型</span></span><br><span class="line">    <span class="number">5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h2><p>表达式的结尾没有分号</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> y = &#123;</span><br><span class="line">        <span class="keyword">let</span> x = <span class="number">3</span>;</span><br><span class="line">        x + <span class="number">1</span> <span class="comment">// 没有分号</span></span><br><span class="line">    &#125;;</span><br><span class="line"><span class="comment">// y=4</span></span><br></pre></td></tr></table></figure>
<h2 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h2><p>loop,while,for</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> result = <span class="keyword">loop</span> &#123;</span><br><span class="line">    counter += <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> counter == <span class="number">10</span> &#123;</span><br><span class="line">        <span class="keyword">break</span> counter * <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">assert_eq!</span>(result, <span class="number">20</span>);</span><br><span class="line"><span class="keyword">while</span> index &lt; <span class="number">5</span> &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"the value is: &#123;&#125;"</span>, a[index]);</span><br><span class="line">    index = index + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> a = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>];</span><br><span class="line"><span class="keyword">for</span> element <span class="keyword">in</span> a.iter() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"the value is: &#123;&#125;"</span>, element);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> number <span class="keyword">in</span> (<span class="number">1</span>..<span class="number">4</span>).rev() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;!"</span>, number);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="ownership-所有权"><a href="#ownership-所有权" class="headerlink" title="ownership 所有权"></a>ownership 所有权</h1><p>rust无需gc。<br>要学习的点包括: 借用、slice、内存布局。</p>
<blockquote>
<p>所有权：管理堆数据</p>
</blockquote>
<p>所有权的三大法则: </p>
<blockquote>
<ol>
<li>Rust中的每一个值都有一个被称为其 所有者（owner）的变量。</li>
<li>值有且只有一个所有者。</li>
<li>当所有者（变量）离开作用域，这个值将被丢弃。</li>
</ol>
</blockquote>
<p>创建一个堆上的变量:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="keyword">let</span> s = <span class="built_in">String</span>::from(<span class="string">"hello"</span>);</span><br><span class="line">s.push_str(<span class="string">", world!"</span>); <span class="comment">// 追加</span></span><br><span class="line">&#125;<span class="comment">// rust自动调用s的drop,回收内存(类似于free\RAII模式)</span></span><br></pre></td></tr></table></figure>
<p>s的大小运行时可变，因此它显然分配在堆上。(栈每个slot大小相同)</p>
<h2 id="浅拷贝、深拷贝、移动"><a href="#浅拷贝、深拷贝、移动" class="headerlink" title="浅拷贝、深拷贝、移动"></a>浅拷贝、深拷贝、移动</h2><p>rust对复杂类型默认是移动;<br>基本类型直接深拷贝。<br>rust没有浅拷贝、只有移动。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 移动:</span></span><br><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">String</span>::from(<span class="string">"hello"</span>);</span><br><span class="line"><span class="keyword">let</span> s2 = s1;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">"&#123;&#125;, world!"</span>, s1); <span class="comment">// fail,s1已经无效,被移动为s2了。</span></span><br><span class="line"><span class="comment">// 深拷贝:</span></span><br><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">String</span>::from(<span class="string">"hello"</span>);</span><br><span class="line"><span class="keyword">let</span> s2 = s1.clone();</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">"s1 = &#123;&#125;, s2 = &#123;&#125;"</span>, s1, s2);</span><br><span class="line"><span class="comment">// 基本类型:</span></span><br><span class="line"><span class="keyword">let</span> x = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">let</span> y = x;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">"x = &#123;&#125;, y = &#123;&#125;"</span>, x, y);</span><br></pre></td></tr></table></figure>
<p>总结就是:<br>浅拷贝: 无;<br>深拷贝: 显式调用<code>clone</code>、或者是基本类型;<br>移动:   复杂类型;</p>
<p>如果一个类型拥有<code>Copy trait</code>,<br>一个旧的变量在将其赋值给其他变量后仍然可用。<br>rust的逻辑是，如果发现一个类型没有实现<code>Copy</code>，它就进行<code>move</code>。</p>
<p>除了用等号，调用函数时也会发生移动或者深拷贝。<br>例如:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="built_in">String</span>::from(<span class="string">"hello"</span>);  <span class="comment">// s 进入作用域</span></span><br><span class="line">takes_ownership(s);             <span class="comment">// s 的值移动到函数里 ...</span></span><br><span class="line">                                <span class="comment">// ... 所以到这里s不再有效</span></span><br></pre></td></tr></table></figure>
<p>函数return的时候也类似于等号，也会发生移动或者深拷贝，因此可以用return再取回所有权。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="built_in">String</span>::from(<span class="string">"hello"</span>);</span><br><span class="line"><span class="keyword">let</span> s = takes_back_ownership(s);</span><br></pre></td></tr></table></figure>
<p>可以用<code>&amp;</code>号来简化这个过程:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">String</span>::from(<span class="string">"hello"</span>);</span><br><span class="line"><span class="keyword">let</span> len = calculate_length(&amp;s1); <span class="comment">// 多一个&amp;来取回所有权</span></span><br></pre></td></tr></table></figure>
<p>这里<code>calculate_length</code>函数没有所有权，因此是借用了s1变量。</p>
<h2 id="借用"><a href="#借用" class="headerlink" title="借用"></a>借用</h2><p>函数借用变量s,不拥有所有权。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> s = <span class="built_in">String</span>::from(<span class="string">"hello"</span>);</span><br><span class="line">    change(&amp;<span class="keyword">mut</span> s);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">change</span></span>(some_string: &amp;<span class="keyword">mut</span> <span class="built_in">String</span>) &#123;</span><br><span class="line">    some_string.push_str(<span class="string">", world"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>借用并且要修改的话，要显式写上<code>&amp;mut</code>.</p>
<h3 id="借用的竞态"><a href="#借用的竞态" class="headerlink" title="借用的竞态"></a>借用的竞态</h3><p>rust默认禁止竞态,编译不予通过:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> s = <span class="built_in">String</span>::from(<span class="string">"hello"</span>);</span><br><span class="line"><span class="keyword">let</span> r1 = &amp;<span class="keyword">mut</span> s;</span><br><span class="line"><span class="keyword">let</span> r2 = &amp;<span class="keyword">mut</span> s;<span class="comment">// 如果后续都用的话报错,两个变量都借用了s,而且都是可写，有竞态,在同一作用域内。</span></span><br><span class="line"><span class="comment">// 只读引用的话可以有多个:</span></span><br><span class="line"><span class="keyword">let</span> r1 = &amp;s; <span class="comment">// no problem</span></span><br><span class="line"><span class="keyword">let</span> r2 = &amp;s; <span class="comment">// no problem</span></span><br><span class="line"><span class="keyword">let</span> r3 = &amp;<span class="keyword">mut</span> s; <span class="comment">// BIG PROBLEM 有只读引用的时候，也不能再有可写引用</span></span><br></pre></td></tr></table></figure>
<p>借用结束的话可以消除竞态:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> a = <span class="built_in">String</span>::from(<span class="string">"hello world"</span>);</span><br><span class="line"><span class="keyword">let</span> b = &amp;a[<span class="number">0</span>..<span class="number">4</span>];</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, b);</span><br><span class="line">append_a(&amp;<span class="keyword">mut</span> a);<span class="comment">// 这里没问题,因为b后面没有用到。</span></span><br><span class="line"><span class="comment">// println!("&#123;&#125;", b); // 这里会报错，因为b的作用域和a的有交叉。</span></span><br></pre></td></tr></table></figure>

<h3 id="悬挂指针"><a href="#悬挂指针" class="headerlink" title="悬挂指针"></a>悬挂指针</h3><p>Rust 中编译器确保永远不会有悬挂指针。<br>构造悬挂指针: </p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> reference_to_nothing = dangle();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">dangle</span></span>() -&gt; &amp;<span class="built_in">String</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> s = <span class="built_in">String</span>::from(<span class="string">"hello"</span>);</span><br><span class="line">    &amp;s <span class="comment">// 编译失败</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="slice"><a href="#slice" class="headerlink" title="slice"></a>slice</h2><p>slice的类型多一个&amp;,属于不可变引用。<br>比如string的slice类型: <code>&amp;str</code>，<br>字符串的字面量的类型：<code>str</code><br>slice语法很简单:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="built_in">String</span>::from(<span class="string">"hello"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> slice = &amp;s[<span class="number">0</span>..<span class="number">2</span>];</span><br><span class="line"><span class="keyword">let</span> slice = &amp;s[..<span class="number">2</span>];</span><br><span class="line"><span class="keyword">let</span> slice = &amp;s[<span class="number">0</span>..len]; <span class="comment">// 整个字符串</span></span><br><span class="line"><span class="keyword">let</span> slice = &amp;s[..]; <span class="comment">// 省略头尾</span></span><br><span class="line"><span class="comment">// 包含右端点:</span></span><br><span class="line"><span class="keyword">let</span> hello = &amp;s[<span class="number">0</span>..=<span class="number">4</span>];</span><br></pre></td></tr></table></figure>
<p>用slice的好处是可以预防错误，因为持有了不可变引用，其他试图修改s的操作就会被阻止，因为修改s的时候会申请可变引用，根据上一节中的竞态阻止，申请可变引用会失败。</p>
<h3 id="数组的slice"><a href="#数组的slice" class="headerlink" title="数组的slice"></a>数组的slice</h3><p>类型是 <code>&amp;[i32]</code></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">let</span> slice = &amp;a[<span class="number">1</span>..<span class="number">3</span>];</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">"&#123;:?&#125;"</span>,slice);</span><br></pre></td></tr></table></figure>

<h2 id="结构体struct"><a href="#结构体struct" class="headerlink" title="结构体struct"></a>结构体struct</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># <span class="class"><span class="keyword">struct</span> <span class="title">User</span></span> &#123;</span><br><span class="line">#     username: <span class="built_in">String</span>,</span><br><span class="line">#     email: <span class="built_in">String</span>,</span><br><span class="line">#     sign_in_count: <span class="built_in">u64</span>,</span><br><span class="line">#     active: <span class="built_in">bool</span>,</span><br><span class="line"># &#125;</span><br><span class="line">#</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> user1 = User &#123;</span><br><span class="line">    email: <span class="built_in">String</span>::from(<span class="string">"someone@example.com"</span>),</span><br><span class="line">    username: <span class="built_in">String</span>::from(<span class="string">"someusername123"</span>),</span><br><span class="line">    active: <span class="literal">true</span>,</span><br><span class="line">    sign_in_count: <span class="number">1</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">user1.email = <span class="built_in">String</span>::from(<span class="string">"anotheremail@example.com"</span>);</span><br></pre></td></tr></table></figure>
<p>以前写代码经常会有<code>this.email=email</code>这种机械重复的代码，rust提供了简写省略的方法。<br>构造函数的简写: (<code>new</code>)</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">build_user</span></span>(email: <span class="built_in">String</span>, username: <span class="built_in">String</span>) -&gt; User &#123;</span><br><span class="line">    User &#123;</span><br><span class="line">        email, <span class="comment">// 这里省略了同名输入变量</span></span><br><span class="line">        username,</span><br><span class="line">        active: <span class="literal">true</span>,</span><br><span class="line">        sign_in_count: <span class="number">1</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类似的，结构体的update也有相应的简写:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> user2 = User &#123;</span><br><span class="line">    email: <span class="built_in">String</span>::from(<span class="string">"another@example.com"</span>),</span><br><span class="line">    username: <span class="built_in">String</span>::from(<span class="string">"anotherusername567"</span>),</span><br><span class="line">    ..user1 <span class="comment">// 这句话的意思是其他变量都按user1的值来赋值就好</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>结构体的实例方法和类方法区别在于有没有第一个<code>&amp;self</code>参数,方法可以位于不同<code>impl</code>块中:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"># <span class="meta">#[derive(Debug)]</span></span><br><span class="line"># <span class="class"><span class="keyword">struct</span> <span class="title">Rectangle</span></span> &#123;</span><br><span class="line">#     width: <span class="built_in">u32</span>,</span><br><span class="line">#     height: <span class="built_in">u32</span>,</span><br><span class="line"># &#125;</span><br><span class="line">#</span><br><span class="line"><span class="keyword">impl</span> Rectangle &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">area</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">u32</span> &#123; <span class="comment">// 实例方法</span></span><br><span class="line">        <span class="keyword">self</span>.width * <span class="keyword">self</span>.height</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Rectangle &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">can_hold</span></span>(&amp;<span class="keyword">self</span>, other: &amp;Rectangle) -&gt; <span class="built_in">bool</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.width &gt; other.width &amp;&amp; <span class="keyword">self</span>.height &gt; other.height</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> Rectangle &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">square</span></span>(size: <span class="built_in">u32</span>) -&gt; Rectangle &#123;<span class="comment">// 关联方法、类方法</span></span><br><span class="line">        Rectangle &#123; width: size, height: size &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="自动解引用功能"><a href="#自动解引用功能" class="headerlink" title="自动解引用功能"></a>自动解引用功能</h2><p>统一<code>obj.xxx()</code>操作和<code>obj-&gt;xxx()</code>.<br>rust自动解引用:</p>
<blockquote>
<p>当使用 object.something() 调用方法时，Rust 会自动为 object 添加 &amp;、&amp;mut 或 * 以便使 object 与方法签名匹配。</p>
</blockquote>
<h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><p>枚举可以直接绑定数据类型：(类似于一种<code>typedef</code>)</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">IpAddr</span></span> &#123;</span><br><span class="line">    V4(<span class="built_in">u8</span>, <span class="built_in">u8</span>, <span class="built_in">u8</span>, <span class="built_in">u8</span>),</span><br><span class="line">    V6(<span class="built_in">String</span>),</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> home = IpAddr::V4(<span class="number">127</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">let</span> loopback = IpAddr::V6(<span class="built_in">String</span>::from(<span class="string">"::1"</span>));</span><br></pre></td></tr></table></figure>
<p>也可以作为朴素的数据(数字):</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># <span class="class"><span class="keyword">enum</span> <span class="title">IpAddrKind</span></span> &#123;</span><br><span class="line">#     V4,</span><br><span class="line">#     V6,</span><br><span class="line"># &#125;</span><br><span class="line">#</span><br><span class="line"><span class="keyword">let</span> four = IpAddrKind::V4;</span><br><span class="line"><span class="keyword">let</span> six = IpAddrKind::V6;</span><br></pre></td></tr></table></figure>
<p><code>Option</code>也是一种枚举类型。</p>
<h2 id="match"><a href="#match" class="headerlink" title="match"></a>match</h2><p>match的时候可以自动unapply枚举型:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">match</span> x &#123;</span><br><span class="line">        <span class="literal">None</span> =&gt; <span class="literal">None</span>,</span><br><span class="line">        <span class="literal">Some</span>(i) =&gt; <span class="literal">Some</span>(i + <span class="number">1</span>),</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 更复杂:</span></span><br><span class="line"># <span class="meta">#[derive(Debug)]</span> <span class="comment">// 支持直接打印</span></span><br><span class="line"># <span class="class"><span class="keyword">enum</span> <span class="title">UsState</span></span> &#123;</span><br><span class="line">#    Alabama,</span><br><span class="line">#    Alaska,</span><br><span class="line"># &#125;</span><br><span class="line">#</span><br><span class="line"># <span class="class"><span class="keyword">enum</span> <span class="title">Coin</span></span> &#123;</span><br><span class="line">#    Penny,</span><br><span class="line">#    Nickel,</span><br><span class="line">#    Dime,</span><br><span class="line">#    Quarter(UsState),</span><br><span class="line"># &#125;</span><br><span class="line">#</span><br><span class="line"><span class="keyword">match</span> coin &#123;</span><br><span class="line">        Coin::Penny =&gt; <span class="number">1</span>,</span><br><span class="line">        Coin::Nickel =&gt; <span class="number">5</span>,</span><br><span class="line">        Coin::Dime =&gt; <span class="number">10</span>,</span><br><span class="line">        Coin::Quarter(state) =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">"State quarter from &#123;:?&#125;!"</span>, state);</span><br><span class="line">            <span class="number">25</span></span><br><span class="line">        &#125;,</span><br><span class="line">        _ =&gt; (), </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里类似于最后default兜底的值是<code>_</code>,返回值是<code>()</code>也就是<code>unit</code>类型。<br><code>if let</code>是match的语法糖:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> Coin::Quarter(state) = coin &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"State quarter from &#123;:?&#125;!"</span>, state);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    count += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="包"><a href="#包" class="headerlink" title="包"></a>包</h1><p>package: 包。cargo的功能.<code>cargo new</code>生成,带有<code>Cargo.toml</code>文件;里面可以有多个库。<br>Crates： 库。很多模块构成的库；(或者程序)<br>Modules: 模块。</p>
<p>包默认生成的库：</p>
<ol>
<li><code>src/main.rs</code>; (程序、数量任意)</li>
<li><code>src/lib.rs</code>;  (库、最多1个)</li>
</ol>
<h1 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h1><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mod</span> sound &#123;<span class="comment">// 同包下可以访问</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">mod</span> instrument &#123;<span class="comment">// 公有</span></span><br><span class="line">        <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">clarinet</span></span>() &#123;<span class="comment">// 公有</span></span><br><span class="line">            <span class="comment">// 函数体</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="comment">// 绝对路径</span></span><br><span class="line">    crate::sound::instrument::clarinet();</span><br><span class="line">    <span class="comment">// 相对路径</span></span><br><span class="line">    sound::instrument::clarinet();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="super相对路径"><a href="#super相对路径" class="headerlink" title="super相对路径"></a>super相对路径</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mod</span> sound &#123;</span><br><span class="line">    <span class="keyword">mod</span> instrument &#123;</span><br><span class="line">        <span class="function"><span class="keyword">fn</span> <span class="title">clarinet</span></span>() &#123;</span><br><span class="line">            super::breathe_in();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">breathe_in</span></span>() &#123;</span><br><span class="line">        <span class="comment">// 函数体</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="use关键字引用"><a href="#use关键字引用" class="headerlink" title="use关键字引用"></a>use关键字引用</h2><p>类似于<code>import</code></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> crate::sound::instrument;</span><br><span class="line"><span class="comment">// 相对路径引入:</span></span><br><span class="line"><span class="keyword">use</span> self::sound::instrument; <span class="comment">// 一般还是用绝对路径引入</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 同名冲突处理: 使用as重命名</span></span><br><span class="line"><span class="keyword">use</span> std::fmt::<span class="built_in">Result</span>;</span><br><span class="line"><span class="keyword">use</span> std::io::<span class="built_in">Result</span> <span class="keyword">as</span> IoResult;</span><br></pre></td></tr></table></figure>
<p>默认use引入的项变成了私有，可以再加上pub让引入的项维持公有:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">use</span> crate::sound::instrument;</span><br></pre></td></tr></table></figure>

<h2 id="访问修饰符pub"><a href="#访问修饰符pub" class="headerlink" title="访问修饰符pub"></a>访问修饰符pub</h2><p>枚举<code>enum</code>: 一旦pub，则所有字段pub;<br>结构体<code>struct</code>: 必须显式设定每个字段为pub，默认是private;</p>
<h2 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h2><p>每个mod放在自己的同名文件中，其他文件中要用的时候，声明一下即可:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mod</span> sound;</span><br></pre></td></tr></table></figure>
<p>末尾是分号。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://xiaoyue26.github.io/2019/09/22/2019-09/rust%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0-1/" data-id="ck96cxpq700jtmaamfyfe6f5b" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/rust/" rel="tag">rust</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-2019-09/JNI如何优雅引用so文件" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/09/08/2019-09/JNI%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E5%BC%95%E7%94%A8so%E6%96%87%E4%BB%B6/" class="article-date">
  <time datetime="2019-09-08T10:55:58.000Z" itemprop="datePublished">2019-09-08</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/java/">java</a>►<a class="article-category-link" href="/categories/java/%E6%80%A7%E8%83%BD/">性能</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/09/08/2019-09/JNI%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E5%BC%95%E7%94%A8so%E6%96%87%E4%BB%B6/">JNI如何优雅引用so文件</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <p>JNI背景知识参见: <a href="http://xiaoyue26.github.io/2019/09/07/2019-09/JNI%E6%80%BB%E7%BB%93/">http://xiaoyue26.github.io/2019/09/07/2019-09/JNI%E6%80%BB%E7%BB%93/</a></p>
<p>总之假设我们到了临门一脚想要引用so文件到时候,方法有很多种,大致分为两大类:</p>
<ol>
<li>预先把so文件部署到运行的机器特定目录,代码里使用绝对路径加载;</li>
<li>把so文件打包到resource目录,运行时用相对路径加载。</li>
</ol>
<p>主要推荐绝对路径的姿势2和相对路径的姿势5.</p>
<h2 id="优劣势"><a href="#优劣势" class="headerlink" title="优劣势:"></a>优劣势:</h2><h3 id="绝对路径"><a href="#绝对路径" class="headerlink" title="绝对路径:"></a>绝对路径:</h3><ul>
<li>多个java程序可以引用同一个so文件,不用都打包到jar包里,降低jar包大小;  </li>
<li>可以灵活切换so文件实现,不用重新打包jar包, 符合c++中动态链接库的思想。</li>
</ul>
<h3 id="相对路径"><a href="#相对路径" class="headerlink" title="相对路径:"></a>相对路径:</h3><ul>
<li>一般一个so文件就一个java程序使用,相对路径用起来省心,不用配置多个运行环境. </li>
<li>比较符合jvm平台无关的思想,当然so文件肯定是平台有关的。一般so文件是某个公开库,不是我们自己写的,也不需要修改其实现。</li>
</ul>
<p>目前我个人使用的是第5种姿势。</p>
<h2 id="绝对路径-1"><a href="#绝对路径-1" class="headerlink" title="绝对路径"></a>绝对路径</h2><p>姿势1: 直接写死:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.load(<span class="string">"/opt/ld_path/libtest.so"</span>);</span><br></pre></td></tr></table></figure>
<p>姿势2: 结合环境变量,这里第一行代码可以在运行时由命令<code>java -Djava.library.path=/opt/ld_path</code>代替:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">System.setProperty(<span class="string">"java.library.path"</span>, <span class="string">"/opt/ld_path"</span>);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    Field sysPath = ClassLoader.class.getDeclaredField("sys_paths");</span><br><span class="line">    sysPath.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    sysPath.set(<span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">// System.out.println(System.mapLibraryName("dynamic"));</span></span><br><span class="line">    System.loadLibrary(<span class="string">"dynamic"</span>);</span><br><span class="line">    <span class="comment">// 注意mac需要.dylib结尾的依赖文件</span></span><br><span class="line">    <span class="comment">// linux需要.so结尾的依赖文件</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (NoSuchFieldException | IllegalAccessException e) &#123;</span><br><span class="line">    System.out.println(<span class="string">"error"</span>);</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="相对路径-仅在ide里可用的方法"><a href="#相对路径-仅在ide里可用的方法" class="headerlink" title="相对路径: 仅在ide里可用的方法"></a>相对路径: 仅在ide里可用的方法</h2><blockquote>
<p>这两种方法都需要首先把<code>libdynamic.so</code>文件放到<code>resource</code>目录。</p>
</blockquote>
<p>姿势3:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">URL url = JNIDyn.class.getClassLoader().getResource("libdynamic.so");</span><br><span class="line">System.load(url.getPath());</span><br></pre></td></tr></table></figure>
<p>姿势4:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ClassPathResource resource = <span class="keyword">new</span> ClassPathResource(<span class="string">"libdynamic.so"</span>);</span><br><span class="line"><span class="comment">// System.out.println(resource.getPath());</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    File file = resource.getFile();</span><br><span class="line">    System.load(file.getAbsolutePath());</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="相对路径-ide和jar包都能用的方法"><a href="#相对路径-ide和jar包都能用的方法" class="headerlink" title="相对路径: ide和jar包都能用的方法"></a>相对路径: ide和jar包都能用的方法</h2><p>姿势5: </p>
<blockquote>
<p>需要首先把<code>libdynamic.so</code>文件放到<code>resource</code>目录。</p>
</blockquote>
<p>然后需要创建<code>NativeUtils</code>工具类;<br>加载代码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        NativeUtils.loadLibraryFromJar(<span class="string">"/libnative.so"</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里使用到的<code>NativeUtils</code>源码如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NativeUtils</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_PREFIX_LENGTH = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String NATIVE_FOLDER_PATH_PREFIX = <span class="string">"nativeutils"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> File temporaryDir;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">NativeUtils</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loadLibraryFromJar</span><span class="params">(String path)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == path || !path.startsWith(<span class="string">"/"</span>)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"The path has to be absolute (start with '/')."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        String[] parts = path.split(<span class="string">"/"</span>);</span><br><span class="line">        String filename = (parts.length &gt; <span class="number">1</span>) ? parts[parts.length - <span class="number">1</span>] : <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (filename == <span class="keyword">null</span> || filename.length() &lt; MIN_PREFIX_LENGTH) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"The filename has to be at least 3 characters long."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (temporaryDir == <span class="keyword">null</span>) &#123;</span><br><span class="line">            temporaryDir = createTempDirectory(NATIVE_FOLDER_PATH_PREFIX);</span><br><span class="line">            temporaryDir.deleteOnExit();</span><br><span class="line">        &#125;</span><br><span class="line">        File temp = <span class="keyword">new</span> File(temporaryDir, filename);</span><br><span class="line">        <span class="keyword">try</span> (InputStream is = NativeUtils<span class="class">.<span class="keyword">class</span>.<span class="title">getResourceAsStream</span>(<span class="title">path</span>)) </span>&#123;</span><br><span class="line">            Files.copy(is, temp.toPath(), StandardCopyOption.REPLACE_EXISTING);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            temp.delete();</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NullPointerException e) &#123;</span><br><span class="line">            temp.delete();</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> FileNotFoundException(<span class="string">"File "</span> + path + <span class="string">" was not found inside JAR."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.load(temp.getAbsolutePath());</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (isPosixCompliant()) &#123;</span><br><span class="line">                temp.delete();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                temp.deleteOnExit();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isPosixCompliant</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> FileSystems.getDefault()</span><br><span class="line">                    .supportedFileAttributeViews()</span><br><span class="line">                    .contains(<span class="string">"posix"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileSystemNotFoundException</span><br><span class="line">                | ProviderNotFoundException</span><br><span class="line">                | SecurityException e) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> File <span class="title">createTempDirectory</span><span class="params">(String prefix)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        String tempDir = System.getProperty(<span class="string">"java.io.tmpdir"</span>);</span><br><span class="line">        File generatedDir = <span class="keyword">new</span> File(tempDir, prefix + System.nanoTime());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!generatedDir.mkdir())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Failed to create temp directory "</span> + generatedDir.getName());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> generatedDir;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://xiaoyue26.github.io/2019/09/08/2019-09/JNI%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E5%BC%95%E7%94%A8so%E6%96%87%E4%BB%B6/" data-id="ck96cxpq600jomaam0b6r19z1" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JNI/" rel="tag">JNI</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/" rel="tag">java</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-2019-09/springboot包结构" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/09/08/2019-09/springboot%E5%8C%85%E7%BB%93%E6%9E%84/" class="article-date">
  <time datetime="2019-09-08T10:32:14.000Z" itemprop="datePublished">2019-09-08</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/java/">java</a>►<a class="article-category-link" href="/categories/java/spring/">spring</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/09/08/2019-09/springboot%E5%8C%85%E7%BB%93%E6%9E%84/">springboot包结构</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <h1 id="使用springboot打包插件"><a href="#使用springboot打包插件" class="headerlink" title="使用springboot打包插件"></a>使用springboot打包插件</h1><p>如果用springboot插件进行打包以后,包结构会发生变化:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mainClass</span>&gt;</span>com.tencent.xxx.Application<span class="tag">&lt;/<span class="name">mainClass</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">goal</span>&gt;</span>repackage<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>springboot打包的jar包用<code>tar -xvf</code>解压以后,大致结构如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">+-META-INF</span><br><span class="line">|  +-MANIFEST.MF</span><br><span class="line">|  +-maven</span><br><span class="line">|     +-pom.xml</span><br><span class="line">|     +-pom.properties</span><br><span class="line">+-org</span><br><span class="line">|  +-springframework</span><br><span class="line">|     +-boot</span><br><span class="line">|        +-loader</span><br><span class="line">|           +-&lt;spring boot loader classes&gt;</span><br><span class="line">+-BOOT-INF</span><br><span class="line">   +-classes</span><br><span class="line">   |  +-com</span><br><span class="line">   |     +-tencent</span><br><span class="line">   |        +-xxx.class</span><br><span class="line">   |  +-其他src&#x2F;main&#x2F;resource路径下的文件</span><br><span class="line">   +-lib</span><br><span class="line">      +-依赖的jar包</span><br></pre></td></tr></table></figure>
<p>可以看出主要分为三部分:<br><code>META-INF</code>文件夹: 元数据信息;<br><code>org</code>文件夹: springboot框架相关的class和依赖;<br><code>BOOT-INF</code>: 我们写的代码、resource以及引入的相关依赖。</p>
<p>其中比较重要的是元数据信息中的<code>MANIFEST.MF</code>:</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">Manifest-Version:</span> <span class="number">1.0</span></span><br><span class="line"><span class="attr">Archiver-Version:</span> <span class="string">Plexus</span> <span class="string">Archiver</span></span><br><span class="line"><span class="attr">Built-By:</span> <span class="string">mengqifeng</span></span><br><span class="line"><span class="attr">Start-Class:</span> <span class="string">com.tencent.xxx.Application</span></span><br><span class="line"><span class="attr">Spring-Boot-Classes:</span> <span class="string">BOOT-INF/classes/</span></span><br><span class="line"><span class="attr">Spring-Boot-Lib:</span> <span class="string">BOOT-INF/lib/</span></span><br><span class="line"><span class="attr">Spring-Boot-Version:</span> <span class="number">2.2</span><span class="number">.0</span><span class="string">.M4</span></span><br><span class="line"><span class="attr">Created-By:</span> <span class="string">Apache</span> <span class="string">Maven</span> <span class="number">3.5</span><span class="number">.3</span></span><br><span class="line"><span class="attr">Build-Jdk:</span> <span class="number">1.8</span><span class="string">.0_161</span></span><br><span class="line"><span class="attr">Main-Class:</span> <span class="string">org.springframework.boot.loader.JarLauncher</span></span><br></pre></td></tr></table></figure>
<p>这里可以看出springboot的入口类是<code>org.springframework.boot.loader.JarLauncher</code>。<br>先启动它这个类(main-class)，然后反射调用我们的类(start-class)。</p>
<p>此外由于这里看出lib文件夹的目录是<code>/BOOT-INF/class/lib</code>,我们可以手动在pom文件中修改resource文件的打包路径,对准这个目录放进去就可以作为库文件依赖了:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src\main\resources\lib<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">targetPath</span>&gt;</span>/BOOT-INF/class/lib<span class="tag">&lt;/<span class="name">targetPath</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.jar<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="默认的maven包结构"><a href="#默认的maven包结构" class="headerlink" title="默认的maven包结构"></a>默认的maven包结构</h1><p>如果把<code>xxx.jar.original</code>解压开的话,能得到springboot<code>repackage</code>以前的包结构。<br>此时只有两部分,元数据信息和我们写的代码(字节码和资源文件),没有依赖库:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+-META-INF</span><br><span class="line">|  +-MANIFEST.MF</span><br><span class="line">|  +-maven</span><br><span class="line">|     +-pom.xml</span><br><span class="line">|     +-pom.properties</span><br><span class="line">+-com(我们写的代码)以及其他src&#x2F;main&#x2F;resource路径下的文件</span><br></pre></td></tr></table></figure>

<p>元数据信息中的<code>MANIFEST.MF</code>内容也少一些:</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">Manifest-Version:</span> <span class="number">1.0</span></span><br><span class="line"><span class="attr">Archiver-Version:</span> <span class="string">Plexus</span> <span class="string">Archiver</span></span><br><span class="line"><span class="attr">Built-By:</span> <span class="string">mengqifeng</span></span><br><span class="line"><span class="attr">Created-By:</span> <span class="string">Apache</span> <span class="string">Maven</span> <span class="number">3.5</span><span class="number">.3</span></span><br><span class="line"><span class="attr">Build-Jdk:</span> <span class="number">1.8</span><span class="string">.0_161</span></span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://xiaoyue26.github.io/2019/09/08/2019-09/springboot%E5%8C%85%E7%BB%93%E6%9E%84/" data-id="ck96cxpq700jwmaaman5t7jxy" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/" rel="tag">java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/maven/" rel="tag">maven</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/spring/" rel="tag">spring</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-2019-09/JNI总结" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/09/07/2019-09/JNI%E6%80%BB%E7%BB%93/" class="article-date">
  <time datetime="2019-09-07T10:20:10.000Z" itemprop="datePublished">2019-09-07</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/java/">java</a>►<a class="article-category-link" href="/categories/java/%E6%80%A7%E8%83%BD/">性能</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/09/07/2019-09/JNI%E6%80%BB%E7%BB%93/">JNI总结</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <h1 id="what-JNI是啥"><a href="#what-JNI是啥" class="headerlink" title="what: JNI是啥"></a>what: JNI是啥</h1><p><code>JNI(Java Native Interface)</code>是java访问<code>native</code>方法的接口规范。<br>所谓<code>native</code>方法一般是c/c++代码。（也可以是汇编）<br>java实现了一个JNI框架来让java和其他语言互调，java方法可以调JNI接口声明了的native方法，native方法也可以创建、使用java对象。<br>JNI接口规范主要按照<code>c</code>语言，不像<code>c++</code>一样改写方法名。<br>因此实际编码中需要用<code>extern c</code>来维持方法名的纯净。</p>
<p>编译方法:<br>c++: <code>print(int)</code>=&gt;<code>print_int</code>;<br>c: <code>print</code>.<br>所以我们需要c这种风格的。(不支持重载)</p>
<h1 id="why-为啥要使用JNI"><a href="#why-为啥要使用JNI" class="headerlink" title="why: 为啥要使用JNI"></a>why: 为啥要使用JNI</h1><p>使用的场景包括:</p>
<ol>
<li>有些现成的代码是c/c++的，需要在java中调用; （比如一些平台相关的、SIMD操作、或其他java中没有的库）</li>
<li>c/c++版本的代码也许有巨大的性能优势。</li>
</ol>
<h1 id="HOW-JNI如何工作"><a href="#HOW-JNI如何工作" class="headerlink" title="HOW: JNI如何工作"></a>HOW: JNI如何工作</h1><h2 id="如何使用JNI"><a href="#如何使用JNI" class="headerlink" title="如何使用JNI"></a>如何使用JNI</h2><p>两种方法： 静态注册和动态加载。</p>
<h3 id="静态注册"><a href="#静态注册" class="headerlink" title="静态注册"></a>静态注册</h3><p>假设我们要在java中调用c的方法,大致分为6个步骤:</p>
<ol>
<li>在java中声明一个<code>native</code>方法,但是不实现;</li>
<li>编译java字节码,生成<code>class</code>文件;(<code>javac</code>命令)</li>
<li>用class文件生成<code>.h</code>的文件头;(<code>javah</code>命令)</li>
<li>创建<code>.c</code>文件实现<code>.h</code>文件头中声明的方法;</li>
<li>编译<code>.c</code>，<code>.h</code>文件生成动态链接库<code>.so</code>;</li>
<li>在<code>java</code>中加载<code>.so</code>文件,使用第一步中声明的方法。</li>
</ol>
<p>相关命令:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:.</span><br><span class="line">javac HelloWorld.java</span><br><span class="line">javah HelloWorld</span><br><span class="line">gcc -fPIC -I /usr/lib/jvm/jdk/include -I /usr/lib/jvm/jdk/include/linux -shared libHelloWorld.c -o libHelloWorld.so</span><br><span class="line">export LD_LIBRARY_PATH=.:$LD_LIBRARY_PATH # 为了找到so文件</span><br><span class="line">java -Djava.library.path=. HelloWorld  # 也是为了找到so文件(二选一即可)</span><br></pre></td></tr></table></figure>

<h3 id="动态加载"><a href="#动态加载" class="headerlink" title="动态加载"></a>动态加载</h3><p>利用<code>RegisterNatives</code>方法来注册Java方法与JNI函数的映射。</p>
<ol>
<li>利用结构体<code>JNINativeMethod</code>数组记录 Java 方法与 JNI 函数的对应关系</li>
<li>实现 <code>JNI_OnLoad</code> 方法，在加载动态库后，执行动态注册</li>
<li>调用 <code>FindClass</code> 方法，获取Java对象</li>
<li>调用 <code>RegisterNatives</code>方法，传入 Java 对象、<code>JNINativeMethod</code>;</li>
<li>数组及注册方法数完成注册；</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下是c++版本的,c语言版本的话很简单,只要把:</span></span><br><span class="line"><span class="comment">// env-&gt;改成(*env)-&gt;</span></span><br><span class="line"><span class="comment">// 调用的方法参数第一个参数加上env即可。</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> JNI_CLASS_PAPT <span class="meta-string">"com/xxx"</span></span></span><br><span class="line"><span class="function">JNIEXPORT jstring JNICALL <span class="title">native_test</span><span class="params">(JNIEnv *env, jobject instance)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> env-&gt;NewStringUTF(<span class="string">"hello world"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> JNINativeMethod g_methods[] = &#123;</span><br><span class="line">        <span class="comment">// Java层方法、参数类型、native方法</span></span><br><span class="line">        &#123;<span class="string">"get_hello_world"</span>, <span class="string">"()Ljava/lang/String;"</span>, (<span class="keyword">void</span>*)native_test&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 动态库加载时回调方法</span></span><br><span class="line"><span class="function">jint <span class="title">JNI_OnLoad</span><span class="params">(JavaVM *vm, <span class="keyword">void</span> *reserved)</span> </span>&#123;</span><br><span class="line">    JNIEnv *env = <span class="literal">NULL</span>;</span><br><span class="line">    vm-&gt;GetEnv((<span class="keyword">void</span>**)&amp;env, JNI_VERSION_1_8);</span><br><span class="line">    jclass clazz= env-&gt;FindClass(JNI_CLASS_PAPT);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 注册Java和natvie方法映射表</span></span><br><span class="line">    env-&gt;RegisterNatives(clazz</span><br><span class="line">    , g_methods</span><br><span class="line">    , <span class="keyword">sizeof</span>(g_methods)/<span class="keyword">sizeof</span>(g_methods[<span class="number">0</span>]));</span><br><span class="line">    <span class="keyword">return</span> JNI_VERSION_1_8;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参见<code>jni.h</code>中的<code>JNINativeMethod</code>结构体:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* name; <span class="comment">// java方法名</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* signature;<span class="comment">// java方法签名</span></span><br><span class="line">    <span class="keyword">void</span>*       fnPtr; <span class="comment">// c函数指针</span></span><br><span class="line">&#125; JNINativeMethod;</span><br></pre></td></tr></table></figure>


<h2 id="JNI原理"><a href="#JNI原理" class="headerlink" title="JNI原理"></a>JNI原理</h2><p>本质其实就是JVM使用了so动态链接库中的函数，所以关键在于函数名的映射。<br>一个典型的<code>native</code>方法的签名如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// native方法的签名由类名(含包名,点换成下划线)和方法名拼接而成:</span></span><br><span class="line">JNIEXPORT <span class="keyword">void</span> JNICALL Java_packname_classname_methodname</span><br><span class="line">  (JNIEnv *env, jobject obj)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*Implement Native Method Here*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可见，JVM调用native方法的时候，需要传递一个<code>JNIEnv</code>指针和一个<code>jobject</code>指针。</p>
<blockquote>
<p>JNIEnv: 包含访问JVM的接口，可以进行native数组和java数组转换，字符串转换，对象实例化、抛异常等等java能做的事情；</p>
</blockquote>
<blockquote>
<p>jobject: 声明native方法的java对象。</p>
</blockquote>
<p>每一个Java线程对应一个<code>JNIEnv</code>。<br><code>JNIEnv</code>指针仅在native方法当前线程中有效；如果手动保存到其他地方，然后在其他线程中想要使用，需要调用<code>AttachCurrentThread</code>来挂靠当前线程到jvm，使用完毕后调用<code>DetachCurrentThread</code>脱离jvm。<br>挂靠样例:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. </span></span><br><span class="line">JNIEnv *env;</span><br><span class="line">(*g_vm)-&gt;AttachCurrentThread (g_vm, (<span class="keyword">void</span> **) &amp;env, <span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">// 2. 脱离:</span></span><br><span class="line">(*g_vm)-&gt;DetachCurrentThread (g_vm);</span><br></pre></td></tr></table></figure>



<h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p>native和java的基本类型能自动互转，复杂类型（数组、数组、对象）则要使用<code>JNIEnv</code>显式地进行转换。</p>
<p>字符串转换(C++版本):</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span></span><br><span class="line">JNIEXPORT <span class="keyword">void</span> JNICALL Java_ClassName_MethodName</span><br><span class="line">  (JNIEnv *env, jobject obj, jstring javaString)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// java字符串=&gt;c字符串</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *nativeString = env-&gt;GetStringUTFChars(javaString, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// do something with nativeString</span></span><br><span class="line">    <span class="comment">// 释放:</span></span><br><span class="line">    env-&gt;ReleaseStringUTFChars(javaString, nativeString);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>c语言版本就是参数多了<code>env</code>参数:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">JNIEXPORT <span class="keyword">void</span> JNICALL Java_ClassName_MethodName</span><br><span class="line">  (JNIEnv *env, jobject obj, jstring javaString)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 转换:</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *nativeString = (*env)-&gt;GetStringUTFChars(env, javaString, <span class="number">0</span>);</span><br><span class="line"><span class="comment">// 释放:</span></span><br><span class="line">    (*env)-&gt;ReleaseStringUTFChars(env, javaString, nativeString);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="基本类型的映射"><a href="#基本类型的映射" class="headerlink" title="基本类型的映射"></a>基本类型的映射</h2><table>
<thead>
<tr>
<th>native类型</th>
<th>Java类型</th>
<th>描述</th>
<th>java类型签名（signature）</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>unsigned char</td>
<td>jboolean</td>
<td>unsigned 8位</td>
<td>Z</td>
<td></td>
</tr>
<tr>
<td>signed char</td>
<td>jbyte</td>
<td>signed 8位</td>
<td>B</td>
<td></td>
</tr>
<tr>
<td>unsigned short</td>
<td>jchar</td>
<td>unsigned 16位</td>
<td>C</td>
<td></td>
</tr>
<tr>
<td>short</td>
<td>jshort</td>
<td>signed 16位</td>
<td>S</td>
<td></td>
</tr>
<tr>
<td>long</td>
<td>jint</td>
<td>signed 32位</td>
<td>I</td>
<td></td>
</tr>
<tr>
<td>long long__int64</td>
<td>jlong</td>
<td>signed 64位</td>
<td>J</td>
<td></td>
</tr>
<tr>
<td>float</td>
<td>jfloat</td>
<td>32位</td>
<td>F</td>
<td></td>
</tr>
<tr>
<td>double</td>
<td>jdouble</td>
<td>64位</td>
<td>D</td>
<td></td>
</tr>
<tr>
<td>void</td>
<td>void</td>
<td></td>
<td>V</td>
<td></td>
</tr>
</tbody></table>
<p>string类的类型签名: <code>Ljava/lang/String;</code><br>整型数组的类型签名: <code>[I</code><br><code>int[][]</code>的签名: <code>[[I</code></p>
<h1 id="JNI代码中调用java对象方法"><a href="#JNI代码中调用java对象方法" class="headerlink" title="JNI代码中调用java对象方法"></a>JNI代码中调用java对象方法</h1><h2 id="1-调用实例方法"><a href="#1-调用实例方法" class="headerlink" title="1. 调用实例方法"></a>1. 调用实例方法</h2><p>首先我们有env和obj，步骤是：</p>
<blockquote>
<ol>
<li>用env、obj获取class对象cls;</li>
<li>用env、cls和方法签名反射获得方法引用mid;</li>
<li>用env、obj、mid调用方法。</li>
</ol>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">JNIEXPORT <span class="keyword">void</span> JNICALL  <span class="title">Java_InstanceMethodCall_nativeMethod</span><span class="params">(JNIEnv *env, jobject obj)</span> </span>&#123; </span><br><span class="line">     jclass cls = (*env)-&gt;GetObjectClass(env, obj);  </span><br><span class="line">     jmethodID mid =  (*env)-&gt;GetMethodID(env, cls, <span class="string">"callback"</span>, <span class="string">"()V"</span>);  </span><br><span class="line">     <span class="keyword">if</span> (mid == <span class="literal">NULL</span>) &#123; </span><br><span class="line">         <span class="keyword">return</span>; <span class="comment">/* method not found */</span> </span><br><span class="line">     &#125; </span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">"In C\n"</span>); </span><br><span class="line">     (*env)-&gt;CallVoidMethod(env, obj, mid);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-调用静态方法"><a href="#2-调用静态方法" class="headerlink" title="2. 调用静态方法"></a>2. 调用静态方法</h2><p>前两步和刚才一样,第三部把Obj换成cls即可:</p>
<ol>
<li>获取cls;</li>
<li>获取mid;</li>
<li>用env、cls、mid调用静态方法。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">JNIEXPORT <span class="keyword">void</span> JNICALL  <span class="title">Java_StaticMethodCall_nativeMethod</span><span class="params">(JNIEnv *env, jobject obj)</span> </span>&#123; </span><br><span class="line">     jclass cls = (*env)-&gt;GetObjectClass(env, obj); </span><br><span class="line">     jmethodID mid =  </span><br><span class="line">         (*env)-&gt;GetStaticMethodID(env, cls, <span class="string">"callback"</span>, <span class="string">"()V"</span>); </span><br><span class="line">     <span class="keyword">if</span> (mid == <span class="literal">NULL</span>) &#123; </span><br><span class="line">         <span class="keyword">return</span>;  <span class="comment">/* method not found */</span> </span><br><span class="line">     &#125; </span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">"In C\n"</span>); </span><br><span class="line">     (*env)-&gt;CallStaticVoidMethod(env, cls, mid);  <span class="comment">// 这里是cls</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="JNI需要注意的点"><a href="#JNI需要注意的点" class="headerlink" title="JNI需要注意的点"></a>JNI需要注意的点</h1><ol>
<li>native方法自己管理内存,jvm不gc这部分;</li>
<li>JNI调用开销较大，不宜频繁调用;（java数组、字符串都会线性拷贝）</li>
<li>JNI方法平台有关,移植性差;</li>
<li>c代码里显式释放内存;</li>
<li>字符编码问题。</li>
</ol>
<p>第四点一般是获取和释放成对使用：(多少get就有多少delete或release)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GetObjectField&#x3D;&gt;DeleteLocalRef</span><br><span class="line">GetStringUTFChars&#x3D;&gt;ReleaseStringUTFChars</span><br></pre></td></tr></table></figure>

<p>最后一个字符编码问题:<br>JNI里的这几个函数实际上用的是修改版本的<code>UTF-8</code>，并不完全等效于<code>UTF-8</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">NewStringUTF</span><br><span class="line">GetStringUTFLength</span><br><span class="line">GetStringUTFChars</span><br><span class="line">ReleaseStringUTFChars</span><br><span class="line">GetStringUTFRegion</span><br></pre></td></tr></table></figure>
<p>用户应当使用这几个函数,先创建UTF-16，然后安全地转换成标准<code>UTF-8</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">NewString</span><br><span class="line">GetStringLength</span><br><span class="line">GetStringChars</span><br><span class="line">ReleaseStringChars</span><br><span class="line">GetStringRegion</span><br><span class="line">GetStringCritical</span><br><span class="line">ReleaseStringCritical</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://xiaoyue26.github.io/2019/09/07/2019-09/JNI%E6%80%BB%E7%BB%93/" data-id="ck96cxpq400jlmaam08ly4o8b" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JNI/" rel="tag">JNI</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/" rel="tag">java</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-2019-09/静态链接库和动态链接库" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/09/04/2019-09/%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93%E5%92%8C%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93/" class="article-date">
  <time datetime="2019-09-04T02:24:06.000Z" itemprop="datePublished">2019-09-04</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/java/">java</a>►<a class="article-category-link" href="/categories/java/%E6%80%A7%E8%83%BD/">性能</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/09/04/2019-09/%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93%E5%92%8C%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93/">静态链接库和动态链接库</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <h2 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h2><p><code>JNI</code>的时候发现要使用<code>so</code>文件、动态链接库，那么究竟什么是动态链接库呢？</p>
<p>参考:<br><a href="https://www.zhihu.com/question/20484931" target="_blank" rel="noopener">https://www.zhihu.com/question/20484931</a></p>
<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>库有两种：静态库和动态库。<br>静态库: <code>.a</code>,<code>.lib</code>;<br>动态库：<code>.so</code>,<code>.dll</code>;<br><code>windows</code>:<code>.lib</code>,<code>.dll</code>;<br><code>linux</code>:<code>.a</code>,<code>.so</code>;</p>
<p>非库:<br>生成<code>.o</code>文件: <code>g++ -c hellospeak.cpp</code>;<br>// 只产生编译的代码(没有链接link)<br>生成<code>.out</code>文件: <code>g++ hellospeak.cpp speak.cpp -o hellospeak</code>;<br>// 执行完整的编译过程，并且生成一个a.out文件。</p>
<h1 id="链接过程"><a href="#链接过程" class="headerlink" title="链接过程"></a>链接过程</h1><p>源文件(<code>.h</code>,<code>.cpp</code>)<br>=&gt;预编译=&gt;编译=&gt;汇编<br>=&gt;<strong>链接</strong><br>=&gt;可执行文件</p>
<p>这里我们主要关心<strong>链接</strong>阶段。</p>
<h2 id="静态库"><a href="#静态库" class="headerlink" title="静态库"></a>静态库</h2><p>链接阶段:<br>汇编生成的<code>.o</code>+引用的库=&gt; 可执行文件;</p>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ol>
<li>静态库在内存中可能造成空间浪费。<br>如100个进程都使用了静态库A，则内存中有100份占用。</li>
<li>更新库不灵活。</li>
</ol>
<h2 id="动态库-又称共享库"><a href="#动态库-又称共享库" class="headerlink" title="动态库(又称共享库)"></a>动态库(又称共享库)</h2><p>链接阶段：<br>不加入引用的库。推迟到运行时。<br>运行时：<br>动态加载<code>.so</code>,<code>.dll</code>文件。</p>
<h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h3><p>多了运行时计算符号链接的开销，但是这个开销不大。</p>
<p>所以jni只能使用动态链接库。(linux的话就是<code>so</code>文件)</p>
<h2 id="gcc相关参数"><a href="#gcc相关参数" class="headerlink" title="gcc相关参数"></a>gcc相关参数</h2><p><a href="https://colobu.com/2018/08/28/15-Most-Frequently-Used-GCC-Compiler-Command-Line-Options/" target="_blank" rel="noopener">https://colobu.com/2018/08/28/15-Most-Frequently-Used-GCC-Compiler-Command-Line-Options/</a></p>
<p><code>-fPIC</code>: 产生位置无关的代码；<br><code>-shared</code>: 产生共享库;(动态库)<br>例子:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc -c -Wall -Werror -fPIC Cfile.c</span><br><span class="line">gcc -shared -o libCfile.so Cfile.o</span><br></pre></td></tr></table></figure>

<p><code>-static</code>: 生成静态链接的文件<br>例子:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc main.c -static -o main -lpthread</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://xiaoyue26.github.io/2019/09/04/2019-09/%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93%E5%92%8C%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93/" data-id="ck96cxpq900k4maamdzml6iii" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JNI/" rel="tag">JNI</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/" rel="tag">java</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-2019-09/CriticalNative-降低JNI开销" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/09/01/2019-09/CriticalNative-%E9%99%8D%E4%BD%8EJNI%E5%BC%80%E9%94%80/" class="article-date">
  <time datetime="2019-09-01T08:41:03.000Z" itemprop="datePublished">2019-09-01</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/java/">java</a>►<a class="article-category-link" href="/categories/java/%E6%80%A7%E8%83%BD/">性能</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/09/01/2019-09/CriticalNative-%E9%99%8D%E4%BD%8EJNI%E5%BC%80%E9%94%80/">CriticalNative:降低JNI开销</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <h1 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h1><p><code>Android</code>中有<code>@CriticalNative</code>注解:<br><a href="https://source.android.google.cn/devices/tech/dalvik/improvements" target="_blank" rel="noopener">https://source.android.google.cn/devices/tech/dalvik/improvements</a><br>里面说到:</p>
<blockquote>
<p>@FastNative 可以使原生方法的性能提升高达 2 倍，@CriticalNative 则可以提升高达4倍。 </p>
</blockquote>
<p>那么这是怎么做到的呢？</p>
<h1 id="native方法"><a href="#native方法" class="headerlink" title="native方法"></a>native方法</h1><p>调用native方法时,JVM的工作步骤:<br>(源码: <a href="http://hg.openjdk.java.net/jdk8u/jdk8u/hotspot/file/4d9931ebf861/src/cpu/x86/vm/sharedRuntime_x86_64.cpp#l1723" target="_blank" rel="noopener">http://hg.openjdk.java.net/jdk8u/jdk8u/hotspot/file/4d9931ebf861/src/cpu/x86/vm/sharedRuntime_x86_64.cpp#l1723</a>)</p>
<blockquote>
<ol>
<li>创建栈帧;</li>
<li>根据ABI移动参数到寄存器或者栈;(ABI: 应用二进制接口)</li>
<li>封装对象引用到JNI handlers;</li>
<li>获取静态方法的<code>JNIEnv*</code>和<code>jclass</code>,把他们作为额外参数传递;</li>
<li>检查是否调用<code>method_entry</code>的trace函数; </li>
<li>检查是否调用对象锁;（<code>synchronized</code>）(optinal)</li>
<li>检查native方法是否已经链接;(懒加载函数检查、链接)</li>
<li>线程状态从<code>in_java</code>转变为<code>in_native</code>;</li>
<li>调用native方法;</li>
<li>检查是否需要safepoint;</li>
<li>线程状态转回<code>in_java</code>;</li>
<li>解锁对象锁;(optional)</li>
<li>notify <code>method_exit</code>;(optional)</li>
<li>将对象结果解出，重置JNI handlers;</li>
<li>处理JNI异常;</li>
<li>移除栈帧。</li>
</ol>
</blockquote>
<p>开销比较大,主要是用于各种参数拷贝,尤其是遇到数组，需要来回拷贝、检查。</p>
<p>此时，如果是足够简单的native方法,可以用<code>Critical Natives</code>来降低开销。</p>
<h1 id="Critical-Native方法"><a href="#Critical-Native方法" class="headerlink" title="Critical Native方法"></a>Critical Native方法</h1><p><code>Critical Natives</code>方法是需要满足下列约束的<code>native</code>方法:</p>
<blockquote>
<ol>
<li>必须是static且没有synchronized; (省掉上一节的6、12步)</li>
<li>参数类型必须是基本类型或基本类型的数组;(省掉上一节中的对象相关3、14)</li>
<li>具体实现不能调用JNI函数(也就是不使用<code>JNIEnv* env</code>和<code>jclass cls</code>,既然不使用就不用传给它了),不能分配java对象或者抛出异常;(省掉上一节中的4、15)</li>
<li>不能运行太长时间.(因为它会阻塞gc)</li>
</ol>
</blockquote>
<p>基于这个原理的话, <code>critical native</code>方法比普通<code>native</code>方法快的原因其实是节省了一些调用开始和结束的开销，因此如果被调用的方法如果是时间占用的大头的话，其实这个优化幅度就很小了。<br>反之如果是频繁调用的方法，而且每次调用的数据量很小，此时调用开销和执行开销是同量级，那么累计的优化幅度就会很大。<br>（比如只是长度为16的数组计算的话，计算力提升可以达到2～3倍。）</p>
<p>满足上述约束以后,<code>Critical Natives</code>方法还需要进行下列声明:</p>
<blockquote>
<ol>
<li>方法名以<code>JavaCritical_</code>开头;</li>
<li>没有额外的<code>JNIEnv*</code>和<code>jclass</code>参数;(因为是static方法,自然也就没有jobject参数了)</li>
<li>java数组传递的时候用两个参数: 数组长度、数组引用(基本类型)。<br>// 这样不再需要调用<code>GetArrayLength</code>、<code>GetByteArrayElements</code>等函数。</li>
</ol>
</blockquote>
<p>此外critical natives方法变成临界区。<br><code>native</code>方法示例:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">JNIEXPORT jint JNICALL</span><br><span class="line">Java_com_package_MyClass_nativeMethod(JNIEnv* env, jclass klass, jbyteArray <span class="built_in">array</span>) &#123;</span><br><span class="line">    jboolean isCopy;</span><br><span class="line">    jint length = (*env)-&gt;GetArrayLength(env, <span class="built_in">array</span>);</span><br><span class="line">    jbyte* buf = (*env)-&gt;GetByteArrayElements(env, <span class="built_in">array</span>, &amp;isCopy);</span><br><span class="line">    jint result = <span class="built_in">process</span>(buf, length);</span><br><span class="line">    (*env)-&gt;ReleaseByteArrayElements(env, <span class="built_in">array</span>, buf, JNI_ABORT);</span><br><span class="line">    <span class="keyword">return</span> result;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Critical Natives</code>方法示例:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">JNIEXPORT jint JNICALL</span><br><span class="line">JavaCritical_com_package_MyClass_nativeMethod(jint length, jbyte* buf) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">process</span>(buf, length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>critical</code>版本的方法是JIT需要的(默认是调用超过1500次,可以调JIT参数<code>-XX:CompileThreshold=invocations</code>);<br>普通<code>native</code>版本的方法是解释器需要的;</p>
<p>因此实际用的时候，这俩版本的代码都要写上。比如是这样的:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;jni.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(jbyte* <span class="built_in">array</span>, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">        result += <span class="built_in">array</span>[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Class:     com_tencent_xxx_test_Natives</span></span><br><span class="line"><span class="comment"> * Method:    javaCriticalImpl</span></span><br><span class="line"><span class="comment"> * Signature: ([B)I</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">JNIEXPORT jint JNICALL Java_com_tencent_xxx_test_Natives_javaCriticalImpl</span><br><span class="line">  (JNIEnv* env, jclass cls, jbyteArray <span class="built_in">array</span>)&#123;</span><br><span class="line">  jboolean isCopy;</span><br><span class="line">  jint length = (*env)-&gt;GetArrayLength(env, <span class="built_in">array</span>);</span><br><span class="line">  jbyte* buf = (jbyte*) (*env)-&gt;GetPrimitiveArrayCritical(env, <span class="built_in">array</span>, &amp;isCopy);</span><br><span class="line">  jint result = sum(buf, length);</span><br><span class="line">  (*env)-&gt;ReleasePrimitiveArrayCritical(env, <span class="built_in">array</span>, buf, JNI_ABORT);</span><br><span class="line">  <span class="comment">// 有副作用的c函数用0; 无副作用的c函数直接用JNI_ABORT.</span></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">JNIEXPORT jint JNICALL</span><br><span class="line">JavaCritical_com_tencent_xxx_test_Natives_javaCriticalImpl(jint length, jbyte* buf) &#123;</span><br><span class="line">    <span class="keyword">return</span> sum(buf, length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>(之所以这么繁琐的原因是这个特性和Unsafe一样是jdk内部使用的,没有公开发布给普通程序员,正式发布估计要到jdk10了)</p>
<p>参考:<br><a href="http://cr.openjdk.java.net/~jrose/panama/native-call-primitive.html" target="_blank" rel="noopener">http://cr.openjdk.java.net/~jrose/panama/native-call-primitive.html</a><br><a href="http://mail.openjdk.java.net/pipermail/panama-dev/2015-December/000225.html" target="_blank" rel="noopener">http://mail.openjdk.java.net/pipermail/panama-dev/2015-December/000225.html</a><br><a href="https://stackoverflow.com/questions/36298111/is-it-possible-to-use-sun-misc-unsafe-to-call-c-functions-without-jni/36309652#36309652" target="_blank" rel="noopener">https://stackoverflow.com/questions/36298111/is-it-possible-to-use-sun-misc-unsafe-to-call-c-functions-without-jni/36309652#36309652</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://xiaoyue26.github.io/2019/09/01/2019-09/CriticalNative-%E9%99%8D%E4%BD%8EJNI%E5%BC%80%E9%94%80/" data-id="ck96cxpq200jgmaam80lnhwyz" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JNI/" rel="tag">JNI</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/" rel="tag">java</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-2019-09/程序计算加速之SIMD相关概念" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/09/01/2019-09/%E7%A8%8B%E5%BA%8F%E8%AE%A1%E7%AE%97%E5%8A%A0%E9%80%9F%E4%B9%8BSIMD%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/" class="article-date">
  <time datetime="2019-09-01T08:27:04.000Z" itemprop="datePublished">2019-09-01</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/java/">java</a>►<a class="article-category-link" href="/categories/java/%E6%80%A7%E8%83%BD/">性能</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/09/01/2019-09/%E7%A8%8B%E5%BA%8F%E8%AE%A1%E7%AE%97%E5%8A%A0%E9%80%9F%E4%B9%8BSIMD%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/">程序计算加速之SIMD相关概念</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <h1 id="What-什么是SIMD"><a href="#What-什么是SIMD" class="headerlink" title="What: 什么是SIMD"></a>What: 什么是SIMD</h1><p>SIMD全称<code>Single Instruction Multiple Data</code>，单指令多数据流，是一种采用一个控制器来控制多个处理器，同时对一组数据（又称“数据向量”）中的每一个分别执行相同的操作从而实现空间上的并行性的技术。</p>
<p>也就是说SIMD需要CPU指令集的支持，才能用一条指令就同时并行计算多个数据。当然了，这里同时计算时运用的是同一种运算，比如都是加法。</p>
<h1 id="WHY-为什么要使用SIMD"><a href="#WHY-为什么要使用SIMD" class="headerlink" title="WHY: 为什么要使用SIMD"></a>WHY: 为什么要使用SIMD</h1><p>能并行计算肯定是要比串行计算快的。<br>SIMD是cpu层面的加速，当然还有gpu层面的加速比如cuda编程。<br>如果需要大量浮点数计算、矩阵计算，比如游戏场景、机器学习场景下都是需要这些加速技术的。</p>
<h1 id="不同版本和历史"><a href="#不同版本和历史" class="headerlink" title="不同版本和历史"></a>不同版本和历史</h1><p>既然说到cpu，肯定绕不开intel和AMD。<br>最早是intel推出的，利用了多余的寄存器来加速多媒体运算，后来逐渐标准化：</p>
<h2 id="缩写"><a href="#缩写" class="headerlink" title="缩写:"></a>缩写:</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MMX(可能是MultiMedia eXtension的缩写)</span><br><span class="line">SSE(Streaming SIMD Extensions)</span><br><span class="line">AVX(Advanced Vcetor Extension) : 对SSE的后续扩展，主要分为AVX、AVX2、AVX512三种。在目前常见的机器上，大多只支持到AVX系列。</span><br></pre></td></tr></table></figure>
<h2 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">MMX: intel, Pentium;</span><br><span class="line">SSE: intel, Pentium 3;</span><br><span class="line">SSE2: intel, Pentium 4;</span><br><span class="line">SSE3: intel, Pentium 4;</span><br><span class="line">SSE4: intel, Core 2 Duo; 128位。</span><br><span class="line">SSE5: AMD;</span><br><span class="line">AVX:  intel, 因为SSE5被AMD抢先出了,intel恼羞成怒改名叫AVX了; 支持256位。</span><br><span class="line">AVX2: intel, 加入了整形支持。支持256位。</span><br><span class="line">AVX512: intel, 支持521位。</span><br></pre></td></tr></table></figure>

<h1 id="HOW：-如何使用SIMD"><a href="#HOW：-如何使用SIMD" class="headerlink" title="HOW： 如何使用SIMD"></a>HOW： 如何使用SIMD</h1><h2 id="JAVA中使用"><a href="#JAVA中使用" class="headerlink" title="JAVA中使用"></a>JAVA中使用</h2><p>jdk8的话，可以<code>jinfo -flag &lt;pid&gt;</code>一下，这三个其实是默认配置(java8):</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-XX:UseAVX&#x3D;2</span><br><span class="line">-XX:UseSSE&#x3D;5</span><br><span class="line">-XX:+UseSSE42Intrinsics</span><br></pre></td></tr></table></figure>

<p>可以受益的操作：<br>加减乘除、乘累加。<br>所以jvm是默认会对一些代码进行SIMD优化，具体方法是自己构造数组，比如本来只是要统计一个数组的总和，用一个局部变量即可，可以改成用一个长度为8的局部数组（或者16、具体长度需要benchmark才知道最优，要符合cpu的SIMD支持长度），然后在8个位置上分别求和，最后把局部数组求和得到答案，这种代码会比直接求和快1倍。</p>
<p>上述trick自然是非常间接地使用了，直接使用SIMD的库还在开发中：<br><a href="https://openjdk.java.net/jeps/338" target="_blank" rel="noopener">https://openjdk.java.net/jeps/338</a><br>估计要等到java10以后才能用上了。<br>也有一些国外的scala库(LMS)： <a href="https://astojanov.github.io/blog/2017/12/20/scala-simd.html?tdsourcetag=s_pcqq_aiomsg" target="_blank" rel="noopener">https://astojanov.github.io/blog/2017/12/20/scala-simd.html?tdsourcetag=s_pcqq_aiomsg</a><br>但不知道靠谱不靠谱。</p>
<p>直接使用的库在C语言中是有的，叫做<code>SIMD Intrinsics</code>：<br><a href="https://software.intel.com/sites/landingpage/IntrinsicsGuide/#techs=MMX,SSE,SSE2,SSE3,SSSE3,SSE4_1,SSE4_2,AVX,AVX2,FMA,AVX_512" target="_blank" rel="noopener">https://software.intel.com/sites/landingpage/IntrinsicsGuide/#techs=MMX,SSE,SSE2,SSE3,SSSE3,SSE4_1,SSE4_2,AVX,AVX2,FMA,AVX_512</a><br>比如<code>_mm_set_ps1</code>函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">???-ss后缀的操作: 4个操作数中有一个参加运算；</span><br><span class="line">???-ps后缀的操作：4个操作数都参加运算。</span><br></pre></td></tr></table></figure>
<p>因此我们可以用JNI调用来使用SIMD。<br>为了一定程度上减少JNI开销的话，可以使用<code>CriticalNative</code>。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://www.cnblogs.com/lgxZJ/p/8688430.html" target="_blank" rel="noopener">https://www.cnblogs.com/lgxZJ/p/8688430.html</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://xiaoyue26.github.io/2019/09/01/2019-09/%E7%A8%8B%E5%BA%8F%E8%AE%A1%E7%AE%97%E5%8A%A0%E9%80%9F%E4%B9%8BSIMD%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/" data-id="ck96cxpq900k1maam7l1r7igy" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/SIMD/" rel="tag">SIMD</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/" rel="tag">java</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-2019-08/clickhouse实战之jdbc接入" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/08/25/2019-08/clickhouse%E5%AE%9E%E6%88%98%E4%B9%8Bjdbc%E6%8E%A5%E5%85%A5/" class="article-date">
  <time datetime="2019-08-25T10:29:55.000Z" itemprop="datePublished">2019-08-25</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/clickhouse/">clickhouse</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/08/25/2019-08/clickhouse%E5%AE%9E%E6%88%98%E4%B9%8Bjdbc%E6%8E%A5%E5%85%A5/">clickhouse实战之jdbc接入</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><p>安装好clickhouse后有几个关键的配置需要调整。<br><code>clickhouse</code>的配置文件主要有两个:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/clickhouse-server/config.xml # 服务器配置 </span><br><span class="line">vi /etc/clickhouse-server/users.xml #  客户端连接的默认配置</span><br></pre></td></tr></table></figure>
<p><code>config.xml</code>里需要调整的主要是数据文件的目录、http端口、监听地址:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">http_port</span>&gt;</span>8080<span class="tag">&lt;/<span class="name">http_port</span>&gt;</span> <span class="comment">&lt;!-- 默认是8123--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">listen_host</span>&gt;</span>0.0.0.0<span class="tag">&lt;/<span class="name">listen_host</span>&gt;</span> <span class="comment">&lt;!-- 默认只监听本地127.0.0.1--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">path</span>&gt;</span>/var/lib/clickhouse/<span class="tag">&lt;/<span class="name">path</span>&gt;</span> <span class="comment">&lt;!-- 需要chown -R clickhouse:clickhouse这个目录 如果后续要修改，也可以停服后通过软链接移动到别的目录--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">uncompressed_cache_size</span>&gt;</span>8589934592<span class="tag">&lt;/<span class="name">uncompressed_cache_size</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mark_cache_size</span>&gt;</span>5368709120<span class="tag">&lt;/<span class="name">mark_cache_size</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>此外也能通过配置文件发现默认的tcp端口是9000,interserver_http_port是9009。</p>
<p><code>users.xml</code>里需要调整的主要是:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">max_memory_usage</span>&gt;</span>20000000000<span class="tag">&lt;/<span class="name">max_memory_usage</span>&gt;</span><span class="comment">&lt;!-- 单个查询的最大内存使用bytes--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">password</span>&gt;</span><span class="tag">&lt;/<span class="name">password</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="启动命令"><a href="#启动命令" class="headerlink" title="启动命令"></a>启动命令</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 服务端:</span></span><br><span class="line">sudo service clickhouse-server start </span><br><span class="line"><span class="meta">#</span><span class="bash"> 客户端(多行模式):</span></span><br><span class="line">clickhouse-client -m </span><br><span class="line"><span class="meta">#</span><span class="bash"> 客户端执行sql文件:</span></span><br><span class="line">clickhouse-client -mn &lt; 1.sql</span><br></pre></td></tr></table></figure>

<h1 id="jdbc"><a href="#jdbc" class="headerlink" title="jdbc"></a>jdbc</h1><p>首先是引入依赖:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/ru.yandex.clickhouse/clickhouse-jdbc --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>ru.yandex.clickhouse<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>clickhouse-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.1.54<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>*<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这里我项目里其他地方用fasterxml，有版本冲突，因此这里exclude掉了。</p>
<p>然后配置yml:</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring.clickhouse.hikari:</span></span><br><span class="line">  <span class="attr">idle-timeout:</span> <span class="number">1000</span></span><br><span class="line">  <span class="attr">jdbc-url:</span> <span class="string">jdbc:clickhouse://&lt;your_host_or_ip_address&gt;:8080/default</span></span><br><span class="line">  <span class="attr">driverClassName:</span> <span class="string">ru.yandex.clickhouse.ClickHouseDriver</span></span><br><span class="line">  <span class="attr">maximumPoolSize:</span> <span class="number">10</span></span><br><span class="line">  <span class="attr">rewriteBatchedStatements:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>最后像普通jdbc一样使用即可:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 配置：</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"spring.clickhouse.hikari"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClickhouseDSConfig</span> <span class="keyword">extends</span> <span class="title">HikariConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span>(name=<span class="string">"chds"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">dataSource</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HikariDataSource(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 存储层:</span></span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChDao</span> <span class="keyword">extends</span> <span class="title">JdbcDaoSupport</span> <span class="keyword">implements</span> <span class="title">IChDao</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ChDao</span><span class="params">(@Qualifier(<span class="string">"chds"</span>)</span> DataSource ds) </span>&#123;</span><br><span class="line">        setDataSource(ds);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title">query</span><span class="params">(String sql, Object... args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.getJdbcTemplate().queryForMap(sql, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Map&lt;String, Object&gt;&gt; queryForList(String sql, Object... args) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.getJdbcTemplate().queryForList(sql, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 使用: </span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">IChDao dao;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"begin~~~"</span>);</span><br><span class="line">    String sqlDB = <span class="string">"show databases"</span>;<span class="comment">//查询数据库</span></span><br><span class="line">    System.out.println(dao.queryForList(sqlDB));</span><br><span class="line">    System.out.println(dao.queryForList(<span class="string">"show tables;"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://xiaoyue26.github.io/2019/08/25/2019-08/clickhouse%E5%AE%9E%E6%88%98%E4%B9%8Bjdbc%E6%8E%A5%E5%85%A5/" data-id="ck96cxpq100jamaam88yifok3" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/clickhouse/" rel="tag">clickhouse</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/" rel="tag">java</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-2019-08/神秘的monad——函数式编程" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/08/23/2019-08/%E7%A5%9E%E7%A7%98%E7%9A%84monad%E2%80%94%E2%80%94%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/" class="article-date">
  <time datetime="2019-08-23T01:20:21.000Z" itemprop="datePublished">2019-08-23</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/java/">java</a>►<a class="article-category-link" href="/categories/java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/08/23/2019-08/%E7%A5%9E%E7%A7%98%E7%9A%84monad%E2%80%94%E2%80%94%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/">神秘的monad——函数式编程</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <p>monad确实比较难理解，我认真翻了一个星期资料才理解。</p>
<p>讲得比较好的参考资料：<br><a href="http://josephguan.github.io/2016/06/25/monad-in-scala/" target="_blank" rel="noopener">http://josephguan.github.io/2016/06/25/monad-in-scala/</a><br>比较形象的、有图的：<br><a href="http://blog.forec.cn/2017/03/02/translation-adit-faamip/" target="_blank" rel="noopener">http://blog.forec.cn/2017/03/02/translation-adit-faamip/</a><br>数学上讲得比较多的：(scala版代码可用)<br><a href="https://segmentfault.com/a/1190000008000905" target="_blank" rel="noopener">https://segmentfault.com/a/1190000008000905</a></p>
<p>参考资料3中的scala版代码:</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 半群:</span></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">SemiGroup</span>[<span class="type">A</span>] </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">op</span></span>(a1: <span class="type">A</span>, a2: <span class="type">A</span>): <span class="type">A</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. monoid: (还不是monad) 比半群多一个零元</span></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Monoid</span>[<span class="type">A</span>] <span class="keyword">extends</span> <span class="title">SemiGroup</span>[<span class="type">A</span>] </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">zero</span></span>: <span class="type">A</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函子: (有map函数就是Functor)</span></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Functor</span>[<span class="type">F</span>[_]] </span>&#123;</span><br><span class="line">  <span class="comment">// 输入一个A的容器F[A],输入一个A类型=&gt;B类型的变化</span></span><br><span class="line">  <span class="comment">// 输出B类型的容器F[B]</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">map</span></span>[<span class="type">A</span>, <span class="type">B</span>](a: <span class="type">F</span>[<span class="type">A</span>])(f: <span class="type">A</span> =&gt; <span class="type">B</span>): <span class="type">F</span>[<span class="type">B</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">MonadTest</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> stringMonoid = <span class="keyword">new</span> <span class="type">Monoid</span>[<span class="type">String</span>] &#123;</span><br><span class="line">      <span class="function"><span class="keyword">def</span> <span class="title">op</span></span>(a1: <span class="type">String</span>, a2: <span class="type">String</span>) = a1 + a2</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">def</span> <span class="title">zero</span> </span>= <span class="string">""</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">listMonoid</span></span>[<span class="type">A</span>] = <span class="keyword">new</span> <span class="type">Monoid</span>[<span class="type">List</span>[<span class="type">A</span>]] &#123;</span><br><span class="line">      <span class="function"><span class="keyword">def</span> <span class="title">op</span></span>(a1: <span class="type">List</span>[<span class="type">A</span>], a2: <span class="type">List</span>[<span class="type">A</span>]) = a1 ++ a2</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">def</span> <span class="title">zero</span> </span>= <span class="type">Nil</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">optionMonoid</span></span>[<span class="type">A</span>] = <span class="keyword">new</span> <span class="type">Monoid</span>[<span class="type">Option</span>[<span class="type">A</span>]] &#123;</span><br><span class="line">      <span class="function"><span class="keyword">def</span> <span class="title">op</span></span>(a1: <span class="type">Option</span>[<span class="type">A</span>], a2: <span class="type">Option</span>[<span class="type">A</span>]) = a1 orElse a2</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">def</span> <span class="title">zero</span> </span>= <span class="type">None</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">listFunctor</span> </span>= <span class="keyword">new</span> <span class="type">Functor</span>[<span class="type">List</span>] &#123;</span><br><span class="line">      <span class="function"><span class="keyword">def</span> <span class="title">map</span></span>[<span class="type">A</span>, <span class="type">B</span>](a: <span class="type">List</span>[<span class="type">A</span>])(f: (<span class="type">A</span>) =&gt; <span class="type">B</span>) = a.map(f)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*trait Monad[M[_]] &#123;</span></span><br><span class="line"><span class="comment">  def unit[A](a: A): M[A]   //identity</span></span><br><span class="line"><span class="comment">  def join[A](mma: M[M[A]]): M[A]</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"><span class="comment">// Monad: (有unit和flatmap就是monad)</span></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Monad</span>[<span class="type">M</span>[_]] </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">unit</span></span>[<span class="type">A</span>](a: <span class="type">A</span>): <span class="type">M</span>[<span class="type">A</span>]</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">flatMap</span></span>[<span class="type">A</span>, <span class="type">B</span>](fa: <span class="type">M</span>[<span class="type">A</span>])(f: <span class="type">A</span> =&gt; <span class="type">M</span>[<span class="type">B</span>]): <span class="type">M</span>[<span class="type">B</span>]</span><br><span class="line"></span><br><span class="line">  <span class="comment">// def join[A](mma: M[M[A]]): M[A] = flatMap(mma)(ma =&gt; ma)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>附抄scala版的monad(参考资料1):</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Monad</span>[+<span class="type">T</span>] </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">flatMap</span></span>[<span class="type">U</span>]( f : (<span class="type">T</span>) =&gt; <span class="type">Monad</span>[<span class="type">U</span>] ) : <span class="type">Monad</span>[<span class="type">U</span>]</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">unit</span></span>(value : <span class="type">B</span>) : <span class="type">Monad</span>[<span class="type">B</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// map可以理解为flatmap的特化:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">map</span></span>[<span class="type">U</span>](f : (<span class="type">T</span>) =&gt; <span class="type">U</span>) : <span class="type">Monad</span>[<span class="type">U</span>] = flatMap(v =&gt; unit(f(v)))</span><br><span class="line"></span><br><span class="line"><span class="comment">// Try类型monad:</span></span><br><span class="line"><span class="keyword">val</span> result:<span class="type">Try</span>[<span class="type">Int</span>] = <span class="type">Try</span>(<span class="string">"5"</span>.toInt).flatMap&#123;a =&gt;</span><br><span class="line">                      <span class="type">Try</span>(<span class="string">"6a"</span>.toInt).flatMap&#123;b =&gt;</span><br><span class="line">                      <span class="type">Try</span>(<span class="string">"9"</span>.toInt).flatMap&#123;c =&gt; <span class="type">Try</span>(a + b +c )&#125;&#125;&#125;</span><br><span class="line"><span class="comment">// for是flatmap的语法糖:</span></span><br><span class="line"><span class="keyword">val</span> result: <span class="type">Try</span>[<span class="type">Int</span>] = <span class="keyword">for</span> (</span><br><span class="line">    a &lt;- <span class="type">Try</span>(<span class="string">"5"</span>.toInt);</span><br><span class="line">    b &lt;- <span class="type">Try</span>(<span class="string">"6a"</span>.toInt);</span><br><span class="line">    c &lt;- <span class="type">Try</span>(<span class="string">"9"</span>.toInt)</span><br><span class="line">  ) <span class="keyword">yield</span>( a + b + c)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.1含幺半群G: </span></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Monad</span>[+<span class="type">T</span>]</span></span><br><span class="line"><span class="class"><span class="title">//</span> 1.2<span class="title">二元封闭、结合运算</span></span>:</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">flatMap</span></span>[<span class="type">U</span>]( f : (<span class="type">T</span>) =&gt; <span class="type">Monad</span>[<span class="type">U</span>] ) : <span class="type">Monad</span>[<span class="type">U</span>]</span><br><span class="line"><span class="comment">// 1.3幺元:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">unit</span></span>(value : <span class="type">B</span>) : <span class="type">Monad</span>[<span class="type">B</span>] </span><br><span class="line"><span class="comment">// 2.1结合律/封闭:</span></span><br><span class="line">monad.flatMap(f).flatMap(g) == monad.flatMap(v =&gt; f(v).flatMap(g)) <span class="comment">// associativity</span></span><br><span class="line"><span class="comment">// 案例:</span></span><br><span class="line"><span class="keyword">val</span> multiplier : <span class="type">Int</span> =&gt; <span class="type">Option</span>[<span class="type">Int</span>] = v =&gt; <span class="type">Some</span>(v * v)</span><br><span class="line"><span class="keyword">val</span> divider : <span class="type">Int</span> =&gt; <span class="type">Option</span>[<span class="type">Int</span>] = v =&gt; <span class="type">Some</span>(v/<span class="number">2</span>)</span><br><span class="line"><span class="keyword">val</span> original = <span class="type">Some</span>(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">original.flatMap(multiplier).flatMap(divider) ===</span><br><span class="line">original.flatMap(v =&gt; multiplier(v).flatMap(divider))</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 2.2 左幺元</span></span><br><span class="line">unit(x).flatMap(f) == f(x)</span><br><span class="line"><span class="comment">// 案例:</span></span><br><span class="line"><span class="keyword">val</span> multiplier : <span class="type">Int</span> =&gt; <span class="type">Option</span>[<span class="type">Int</span>] = v =&gt; <span class="type">Some</span>(v * v)</span><br><span class="line"><span class="keyword">val</span> item = <span class="type">Some</span>(<span class="number">10</span>).flatMap(multiplier)</span><br><span class="line">item === multiplier(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.3 右幺元</span></span><br><span class="line">monad.flatMap(unit) == monad</span><br><span class="line"><span class="comment">// 案例:</span></span><br><span class="line"><span class="keyword">val</span> value = <span class="type">Some</span>(<span class="number">50</span>).flatMap(v =&gt; <span class="type">Some</span>(v))</span><br><span class="line">value === <span class="type">Some</span>(<span class="number">50</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 范畴</span></span><br><span class="line">高阶类型（如<span class="type">List</span>[<span class="type">T</span>+]）</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 函子(Functor)</span></span><br><span class="line"><span class="comment">// 函数， Int =&gt; String</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span></span>(i:<span class="type">Int</span>): <span class="type">String</span> = i.toString</span><br><span class="line"><span class="comment">// 函子， List[T] =&gt; Set[T]</span></span><br><span class="line">scala&gt; <span class="function"><span class="keyword">def</span> <span class="title">baz</span></span>[<span class="type">T</span>](l:<span class="type">List</span>[<span class="type">T</span>]): <span class="type">Set</span>[<span class="type">T</span>] = l.toSet</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5. 自函子(Endofunctor)：</span></span><br><span class="line">把一个类型映射到自身类型，比如<span class="type">Int</span>=&gt;<span class="type">Int</span>, <span class="type">String</span>=&gt;<span class="type">String</span> </span><br><span class="line">例如flatmap:</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">flatMap</span></span>[<span class="type">U</span>]( f : (<span class="type">T</span>) =&gt; <span class="type">Monad</span>[<span class="type">U</span>] ) : <span class="type">Monad</span>[<span class="type">U</span>]</span><br></pre></td></tr></table></figure>



<blockquote>
<p>下面开始是我个人的理解</p>
</blockquote>
<h2 id="函数式语言"><a href="#函数式语言" class="headerlink" title="函数式语言"></a>函数式语言</h2><blockquote>
<p>函数是一等公民。<br>无函数副作用。</p>
</blockquote>
<p>（学校里教的）<br>函数可以像普通变量一样使用。（比c里的函数指针更进一步）</p>
<h3 id="更函数式一点"><a href="#更函数式一点" class="headerlink" title="更函数式一点"></a>更函数式一点</h3><p>尽量无状态，最好都像lambda演算一样，有很深的递归。<br>用递归代替循环。</p>
<p>Monad就是这个思想的一个具体实现。</p>
<h2 id="代码层面理解"><a href="#代码层面理解" class="headerlink" title="代码层面理解"></a>代码层面理解</h2><p>Monad在scala中就是一个有flatmap的容器，可以把函数fmap的输出收集起来打平回原来的Monad类型。<br>比较好理解的Monad类型是容器类型：List,Option. </p>
<h2 id="形象上理解"><a href="#形象上理解" class="headerlink" title="形象上理解"></a>形象上理解</h2><p>Monad形象上理解类似于有管道操作的容器，可以把函数fmap的输出适配回Monad类型，方便投入下一个函数中。</p>
<h2 id="比较严密的定义上理解："><a href="#比较严密的定义上理解：" class="headerlink" title="比较严密的定义上理解："></a>比较严密的定义上理解：</h2><p>（去掉范畴学的数学术语，简化理解）<br>Monad是一个我们定义的集合，它上面有零元（如Option中的None\List中的nil），它上面还有一种二元操作op，op(A,B)的结果依然属于Monad(封闭性)，并且运算满足结合律(可以随意加括号)。<br>所以如果有unit函数(生成零元)，flatmap函数（把二元操作打平回集合元素类型，满足封闭性），就可以成为一个Monad了。至于结合律，由于函数都满足结合律，因此可以忽略。</p>
<p>总结:<br>有map函数: Functor、函子<br>有ap函数（参数为函数的map）: Applicative、应用<br>有flatmap函数: Monad</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://xiaoyue26.github.io/2019/08/23/2019-08/%E7%A5%9E%E7%A7%98%E7%9A%84monad%E2%80%94%E2%80%94%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/" data-id="ck96cxpq200jdmaamd4kn4fpv" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/monad/" rel="tag">monad</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/scala/" rel="tag">scala</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%87%BD%E6%95%B0%E5%BC%8F/" rel="tag">函数式</a></li></ul>

    </footer>
  </div>
  
</article>
 


  


  <nav id="page-nav">
    <a class="extend prev" rel="prev" href="/page/4/">&amp;laquo; 上一页</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><a class="page-number" href="/page/7/">7</a><span class="space">&hellip;</span><a class="page-number" href="/page/23/">23</a><a class="extend next" rel="next" href="/page/6/">下一页&amp;raquo;</a>
  </nav>
</section>
           
    <aside id="sidebar">
  
    

  
    
  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title recent-posts">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/09/26/2022-09/jwt%E7%A0%B4%E8%A7%A3/">jwt破解</a>
          </li>
        
          <li>
            <a href="/2022/09/25/2022-09/nc%E5%91%BD%E4%BB%A4%E7%AC%94%E8%AE%B0/">nc命令笔记</a>
          </li>
        
          <li>
            <a href="/2022/09/25/2022-09/%E8%B0%83%E4%BC%98-%E8%A7%A3%E5%86%B3%E7%BA%BF%E7%A8%8B%E6%B1%A0%E9%80%A0%E6%88%90%E7%9A%84%E8%BF%9B%E7%A8%8B%E5%8D%A1%E9%A1%BF%E3%80%81cpu%E6%AF%9B%E5%88%BA%E9%97%AE%E9%A2%98/">调优-解决线程池造成的进程卡顿、cpu毛刺问题</a>
          </li>
        
          <li>
            <a href="/2022/08/30/2022-08/%E8%B0%83%E4%BC%98-cpu%E6%AF%9B%E5%88%BA%E9%97%AE%E9%A2%98/">调优-cpu毛刺问题</a>
          </li>
        
          <li>
            <a href="/2022/05/31/2022-05/w-tinylfu%E7%BC%93%E5%AD%98%E7%AE%97%E6%B3%95/">w-tinylfu缓存算法</a>
          </li>
        
      </ul>
    </div>
  </div>

  
    

  
</aside>

      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-left">
      &copy; 2014 - 2022 风梦七&nbsp;|&nbsp;
      主题 <a href="https://github.com/giscafer/hexo-theme-cafe/" target="_blank">Cafe</a>
    </div>
     <div id="footer-right">
      联系方式&nbsp;|&nbsp;296671657@qq.com
    </div>
  </div>
</footer>
 
<script src="/jquery/jquery.min.js"></script>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">首页</a>
  
    <a href="/archives" class="mobile-nav-link">归档</a>
  
    <a href="/about" class="mobile-nav-link">关于</a>
  
</nav>
    <img class="back-to-top-btn" src="/images/fly-to-top.png"/>
<script>
// Elevator script included on the page, already.
window.onload = function() {
  var elevator = new Elevator({
    selector:'.back-to-top-btn',
    element: document.querySelector('.back-to-top-btn'),
    duration: 1000 // milliseconds
  });
}
</script>
      

  
    <script>
      var cloudTieConfig = {
        url: document.location.href, 
        sourceId: "",
        productKey: "e2fb4051c49842688ce669e634bc983f",
        target: "cloud-tie-wrapper"
      };
    </script>
    <script src="https://img1.ws.126.net/f2e/tie/yun/sdk/loader.js"></script>
    

  







<!-- author:forvoid begin -->
<!-- author:forvoid begin -->

<!-- author:forvoid end -->

<!-- author:forvoid end -->


  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      })
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      })
    </script>
    <script type="text/javascript" src="https://cdn.rawgit.com/mathjax/MathJax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


 
<script src="/js/is.js"></script>



  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>


<script src="/js/elevator.js"></script>

  </div>
</body>
</html>