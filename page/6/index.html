<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>笔记本</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="笔记本">
<meta property="og:url" content="http://xiaoyue26.github.io/page/6/index.html">
<meta property="og:site_name" content="笔记本">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="风梦七">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="笔记本" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    
  
  
<link rel="stylesheet" href="/css/style.css">

  

<meta name="generator" content="Hexo 4.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    
    <div id="header-inner" class="inner">
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://xiaoyue26.github.io"></form>
      </div>
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">首页</a>
        
          <a class="main-nav-link" href="/archives">归档</a>
        
          <a class="main-nav-link" href="/about">关于</a>
        
      </nav>
      
    </div>
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">笔记本</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">风梦七</a>
        </h2>
      
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-2019-02/redis设计与实现笔记3-数据库" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/02/13/2019-02/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E7%AC%94%E8%AE%B03-%E6%95%B0%E6%8D%AE%E5%BA%93/" class="article-date">
  <time datetime="2019-02-13T01:50:59.000Z" itemprop="datePublished">2019-02-13</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/redis/">redis</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/02/13/2019-02/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E7%AC%94%E8%AE%B03-%E6%95%B0%E6%8D%AE%E5%BA%93/">redis设计与实现笔记3-数据库</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <h2 id="架构"><a href="#架构" class="headerlink" title="架构:"></a>架构:</h2><p>server-&gt; db* -&gt; dict*(k/v)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span> &#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    redisDb *db;</span><br><span class="line">    <span class="keyword">int</span> dbnum;    </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125; redisDb;</span><br></pre></td></tr></table></figure>

<h1 id="数据库键空间"><a href="#数据库键空间" class="headerlink" title="数据库键空间"></a>数据库键空间</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisDb</span> &#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 数据库键空间，保存着数据库中的所有键值对</span></span><br><span class="line">    dict *dict;</span><br><span class="line">    <span class="comment">// 过期时间:</span></span><br><span class="line">    dict *expires;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125; redisDb;</span><br></pre></td></tr></table></figure>

<p>db默认有16,客户端可以通过<code>select 1</code>命令来选择1号数据库。<br>每个client会保存当前在哪个db的状态变量。</p>
<h1 id="键-Key"><a href="#键-Key" class="headerlink" title="键:Key"></a>键:Key</h1><p>key只能为字符串。<br>整个架构最多三层: db-&gt;hashtable-&gt;value</p>
<img src="/images/2019-02/db_kv.png" class="" width="800" height="1200" title="db_kv">

<h1 id="key过期"><a href="#key过期" class="headerlink" title="key过期"></a>key过期</h1><h2 id="过期删除策略"><a href="#过期删除策略" class="headerlink" title="过期删除策略"></a>过期删除策略</h2><ol>
<li>定时统一删除 (一般不用，卡太久)</li>
<li>惰性删除(默认使用,访问时发现过期才删除)</li>
<li>定期删除(默认使用,类似于增量删除,每次删除最近过期的)</li>
</ol>
<h2 id="redis持久化策略"><a href="#redis持久化策略" class="headerlink" title="redis持久化策略"></a>redis持久化策略</h2><ol>
<li>RDB: 定期(比如五分钟)做一次快照; (<code>Redis DataBase</code>)</li>
<li>AOF: 类似于WAL，存每条操作指令日志。(<code>Append only file</code>)</li>
</ol>
<h2 id="RDB和AOF下的过期删除"><a href="#RDB和AOF下的过期删除" class="headerlink" title="RDB和AOF下的过期删除"></a>RDB和AOF下的过期删除</h2><ol>
<li>RDB:  主服务器生成快照时删除过期key; 从库则保留。从库只有收到主库DEL指令时候才会删除过期key。</li>
<li>AOF:  保存DEL指令即可。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">从库如果没有收到主库的DEL指令，即使已经key已经过期，也会返回给客户端。</span><br></pre></td></tr></table></figure>
<p>主从复制要点：（中心化，一致性）<br><code>从库</code>只接受<code>主库</code>的<code>写</code>指令，自己只执行<code>读</code>。</p>
<h1 id="通知机制"><a href="#通知机制" class="headerlink" title="通知机制"></a>通知机制</h1><p>两个功能:</p>
<ol>
<li>订阅某个key的所有操作; (只能知道发生了什么类型的操作,不知道操作数)</li>
<li>订阅某个库下的所有DEL操作.(或者别的什么操作)<br>换句话说就是订阅某个库下key，或者订阅指令。</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://xiaoyue26.github.io/2019/02/13/2019-02/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E7%AC%94%E8%AE%B03-%E6%95%B0%E6%8D%AE%E5%BA%93/" data-id="ck96cxpp600g1maam1uc41333" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/redis/" rel="tag">redis</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-2019-02/高性能mysql附录A-E-笔记" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/02/13/2019-02/%E9%AB%98%E6%80%A7%E8%83%BDmysql%E9%99%84%E5%BD%95A-E-%E7%AC%94%E8%AE%B0/" class="article-date">
  <time datetime="2019-02-13T01:36:10.000Z" itemprop="datePublished">2019-02-13</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/mysql/">mysql</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/02/13/2019-02/%E9%AB%98%E6%80%A7%E8%83%BDmysql%E9%99%84%E5%BD%95A-E-%E7%AC%94%E8%AE%B0/">高性能mysql附录A-E-笔记</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <h1 id="高性能mysql附录A-笔记-mysql分支"><a href="#高性能mysql附录A-笔记-mysql分支" class="headerlink" title="高性能mysql附录A-笔记-mysql分支"></a>高性能mysql附录A-笔记-mysql分支</h1><p>mysql的三个分支(变种):</p>
<ol>
<li>Percona Server: 透明、性能、灵活，用XtraDB引擎代替innodb；</li>
<li>MariaDB: mysql原作者。面向客户、补丁插件扩展更多；</li>
<li>Drizzle：sql语法不兼容mysql, 修正bug，最开源。</li>
</ol>
<p>官方mysql: 最接近于Percona Server。</p>
<h1 id="高性能mysql附录B-笔记-服务器状态"><a href="#高性能mysql附录B-笔记-服务器状态" class="headerlink" title="高性能mysql附录B-笔记-服务器状态"></a>高性能mysql附录B-笔记-服务器状态</h1><p>系统变量: <code>show variables like &#39;%xxx%&#39;</code>;<br>只读状态: <code>show status like &#39;%xxx%&#39;</code>; 或<code>infomation_schema.global_status</code>表和<code>information_schama.session_status</code>表;<br>其他信息:<code>infomation_schema</code>库中</p>
<h2 id="线程和连接统计"><a href="#线程和连接统计" class="headerlink" title="线程和连接统计"></a>线程和连接统计</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">connections,max_used_connections,threads_connected</span><br><span class="line">bytes_received,bytes_sent</span><br><span class="line">slow_launch_threads,threads_cached,threads_created,threads_running</span><br></pre></td></tr></table></figure>

<h2 id="二进制日志状态"><a href="#二进制日志状态" class="headerlink" title="二进制日志状态"></a>二进制日志状态</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">binlog_cache_use,binlog_cache_disk_use</span><br></pre></td></tr></table></figure>

<h2 id="命令计数器"><a href="#命令计数器" class="headerlink" title="命令计数器"></a>命令计数器</h2><p><code>Com_*</code>变量统计每种类型的SQL或C API命令发起过的次数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Com_select: select语句的数量;</span><br><span class="line">Com_change_db: 更改默认数据库的次数(use xxx);</span><br></pre></td></tr></table></figure>

<h2 id="临时文件和表"><a href="#临时文件和表" class="headerlink" title="临时文件和表"></a>临时文件和表</h2><p>隐式表和文件:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">global</span> <span class="keyword">status</span> <span class="keyword">like</span> <span class="string">'Created_tmp%'</span></span><br></pre></td></tr></table></figure>
<p>显式临时表:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">global</span> <span class="keyword">temporary</span> <span class="keyword">tables</span>;</span><br></pre></td></tr></table></figure>

<h2 id="查看select查询类型统计"><a href="#查看select查询类型统计" class="headerlink" title="查看select查询类型统计"></a>查看select查询类型统计</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">global</span> <span class="keyword">status</span> <span class="keyword">like</span> <span class="string">'Select%'</span>;</span><br><span class="line">+<span class="comment">------------------------+----------+</span></span><br><span class="line">| Variable_name          | Value    |</span><br><span class="line">+<span class="comment">------------------------+----------+</span></span><br><span class="line">| Select_full_join       | 677      |</span><br><span class="line">| Select_full_range_join | 0        |</span><br><span class="line">| Select_range           | 135124   |</span><br><span class="line">| Select_range_check     | 0        |</span><br><span class="line">| Select_scan            | 16623726 |</span><br><span class="line">+<span class="comment">------------------------+----------+</span></span><br></pre></td></tr></table></figure>
<p>按预期次数从多到少/开销从少到多的顺序:<br>Select_range: 在第一个表上扫描一个索引区间的连接数目；<br>Select_scan: 扫描整个第一个表；<br>Select_full_range_join: 开销多于Select_scan；<br>Select_range_check: 开销非常高；<br>Select_full_join: 开销最高。</p>
<h2 id="表锁"><a href="#表锁" class="headerlink" title="表锁"></a>表锁</h2><p>Table_locks_immediate: 立即授权的表锁次数；<br>Table_locks_waited:    需要等待的表锁次数。</p>
<h2 id="innodb状态"><a href="#innodb状态" class="headerlink" title="innodb状态"></a>innodb状态</h2><p>查看innodb相关的状态开销很大，会创建一个全局锁。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 通过<span class="keyword">show</span> <span class="keyword">engine</span> <span class="keyword">innodb</span> <span class="keyword">status</span>;</span><br><span class="line">2. 通过information_schema表;</span><br><span class="line">3. 通过<span class="keyword">show</span> <span class="keyword">status</span>,<span class="keyword">show</span> <span class="keyword">variables</span>。</span><br></pre></td></tr></table></figure>
<p>因此不能频繁查看这些变量。</p>
<p>输出信息包括:</p>
<ol>
<li>fsync()平均每秒调用次数；</li>
<li>头部信息: 时间；</li>
<li>Semaphores: 操作系统等待数组，等待互斥量的innodb线程；(如果有等待，可以看出热点是什么)<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">waited at buf0buf.ic for 0 second: 等待缓冲区</span><br><span class="line">waiters flag 0: 0个线程在等待；</span><br><span class="line">waiting is ending: 等待结束。</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p><code>innodb_sync_spin_loops</code>变量:<br>空转多少次后停止spin，挂起进入真正等待。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">'%spin%'</span>;</span><br><span class="line">+<span class="comment">------------------------+-------+</span></span><br><span class="line">| Variable_name          | Value |</span><br><span class="line">+<span class="comment">------------------------+-------+</span></span><br><span class="line">| innodb_spin_wait_delay | 6     |</span><br><span class="line">| innodb_sync_spin_loops | 30    |</span><br><span class="line">+<span class="comment">------------------------+-------+</span></span><br></pre></td></tr></table></figure>

<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p><code>SHOW ENGINE INNODB STATUS\G</code>的输出还有一部分是上两次死锁的情况。(包括进程id和sql、等待的是什么锁)</p>
<p>死锁类型：</p>
<ol>
<li>循环等待；</li>
<li>等待关系图太深：<br>(1)检查超过100W个锁;<br>(2)重做超过200个事务。<br>错误信息：”TOO DEEP OR LONG SEARCH IN THE LOCK TABLE WAITS-FOR GRAPH”.</li>
</ol>
<h4 id="减少死锁的TIPS"><a href="#减少死锁的TIPS" class="headerlink" title="减少死锁的TIPS"></a>减少死锁的TIPS</h4><p>在事务里更新数据时，先按主键排序，这样扫描索引的顺序就都是一致的；</p>
<h3 id="事务信息"><a href="#事务信息" class="headerlink" title="事务信息"></a>事务信息</h3><p><code>SHOW ENGINE INNODB STATUS\G</code>的输出里还有一部分是事务总结信息和当前活跃事务信息。</p>
<h4 id="事务总结信息"><a href="#事务总结信息" class="headerlink" title="事务总结信息"></a>事务总结信息</h4><ol>
<li>当前事务ID;</li>
<li>已经清理MVCC行的事务ID;(可以知道有多少老版本数据没被清理)</li>
<li>历史记录的长度；</li>
<li>锁结构的数目（可能包含多个行锁）。</li>
</ol>
<h4 id="活跃事务信息"><a href="#活跃事务信息" class="headerlink" title="活跃事务信息"></a>活跃事务信息</h4><ol>
<li>进程id(与<code>show processlist</code>中id通用)</li>
<li>内部查询号;</li>
<li>连接信息</li>
<li>查询的sql。</li>
</ol>
<h3 id="File-I-O"><a href="#File-I-O" class="headerlink" title="File I/O"></a>File I/O</h3><p><code>SHOW ENGINE INNODB STATUS\G</code>的输出里还有一部分是IO辅助线程的状态和性能计数器的状态。<br>其中:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> buffer <span class="keyword">thread</span>: 插入缓冲合并到表空间；</span><br><span class="line"><span class="keyword">log</span> <span class="keyword">thread</span>: 异步刷日志；</span><br><span class="line"><span class="keyword">read</span> <span class="keyword">thread</span>: 预读操作；</span><br><span class="line">write <span class="keyword">thread</span>: 刷脏缓冲。</span><br></pre></td></tr></table></figure>

<h3 id="redo-log统计"><a href="#redo-log统计" class="headerlink" title="redo log统计"></a>redo log统计</h3><p><code>SHOW ENGINE INNODB STATUS\G</code>的输出里还有一部分是事务日志(redo log)的统计。</p>
<ol>
<li>sequence number: 当前日志序号；</li>
<li>flushed up to  : 当前刷到哪里；  </li>
<li>last checkpoint: 上一个检测点的位置。</li>
<li>pending和done的日志操作数量。</li>
</ol>
<h3 id="缓冲池和内存"><a href="#缓冲池和内存" class="headerlink" title="缓冲池和内存"></a>缓冲池和内存</h3><p><code>SHOW ENGINE INNODB STATUS\G</code>的输出里还有一部分是BufferPool和内存统计。<br>包括信息：</p>
<ol>
<li>分配了多少字节；</li>
<li>pool总共多少页，其中free多少页；</li>
<li>database用了多少页，多少页已经修改；</li>
<li>命中率等统计信息。<br>多个缓冲池的话后头还有各个buffer pool各自的统计信息。</li>
</ol>
<h3 id="ROW-OPERATIONS"><a href="#ROW-OPERATIONS" class="headerlink" title="ROW OPERATIONS"></a>ROW OPERATIONS</h3><p><code>SHOW ENGINE INNODB STATUS\G</code>的输出里最后一部分是行操作统计。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">--------------</span><br><span class="line">ROW OPERATIONS</span><br><span class="line">--------------</span><br><span class="line">0 queries inside InnoDB, 0 queries in queue</span><br><span class="line">15 read views open inside InnoDB</span><br><span class="line">Main thread process no. 9004, id 139699662354176, state: sleeping</span><br><span class="line">Number of rows inserted 1111442430, updated 2610575313, deleted 42594651, read 8977633484</span><br><span class="line">98.47 inserts&#x2F;s, 1108.97 updates&#x2F;s, 0.00 deletes&#x2F;s, 1671.23 reads&#x2F;s</span><br><span class="line">----------------------------</span><br></pre></td></tr></table></figure>
<p>包括信息：</p>
<ol>
<li>多少线程在innodb内核内，多少在等待队列;</li>
<li>累积增删改查;</li>
<li>增删改查的瞬时速度。</li>
</ol>
<h2 id="主备相关查看命令"><a href="#主备相关查看命令" class="headerlink" title="主备相关查看命令"></a>主备相关查看命令</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">show master status \G</span><br><span class="line">show binary logs;</span><br><span class="line">show binlog events ... </span><br><span class="line">show relaylog events</span><br><span class="line">show slave status</span><br></pre></td></tr></table></figure>

<h2 id="Information-schema中的innodb信息表"><a href="#Information-schema中的innodb信息表" class="headerlink" title="Information_schema中的innodb信息表"></a>Information_schema中的innodb信息表</h2><h2 id="innodb-trx-innodb-locks"><a href="#innodb-trx-innodb-locks" class="headerlink" title="innodb_trx,innodb_locks"></a>innodb_trx,innodb_locks</h2><p>事务、拥有和等待锁的事务。</p>
<h2 id="performance-schema"><a href="#performance-schema" class="headerlink" title="performance_schema"></a>performance_schema</h2><p>略</p>
<h1 id="高性能mysql附录C-笔记-大文件传输"><a href="#高性能mysql附录C-笔记-大文件传输" class="headerlink" title="高性能mysql附录C-笔记-大文件传输"></a>高性能mysql附录C-笔记-大文件传输</h1><p>大概是ssh,tar,gz,rsync命令的运用，略。</p>
<h1 id="高性能mysql附录E-笔记-explain"><a href="#高性能mysql附录E-笔记-explain" class="headerlink" title="高性能mysql附录E-笔记-explain"></a>高性能mysql附录E-笔记-explain</h1><p>explain语句：</p>
<ol>
<li><code>explain select xxx</code>: 近似的执行计划信息；</li>
<li>近似的执行计划信息+等效sql:<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">extended</span> <span class="keyword">select</span> xxx;</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">warnings</span>; <span class="comment">-- 这里得到的sql是从执行计划反向翻译过来的sql</span></span><br></pre></td></tr></table></figure></li>
<li><code>explain partitions select xxx</code>: 显示查询的分区。（仅对分区表有效）</li>
</ol>
<p>mysql5.6前，explain的时候会执行子查询创建临时表，以便进行外层优化。</p>
<h2 id="explain各列的含义"><a href="#explain各列的含义" class="headerlink" title="explain各列的含义"></a>explain各列的含义</h2><h2 id="id"><a href="#id" class="headerlink" title="id"></a>id</h2><p>select语句顺序编号，对应在原始语句中的位置;（从外到内）</p>
<p>select的三种类型：</p>
<ol>
<li>简单子查询；</li>
<li>复杂子查询（派生表）；</li>
<li>union查询。</li>
</ol>
<p>其中union查询的id列为null，select_type列为<code>union result</code>。</p>
<h2 id="select-type列"><a href="#select-type列" class="headerlink" title="select_type列"></a>select_type列</h2><p>取值含义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">simple:  简单查询;</span><br><span class="line">primary: 复杂查询的最外层;</span><br><span class="line">subquery: select列表中的子查询;(不在from子句中);</span><br><span class="line">derived:  from子句中的子查询;</span><br><span class="line">union:  union语句中第二个和随后的select;</span><br><span class="line">union result: 从匿名临时表检索结果的select.</span><br></pre></td></tr></table></figure>

<h2 id="table列"><a href="#table列" class="headerlink" title="table列"></a>table列</h2><p>访问的表或别名。<br>或者&lt; derivedN&gt;,其中N是子查询的id。<br>union行中table列出现的&lt; union2,3&gt;其中2，3也是子查询的id。</p>
<h2 id="type列"><a href="#type列" class="headerlink" title="type列"></a>type列</h2><p>访问类型：从差到好：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">all: 扫全表</span><br><span class="line">index: 按索引顺序扫全表(避免排序) <span class="comment">-- extra列的using index表示覆盖索引</span></span><br><span class="line">range: 有范围限制的索引扫描</span><br><span class="line">ref:   索引查找，查找某个索引值；</span><br><span class="line">eq_ref: 唯一索引查找，结果只有一行；</span><br><span class="line">const,system: 可以优化成常量替换；</span><br><span class="line">NULL: 可以优化到无需访问表和索引。</span><br></pre></td></tr></table></figure>

<h2 id="possible-keys列"><a href="#possible-keys列" class="headerlink" title="possible_keys列"></a>possible_keys列</h2><p>优化早期尝试的索引，可能无用。</p>
<h2 id="key列"><a href="#key列" class="headerlink" title="key列"></a>key列</h2><p>决定采用的索引。</p>
<h2 id="key-len列"><a href="#key-len列" class="headerlink" title="key_len列"></a>key_len列</h2><p>采用索引的可能最大长度。</p>
<h2 id="ref列"><a href="#ref列" class="headerlink" title="ref列"></a>ref列</h2><p>在索引查找值时使用的列或常量。</p>
<h2 id="rows列"><a href="#rows列" class="headerlink" title="rows列"></a>rows列</h2><p>估算大概要读取的行数。</p>
<h2 id="filtered列"><a href="#filtered列" class="headerlink" title="filtered列"></a>filtered列</h2><p><code>explain extended select xxx</code>时有的列。<br>符合条件行数的悲观估计。</p>
<h2 id="Extra列"><a href="#Extra列" class="headerlink" title="Extra列"></a>Extra列</h2><p>包括的值：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">using index: 使用覆盖索引；</span><br><span class="line">using where: 从存储引擎返回后，需要在服务器再过滤一次;(可能暗示查询可以加更多索引)</span><br><span class="line">using temporary: 查询结果排序时会使用临时表；</span><br><span class="line">using filesort: 排序时会使用外部索引排序，而不是按索引顺序扫描；</span><br><span class="line">range checked for each record: 没有理想的索引，对于连接后的每一行重新检查使用哪个索引(很慢)。</span><br></pre></td></tr></table></figure>

<p>可以用<code>Percona Toolkit</code>的<code>pt-visual-explain</code>获得树形执行计划。</p>
<h1 id="高性能mysql附录E-笔记-锁的调试"><a href="#高性能mysql附录E-笔记-锁的调试" class="headerlink" title="高性能mysql附录E-笔记-锁的调试"></a>高性能mysql附录E-笔记-锁的调试</h1><p>锁的类型：</p>
<ol>
<li>表锁；</li>
<li>全局锁： <code>flush tables with read lock</code>或设置<code>read_only=1</code></li>
<li>命名锁：表锁的一种，重命名或者删除表时创建；</li>
<li>字符锁：可以用<code>get_lock</code>等函数在服务器级别锁住/释放单个字符。</li>
</ol>
<h2 id="表锁-1"><a href="#表锁-1" class="headerlink" title="表锁"></a>表锁</h2><h3 id="显式"><a href="#显式" class="headerlink" title="显式"></a>显式</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">lock</span> <span class="keyword">tables</span> film <span class="keyword">read</span>;</span><br><span class="line"><span class="keyword">lock</span> <span class="keyword">tables</span> film write;</span><br><span class="line"><span class="keyword">unlock</span> <span class="keyword">tables</span> ...;</span><br></pre></td></tr></table></figure>
<h3 id="隐式"><a href="#隐式" class="headerlink" title="隐式"></a>隐式</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">sleep</span>(<span class="number">30</span>) <span class="keyword">from</span> film <span class="keyword">limit</span> <span class="number">1</span></span><br><span class="line"><span class="comment">-- 相当于lock tables film read;</span></span><br></pre></td></tr></table></figure>
<p>可以用<code>mysqladmin debug</code>命令检测锁的持有信息。（输出的末尾）</p>
<h2 id="全局读锁"><a href="#全局读锁" class="headerlink" title="全局读锁"></a>全局读锁</h2><p><code>show processlist</code>中<code>status</code>是<code>waiting for release of readlock</code>时，就是等待全局读锁了。</p>
<h2 id="命名锁"><a href="#命名锁" class="headerlink" title="命名锁"></a>命名锁</h2><p><code>show processlist</code>中<code>status</code>是<code>waiting for table</code>时，就是等待命名锁了。<br>还可以在<code>show open tables</code>中看到命名锁的影响。</p>
<h2 id="用户锁"><a href="#用户锁" class="headerlink" title="用户锁"></a>用户锁</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 试图获得名为`my_lock`的锁，超时时间100秒。</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">get_lock</span>(<span class="string">'my_lock'</span>,<span class="number">100</span>);</span><br></pre></td></tr></table></figure>

<h2 id="使用information-schema查看锁"><a href="#使用information-schema查看锁" class="headerlink" title="使用information_schema查看锁"></a>使用information_schema查看锁</h2><p><a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-information-schema-examples.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/5.6/en/innodb-information-schema-examples.html</a><br>哪个事务在等待锁，哪个事务持有锁：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">  r.trx_id waiting_trx_id,</span><br><span class="line">  r.trx_mysql_thread_id waiting_thread,</span><br><span class="line">  r.trx_query waiting_query,</span><br><span class="line">  b.trx_id blocking_trx_id,</span><br><span class="line">  b.trx_mysql_thread_id blocking_thread,</span><br><span class="line">  b.trx_query blocking_query</span><br><span class="line"><span class="keyword">FROM</span>       information_schema.innodb_lock_waits w</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> information_schema.innodb_trx b</span><br><span class="line">  <span class="keyword">ON</span> b.trx_id = w.blocking_trx_id</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> information_schema.innodb_trx r</span><br><span class="line">  <span class="keyword">ON</span> r.trx_id = w.requesting_trx_id;</span><br></pre></td></tr></table></figure>

<p>查看阻塞查询的线程元凶:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">	<span class="keyword">CONCAT</span>(<span class="string">'thread '</span>, b.trx_mysql_thread_id, <span class="string">' from '</span>, p.host) <span class="keyword">AS</span> who_blocks,</span><br><span class="line">	<span class="keyword">IF</span>(p.command = <span class="string">"Sleep"</span>, p.time, <span class="number">0</span>) <span class="keyword">AS</span> idle_in_trx,</span><br><span class="line">	<span class="keyword">MAX</span>(<span class="keyword">TIMESTAMPDIFF</span>(<span class="keyword">SECOND</span>, r.trx_wait_started, <span class="keyword">CURRENT_TIMESTAMP</span>)) <span class="keyword">AS</span> max_wait_time,</span><br><span class="line">	<span class="keyword">COUNT</span>(*) <span class="keyword">AS</span> num_waiters</span><br><span class="line">   <span class="keyword">FROM</span> INFORMATION_SCHEMA.INNODB_LOCK_WAITS <span class="keyword">AS</span> w</span><br><span class="line">   <span class="keyword">INNER</span> <span class="keyword">JOIN</span> INFORMATION_SCHEMA.INNODB_TRX <span class="keyword">AS</span> b <span class="keyword">ON</span> b.trx_id = w.blocking_trx_id</span><br><span class="line">   <span class="keyword">INNER</span> <span class="keyword">JOIN</span> INFORMATION_SCHEMA.INNODB_TRX <span class="keyword">AS</span> r <span class="keyword">ON</span> r.trx_id = w.requesting_trx_id</span><br><span class="line">   <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> INFORMATION_SCHEMA.PROCESSLIST <span class="keyword">AS</span> p <span class="keyword">ON</span> p.id = b.trx_mysql_thread_id</span><br><span class="line">   <span class="keyword">GROUP</span> <span class="keyword">BY</span> who_blocks <span class="keyword">ORDER</span> <span class="keyword">BY</span> num_waiters <span class="keyword">DESC</span>;</span><br><span class="line">   </span><br><span class="line">+<span class="comment">-------------------------+-------------+---------------+-------------+</span></span><br><span class="line">| who_blocks              | idle_in_trx | max_wait_time | num_waiters |</span><br><span class="line">+<span class="comment">-------------------------+-------------+---------------+-------------+</span></span><br><span class="line">| thread 4 from localhost |          98 |            12 |           1 |</span><br><span class="line">+<span class="comment">-------------------------+-------------+---------------+-------------+</span></span><br></pre></td></tr></table></figure>

<p>结果看线程4空闲了98秒，至少有一个线程等了它12秒，有1个线程在等待它。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://xiaoyue26.github.io/2019/02/13/2019-02/%E9%AB%98%E6%80%A7%E8%83%BDmysql%E9%99%84%E5%BD%95A-E-%E7%AC%94%E8%AE%B0/" data-id="ck96cxpph00hemaam49869b9w" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/mysql/" rel="tag">mysql</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-2019-02/高性能mysql第12-16章-笔记" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/02/13/2019-02/%E9%AB%98%E6%80%A7%E8%83%BDmysql%E7%AC%AC12-16%E7%AB%A0-%E7%AC%94%E8%AE%B0/" class="article-date">
  <time datetime="2019-02-13T01:34:54.000Z" itemprop="datePublished">2019-02-13</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/mysql/">mysql</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/02/13/2019-02/%E9%AB%98%E6%80%A7%E8%83%BDmysql%E7%AC%AC12-16%E7%AB%A0-%E7%AC%94%E8%AE%B0/">高性能mysql第12-16章-笔记</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <p>这一章主要讲了一些概念和一些Mysql Cluster变种，略。</p>
<h2 id="高可用概念"><a href="#高可用概念" class="headerlink" title="高可用概念"></a>高可用概念</h2><p>5个9: 99.999%，每年允许5分钟宕机时间。</p>
<h2 id="宕机原因"><a href="#宕机原因" class="headerlink" title="宕机原因"></a>宕机原因</h2><ol>
<li>运行环境: 磁盘耗尽；</li>
<li>性能问题：糟糕sql，schema索引设计;</li>
<li>复制问题：主备不一致；</li>
<li>数据丢失：如误操作。</li>
</ol>
<h3 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h3><ol>
<li>禁用查询缓存</li>
<li>禁用复制过滤器、触发器。</li>
</ol>
<h1 id="高性能mysql第13章-笔记-云端mysql"><a href="#高性能mysql第13章-笔记-云端mysql" class="headerlink" title="高性能mysql第13章-笔记-云端mysql"></a>高性能mysql第13章-笔记-云端mysql</h1><p>IaaS:基础设施虚拟化；<br>DaaS:数据库虚拟化。</p>
<h2 id="Iaas"><a href="#Iaas" class="headerlink" title="Iaas:"></a>Iaas:</h2><p>mysql需要的4种资源:</p>
<ol>
<li>cpu: 云cpu一般较慢；</li>
<li>内存: 最好能到512GB~1TB；</li>
<li>IO： ms级，虚拟化后一般慢100倍； </li>
<li>网络： 一般不成为瓶颈。</li>
</ol>
<h2 id="Daas："><a href="#Daas：" class="headerlink" title="Daas："></a>Daas：</h2><p>稍微讲了一下亚马逊RDS，略过。</p>
<h1 id="高性能mysql第14章-笔记-应用层优化"><a href="#高性能mysql第14章-笔记-应用层优化" class="headerlink" title="高性能mysql第14章-笔记-应用层优化"></a>高性能mysql第14章-笔记-应用层优化</h1><h2 id="思考的角度"><a href="#思考的角度" class="headerlink" title="思考的角度"></a>思考的角度</h2><ol>
<li>应用和数据库正确分工；</li>
<li>ORM的循环SQL和嵌套查询的性能优劣；</li>
<li>缓存(redis)；</li>
<li>连接池。</li>
</ol>
<h2 id="web服务器问题"><a href="#web服务器问题" class="headerlink" title="web服务器问题"></a>web服务器问题</h2><p>静态资源： 用nginx代替apache<br>移除无用的apache模块</p>
<h2 id="缓存问题"><a href="#缓存问题" class="headerlink" title="缓存问题"></a>缓存问题</h2><p>不同等级层次的缓存:</p>
<ol>
<li>进程缓存;</li>
<li>本地共享内存缓存;</li>
<li>分布式内存缓存;(memcached)</li>
<li>磁盘缓存。</li>
</ol>
<h3 id="缓存失效策略"><a href="#缓存失效策略" class="headerlink" title="缓存失效策略"></a>缓存失效策略</h3><ol>
<li>TTL;</li>
<li>显式失效:更新数据时候更新缓存或者标记缓存为脏数据;</li>
<li>读时失效:读的时候再判断缓存是否已经过期； （加快写，减慢了读）</li>
</ol>
<h1 id="高性能mysql第15章-笔记-备份与恢复"><a href="#高性能mysql第15章-笔记-备份与恢复" class="headerlink" title="高性能mysql第15章-笔记-备份与恢复"></a>高性能mysql第15章-笔记-备份与恢复</h1><p>备份建议：</p>
<ol>
<li>使用Percona XtraBackup、Mysql Enterprise Backup；</li>
<li>生产服务器和备份服务器分开，以免同时挂掉。</li>
<li>定期进行恢复测试。</li>
</ol>
<h2 id="逻辑备份"><a href="#逻辑备份" class="headerlink" title="逻辑备份"></a>逻辑备份</h2><p>(SQL,mysqldump)<br>缺点: </p>
<ol>
<li>恢复起来慢</li>
</ol>
<h2 id="物理备份"><a href="#物理备份" class="headerlink" title="物理备份"></a>物理备份</h2><p>(文件)<br>缺点：</p>
<ol>
<li>受版本、兼容性影响，bug概率高。</li>
<li>文件很大。</li>
</ol>
<p>建议：<br>0. 全局使用<code>utf-8</code>;</p>
<ol>
<li>逻辑：使用<code>mysqldump</code>备份结构；</li>
<li>物理: 使用<code>select into outfile</code>导出数据为分隔符文件。</li>
<li>恢复结构：执行1中的sql;</li>
<li>恢复数据：<code>load data infile</code>。<br>其中2，4两步对字符集有要求。（不能单独设置某列字符集）</li>
</ol>
<h2 id="增量备份和全量备份"><a href="#增量备份和全量备份" class="headerlink" title="增量备份和全量备份"></a>增量备份和全量备份</h2><p>尽量做全备，增量bug多；</p>
<h2 id="数据一致性"><a href="#数据一致性" class="headerlink" title="数据一致性"></a>数据一致性</h2><p><code>mysqldump --single-transaction</code><br>可能会导致非常长的事务，从而失败。</p>
<h2 id="binlog清理"><a href="#binlog清理" class="headerlink" title="binlog清理"></a>binlog清理</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">purge</span> <span class="keyword">master</span> <span class="keyword">logs</span> <span class="keyword">before</span> <span class="keyword">current_date</span> - <span class="built_in">Interval</span> N <span class="keyword">day</span></span><br></pre></td></tr></table></figure>
<p>或者设置<code>expire_logs_days</code>。</p>
<h2 id="innodb损坏恢复"><a href="#innodb损坏恢复" class="headerlink" title="innodb损坏恢复"></a>innodb损坏恢复</h2><h3 id="1-二级索引损坏"><a href="#1-二级索引损坏" class="headerlink" title="1. 二级索引损坏"></a>1. 二级索引损坏</h3><p>3种办法：</p>
<ol>
<li><code>optimize table</code>语句;</li>
<li>删除重建表;</li>
<li>表引擎改为<code>myisam</code>，再改回来。</li>
</ol>
<h3 id="2-聚簇索引损坏"><a href="#2-聚簇索引损坏" class="headerlink" title="2. 聚簇索引损坏"></a>2. 聚簇索引损坏</h3><p><strong>优先使用备份还原</strong><br>否则：<br>(大概率只能修复未受损坏影响的行。)<br>通过<code>innodb_force_recover</code>选项导出表，如果导出过程崩溃，需要跳过受损行。</p>
<h3 id="3-损坏系统结构"><a href="#3-损坏系统结构" class="headerlink" title="3. 损坏系统结构"></a>3. 损坏系统结构</h3><p>损坏： innodb事务日志(redo log),表空间撤销日志(undo log),数据字典。</p>
<p><strong>优先使用备份还原</strong><br>否则：<br>可能需要做整个数据库的导出和还原。<br>innodb内部绝大部分工作可能受影响。</p>
<p>上述2，3两种损坏最好从备份还原数据。</p>
<h1 id="高性能mysql第16章-笔记-用户工具"><a href="#高性能mysql第16章-笔记-用户工具" class="headerlink" title="高性能mysql第16章-笔记-用户工具"></a>高性能mysql第16章-笔记-用户工具</h1><p>这章主要介绍一些工具：</p>
<h3 id="UI工具"><a href="#UI工具" class="headerlink" title="UI工具:"></a>UI工具:</h3><ol>
<li>MysqlWorkbench;</li>
<li>SQLyog: 同workbench,windows专用；</li>
</ol>
<h3 id="命令行工具"><a href="#命令行工具" class="headerlink" title="命令行工具:"></a>命令行工具:</h3><ol>
<li>Percona Toolkit: 管理员必备；</li>
<li>The openark kit：一些管理任务的python脚本。</li>
</ol>
<h3 id="监控工具"><a href="#监控工具" class="headerlink" title="监控工具"></a>监控工具</h3><ol>
<li>Nagios;<br>2-6等其余很多略过。</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://xiaoyue26.github.io/2019/02/13/2019-02/%E9%AB%98%E6%80%A7%E8%83%BDmysql%E7%AC%AC12-16%E7%AB%A0-%E7%AC%94%E8%AE%B0/" data-id="ck96cxppe00gzmaam67zeat24" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/mysql/" rel="tag">mysql</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-2019-02/高性能mysql-第十一章-笔记-可扩展" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/02/12/2019-02/%E9%AB%98%E6%80%A7%E8%83%BDmysql-%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0-%E7%AC%94%E8%AE%B0-%E5%8F%AF%E6%89%A9%E5%B1%95/" class="article-date">
  <time datetime="2019-02-12T03:03:52.000Z" itemprop="datePublished">2019-02-12</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/mysql/">mysql</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/02/12/2019-02/%E9%AB%98%E6%80%A7%E8%83%BDmysql-%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0-%E7%AC%94%E8%AE%B0-%E5%8F%AF%E6%89%A9%E5%B1%95/">高性能mysql-第十一章-笔记-可扩展</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <h2 id="可扩展"><a href="#可扩展" class="headerlink" title="可扩展"></a>可扩展</h2><ol>
<li>数据量；</li>
<li>用户量: 并发量。</li>
<li>负载。</li>
</ol>
<h2 id="可扩展性的描述"><a href="#可扩展性的描述" class="headerlink" title="可扩展性的描述"></a>可扩展性的描述</h2><img src="/images/2019-02/usl_ext.png" class="" width="400" height="600" title="usl_ext">
<ul>
<li><p>线性扩展: 加1倍资源=&gt;加1倍性能。(理想最优情况，一般达不到)</p>
</li>
<li><p>Amdahl定律: </p>
</li>
</ul>
<ol>
<li>存在无法并发的工作;</li>
<li>存在需要交互的工作;<br>因此吞吐量达不到线性增长，会趋于平缓。</li>
</ol>
<ul>
<li>USL扩展:(通用可扩展定律)</li>
</ul>
<ol>
<li>存在无法并发的工作;</li>
<li>存在需要交互的工作;</li>
<li>存在内部系统通信开销。</li>
</ol>
<p>从3种扩展性的描述看，我们的目标是趋近于线性扩展，因此应该尽量削减USL扩展中的三个方面: 减少串行、减少交互、减少内部通信。</p>
<h2 id="垂直扩展-纵向扩展、向上扩展"><a href="#垂直扩展-纵向扩展、向上扩展" class="headerlink" title="垂直扩展(纵向扩展、向上扩展)"></a>垂直扩展(纵向扩展、向上扩展)</h2><p>升级硬件。价格更高，性能比低。<br>mysql利用极限:<br>CPU: 24<br>内存: 128<br>更多的时候提升趋于平缓。</p>
<h2 id="向内扩展"><a href="#向内扩展" class="headerlink" title="向内扩展"></a>向内扩展</h2><p>优化查询、索引，压缩数据。</p>
<h2 id="水平扩展-横向扩展，向外扩展"><a href="#水平扩展-横向扩展，向外扩展" class="headerlink" title="水平扩展(横向扩展，向外扩展)"></a>水平扩展(横向扩展，向外扩展)</h2><ol>
<li>复制</li>
<li>拆分</li>
<li>分片(sharding)</li>
</ol>
<p>拆分: 按功能拆分（微服务），划分的表之间不会进行关联操作</p>
<h3 id="数据分片-sharding"><a href="#数据分片-sharding" class="headerlink" title="数据分片(sharding)"></a>数据分片(sharding)</h3><p>用userid分片。<br>id+hash。</p>
<img src="/images/2019-02/star_model.png" class="" width="400" height="600" title="star_model">
<p>星形/雪花模型: 容易分片。<br>网状模型:      难以分片。 </p>
<p>因此早期设计应该避免网状模型。</p>
<p>分片方式:</p>
<ol>
<li>固定分配，硬编码; 缺点: 无法处理热点。优点: 简单。</li>
<li>动态分配：缺点：实现复杂。</li>
</ol>
<p>热点解决方案：随机数+哈希；<br>扩展性： 预分配32个分片，用DNS单点，把4个库放在一个实例(IP)上。</p>
<p>小猿(CP): 库名_32.表名; DNS作为单点。<br>网易(CP): 类似codis，引入中间件单点。</p>
<h3 id="全局唯一ID"><a href="#全局唯一ID" class="headerlink" title="全局唯一ID"></a>全局唯一ID</h3><ol>
<li>autoinc: 利用自增幅度和初始偏移;</li>
<li>创建一个全局表，进行autoinc id分配;</li>
<li>使用memcached/redis，生成全局自增id;(没有持久性)</li>
</ol>
<p>其中2，3可以批量生成一批，减少调用次数。</p>
<h3 id="冷热数据分表"><a href="#冷热数据分表" class="headerlink" title="冷热数据分表"></a>冷热数据分表</h3><p>归档、冷数据分离到另一张表、或者将冷数据分离到较差的节点。</p>
<h3 id="负载均衡的目的"><a href="#负载均衡的目的" class="headerlink" title="负载均衡的目的"></a>负载均衡的目的</h3><img src="/images/2019-02/balance.png" class="" width="400" height="600" title="balance">
<ol>
<li>可扩展性；（读写分离）</li>
<li>高效性；</li>
<li>可用性；</li>
<li>透明性；</li>
<li>一致性。</li>
</ol>
<h3 id="负载均衡算法"><a href="#负载均衡算法" class="headerlink" title="负载均衡算法"></a>负载均衡算法</h3><ol>
<li>随机</li>
<li>轮询</li>
<li>最少连接数: 有缺点，新加入的机器还没有预热缓存，却立即分配了最多的连接；</li>
<li>最快响应；</li>
<li>哈希：通过源IP进行哈希（会话局部性）；</li>
<li>权重：结合上述算法，根据底层机器的性能差异进行权重。</li>
</ol>
<p>具体采用哪个算法，取决于工作负载类型。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://xiaoyue26.github.io/2019/02/12/2019-02/%E9%AB%98%E6%80%A7%E8%83%BDmysql-%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0-%E7%AC%94%E8%AE%B0-%E5%8F%AF%E6%89%A9%E5%B1%95/" data-id="ck96cxppd00gvmaamfl3ydges" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/mysql/" rel="tag">mysql</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-2019-02/高性能mysql第九-十章-笔记-选硬件-主备复制" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/02/11/2019-02/%E9%AB%98%E6%80%A7%E8%83%BDmysql%E7%AC%AC%E4%B9%9D-%E5%8D%81%E7%AB%A0-%E7%AC%94%E8%AE%B0-%E9%80%89%E7%A1%AC%E4%BB%B6-%E4%B8%BB%E5%A4%87%E5%A4%8D%E5%88%B6/" class="article-date">
  <time datetime="2019-02-11T14:41:01.000Z" itemprop="datePublished">2019-02-11</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/mysql/">mysql</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/02/11/2019-02/%E9%AB%98%E6%80%A7%E8%83%BDmysql%E7%AC%AC%E4%B9%9D-%E5%8D%81%E7%AB%A0-%E7%AC%94%E8%AE%B0-%E9%80%89%E7%A1%AC%E4%BB%B6-%E4%B8%BB%E5%A4%87%E5%A4%8D%E5%88%B6/">高性能mysql第九/十章-笔记-选硬件/主备复制</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <p>这章主要讲怎么挑mysql的硬件。</p>
<h1 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h1><p>多核的</p>
<h1 id="磁盘"><a href="#磁盘" class="headerlink" title="磁盘"></a>磁盘</h1><p>raid卡，带电，防断电的</p>
<h2 id="iostat和vmstat用法"><a href="#iostat和vmstat用法" class="headerlink" title="iostat和vmstat用法"></a>iostat和vmstat用法</h2><p>略</p>
<h1 id="高性能mysql第十章-笔记-复制"><a href="#高性能mysql第十章-笔记-复制" class="headerlink" title="高性能mysql第十章-笔记-复制"></a>高性能mysql第十章-笔记-复制</h1><p>使用场景：</p>
<ol>
<li>数据分布；</li>
<li>负载均衡（从库可以读）；</li>
<li>备份；</li>
<li>高可用/故障切换；</li>
<li>升级测试。 <img src="/images/2019-02/relay_log.png" class="" width="800" height="1200" title="relay_log">
主库备库同步流程：</li>
<li>主库: 生成binlog;(binlog dump线程)</li>
<li>备库: 读取binlong放入中继日志relay log;（通过TCP/IP协议,IO线程）</li>
<li>备库: 重放relay log。(单线程,SQL线程)</li>
</ol>
<h2 id="配置复制"><a href="#配置复制" class="headerlink" title="配置复制"></a>配置复制</h2><ol>
<li>每台服务器上创建账号;</li>
<li>配置主库和备库；</li>
<li>通知备库连接到主库，并从主库复制数据。</li>
</ol>
<h3 id="第一步创建账号"><a href="#第一步创建账号" class="headerlink" title="第一步创建账号"></a>第一步创建账号</h3><p>主库、备库：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">grant</span> <span class="keyword">replication</span> <span class="keyword">slave</span>, <span class="keyword">replication</span> <span class="keyword">client</span> <span class="keyword">on</span> *.*</span><br><span class="line"><span class="keyword">to</span> repl@<span class="string">'192.168.0.%'</span> indentified <span class="keyword">by</span> <span class="string">'p4ssword'</span>,;</span><br></pre></td></tr></table></figure>

<h3 id="第二步设置主库和备库"><a href="#第二步设置主库和备库" class="headerlink" title="第二步设置主库和备库"></a>第二步设置主库和备库</h3><p>主库:<br><code>[my.conf]</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">log_bin &#x3D; mysql-bin</span><br><span class="line">server_id &#x3D; 10</span><br></pre></td></tr></table></figure>
<p>重启主库。<br>检查主库完成配置:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">master</span> <span class="keyword">status</span>;</span><br><span class="line"></span><br><span class="line">+<span class="comment">------------------+-----------+--------------+------------------+-------------------+</span></span><br><span class="line">| File             | Position  | Binlog_Do_DB | Binlog_Ignore_DB | Executed_Gtid_Set |</span><br><span class="line">+<span class="comment">------------------+-----------+--------------+------------------+-------------------+</span></span><br><span class="line">| mysql-bin.000611 | 618598987 |              |                  |                   |</span><br><span class="line">+<span class="comment">------------------+-----------+--------------+------------------+-------------------+</span></span><br></pre></td></tr></table></figure>


<p>备库配置：<br><code>[my.conf]</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">log_bin &#x3D; mysql-bin</span><br><span class="line">server_id &#x3D; 2 </span><br><span class="line">relay_log &#x3D; &#x2F;var&#x2F;lib&#x2F;mysql&#x2F;mysql-relay-bin</span><br><span class="line">log_slave_updates &#x3D; 1 # 备库自身的重放事件也记录到binlog中</span><br><span class="line">read_only &#x3D; 1</span><br></pre></td></tr></table></figure>

<h3 id="第三步：启动复制"><a href="#第三步：启动复制" class="headerlink" title="第三步：启动复制"></a>第三步：启动复制</h3><p>备库执行sql:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">change</span> <span class="keyword">master</span> <span class="keyword">to</span> MASTER_HOST= <span class="string">'server1'</span></span><br><span class="line">,MASTER_USER=<span class="string">'reply'</span></span><br><span class="line">,MASTER_PASSWORD=<span class="string">'p4ssword'</span></span><br><span class="line">,MASTER_LOG_FILE=<span class="string">'mysql-bin.000001'</span></span><br><span class="line">,MASTER_LOG_POS=<span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>检查备库配置:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">slave</span> <span class="keyword">status</span> \G</span><br></pre></td></tr></table></figure>

<p>让备库开始复制:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">start</span> <span class="keyword">slave</span>;</span><br></pre></td></tr></table></figure>



<h2 id="binlog配置"><a href="#binlog配置" class="headerlink" title="binlog配置"></a>binlog配置</h2><h3 id="主库配置"><a href="#主库配置" class="headerlink" title="主库配置"></a>主库配置</h3><p><code>sync_binlog</code>=1: 事务提交前把binlog存到磁盘上。</p>
<h2 id="复制的原理"><a href="#复制的原理" class="headerlink" title="复制的原理"></a>复制的原理</h2><p><code>binlog_format</code>:</p>
<ol>
<li>基于语句的复制(逻辑): 出错机率大,开销小;</li>
<li>基于行的复制(物理): 几乎不出错,开销一般更大。(5.1以后开始有)</li>
</ol>
<p>基于语句的复制的<strong>缺点</strong>:</p>
<ol>
<li>不支持触发器或者存储过程：有bug;</li>
<li>只能串行重放。</li>
</ol>
<p>基于行的<strong>缺点</strong>:</p>
<ol>
<li>可读性差，无法直接知道执行了什么SQL。<br>解决方案: <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 1:</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">master</span> <span class="keyword">logs</span>;</span><br><span class="line"><span class="comment">-- 2:</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">binlog</span> <span class="keyword">events</span> <span class="keyword">in</span> <span class="string">'mysql-bin.000643'</span> <span class="keyword">from</span> <span class="number">1073742091</span>;</span><br></pre></td></tr></table></figure>


</li>
</ol>
<h2 id="复制的过滤器"><a href="#复制的过滤器" class="headerlink" title="复制的过滤器"></a>复制的过滤器</h2><p>不建议使用。</p>
<h2 id="复制的拓扑"><a href="#复制的拓扑" class="headerlink" title="复制的拓扑"></a>复制的拓扑</h2><h3 id="1-一主多备-星形模型"><a href="#1-一主多备-星形模型" class="headerlink" title="1. 一主多备(星形模型)"></a>1. 一主多备(星形模型)</h3><h3 id="2-双主"><a href="#2-双主" class="headerlink" title="2. 双主"></a>2. 双主</h3><p>不建议使用,两个主库都可写会有很多问题</p>
<h3 id="3-HA模式-类似于双主-但只有一个可写"><a href="#3-HA模式-类似于双主-但只有一个可写" class="headerlink" title="3. HA模式(类似于双主,但只有一个可写)"></a>3. HA模式(类似于双主,但只有一个可写)</h3><img src="/images/2019-02/HA.png" class="" width="800" height="1200" title="HA">
<p>两个库的配置基本相同，只是其中一个库是只读的。<br>如果有Alter table等耗时操作，可以在备库上执行，然后互换两个库。<br>优点：<br>故障恢复很简单。</p>
<p>具体设置情况:</p>
<ol>
<li>两个库数据相同;</li>
<li>创建复制账号，选择不同serverid；</li>
<li>两者启用binlog,互相跟踪;</li>
<li>备库设置成只读，主库设置成可写。</li>
</ol>
<p>由于serverid，主库不会重复消费自己的变更。（忽略自己的日志）</p>
<h3 id="确定备库追上了主库"><a href="#确定备库追上了主库" class="headerlink" title="确定备库追上了主库"></a>确定备库追上了主库</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 主库:</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">master</span> <span class="keyword">status</span>;<span class="comment">-- 记录一下文件名和偏移量</span></span><br><span class="line"><span class="comment">-- 备库:</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">master_pos_wait</span>(<span class="keyword">file</span>, pos[, <span class="keyword">timeout</span>])</span><br></pre></td></tr></table></figure>

<h3 id="4-环形-gt-3的库成环"><a href="#4-环形-gt-3的库成环" class="headerlink" title="4. 环形(&gt;=3的库成环)"></a>4. 环形(&gt;=3的库成环)</h3><p>不建议使用，太脆弱容易死循环。</p>
<h3 id="5-分发主库"><a href="#5-分发主库" class="headerlink" title="5. 分发主库"></a>5. 分发主库</h3><img src="/images/2019-02/fenfa_mysql.png" class="" width="800" height="1200" title="fenfa_mysql">
<p>一主多备对于备的数量有上限，可以用分发主库来进行扩展。<br>为了避免在分发主库上执行查询，可以将它的表修改为blackhole引擎。<br>（storage_engine=blackhole）</p>
<h3 id="6-模拟多主库"><a href="#6-模拟多主库" class="headerlink" title="6. 模拟多主库"></a>6. 模拟多主库</h3><img src="/images/2019-02/moni_multi.png" class="" width="800" height="1200" title="moni_multi">
<p>备库可以轮流读两个主库，俩主库带blackhole即可。</p>
<h2 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">insert ...</span><br><span class="line">select ...</span><br><span class="line">-- 转换成:</span><br><span class="line">select into outfile .. </span><br><span class="line">load data infile  ...</span><br></pre></td></tr></table></figure>
<p>这样更快(不需要加锁)</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://xiaoyue26.github.io/2019/02/11/2019-02/%E9%AB%98%E6%80%A7%E8%83%BDmysql%E7%AC%AC%E4%B9%9D-%E5%8D%81%E7%AB%A0-%E7%AC%94%E8%AE%B0-%E9%80%89%E7%A1%AC%E4%BB%B6-%E4%B8%BB%E5%A4%87%E5%A4%8D%E5%88%B6/" data-id="ck96cxppg00h7maam081s1f7j" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/mysql/" rel="tag">mysql</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-2019-02/高性能mysql第八章-笔记-优化服务器配置" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/02/11/2019-02/%E9%AB%98%E6%80%A7%E8%83%BDmysql%E7%AC%AC%E5%85%AB%E7%AB%A0-%E7%AC%94%E8%AE%B0-%E4%BC%98%E5%8C%96%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE/" class="article-date">
  <time datetime="2019-02-11T14:37:32.000Z" itemprop="datePublished">2019-02-11</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/mysql/">mysql</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/02/11/2019-02/%E9%AB%98%E6%80%A7%E8%83%BDmysql%E7%AC%AC%E5%85%AB%E7%AB%A0-%E7%AC%94%E8%AE%B0-%E4%BC%98%E5%8C%96%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE/">高性能mysql第八章-笔记-优化服务器配置</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <blockquote>
<p>错误配置不如维持默认配置。</p>
</blockquote>
<h1 id="优化服务器配置"><a href="#优化服务器配置" class="headerlink" title="优化服务器配置"></a>优化服务器配置</h1><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><p>服务端读取<code>mysqld</code>分段<br>客户端可能会读取客户端分段。</p>
<h2 id="配置级别"><a href="#配置级别" class="headerlink" title="配置级别"></a>配置级别</h2><p>全局、连接级、会话级<br><code>sort_buffer_size</code>: 每个线程都可以设置<br><code>join_buffer_size</code>: 可以为每个关联都设置一个关联缓冲。</p>
<h2 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h2><p>用git管理配置文件</p>
<h2 id="最优配置"><a href="#最优配置" class="headerlink" title="最优配置"></a>最优配置</h2><p>书上也不知道怎么配出最优配置。</p>
<ol>
<li>用benchmark：穷举配置成本太高；</li>
<li>用比较低的值慢慢试探，较低的内存配置对性能影响不大（百分之几），但较高的内存配置会造成较大的性能抖动，因此尽量以较低的配置。</li>
</ol>
<h2 id="Buffer-pool（Innodb）"><a href="#Buffer-pool（Innodb）" class="headerlink" title="Buffer pool（Innodb）"></a>Buffer pool（Innodb）</h2><p>缓存内容:</p>
<ol>
<li>缓存索引;</li>
<li>缓存行数据；</li>
<li>缓存自适应哈希索引；</li>
<li>插入缓冲；（延迟合并写入）</li>
<li>锁。</li>
</ol>
<h2 id="Key-caches-MyIsam"><a href="#Key-caches-MyIsam" class="headerlink" title="Key caches(MyIsam)"></a>Key caches(MyIsam)</h2><p>键缓冲(键缓存)。<br>MyIsam只缓存索引，不缓存数据。</p>
<p>查看MyIsam的索引总大小:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">sum</span>(index_length) </span><br><span class="line"><span class="keyword">from</span> information_schema.tables</span><br><span class="line"><span class="keyword">where</span> <span class="keyword">engine</span>=<span class="string">'MYISAM'</span>;</span><br><span class="line"><span class="comment">-- 也可以看看分布:</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">engine</span>,<span class="keyword">sum</span>(index_length) </span><br><span class="line"><span class="keyword">from</span> information_schema.tables</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="keyword">engine</span>;</span><br><span class="line"></span><br><span class="line">+<span class="comment">--------------------+-------------------+</span></span><br><span class="line">| engine             | sum(index_length) |</span><br><span class="line">+<span class="comment">--------------------+-------------------+</span></span><br><span class="line">| CSV                |                 0 |</span><br><span class="line">| InnoDB             |       68176035840 |</span><br><span class="line">| MEMORY             |                 0 |</span><br><span class="line">| MyISAM             |            124928 |</span><br><span class="line">| PERFORMANCE_SCHEMA |                 0 |</span><br><span class="line">+<span class="comment">--------------------+-------------------+</span></span><br></pre></td></tr></table></figure>
<p>key cache的大小不要超过MYISAM索引总大小。</p>
<h2 id="线程缓存"><a href="#线程缓存" class="headerlink" title="线程缓存"></a>线程缓存</h2><p><code>thread_cache_size</code>:  缓存线程数量。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">'%thread_cache_size%'</span>;</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">'%thread%'</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">+<span class="comment">-----------------------------------------+---------------------------+</span></span><br><span class="line">| Variable_name                           | Value                     |</span><br><span class="line">+<span class="comment">-----------------------------------------+---------------------------+</span></span><br><span class="line">| innodb_purge_threads                    | 1                         |</span><br><span class="line">| innodb_read_io_threads                  | 12                        |</span><br><span class="line">| innodb_thread_concurrency               | 0                         |</span><br><span class="line">| innodb_thread_sleep_delay               | 10000                     |</span><br><span class="line">| innodb_write_io_threads                 | 12                        |</span><br><span class="line">| max_delayed_threads                     | 20                        |</span><br><span class="line">| max_insert_delayed_threads              | 20                        |</span><br><span class="line">| myisam_repair_threads                   | 1                         |</span><br><span class="line">| performance_schema_max_thread_classes   | 50                        |</span><br><span class="line">| performance_schema_max_thread_instances | -1                        |</span><br><span class="line">| pseudo_thread_id                        | 4804578                   |</span><br><span class="line">| thread_cache_size                       | 512                       |</span><br><span class="line">| thread_concurrency                      | 4                         |</span><br><span class="line">| thread_handling                         | one-thread-per-connection |</span><br><span class="line">| thread_stack                            | 524288                    |</span><br><span class="line">+<span class="comment">-----------------------------------------+---------------------------+</span></span><br></pre></td></tr></table></figure>

<h2 id="表缓存"><a href="#表缓存" class="headerlink" title="表缓存"></a>表缓存</h2><p>对myisam有用，innodb用处不大。<br>算是一个已经过时的配置。</p>
<h2 id="Buffer-Pool相关架构"><a href="#Buffer-Pool相关架构" class="headerlink" title="Buffer Pool相关架构"></a>Buffer Pool相关架构</h2><img src="/images/2019-02/buffer_pool.png" class="" width="800" height="1200" title="buffer_pool">
<p>图中的undo日志是方便事务回滚的。<br>(redo日志是类似WAL，防断电的，利用顺序IO优化性能)</p>
<p>事务日志(redo log)使用类似环形数组的数据结构，可以环形写入到flush过的头部，节省存储空间。</p>
<h3 id="Log-Buffer（Redo-log-事务日志）"><a href="#Log-Buffer（Redo-log-事务日志）" class="headerlink" title="Log Buffer（Redo log/事务日志）"></a>Log Buffer（Redo log/事务日志）</h3><p>每次变更: 记录到Log Buffer(Buffer Pool =&gt; Log Buffer)</p>
<p>Log Buffer刷盘到磁盘日志文件的时机(或者说触发事件):</p>
<ol>
<li>每一秒钟(定时器tick事件);</li>
<li>或事务提交事件;</li>
<li>或缓冲区满。</li>
</ol>
<p>以上是默认的三个事件，调节参数为<code>innodb_flush_log_at_trx_commit</code>,3种取值:<br>0: 事务提交:不触发;<br>1: 事务提交:刷盘到磁盘;(默认值，3种事件皆触发刷盘)<br>2: 事务提交:刷新到操作系统缓存。（能扛mysql进程挂掉，不能扛断电，断电的话会丢一秒数据。）</p>
<p>如果缓冲区满的太频繁(1s满了很多次)，可以考虑增大缓冲区大小来减少IO次数。<br>参数:<br><code>innodb_log_buffer_size</code>: 默认1M，推荐1~8M。</p>
<p>调节这个参数需要命令:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">engine</span> <span class="keyword">innodb</span> <span class="keyword">status</span></span><br></pre></td></tr></table></figure>

<h2 id="Innodb读写日志、数据文件配置"><a href="#Innodb读写日志、数据文件配置" class="headerlink" title="Innodb读写日志、数据文件配置"></a>Innodb读写日志、数据文件配置</h2><p>这是一个风险很高的选项，认真学习以后有必要再修改。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">global</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">'%flush_method%'</span>;</span><br><span class="line"></span><br><span class="line">+<span class="comment">---------------------+----------+</span></span><br><span class="line">| Variable_name       | Value    |</span><br><span class="line">+<span class="comment">---------------------+----------+</span></span><br><span class="line">| innodb_flush_method | O_DIRECT |</span><br><span class="line">+<span class="comment">---------------------+----------+</span></span><br></pre></td></tr></table></figure>
<p>windows用的选项:<br>async_unbuffered,unbuffered,normal.</p>
<p>linux：</p>
<ul>
<li><p><code>fdatasync</code>: 默认值。用<code>fsync()</code>刷新数据和日志文件。<br><code>fdatasync()</code>函数只刷新文件的数据；<br><code>fsync()</code>函数刷新数据和日志文件。<br>配置为<code>fdatasync</code>时其实会调用<code>fsync()</code>函数。默认会合并多个文件的fsync()操作，合并IO操作。可以通过<code>innodb_file_per_table</code>选项为每个文件独立fsync()，但也会增多IO操作。</p>
</li>
<li><p><code>O_DIRECT</code>: 数据文件: 用<code>O_DIRECT</code>标记或<code>directio()</code>函数。<br>（不影响日志文件）<br>区别: 使用fsync()函数刷盘，但会通知操作系统不要缓存数据，也不要预读。<br>相当于关闭了操作系统缓存（读写）。<br>特例： 不影响raid卡的预读、写缓存。</p>
</li>
<li><p><code>ALL_O_DIRECT</code>: 影响数据和日志文件。</p>
</li>
<li><p><code>O_DSYNC</code>: 日志文件: 用<code>O_SYNC</code>标记，写同步（日志写到磁盘才返回）<br>（不影响数据文件）<br>区别：不禁用操作系统的缓存。</p>
</li>
</ul>
<table>
<thead>
<tr>
<th align="center">配置值</th>
<th align="center">实际调用函数</th>
<th align="center">概述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">fdatasync</td>
<td align="center">fsync(含义相反)</td>
<td align="center">刷新数据和日志，有操作系统缓存</td>
</tr>
<tr>
<td align="center">O_DIRECT</td>
<td align="center"></td>
<td align="center">刷新数据，关闭缓存</td>
</tr>
<tr>
<td align="center">ALL_O_DIRECT</td>
<td align="center"></td>
<td align="center">刷新数据和日志，关闭缓存</td>
</tr>
<tr>
<td align="center">O_DSYNC</td>
<td align="center">O_SYNC</td>
<td align="center">刷新日志，有操作系统缓存</td>
</tr>
</tbody></table>
<p>O_DSYNC和fdatasync的区别:<br>（实际是O_SYNC和fsync的区别）fsync允许写操作累积在缓存，然后一次性刷新。<br>O_SYNC是每次都是同步IO，每次都刷盘。</p>
<h3 id="tips-1"><a href="#tips-1" class="headerlink" title="tips"></a>tips</h3><p>如果使用raid卡带电: O_DIRECT;<br>否则: O_DIRECT或fdatasync都有可能，看业务需求。</p>
<h2 id="Innodb表空间"><a href="#Innodb表空间" class="headerlink" title="Innodb表空间"></a>Innodb表空间</h2><p>位于<code>innodb_data_home_dir</code>目录:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">表、索引、回滚日志(undo log)、插入缓冲(Insert Buffer)、双写缓冲(DoubleWrite Buffer)。</span><br></pre></td></tr></table></figure>

<p>目录下可以挂载多个设备，但不会自动做负载均衡，只有写满第一个才会写第二个，因此需要底层用raid自己做负载均衡。<br>挂载多个目录:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">innodb_data_file_path &#x3D; &#x2F;disk1&#x2F;ibdata1:1G;&#x2F;disk2&#x2F;ibdata2:1G;&#x2F;disk3&#x2F;ibdata3:1G:autoextended:max:2G</span><br></pre></td></tr></table></figure>

<p>建议使用<code>innodb_file_per_table</code>选项，每个表的表空间一个文件。<br>缺点：DROP Table慢。<br>原因: </p>
<ol>
<li>删除文件慢；</li>
<li>移除表空间需要Innodb锁定和扫描缓冲区，查找属于这个表空间的页。</li>
</ol>
<h4 id="运行时间长的事务"><a href="#运行时间长的事务" class="headerlink" title="运行时间长的事务"></a>运行时间长的事务</h4><p>缺点: undo log增长到打爆表空间、磁盘。</p>
<h3 id="双写缓冲-Doublewrite-Buffer"><a href="#双写缓冲-Doublewrite-Buffer" class="headerlink" title="双写缓冲(Doublewrite Buffer)"></a>双写缓冲(Doublewrite Buffer)</h3><p>功能: 避免页没写完整导致的数据损坏。<br>buffer pool =&gt; Doublewrite Buffer =&gt; 磁盘</p>
<p>写两次，但由于有<code>fsync()</code>，而且这个过程时间顺序上比较紧密，可以一次性刷到磁盘，写两次的性能损耗也就多了百分之记。</p>
<h3 id="binlog-IO配置"><a href="#binlog-IO配置" class="headerlink" title="binlog IO配置"></a>binlog IO配置</h3><p><code>sync_binlog</code>: binlog配置。<br>N=0(默认值): 不干预，让操作系统自己决定。<br>N&gt;0: N次写以后，刷新到磁盘。（一般不会大于1)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show global variables like &#39;%log%&#39;;</span><br></pre></td></tr></table></figure>

<p>innodb的6种日志:</p>
<ol>
<li>redo log(物理/WAL): 事务开始后写入缓冲区innodb_log_buffer;（存储引擎层）</li>
<li>undo log(逻辑/版本): 事务开始后为了事务回滚准备的日志，从buffer pool=&gt;表空间;</li>
<li>bin log(逻辑/SQL): 主从复制。或者基于时间点的还原。(类似于存了sql)。（事务提交前产生，数据库层）</li>
<li>slow query log: 慢查询;</li>
<li>general log: 一般日志;</li>
<li>relay log: 中继日志。</li>
</ol>
<p>undo log（在表空间）: 修改前的值/版本号;<br>undo log可以配置从表空间中分离出来。</p>
<p>redo log（在log buffer）: 类似于WAL，记录buffer pool和disk的不同。</p>
<h3 id="回滚事务的crash恢复"><a href="#回滚事务的crash恢复" class="headerlink" title="回滚事务的crash恢复"></a>回滚事务的crash恢复</h3><ul>
<li>redo log: 只追加写，提交到磁盘以后标记为可以被新日志覆盖。</li>
<li>基于这个特性，即使事务已经回滚了，它的redo log依然是存在的。</li>
<li>再基于以上这点，db crash以后，可以恢复已经回滚的事务。</li>
</ul>
<p>回滚事务的crash恢复,有两种策略:</p>
<ol>
<li>读redo log,挑已经提交的事务进行恢复;</li>
<li>读redo log,恢复所有事务，再用undo log解决回滚的事务。</li>
</ol>
<p><code>innodb</code>使用的是策略2，也就是先redo,再undo。</p>
<p>使用策略2的难点:</p>
<ul>
<li><p>需要redo log相应的undo log是健全的，否则就漏回滚了。<br>(1)解决方案1:确保undo log落盘早于redo log；（很麻烦，不用）<br>(2)解决方案2:将undo log也视为数据，记录到redo log中。（innodb采用）</p>
</li>
<li><p>总结</p>
<blockquote>
<p>crash恢复: 先读取执行redo log，再执行undo log，这样可以恢复未提交事务和回滚事务。<br>undo log和redo log的数据一致性: 把undo log也视为数据，写入redo log。</p>
</blockquote>
</li>
</ul>
<h3 id="日志与事务提交速度"><a href="#日志与事务提交速度" class="headerlink" title="日志与事务提交速度:"></a>日志与事务提交速度:</h3><p>redo log: 不影响事务提交速度。因为是事务进行中就产生、而且每秒刷盘了；<br>binlog: 影响事务提交速度。因为事务提交前才产生binlog、刷盘，因此如果开启了binlog，长时间的事务提交很慢。</p>
<p>三种重要日志的写顺序:</p>
<ol>
<li>undo log;</li>
<li>redo log;</li>
<li>binlog.</li>
</ol>
<h2 id="MYISAM的IO配置"><a href="#MYISAM的IO配置" class="headerlink" title="MYISAM的IO配置"></a>MYISAM的IO配置</h2><p><code>delay_key_write</code>:<br>OFF: 不延迟。每次写操作后刷新键缓存;<br>ON: 延迟。对使用该选项创建的表生效;<br>ALL: 延迟。对所有表生效。<br>该选项对性能提升不大,缺点:</p>
<ol>
<li>索引可能损坏;</li>
<li>关闭表时间变长;</li>
<li>占用空间变大。</li>
</ol>
<p><code>myisam_use_mmap</code>: 使用内存映射，减少系统调用开销。</p>
<h2 id="Innodb并发"><a href="#Innodb并发" class="headerlink" title="Innodb并发"></a>Innodb并发</h2><p><code>innodb_thread_concurrency</code>:<br>N=0: 不限制有多少线程进入内核;<br>N&gt;0: 同时可以有N个线程进入内核。<br>N的推荐值&lt; 2<em>cpu数</em>disk数</p>
<p><code>innodb_commit_concurrency</code>:<br>同时可以有多少个线程提交。</p>
<h2 id="Myisam并发"><a href="#Myisam并发" class="headerlink" title="Myisam并发"></a>Myisam并发</h2><p><code>concurrent_insert</code>:<br>0: 不允许并发插入;<br>1: 默认值。只要表中没有空洞，就允许并发插入。<br>2: 强制并发插入到Myisam表末尾，即使有空洞。（碎片会更多）</p>
<h2 id="基于工作负载的配置"><a href="#基于工作负载的配置" class="headerlink" title="基于工作负载的配置"></a>基于工作负载的配置</h2><ol>
<li>blob,text的表，临时表都会变成磁盘表。<br>解决方案: 使用substr。</li>
</ol>
<p><code>tmp_table_size</code>,<code>max_heap_table_size</code>: 临时表大小上限。<br><code>max_connections</code>: 最大连接数。<br><code>thread_cache_size</code>: 缓存线程数。</p>
<p> 查看配置和状态:<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">show variables like &#39;%thread%&#39;;</span><br><span class="line">show status like &#39;%thread%&#39;;</span><br></pre></td></tr></table></figure></p>
<p> <code>innodb_autoinc_lock_mode</code><br> 0: 每次都锁；<br> 1: 确定需要分配多少自增值的话，可以立即释放锁；<br> 2: 每次都不锁，空洞很多。</p>
<h2 id="两个最重要的配置"><a href="#两个最重要的配置" class="headerlink" title="两个最重要的配置"></a>两个最重要的配置</h2><p> <code>innodb_log_file_size</code>: redo log的缓冲区，如果调大了<code>innodb_buffer_pool_size</code>就要相应调大它。<br>(一种可能的值是512<em>1024</em>1024,512M,搭配2G的<code>innodb_buffer_pool_size</code>)<br>可以通过<code>show engine innodb status\G select sleep(60); show engine innodb status\G</code>,查看<code>Log sequence number</code>差，计算1个小时的redo日志写入量，大致可以设置为这个缓冲区的大小。</p>
<p><code>innodb_buffer_pool_size</code>的大小设置就比较简单了，按服务器可用内存75%设定即可。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://xiaoyue26.github.io/2019/02/11/2019-02/%E9%AB%98%E6%80%A7%E8%83%BDmysql%E7%AC%AC%E5%85%AB%E7%AB%A0-%E7%AC%94%E8%AE%B0-%E4%BC%98%E5%8C%96%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE/" data-id="ck96cxppf00h3maamgo769a0c" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/mysql/" rel="tag">mysql</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-2019-02/高性能mysql第七章-笔记-高级特性" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/02/11/2019-02/%E9%AB%98%E6%80%A7%E8%83%BDmysql%E7%AC%AC%E4%B8%83%E7%AB%A0-%E7%AC%94%E8%AE%B0-%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/" class="article-date">
  <time datetime="2019-02-11T14:31:10.000Z" itemprop="datePublished">2019-02-11</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/mysql/">mysql</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/02/11/2019-02/%E9%AB%98%E6%80%A7%E8%83%BDmysql%E7%AC%AC%E4%B8%83%E7%AB%A0-%E7%AC%94%E8%AE%B0-%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/">高性能mysql第七章-笔记-高级特性</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <h1 id="高级特性"><a href="#高级特性" class="headerlink" title="高级特性"></a>高级特性</h1><p>略过: 分区表,合并表,全文索引</p>
<h2 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h2><p>视图会影响优化器</p>
<h2 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h2><p>在线系统: 不推荐使用;<br>离线系统: 如果代码很简单，为了批量性能可以考虑。</p>
<h2 id="游标"><a href="#游标" class="headerlink" title="游标"></a>游标</h2><p>游标使用临时表实现。</p>
<p>因此：</p>
<ol>
<li>逐行只读;</li>
<li>会执行整个查询。</li>
</ol>
<p>基于2，如果只读一小部分结果，请使用limit。<br>(也就是不要使用游标来实现limit的效果，直接使用limit语句即可)</p>
<h2 id="prepareStatement"><a href="#prepareStatement" class="headerlink" title="prepareStatement"></a>prepareStatement</h2><h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><ol>
<li>客户端=&gt;服务端: SQL原型</li>
<li>服务端: SQL原型=&gt;部分执行计划A;</li>
<li>服务端=&gt;客户端: A的句柄;</li>
<li>客户端=&gt;服务端: 变量、A的句柄.</li>
</ol>
<p>优点:</p>
<ol>
<li>服务端: SQL解析只需解析/优化一次;</li>
<li>通信: 只发送参数+句柄，通信成本降低;</li>
<li>缓存: 参数可以被缓存;</li>
<li>安全: 无须转义、由于执行计划定了，不会被SQL注入。</li>
</ol>
<p><code>prepareStatement</code>的三类优化:<br>(和传入参数无关的)</p>
<ol>
<li>准备阶段: 根据已知条件,where条件优化;</li>
<li>第一次执行: 简化嵌套关联,将外关联转化成内关联;</li>
<li>每次SQL执行:<br>(1) 过滤分区;<br>(2) 尽量移除count,min,max;<br>(3) 移除常量表达式;<br>(4) 检测常量表;<br>(5) 做必要的等值传播;<br>(6) 分析和优化ref,range和索引优化等访问数据的方法;<br>(7) 优化关联顺序。</li>
</ol>
<h2 id="绑定变量"><a href="#绑定变量" class="headerlink" title="绑定变量"></a>绑定变量</h2><p><code>set @xxx:= 123</code><br>绑定变量是会话级的。</p>
<h2 id="字符集和校对"><a href="#字符集和校对" class="headerlink" title="字符集和校对"></a>字符集和校对</h2><p>字符集(<code>encode</code>)： 二进制&lt;=&gt;某类编码字符<br>校对(<code>collation</code>)：某字符集的排序规则。</p>
<p>校对集都是针对某一个字符集的。(类似于弱实体)</p>
<p>相关设置分为两类:</p>
<ol>
<li>创建对象时候的默认值</li>
<li>服务器和客户端通信的设置</li>
</ol>
<h3 id="1-创建对象时候的默认值"><a href="#1-创建对象时候的默认值" class="headerlink" title="1. 创建对象时候的默认值"></a>1. 创建对象时候的默认值</h3><p>(1)<code>character_set_server</code>: 服务器创建数据库默认值;<br>(2)表字符集;<br>(3)列字符集.<br>越小范围的优先级越高。</p>
<h3 id="2-服务器和客户端通信的设置"><a href="#2-服务器和客户端通信的设置" class="headerlink" title="2. 服务器和客户端通信的设置"></a>2. 服务器和客户端通信的设置</h3><h4 id="服务端"><a href="#服务端" class="headerlink" title="服务端:"></a>服务端:</h4><img src="/images/2019-02/mysql_char.png" class="" width="800" height="1200" title="mysql_char">
<p>(1)<code>character_set_client</code>: 服务端总是假设客户端按照<code>character_set_client</code>设置的字符集来传输数据和sql语句;<br>(2)<code>character_set_connection</code>: 服务器收到客户端sql后,转换成<code>character_set_connection</code>类型;<br>(3)<code>character_result</code>:服务端返回数据时,转换成<code>character_result</code>类型。</p>
<h4 id="客户端"><a href="#客户端" class="headerlink" title="客户端:"></a>客户端:</h4><p>客户端: <code>jdbc:mysql://localhost:3306/exceltest1?useUnicode=true&amp;characterEncoding=UTF-8</code></p>
<p>客户端可以使用<code>set names utf-8</code>语句来告诉服务端自己将使用<code>utf-8</code>传输数据。</p>
<h4 id="特殊情况"><a href="#特殊情况" class="headerlink" title="特殊情况"></a>特殊情况</h4><p>诡异的<code>character_set_database</code>: 某个数据库的默认字符集。当数据库改变的时候，它也会改变。当没有指定数据库的时候，会按照<code>character_set_server</code>。</p>
<p><code>Load Data Infile</code>:<br>数据库总是将文件中的字符按照字符集<code>character_set_database</code>来解析。<br>mysql加载数据的时候，总是以同一个字符集处理所有数据，不管表中的列是否有不同的字符集设定。</p>
<p><code>Select Into OutFile</code>:<br>输出文件时不会自动做转码，也不能指定。唯一的方法是手动调用函数<code>convert</code>。</p>
<h4 id="查看字符集设置"><a href="#查看字符集设置" class="headerlink" title="查看字符集设置"></a>查看字符集设置</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">VARIABLES</span> <span class="keyword">LIKE</span> <span class="string">'character%'</span>;</span><br></pre></td></tr></table></figure>

<p>查看mysql支持的校对集: <code>show collation</code></p>
<p>一般校对集是字符集加上三种后缀:<br><code>_bin</code>: 二进制比较;<br><code>_ci</code>: 忽略大小写(ignore);<br><code>_cs</code>: 大小写敏感(sensitive)</p>
<p>大小写敏感比二进制比较更加复杂，会有更多规则。</p>
<h3 id="mysql如何选择字符集"><a href="#mysql如何选择字符集" class="headerlink" title="mysql如何选择字符集"></a>mysql如何选择字符集</h3><p>每个字符集有对应的默认校对集；<br>每个校对集有对应的默认字符集。（一般来说，校对集依赖于字符集）</p>
<ol>
<li>如果用户设置了: 那肯定按用户设置的来;</li>
<li>如果设置了一部分: 根据用户设置找默认的。</li>
<li>什么都没设置: 根据默认配置设置。</li>
</ol>
<h1 id="分布式（XA）事务"><a href="#分布式（XA）事务" class="headerlink" title="分布式（XA）事务"></a>分布式（XA）事务</h1><p>两阶段提交。<br>协调者+参与者。</p>
<ol>
<li>所有参与者完成准备工作；</li>
<li>协调者收到所有参与者的回复，提交事务。</li>
</ol>
<p>两种XA: 内部XA,外部XA。</p>
<h2 id="内部XA"><a href="#内部XA" class="headerlink" title="内部XA"></a>内部XA</h2><p>mysql是插件式的，因此每个存储引擎是互相独立，不知道彼此存在的。<br>他们之间协调需要分布式事务。(内部XA)</p>
<ul>
<li>跨存储引擎的事务需要内部XA。</li>
</ul>
<p>如果开启了二进制日志，日志也可以看作一种特别的存储引擎，因此也需要内部XA。</p>
<h2 id="外部XA"><a href="#外部XA" class="headerlink" title="外部XA"></a>外部XA</h2><p>mysql对xa协议支持不完整，无法在一个XA中关联多个连接。<br>外部XA网络开销大，建议引入<code>MQ</code>解决，而不使用外部XA。</p>
<h1 id="查询缓存"><a href="#查询缓存" class="headerlink" title="查询缓存"></a>查询缓存</h1><ol>
<li>检查sql是不是<code>select</code>开头,如果数据源表没有更改,hash查找缓存,返回结果;</li>
<li>如果有确定性结果,存储查询语句的结果和hash值到缓存。</li>
</ol>
<p>由于2(确定性结果)，所以使用<code>current_date</code>这样的函数时，sql结果不会被缓存。</p>
<p>查询缓存的注意事项:</p>
<ol>
<li>不能有长时间的事务;(会引入全局锁)</li>
<li>不要占用太大内存(过度依赖缓存)，可以直接使用redis。</li>
</ol>
<p>过度依赖缓存的话，缓存清理以后系统会假死很久。</p>
<h2 id="查询缓存的配置参数"><a href="#查询缓存的配置参数" class="headerlink" title="查询缓存的配置参数"></a>查询缓存的配置参数</h2><p><code>show variables like &#39;%query_cache%&#39;</code></p>
<h3 id="query-cache-type"><a href="#query-cache-type" class="headerlink" title="query_cache_type"></a>query_cache_type</h3><p>三种取值:</p>
<ol>
<li>OFF(0): 关闭,默认值。</li>
<li>ON(1):  打开</li>
<li>DEMAND(2): sql里写明<code>sql_cache</code>hint的语句才放入缓存。</li>
</ol>
<p><code>query_cache_size</code>: 查询缓存占的空间;<br><code>query_cache_limit</code>: 缓存结果集最大条数;</p>
<p>清空缓存: <code>reset query cache</code><br>整理缓存碎片: <code>flush query cache</code>(服务僵死一段时间)</p>
<img src="/images/2019-02/query_cache_opt.png" class="" width="800" height="1200" title="query_cache_opt">
      
    </div>
    <footer class="article-footer">
      <a data-url="http://xiaoyue26.github.io/2019/02/11/2019-02/%E9%AB%98%E6%80%A7%E8%83%BDmysql%E7%AC%AC%E4%B8%83%E7%AB%A0-%E7%AC%94%E8%AE%B0-%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/" data-id="ck96cxppg00hamaamd748dsy9" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/mysql/" rel="tag">mysql</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-2019-02/半小时真正理解记住paxos协议" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/02/01/2019-02/%E5%8D%8A%E5%B0%8F%E6%97%B6%E7%9C%9F%E6%AD%A3%E7%90%86%E8%A7%A3%E8%AE%B0%E4%BD%8Fpaxos%E5%8D%8F%E8%AE%AE/" class="article-date">
  <time datetime="2019-02-01T01:45:14.000Z" itemprop="datePublished">2019-02-01</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/">分布式</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/02/01/2019-02/%E5%8D%8A%E5%B0%8F%E6%97%B6%E7%9C%9F%E6%AD%A3%E7%90%86%E8%A7%A3%E8%AE%B0%E4%BD%8Fpaxos%E5%8D%8F%E8%AE%AE/">半小时真正理解记住paxos协议</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <p>摘要:</p>
<blockquote>
<p>简单浏览一遍流程，然后看半小时视频: <a href="https://www.bilibili.com/video/av36134550" target="_blank" rel="noopener">https://www.bilibili.com/video/av36134550</a><br>就OK了。</p>
</blockquote>
<p>paxos是分布式一致性协议，对于CAP的取舍是完全的C，较好的A，较好的P。<br>（关于CAP: <a href="http://xiaoyue26.github.io/2019/02/01/2019-02/简单解释CAP原理">http://xiaoyue26.github.io/2019/02/01/2019-02/简单解释CAP原理</a> ）</p>
<h1 id="paxos协商流程"><a href="#paxos协商流程" class="headerlink" title="paxos协商流程"></a>paxos协商流程</h1><h2 id="两个角色"><a href="#两个角色" class="headerlink" title="两个角色"></a>两个角色</h2><p>Proposer<br>Acceptor</p>
<h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><p>首先大致扫一遍下叙流程，第一遍大概率是完全懵逼看不懂的，花1分钟在脑中留下一点点印象即可:</p>
<h3 id="准备阶段（prepare）Proposer申请epoch"><a href="#准备阶段（prepare）Proposer申请epoch" class="headerlink" title="准备阶段（prepare）Proposer申请epoch"></a>准备阶段（prepare）Proposer申请epoch</h3><p>第一阶段A：Proposer选择一个提议编号n，向所有的Acceptor广播Prepare（n）请求。</p>
<p>第一阶段B：若Acceptor接收到Prepare（n）请求，两个选择:<br>    (1)n&gt;接受过的n_old: 接受请求,返回<code>(n_old,value_old)</code>。<br>    (2)n&lt;接受过的n_old: 拒绝请求。</p>
<h3 id="接受阶段（提交阶段）"><a href="#接受阶段（提交阶段）" class="headerlink" title="接受阶段（提交阶段）"></a>接受阶段（提交阶段）</h3><p>第二阶段A：Proposer得到了Acceptor响应:<br>1.如果未超过半数accpetor响应，直接转为提议失败；</p>
<p>2.如果超过多数Acceptor的承诺，又分为不同情况：<br>(1)如果所有Acceptor返回的value都是<code>null</code>，那么向所有的Acceptor发送<code>(n,value_n)</code>;<br>(2)如果存在Acceptor返回的value不为<code>null</code>，那么从所有接受过的值中选择对应的n_old最大的作为提议的值value_old，提议编号仍然为n。但此时Proposer就不能提议自己的值，只能信任Acceptor通过的值，维护一但获得确定性取值就不能更改原则: 向所有Acceptor发送<code>(n,value_old of max n_old)</code>。</p>
<p>第二阶段B：Acceptor接收到提议<code>(n,value)</code>后：<br>(1)n!=本地保存的last_n，拒绝。<br>(2)n=本地保存的last_n，写入本地值。</p>
<h2 id="看教学视频"><a href="#看教学视频" class="headerlink" title="看教学视频:"></a>看教学视频:</h2><p><a href="https://www.bilibili.com/video/av36134550" target="_blank" rel="noopener">https://www.bilibili.com/video/av36134550</a></p>
<p>由于之前花1分钟浏览了流程，视频看到15分钟的时候心里就会已经有数了。<br>看完30分钟就理解记住了。</p>
<h2 id="温习要点"><a href="#温习要点" class="headerlink" title="温习要点"></a>温习要点</h2><ol>
<li>类似于CAS，仅当，当前值为null时，才能提议值为value。</li>
<li>类似于jdk里的hashmap扩容，当发现有人捷足先登的时候，放下陈见开始辅助n_old完成value_old的扩散。发送(n,value_old)，以自己的名义，但是以别人的值，帮助一致性尽快达成。</li>
<li>Acceptor对于epoch: 喜新厌旧,总是接受最大的epoch，防止Proposor单点故障死等。</li>
<li>Proposor对于value: 喜旧厌新,总是接受更旧的value，尽快达成一致性。</li>
</ol>
<p>以上就是Basic Paxos。其实依然会有活锁，需要引进leader缓解。leader挂了的时候退化到Basic Paxos，出现活锁几率提升。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://xiaoyue26.github.io/2019/02/01/2019-02/%E5%8D%8A%E5%B0%8F%E6%97%B6%E7%9C%9F%E6%AD%A3%E7%90%86%E8%A7%A3%E8%AE%B0%E4%BD%8Fpaxos%E5%8D%8F%E8%AE%AE/" data-id="ck96cxppb00gnmaamhyerfdxe" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/paxos/" rel="tag">paxos</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F/" rel="tag">分布式</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-2019-02/简单解释CAP原理" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/02/01/2019-02/%E7%AE%80%E5%8D%95%E8%A7%A3%E9%87%8ACAP%E5%8E%9F%E7%90%86/" class="article-date">
  <time datetime="2019-02-01T01:33:53.000Z" itemprop="datePublished">2019-02-01</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/">分布式</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/02/01/2019-02/%E7%AE%80%E5%8D%95%E8%A7%A3%E9%87%8ACAP%E5%8E%9F%E7%90%86/">简单解释CAP原理</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <p>关于CAP原理的术语描述很多,其实给理解带来了障碍。(以下是维基百科:)</p>
<blockquote>
<p>一致性（Consistency）： （等同于所有节点访问同一份最新的数据副本）<br>可用性（Availability）：（每次请求都能获取到非错的响应——但是不保证获取的数据为最新数据）<br>分区容错性（Partition tolerance）：（以实际效果而言，分区相当于对通信的时限要求。系统如果不能在时限内达成数据一致性，就意味着发生了分区的情况，必须就当前操作在C和A之间做出选择。）</p>
</blockquote>
<img src="/images/2019-02/cap.png" class="" width="800" height="1200" title="cap">
<p>如图所示,CAP最多只能取两者。（如果每项要彻底达标，只能取2个，但也可以三者都不完全实现）</p>
<p>改成自然语言，通俗解释一下，就容易理解多了:</p>
<blockquote>
<p>C: 一致性。达成一致的速度足够快、或者每次更新是整个集群原子性的操作。如果有一个中控节点(单点瓶颈)，很容易让值变更是原子性的。(但也牺牲了A)<br>A: 可用性。 没有单点瓶颈，挂1，2个节点也能正常工作。<br>P: 可分性。 把集群切两半，让它们失联，让两半都能正常工作。</p>
</blockquote>
<h2 id="具体案例的CAP取舍"><a href="#具体案例的CAP取舍" class="headerlink" title="具体案例的CAP取舍"></a>具体案例的CAP取舍</h2><p>大部分的分布式系统(或者说集群)都是先取P，然后取舍A或者C（引入单点，或者使用P2P的协议）。</p>
<p><code>lease机制</code>: CP。例如hdfs中pipeline写入,client先申请租约lease，然后写入3备份后才返回。一致性由client单点控制完成,P由3副本完成，牺牲了A（有单点）。<br><code>Quorum机制</code>:C+0.5A+0.5P。N个副本，更新W个，读R个。<br><code>2PC/两阶段提交</code>: C+0.1A+0.1P。<br><code>Paxos</code>: C+0.8C+0.8P。</p>
<p><code>redis-cluster</code>: AP。key的分布:用gossip协议(类似于p2p)达成一致性,因此C比较慢。<br><code>redis-sentile</code>: CP。key的分布:各节点完全独立,数据存在哪里完全由客户端单点维护。因此没有A。<br><code>codis</code>：CP。由代理单点维护key的分布，因此也没有A。</p>
<p>一个实际的系统可能涉及到很多分布式协议，因此每个部分对于CAP的取舍可能会有不同。<br>HDFS系统: CP。大部分看起来是有单点。<br>ceph系统: AP。大部分看起来是p2p的，</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://xiaoyue26.github.io/2019/02/01/2019-02/%E7%AE%80%E5%8D%95%E8%A7%A3%E9%87%8ACAP%E5%8E%9F%E7%90%86/" data-id="ck96cxppa00gkmaam2ka94wve" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F/" rel="tag">分布式</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-2019-01/redis的quicklist" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/01/19/2019-01/redis%E7%9A%84quicklist/" class="article-date">
  <time datetime="2019-01-19T12:29:18.000Z" itemprop="datePublished">2019-01-19</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/redis/">redis</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/01/19/2019-01/redis%E7%9A%84quicklist/">redis的quicklist</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <p>列表对象: <code>REDIS_LIST</code></p>
<p>列表对象以前有两种编码: <code>linkedlist</code>和<code>zipList</code>：<br><code>linkedList</code>: 双向链表,灵活扩展,存取效率低。<br><code>zipList</code>: 连续存储,存取效率高，对缓存友好，扩展性差，修改插入需要级联移动.甚至可以粗略看做数组。<br>小数据量的时候会使用<code>zipList</code>,大数据量的时候会使用<code>linkedList</code>。<br>但它们其实是两个极端，各有优缺点。因此之后的版本就把它们混血了一下，出了一个<code>quickList</code>，平衡优缺点。</p>
<h2 id="quickList设计"><a href="#quickList设计" class="headerlink" title="quickList设计"></a>quickList设计</h2><p>粗略地看，把双向链表的每一个节点变成<code>zipList</code>，就是<code>quickList</code>了。<br>在原来的两个数据结构之间做一个折中，量化折中的参数:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 负数表示存储容量等级,每个节点上的ziplist大小不能超过8Kb（也就是2^3KB，以此类推）</span><br><span class="line">list-max-ziplist-size -2</span><br><span class="line"># 正数表示存储个数，每个节点上的zipList内元素不能超过5个:</span><br><span class="line">list-max-ziplist-size 5</span><br></pre></td></tr></table></figure>

<p>还有一个压缩参数:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 不进行压缩:</span><br><span class="line">list-compress-depth 0 </span><br><span class="line"># 除了首尾1个，中间的压缩:</span><br><span class="line">list-compress-depth 1</span><br></pre></td></tr></table></figure>
<p>由于双向链表一般用<code>LPush</code>,<code>Rpush</code>，两端的数据访问比较频繁，</p>
<h2 id="quickList源码"><a href="#quickList源码" class="headerlink" title="quickList源码"></a>quickList源码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">quicklist</span> &#123;</span></span><br><span class="line">    quicklistNode *head;    <span class="comment">// 头结点</span></span><br><span class="line">    quicklistNode *tail;    <span class="comment">// 尾节点</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> count;    <span class="comment">// 所有数据的数量</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> len;       <span class="comment">// quicklist节点数量</span></span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">fill</span>:<span class="number">16</span>;          <span class="comment">// 单个ziplist的大小限制</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> compress:<span class="number">16</span>;   <span class="comment">// 压缩深度</span></span><br><span class="line">&#125; quicklist;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">quicklistNode</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">quicklistNode</span> *<span class="title">prev</span>;</span> <span class="comment">// 前一个节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">quicklistNode</span> *<span class="title">next</span>;</span> <span class="comment">// 后一个节点</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *zl;  <span class="comment">// ziplist</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> sz;             <span class="comment">// ziplist的内存大小</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> count:<span class="number">16</span>;     <span class="comment">// zpilist中数据项的个数</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> encoding:<span class="number">2</span>;   <span class="comment">// 1为ziplist 2是LZF压缩存储方式</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> container:<span class="number">2</span>;  </span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> recompress:<span class="number">1</span>;   <span class="comment">// 压缩标志, 为1 是压缩</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> attempted_compress:<span class="number">1</span>; <span class="comment">// 节点是否能够被压缩,只用在测试</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> extra:<span class="number">10</span>; <span class="comment">/* more bits to steal for future usage */</span></span><br><span class="line">&#125; quicklistNode;</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://xiaoyue26.github.io/2019/01/19/2019-01/redis%E7%9A%84quicklist/" data-id="ck96cxpp400fqmaam3ugwg3le" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/redis/" rel="tag">redis</a></li></ul>

    </footer>
  </div>
  
</article>
 


  


  <nav id="page-nav">
    <a class="extend prev" rel="prev" href="/page/5/">&amp;laquo; 上一页</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><span class="page-number current">6</span><a class="page-number" href="/page/7/">7</a><a class="page-number" href="/page/8/">8</a><span class="space">&hellip;</span><a class="page-number" href="/page/21/">21</a><a class="extend next" rel="next" href="/page/7/">下一页&amp;raquo;</a>
  </nav>
</section>
           
    <aside id="sidebar">
  
    

  
    
  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title recent-posts">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/06/15/2020-06/jdk11%E4%B8%8Bg1%E6%94%B6%E9%9B%86%E5%99%A8%E4%BD%BF%E7%94%A8/">jdk11下g1收集器使用</a>
          </li>
        
          <li>
            <a href="/2020/06/08/2020-06/mysql%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB%E4%B8%8B%E7%94%A8for-update%E5%AF%BC%E8%87%B4%E7%9A%84%E6%AD%BB%E9%94%81/">mysql可重复读下用for update导致的死锁</a>
          </li>
        
          <li>
            <a href="/2020/05/05/2020-05/BeanCopier%E6%B5%8B%E8%AF%84%E6%8A%A5%E5%91%8A/">BeanCopier测评报告</a>
          </li>
        
          <li>
            <a href="/2020/04/19/2020-04/spring%E6%8B%BE%E9%81%97/">spring拾遗</a>
          </li>
        
          <li>
            <a href="/2020/03/26/2020-03/%E5%88%A9%E7%94%A8UTF-8%E7%BC%96%E7%A0%81%E7%9A%84%E7%89%B9%E6%80%A7%E8%BF%9B%E8%A1%8C%E4%BC%98%E5%8C%96/">利用UTF-8编码的特性进行优化</a>
          </li>
        
      </ul>
    </div>
  </div>

  
    

  
</aside>

      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-left">
      &copy; 2014 - 2020 风梦七&nbsp;|&nbsp;
      主题 <a href="https://github.com/giscafer/hexo-theme-cafe/" target="_blank">Cafe</a>
    </div>
     <div id="footer-right">
      联系方式&nbsp;|&nbsp;296671657@qq.com
    </div>
  </div>
</footer>
 
<script src="/jquery/jquery.min.js"></script>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">首页</a>
  
    <a href="/archives" class="mobile-nav-link">归档</a>
  
    <a href="/about" class="mobile-nav-link">关于</a>
  
</nav>
    <img class="back-to-top-btn" src="/images/fly-to-top.png"/>
<script>
// Elevator script included on the page, already.
window.onload = function() {
  var elevator = new Elevator({
    selector:'.back-to-top-btn',
    element: document.querySelector('.back-to-top-btn'),
    duration: 1000 // milliseconds
  });
}
</script>
      

  
    <script>
      var cloudTieConfig = {
        url: document.location.href, 
        sourceId: "",
        productKey: "e2fb4051c49842688ce669e634bc983f",
        target: "cloud-tie-wrapper"
      };
    </script>
    <script src="https://img1.ws.126.net/f2e/tie/yun/sdk/loader.js"></script>
    

  







<!-- author:forvoid begin -->
<!-- author:forvoid begin -->

<!-- author:forvoid end -->

<!-- author:forvoid end -->


  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      })
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      })
    </script>
    <script type="text/javascript" src="https://cdn.rawgit.com/mathjax/MathJax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


 
<script src="/js/is.js"></script>



  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>


<script src="/js/elevator.js"></script>

  </div>
</body>
</html>