<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>笔记本</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="笔记本">
<meta property="og:url" content="http://xiaoyue26.github.io/page/2/index.html">
<meta property="og:site_name" content="笔记本">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="风梦七">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="笔记本" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    
  
  
<link rel="stylesheet" href="/css/style.css">

  

<meta name="generator" content="Hexo 4.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    
    <div id="header-inner" class="inner">
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://xiaoyue26.github.io"></form>
      </div>
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">首页</a>
        
          <a class="main-nav-link" href="/archives">归档</a>
        
          <a class="main-nav-link" href="/about">关于</a>
        
      </nav>
      
    </div>
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">笔记本</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">风梦七</a>
        </h2>
      
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-2020-12/线上性能优化-查看方法级耗时" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/12/20/2020-12/%E7%BA%BF%E4%B8%8A%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-%E6%9F%A5%E7%9C%8B%E6%96%B9%E6%B3%95%E7%BA%A7%E8%80%97%E6%97%B6/" class="article-date">
  <time datetime="2020-12-20T12:36:32.000Z" itemprop="datePublished">2020-12-20</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/java/">java</a>►<a class="article-category-link" href="/categories/java/%E6%80%A7%E8%83%BD/">性能</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/12/20/2020-12/%E7%BA%BF%E4%B8%8A%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-%E6%9F%A5%E7%9C%8B%E6%96%B9%E6%B3%95%E7%BA%A7%E8%80%97%E6%97%B6/">线上性能debug-查看方法级耗时</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><p>可以手动挨个儿方法打debug日志；<br>可以用AOP集中拦截打日志；<br>可以用async-profiler查看火焰图；<br>可以用groovy动态执行benchmark;<br>可以用arthas的trace命令。</p>
<h1 id="目标-问题背景"><a href="#目标-问题背景" class="headerlink" title="目标(问题背景)"></a>目标(问题背景)</h1><p>背景是线上某个接口慢，需要优化。为了找到优化的方向，首先需要知道接口的各个部分的耗时，这样才能找到耗时比例最高的部分针对性地优化。<br>有些时候我们可以使用公司基础架构提供的<code>trace</code>\ <code>rpc monitor</code>来查看rpc调用粒度的耗时；（很多时候慢都是因为某个rpc服务调用慢）<br>但有些时候我们还是需要知道更细粒度、方法粒度的耗时或者耗时占比, 因为<code>trace</code>中的<code>span</code>一般粒度都是IO调用、如数据库访问、redis访问、rpc调用这种级别。</p>
<h1 id="实操"><a href="#实操" class="headerlink" title="实操"></a>实操</h1><h2 id="方法1：每个方法打日志"><a href="#方法1：每个方法打日志" class="headerlink" title="方法1：每个方法打日志"></a>方法1：每个方法打日志</h2><p>直接在每个方法开始结束的地方打上debug日志，然后在需要查看耗时的时候，运行时调整日志级别，用arthas:</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ognl <span class="string">'@com.xxx.spring.BeanFactory@getBean("xxxxServiceImpl").logger.setLevel(@ch.qos.logback.classic.Level@DEBUG)'</span></span><br></pre></td></tr></table></figure>

<p>这里不一定用<code>com.xxx.spring.BeanFactory</code>, 也可以用某个<code>applicationAware</code>、能拿到<code>applicatoinContext</code>的类，反正只要能用一行代码访问到logger就行。<br>如果logger所在的bean没有在<code>ApplicationContext</code>里(比如<code>interceptor</code>)，可以考虑把logger改成<code>static</code>的。 </p>
<h2 id="方法2：AOP集中拦截打日志"><a href="#方法2：AOP集中拦截打日志" class="headerlink" title="方法2：AOP集中拦截打日志"></a>方法2：AOP集中拦截打日志</h2><p>这个方法其实算是方法1的简单升级，毕竟每个方法都加上两行开始结束的日志代码量太大，实现上不可能做到。可以用AOP的表达式把所有需要监控的方法都覆盖进去。</p>
<p>这种方法也需要改动代码。</p>
<h2 id="方法3：用async-profiler查看火焰图"><a href="#方法3：用async-profiler查看火焰图" class="headerlink" title="方法3：用async-profiler查看火焰图"></a>方法3：用async-profiler查看火焰图</h2><p>前两种方法都需要改动代码，改造成本较高。一个很自然的思路查看耗时占比是我们手动疯狂jstack，统计一下最多次停留的方法，就是耗时占比最高的方法。</p>
<p>代替手动jstack的工具就是<a href="https://github.com/jvm-profiling-tools/async-profiler。" target="_blank" rel="noopener">https://github.com/jvm-profiling-tools/async-profiler。</a><br>可以使用命令(采样30秒)： </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./profiler.sh -d 30 -f time.svg &lt;pid&gt;</span><br></pre></td></tr></table></figure>
<p>有时候会发现意外的耗时瓶颈。（简单的过滤入口操作）<br>生成的svg文件可以直接用谷歌浏览器打开，可视化的结果，支持点击展开任意层级，非常得方便。</p>
<img src="/images/2020-12/svg.png" class="" width="800" height="1200" title="svg">


<h2 id="方法4：用groovy脚本动态执行benchmark"><a href="#方法4：用groovy脚本动态执行benchmark" class="headerlink" title="方法4：用groovy脚本动态执行benchmark"></a>方法4：用groovy脚本动态执行benchmark</h2><p>有时候线上接口有缓存，阻碍了我们收集p95耗时的瓶颈。这个时候我们可以用groovy脚本动态传入需要执行的java代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 某个bean中的预留方法:</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">debug</span><span class="params">(String code)</span></span>&#123;</span><br><span class="line">        String groovyStr = code; <span class="comment">// 需要执行的benchmark代码</span></span><br><span class="line">        Binding binding = <span class="keyword">new</span> Binding();</span><br><span class="line">        GroovyShell groovyShell = <span class="keyword">new</span> GroovyShell(binding);</span><br><span class="line">        Script script = groovyShell.parse(groovyStr);</span><br><span class="line">        <span class="keyword">return</span> script.run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里由于当做脚本语言来用了，安全隐患就是不能让我们以外的人调用，因此如果是内网业务可以鉴权后调用；<br>外网业务则让可以这个方法没有任何地方调用，需要用的时候我们自己登到机器上用arthas来调用。<br>(如果黑客入侵到这个程度的话，也无所谓有没有这个方法了)</p>
<h2 id="方法5：用arthas的trace命令"><a href="#方法5：用arthas的trace命令" class="headerlink" title="方法5：用arthas的trace命令"></a>方法5：用arthas的trace命令</h2><p>如果不仅需要知道耗时占比，还想知道耗时的具体大小，可以用arthas的trace命令:</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">trace --skipJDKMethod <span class="literal">false</span> com.xxx.service.impl.XXXXServiceImpl method1 <span class="string">'#cost &gt; 200'</span></span><br></pre></td></tr></table></figure>
<p>需要注意一定要加<code>--skipJDKMethod false</code>这个参数，因为我们很多时候用了java8的stream方法，如果跳过了jdk方法的统计，会发现各个子方法的耗时加起来不等于总耗时。</p>
<p>这个不像<code>async-profiler</code>一样能看到所有层级的调用，默认是一层，如果加了这个参数，能看到很多时候耗时最高的方法是 <code>collect</code>方法。</p>
<img src="/images/2020-12/trace.png" class="" width="800" height="1200" title="trace">



<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>方法3可以看到整个调用栈展开后的耗时占比；<br>方法4可以构造多次的调用；<br>方法5只能每次看一层，需要一层一层手动去找，而且官方给的通过listenId增强的方法需要用到telnet，而容器里往往根本没有telnet。因此实际上需要我们一层层去找。</p>
<p>实际工作上往往需要我们结合方法3、4、5。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://xiaoyue26.github.io/2020/12/20/2020-12/%E7%BA%BF%E4%B8%8A%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-%E6%9F%A5%E7%9C%8B%E6%96%B9%E6%B3%95%E7%BA%A7%E8%80%97%E6%97%B6/" data-id="cklkmfo8z0003pdam0q8a4i0z" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/arthas/" rel="tag">arthas</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/groovy/" rel="tag">groovy</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/" rel="tag">java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" rel="tag">性能优化</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-2020-12/升级HTTP2笔记" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/12/19/2020-12/%E5%8D%87%E7%BA%A7HTTP2%E7%AC%94%E8%AE%B0/" class="article-date">
  <time datetime="2020-12-19T07:45:17.000Z" itemprop="datePublished">2020-12-19</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/http/">http</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/12/19/2020-12/%E5%8D%87%E7%BA%A7HTTP2%E7%AC%94%E8%AE%B0/">升级HTTP2笔记</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <h1 id="已知的坑"><a href="#已知的坑" class="headerlink" title="已知的坑"></a>已知的坑</h1><h2 id="header大小写"><a href="#header大小写" class="headerlink" title="header大小写"></a>header大小写</h2><p>header names按http1.1协议是不区分大小写的，http2里全是小写，nginx反向代理会保留大小写，所以如果以前的代码依赖大写，就会挂掉。</p>
<p>(为啥h2里变小写了: HPACK算法, 解压的时候查表还原header names, 类似于哈夫曼算法)</p>
<h2 id="与websocket不能共用域名-只支持https"><a href="#与websocket不能共用域名-只支持https" class="headerlink" title="与websocket不能共用域名, 只支持https"></a>与websocket不能共用域名, 只支持https</h2><p>websocket和http2都是从http协议握手协商升级过去的，也就是起点是http1.1。 两种协商过程:</p>
<ul>
<li>http1.1 -Upgrade=&gt; websocket+ssl (wss)</li>
<li>http1.1 -Upgrade=&gt; http2</li>
</ul>
<p>H2是基于https的，因此如果某个域名切换到H2以后，就只能支持https的链接了，不再支持http;<br>如果硬要不加密、不安全，可以使用H2C，但是主流浏览器都声称不会支持H2C，因此这个选项其实并不实际。</p>
<p> (这个倒是不能算坑，只能算一个特性)</p>
<h1 id="Why-为什么要升级到H2"><a href="#Why-为什么要升级到H2" class="headerlink" title="Why: 为什么要升级到H2"></a>Why: 为什么要升级到H2</h1><p>主要是性能上的优化。</p>
<p>Http2的修改:</p>
<p>1.header压缩: HPACK算法;</p>
<p>2.服务器推送: server push，推送html里的css,js; </p>
<p>3.pipeline请求;</p>
<p>4.多路复用，同域名单个TCP连接，划分stream id;</p>
<p>5.二进制传输;</p>
<p>其中1、3、5肯定提升性能；</p>
<p>2则取决于缓存策略，因为可能服务器push了客户端已经缓存的资源，浪费带宽；</p>
<p>4取决于优先级策略，因为把以前前端手动控制的优先级策略，交给浏览器内核来自动实现，按<a href="https://blog.cloudflare.com/zh/better-http-2-prioritization-for-a-faster-web-zh/" target="_blank" rel="noopener">https://blog.cloudflare.com/zh/better-http-2-prioritization-for-a-faster-web-zh/</a> ， 谷歌内核是最接近最优策略的。但是由于以前可以多开TCP连接，现在是单开，因此如果有大图片，会阻塞后面的小图片。</p>
<p>谷歌的优先级处理逻辑如下：</p>
<img src="/images/2020-12/chrome_loading-1.gif" class="" width="800" height="1200" title="loading">

<p>此外，由于有了特性4，不再需要前端内联资源，因此一些针对http1.1的优化可以回滚，好处是可以简化代码，提高缓存效率，去掉重复建立连接的开销；</p>
<p>坏处就是不能再依赖多开TCP连接了，图片只能一张一张刷开。</p>
<h1 id="HOW-怎么升级到H2"><a href="#HOW-怎么升级到H2" class="headerlink" title="HOW:怎么升级到H2"></a>HOW:怎么升级到H2</h1><p>根据nginx官网的指导，没有必要全链路H2,只需要client到nginx是H2就够了(terminate protocol)。后端服务可以维持原来的协议。（类似于以前升级https）</p>
<p>因此只需要修改nginx配置即可，对后端服务无感知。(如下图)</p>
<img src="/images/2020-12/ng.png" class="" width="800" height="1200" title="ng">

<p>ng官网指导: <a href="https://www.nginx.com/blog/7-tips-for-faster-http2-performance/" target="_blank" rel="noopener">https://www.nginx.com/blog/7-tips-for-faster-http2-performance/</a></p>
<h2 id="为什么没必要全链路H2"><a href="#为什么没必要全链路H2" class="headerlink" title="为什么没必要全链路H2:"></a>为什么没必要全链路H2:</h2><p>按ng官网的说法，H2的主要优点是性能提高，对于内网网速来说，这点提升意义不大；</p>
<p>因此nginx只在服务端支持H2, 不支持客户端H2(转发的时候)。</p>
<p>如果想要全链路H2, 就不能用nginx了。</p>
<h1 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h1><p>1.<a href="https://zhuanlan.zhihu.com/p/276057825" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/276057825</a></p>
<p>2.<a href="https://www.cnblogs.com/confach/p/10141273.html" target="_blank" rel="noopener">https://www.cnblogs.com/confach/p/10141273.html</a></p>
<p>3.<a href="https://zhuanlan.zhihu.com/p/89471776" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/89471776</a></p>
<p>4.<a href="https://juejin.im/post/6844903745218674695" target="_blank" rel="noopener">https://juejin.im/post/6844903745218674695</a></p>
<p>5.<a href="https://blog.cloudflare.com/zh/better-http-2-prioritization-for-a-faster-web-zh/" target="_blank" rel="noopener">https://blog.cloudflare.com/zh/better-http-2-prioritization-for-a-faster-web-zh/</a></p>
<p>6.<a href="https://hpbn.co/http2/#stream-prioritization" target="_blank" rel="noopener">https://hpbn.co/http2/#stream-prioritization</a></p>
<p>7.<a href="https://calendar.perfplanet.com/2018/http2-prioritization/" target="_blank" rel="noopener">https://calendar.perfplanet.com/2018/http2-prioritization/</a></p>
<p>8.<a href="https://www.jianshu.com/p/e57ca4fec26f" target="_blank" rel="noopener">https://www.jianshu.com/p/e57ca4fec26f</a></p>
<p>9.<a href="https://zhuanlan.zhihu.com/p/26559480" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/26559480</a></p>
<p>10.<a href="https://www.cnblogs.com/ranFengHua/p/10816956.html" target="_blank" rel="noopener">https://www.cnblogs.com/ranFengHua/p/10816956.html</a></p>
<p>11.<a href="https://blog.csdn.net/liujiyong7/article/details/64478317" target="_blank" rel="noopener">https://blog.csdn.net/liujiyong7/article/details/64478317</a></p>
<p>12.<a href="https://www.nginx.com/blog/7-tips-for-faster-http2-performance/" target="_blank" rel="noopener">https://www.nginx.com/blog/7-tips-for-faster-http2-performance/</a></p>
<p>13.<a href="https://www.cnblogs.com/operationhome/p/12577540.html" target="_blank" rel="noopener">https://www.cnblogs.com/operationhome/p/12577540.html</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://xiaoyue26.github.io/2020/12/19/2020-12/%E5%8D%87%E7%BA%A7HTTP2%E7%AC%94%E8%AE%B0/" data-id="cklkmfo8y0001pdam8kzy25s3" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/http/" rel="tag">http</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/nginx/" rel="tag">nginx</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-2020-07/ES实战笔记" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/07/22/2020-07/ES%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0/" class="article-date">
  <time datetime="2020-07-22T10:58:58.000Z" itemprop="datePublished">2020-07-22</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/es/">es</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/07/22/2020-07/ES%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0/">ES实战笔记</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <h1 id="索引结构"><a href="#索引结构" class="headerlink" title="索引结构"></a>索引结构</h1><img src="/images/2020-07/lsm-tree.png" class="" width="800" height="1200" title="lsm-tree">
<p>ES底层的lucene引擎的分段，比较类似LSM tree的机制。<br>分段不可变，合并生成新的大的分段。<br>ES中的translog对应Hbase中的WAL日志，防止进程崩了丢数据;</p>
<h1 id="常用api"><a href="#常用api" class="headerlink" title="常用api"></a>常用api</h1><p>查看分析器对某段文本的结果:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -XPOST 'localhost:9200/get-together/_analyze?analyzer=myCustomAnalyzer' -d 'share your experience with NoSqlιbig data technologies'</span><br></pre></td></tr></table></figure>


<p>组合内置分词器和过滤器,空格分词、小写+反转:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -XPOST 'localhost:9200/_analyze?tokenizer=whitespace&amp;filters=lowercase,reverse' -d  'share your experience with NoSql big data technolog es'</span><br></pre></td></tr></table></figure>

<p>查看单文档的所有token信息:(get-together索引下、group类型、文档id为1):</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl 'localhost:9200/get-together/group/1/_termvector?pretty=true'</span><br></pre></td></tr></table></figure>

<h1 id="分析器"><a href="#分析器" class="headerlink" title="分析器"></a>分析器</h1><p>分析器 = 0到1个字符过滤器 + 1个单个分词器 + 0到n个分词过滤器;</p>
<h2 id="标准分析器-默认"><a href="#标准分析器-默认" class="headerlink" title="标准分析器(默认)"></a>标准分析器(默认)</h2><p><code>standard analyzer</code> = 标准分词器 + 标准分词过滤器 + 小写转换分词过滤器 + 停用词分词过滤器<br>（0字符过滤+1分词器+3分词过滤器）</p>
<h2 id="简单分析器"><a href="#简单分析器" class="headerlink" title="简单分析器"></a>简单分析器</h2><p><code>simple analyzer</code>: 在非字母处进行分词 + 转小写</p>
<h2 id="空白分析器"><a href="#空白分析器" class="headerlink" title="空白分析器"></a>空白分析器</h2><p><code>whitespace analyzer</code>: 根据空白分词 + 0分词过滤器</p>
<h2 id="停用词过滤器"><a href="#停用词过滤器" class="headerlink" title="停用词过滤器"></a>停用词过滤器</h2><p><code>stop analyzer</code>: 根据停用词分词 + 0分词过滤器；</p>
<h2 id="模式分析器"><a href="#模式分析器" class="headerlink" title="模式分析器"></a>模式分析器</h2><p><code>pattern analyzer</code>: 允许指定一个分词切分模式;</p>
<h2 id="语言分析器"><a href="#语言分析器" class="headerlink" title="语言分析器"></a>语言分析器</h2><p>包括汉语;</p>
<h2 id="雪球分析器"><a href="#雪球分析器" class="headerlink" title="雪球分析器"></a>雪球分析器</h2><p><code>snowball analyzer</code>: 标准分析器 + 雪球词干器; </p>
<h1 id="分词器"><a href="#分词器" class="headerlink" title="分词器"></a>分词器</h1><h2 id="标准分词器"><a href="#标准分词器" class="headerlink" title="标准分词器"></a>标准分词器</h2><p>主要处理欧洲语言,移除标点;</p>
<h2 id="关键词分词器"><a href="#关键词分词器" class="headerlink" title="关键词分词器"></a>关键词分词器</h2><p>整个文本提供给过滤器</p>
<h2 id="字母分词器"><a href="#字母分词器" class="headerlink" title="字母分词器"></a>字母分词器</h2><p>基于非字母分词</p>
<h2 id="小写分词器"><a href="#小写分词器" class="headerlink" title="小写分词器"></a>小写分词器</h2><p>非字母分词+转换成小写</p>
<h2 id="空白分词器"><a href="#空白分词器" class="headerlink" title="空白分词器"></a>空白分词器</h2><p>通过空白来分词</p>
<h2 id="模式分词器"><a href="#模式分词器" class="headerlink" title="模式分词器"></a>模式分词器</h2><p>例如可以在出现文本._.的地方分词:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">curl -XPOST 'localhost:9200/pattern' -d '&#123;</span><br><span class="line">"settngs": &#123;</span><br><span class="line">    ”index” : &#123;</span><br><span class="line">        ”analysis”: &#123;</span><br><span class="line">            ”tokenizer": &#123;</span><br><span class="line">                ”patternl”: &#123;</span><br><span class="line">                    ”type": ”pattern”,</span><br><span class="line">                    ”pattern”:”\\.-\\.”</span><br></pre></td></tr></table></figure>

<h2 id="UAX-URL电子邮件分词器"><a href="#UAX-URL电子邮件分词器" class="headerlink" title="UAX/URL电子邮件分词器"></a>UAX/URL电子邮件分词器</h2><p><a href="mailto:john.smith@example.com">john.smith@example.com</a> =&gt; 标准分词<br>=&gt;<br>john.smith<br>example.com</p>
<p><a href="http://example.com?q=foo" target="_blank" rel="noopener">http://example.com?q=foo</a> =&gt; 标准分词<br>http、example.com、q、foo</p>
<p>如果用UAX/URL电子邮件分词器，则可以保留:<br><a href="mailto:john.smith@example.com">john.smith@example.com</a>(type:&lt; EMAIL&gt;)<br><a href="http://example.com?q=bar" target="_blank" rel="noopener">http://example.com?q=bar</a>(type:&lt; URL&gt;)</p>
<h2 id="路径层次分词器"><a href="#路径层次分词器" class="headerlink" title="路径层次分词器"></a>路径层次分词器</h2><p><code>path hierarchy tokenizer</code><br>输入: /usr/local/var/log/es/log<br>分词结果: /usr、/usr/local、 …. /usr/local/var/log/es/log<br>因此有相同父目录的路径搜索(分词有相同部分)，能互相搜到。</p>
<h1 id="分词过滤器"><a href="#分词过滤器" class="headerlink" title="分词过滤器"></a>分词过滤器</h1><p>标准分词过滤器: 啥也不做;<br>小写过滤器、停用词过滤器、长度分词过滤器: 将最短和最长的单词过滤掉(自行设置min\max);<br>截断分词过滤器: 截断超出长度token;<br>修建分词过滤器: trim<br>限制分词数量分词过滤器: 限制最多多少个token被索引,比如设置max=8;<br>reverse分词过滤器: 把token反转，可以用于支持后缀索引;<br>唯一分词过滤器: 每个单词只保留第一次出现的位置(去重了)<br>ascii折叠分词过滤器: 尽量转ascii<br>同义词分词过滤器: 转成同义词<br>ngram过滤器: 略<br>滑动窗口分词过滤器: 略</p>
<h1 id="提取词干"><a href="#提取词干" class="headerlink" title="提取词干"></a>提取词干</h1><p>这个好像只是英文有用。把单词缩减到词根。<br>administrations -&gt; administr<br>词干提取器: snowball,porter_stem,kstem<br>字典提取词干: hunspell分词过滤器+字典</p>
<h1 id="打分相关"><a href="#打分相关" class="headerlink" title="打分相关"></a>打分相关</h1><ol>
<li>TF-IDF: 词频、逆文档频率<img src="/images/2020-07/tf-idf.png" class="" width="800" height="1200" title="tf-idf"></li>
<li>Okapi BM25;</li>
<li>随机性分歧: DFR相似度</li>
<li>IB相似度;</li>
<li>LM dirichlet相似度;</li>
<li>LM Jelinek Mercer相似度;</li>
</ol>
<h2 id="BM25"><a href="#BM25" class="headerlink" title="BM25"></a>BM25</h2><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">"mappings"</span>:&#123;</span><br><span class="line">    <span class="attr">"get-together"</span>: &#123;</span><br><span class="line">        <span class="attr">"properties"</span>: &#123;</span><br><span class="line">            <span class="attr">"title"</span>:&#123;</span><br><span class="line">                <span class="attr">"type"</span>:<span class="string">"string"</span></span><br><span class="line">                ,<span class="attr">"similarity"</span>: <span class="string">"BM25"</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>BM25的3个重要参数:<br>k1: 数值, 词频的重要性; (默认1.2)<br>b: 0~1数值, 篇幅对于得分的影响程度; (默认0.75)<br>discount_overlaps: 多个分词出现在同一位置，是否影响长度的标准化(默认true)</p>
<h2 id="boosting-加权"><a href="#boosting-加权" class="headerlink" title="boosting: 加权"></a>boosting: 加权</h2><p>可以用来修改文档相关性的程序。<br>包括:</p>
<ul>
<li>索引期boosting</li>
<li>查询期boosting</li>
</ul>
<p>一般使用查询期boosting(避免重新索引全部文档)</p>
<h1 id="相关性、语义搜索的一些方案"><a href="#相关性、语义搜索的一些方案" class="headerlink" title="相关性、语义搜索的一些方案"></a>相关性、语义搜索的一些方案</h1><p>首先所有的词向量模型都是基于分布假说的（distributional hypothesis）：拥有相似上下文的词，词义相似。</p>
<p>参考: <a href="https://zhuanlan.zhihu.com/p/80737146" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/80737146</a></p>
<ol>
<li>word embedding</li>
<li>sentence embedding: 更难训练;</li>
</ol>
<p>word embedding算法:<br>word2vec：Skip-gram模型训练神经网络以预测句子中单词周围的上下文单词。<br>GloVe：单词的相似性取决于它们与其他上下文单词出现的频率。该算法训练单词共现计数的简单线性模型。<br>Fasttext：Facebook的词向量模型，其训练速度比word2vec的训练速度更快，效果又不丢失。</p>
<p>网上现有的预训练模型：基于维基百科语料库.</p>
<p>性能更优的方案:</p>
<ol>
<li>粗排: ES;</li>
<li>精排: 语义模型计算相似度;</li>
</ol>
<p>工业界主流: 谷歌的bert模型</p>
<h1 id="中文分词IK相关"><a href="#中文分词IK相关" class="headerlink" title="中文分词IK相关"></a>中文分词IK相关</h1><p><a href="https://github.com/medcl/elasticsearch-analysis-ik" target="_blank" rel="noopener">https://github.com/medcl/elasticsearch-analysis-ik</a></p>
<p>索引时优先使用<code>analyzer</code>配置的分词器，对文档进行分词;<br>// 索引时用ik_max_word,尽量多分几个词出来;<br>查询时优先使用<code>search_analyzer</code>配置的分词器，对输入进行分词;<br>// 查询时使用ik_smark, 尽量用最长的token去查询;<br>//</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">curl -XPOST http://localhost:9200/index/_mapping -H 'Content-Type:application/json' -d'</span><br><span class="line">&#123;</span><br><span class="line">        "properties": &#123;</span><br><span class="line">            "content": &#123;</span><br><span class="line">                "type": "text",</span><br><span class="line">                "analyzer": "ik_max_word",</span><br><span class="line">                "search_analyzer": "ik_smart"</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;'</span><br></pre></td></tr></table></figure>

<h1 id="实践遇到的问题"><a href="#实践遇到的问题" class="headerlink" title="实践遇到的问题"></a>实践遇到的问题</h1><h2 id="分词查询和关键字查询同时使用"><a href="#分词查询和关键字查询同时使用" class="headerlink" title="分词查询和关键字查询同时使用"></a>分词查询和关键字查询同时使用</h2><p>分词查询的时候，切分是ik_max_word，最大只切到单词；<br>比如“工具”就是最小粒度了，因此如果查询的时候使用”工”则不会查询到结果。</p>
<p>如果是默认的标准分词器，则只会有单个字，不会有单词；</p>
<p>所以如果两个都要支持，可以用两个字段，（存两个字段）<br>一个字段用 ik_max_word， 一个字段用 standard;<br>查询的时候也是用bool or 连接，命中一个即可。</p>
<h3 id="可参考的解决方案"><a href="#可参考的解决方案" class="headerlink" title="可参考的解决方案"></a>可参考的解决方案</h3><p>用fields多加一个不分词的结果(name.raw)</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"properties"</span>:&#123;</span><br><span class="line">        <span class="attr">"name"</span>: &#123;</span><br><span class="line">                <span class="attr">"type"</span>: <span class="string">"string"</span>,</span><br><span class="line">                <span class="attr">"analyzer"</span>: <span class="string">"standard"</span>, </span><br><span class="line">                <span class="attr">"fields"</span>: &#123;</span><br><span class="line">                    <span class="attr">"raw"</span>: &#123;</span><br><span class="line">                        <span class="attr">"index"</span>: <span class="string">"not_analyzed"</span>,</span><br><span class="line">                        <span class="attr">"type"</span>: <span class="string">"string"</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    </span><br><span class="line">                &#125;</span><br><span class="line">        </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="整合网上的近义词库"><a href="#整合网上的近义词库" class="headerlink" title="整合网上的近义词库"></a>整合网上的近义词库</h1><p>思路1: 自定义一个分词过滤器；// 可复用程度高<br>思路2: 写入该字段前，先用网上的近义词库把文本解析成空格分割的token，然后用空白分词器索引；（查询时用分词器） // 灵活，不用跟版本<br>// 由于可以配置多个分词过滤器，所以可以同时配置空格分词过滤器和同义词分词过滤器</p>
<p>维基百科近义词库： 528MB<br><a href="http://licstar.net/archives/tag/wikipedia-extractor" target="_blank" rel="noopener">http://licstar.net/archives/tag/wikipedia-extractor</a></p>
<p>某个领域最好的词向量:<br><a href="http://licstar.net/archives/tag/%e8%af%8d%e5%90%91%e9%87%8f" target="_blank" rel="noopener">http://licstar.net/archives/tag/%e8%af%8d%e5%90%91%e9%87%8f</a></p>
<p>考虑用boost加入相似度因素；（加权）</p>
<p>词向量资料：<br><a href="http://licstar.net/archives/328" target="_blank" rel="noopener">http://licstar.net/archives/328</a></p>
<h1 id="聚集"><a href="#聚集" class="headerlink" title="聚集"></a>聚集</h1><p>聚集有几个选项:</p>
<h2 id="桶型聚集-group-by"><a href="#桶型聚集-group-by" class="headerlink" title="桶型聚集: (group by)"></a>桶型聚集: (group by)</h2><p>term: 词条聚集,就是统计文档数量;<br>significant_terms: 显著聚集<br>range: 范围聚集;<br>histogram: 直方图聚集;(类似范围，但是只需要提供间距即可)<br>嵌套聚集、反嵌套聚集、子聚集: 根据文档关系聚集;<br>地理距离聚集;</p>
<h2 id="度量型聚集-agg"><a href="#度量型聚集-agg" class="headerlink" title="度量型聚集: (agg)"></a>度量型聚集: (agg)</h2><p>stats: 就是统计min,max,avg,count,sum信息;<br>extended_stats: 就是加上标准差这种更冷门的统计信息;<br>percentile: 分位数(近似,可以用compress参数控制精度和内存消耗)<br>cardinatily: 基数,也就是uv;// 近似的，hyperLogLog++, precision_threshold控制精度</p>
<h2 id="过滤器和后过滤器"><a href="#过滤器和后过滤器" class="headerlink" title="过滤器和后过滤器"></a>过滤器和后过滤器</h2><h3 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h3><img src="/images/2020-07/es-filter.png" class="" width="800" height="1200" title="es-filter">
<h3 id="后过滤器"><a href="#后过滤器" class="headerlink" title="后过滤器:"></a>后过滤器:</h3><img src="/images/2020-07/es-post-filter.png" class="" width="800" height="1200" title="es-post-filter">

<p><em>两者区别</em></p>
<p>文档-&gt;过滤器-&gt;查询-&gt;后过滤器-&gt;查询结果<br>文档-&gt;过滤器-&gt;查询-&gt;filter聚集-&gt;聚集结果</p>
<p>换句话说就是后过滤器不影响聚集，过滤器则影响聚集结果。<br>filter聚集则只影响聚集。</p>
<p>有一个例外是使用globel聚集，这样即使符合查询的只有2条文档，聚集也会应用到所有的文档上。(聚集比查询结果的数据源大)</p>
<h1 id="文档间的关系"><a href="#文档间的关系" class="headerlink" title="文档间的关系"></a>文档间的关系</h1><h2 id="对象类型"><a href="#对象类型" class="headerlink" title="对象类型"></a>对象类型</h2><p>输入:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"name"</span>: <span class="string">"name1"</span></span><br><span class="line">    ,<span class="attr">"events"</span>: [</span><br><span class="line">        &#123;<span class="attr">"title"</span>: <span class="string">"hadoop"</span></span><br><span class="line">        ,"date”: "12月"</span><br><span class="line">        &#125;</span><br><span class="line">        ,&#123;"title": "es"</span><br><span class="line">        ,"date”: "6月"</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种数据实际索引的时候，会把各个字段分别组成数组:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">events.title: ["hadoop","es"]</span><br><span class="line">events.date: ["6月",“12月”]</span><br></pre></td></tr></table></figure>
<p>所以搜的时候如果想搜6月的hadoop, 也可以搜出12月hadoop的文档(name1).</p>
<h2 id="嵌套类型"><a href="#嵌套类型" class="headerlink" title="嵌套类型"></a>嵌套类型</h2><p>上面的情况可以用嵌套类型解决。<br>这个时候的索引:</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[events.title: hadoop</span><br><span class="line">events.date: <span class="number">12</span>月</span><br><span class="line">,</span><br><span class="line">events.title: es</span><br><span class="line">events.date: <span class="number">6</span>月</span><br><span class="line"></span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h2 id="父子关系和反规范化"><a href="#父子关系和反规范化" class="headerlink" title="父子关系和反规范化"></a>父子关系和反规范化</h2><p>父子关系的存储：<br>1.规范化：父文档和子文档分开存储，然后再存储一个映射关系；// 相关查询: has_parent/has_child<br>2.反规范化：子文档中存储父文档；（空间换时间）</p>
<h2 id="嵌套json的存储"><a href="#嵌套json的存储" class="headerlink" title="嵌套json的存储"></a>嵌套json的存储</h2><p>由于ES的底层Lucence只支持扁平结构，ES支持嵌套json的方法是通过强行打平,如：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">"title"</span>: <span class="string">"titl1"</span></span><br><span class="line">,<span class="attr">"location"</span>:&#123;</span><br><span class="line">    <span class="attr">"name"</span>: <span class="string">"name1"</span></span><br><span class="line">    ,<span class="attr">"geolocation"</span>: <span class="string">"51.52,-0.09"</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实际实施到Lucence层的时候是这样存的:</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">titile:</span> <span class="string">"title1"</span></span><br><span class="line"><span class="attr">location.name:</span> <span class="string">"name1"</span></span><br><span class="line"><span class="attr">location.geolocation:</span> <span class="string">"51.52,-0.09"</span></span><br></pre></td></tr></table></figure>
<p>因此我们设计的key一定不要有小数点符号。<br>而且最好是一对一关系（不是数组）。</p>
<p>父子关系的索引选项：<br>include_in_parent/include_in_root</p>
<h3 id="一对一"><a href="#一对一" class="headerlink" title="一对一"></a>一对一</h3><p>嵌套json/对象</p>
<h4 id="一对多"><a href="#一对多" class="headerlink" title="一对多"></a>一对多</h4><p>嵌套文档: 索引阶段进行join; // 同分片存储，保证本地连接<br>父子关系: 查询阶段进行join; // 不同分片,远程连接</p>
<h4 id="多对多"><a href="#多对多" class="headerlink" title="多对多"></a>多对多</h4><p>反规法化: 可以处理多对多关系</p>
<h1 id="ES扩展"><a href="#ES扩展" class="headerlink" title="ES扩展"></a>ES扩展</h1><p>ES集群使用master-slaver架构，master和slaver用心跳信息来判断彼此的存活；<br>（有点类似hadoop，不知道是不是也有hadoop的HA；hadoop在120个节点的时候namenode容易OOM，不知道ES有没有类似问题）<br>master\slaver互相ping应该会消耗一些带宽，可以考虑调节心跳频率调节性能。</p>
<p>节点下线：先停用（停止数据写入、迁移）</p>
<h2 id="集群升级"><a href="#集群升级" class="headerlink" title="集群升级"></a>集群升级</h2><h3 id="重启"><a href="#重启" class="headerlink" title="重启"></a>重启</h3><p>直接关闭整个集群，不可用。<br>然后升级所有节点，重启集群。<br>有一段时间不可用。</p>
<h3 id="轮流重启"><a href="#轮流重启" class="headerlink" title="轮流重启"></a>轮流重启</h3><p>不牺牲可用性的情况下，重启集群；<br>基本步骤是：关一个节点，升级一个节点，重启这个节点，重新加入集群。<br>这里有一个关键就是，关闭某个节点的期间，不需要集群自己做rebalance.<br>因此配置：<code>cluster.routing.allocation.enable</code>=<code>none</code><br>可以用curl发命令修改这个配置。<br>过后重新设置为<code>all</code>。</p>
<p>如果副本数&gt;1，上述操作期间服务依然可用。</p>
<h2 id="别名API"><a href="#别名API" class="headerlink" title="别名API"></a>别名API</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">curl -XPOST 'localhost:9200/_aliases' -d '</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"actions"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"add"</span>: &#123;</span><br><span class="line">                <span class="attr">"index"</span>: <span class="string">"get-together"</span>,</span><br><span class="line">                <span class="attr">"alias"</span>: <span class="string">"gt-alias"</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"remove"</span>: &#123;</span><br><span class="line">                <span class="attr">"index"</span>: <span class="string">"old-get-together"</span>,</span><br><span class="line">                <span class="attr">"alias"</span>: <span class="string">"gt-alias"</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;'</span><br></pre></td></tr></table></figure>
<p>可以分拆成两个命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -XPUT 'http://localhost:9200/get-together/_alias/gt-alias'</span><br><span class="line">curl -XDELETE 'http://localhost:9200/old-get-together/_alias/gt-alias'</span><br></pre></td></tr></table></figure>
<p>一个别名可以指向多个索引，甚至指向logs-开头的索引。<br>(类似于一个逻辑名称)<br>别名还可以附带一个过滤器。</p>
<h2 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h2><p>默认路由策略：文档id<br>可以手动指定routing=xxx来影响分片行为。</p>
<p>因此可以根据业务，把一起访问的文档路由到同一分片上。</p>
<h3 id="debug-api-查看搜索的分片"><a href="#debug-api-查看搜索的分片" class="headerlink" title="debug api: 查看搜索的分片"></a>debug api: 查看搜索的分片</h3><p>routing为xxx时，会搜索哪个分片:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -XGET 'localhost:9200/get-together/_search_shards&amp;routing=xxxx'</span><br></pre></td></tr></table></figure>


<p>可以在别名中配置路由，简化查询操作。</p>
<h1 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h1><h2 id="合并请求-bulk接口"><a href="#合并请求-bulk接口" class="headerlink" title="合并请求(bulk接口)"></a>合并请求(bulk接口)</h2><p>批量新增、批量更新、批量搜索</p>
<h2 id="IO配置优化"><a href="#IO配置优化" class="headerlink" title="IO配置优化"></a>IO配置优化</h2><p>segments: 分段;</p>
<p>ES接收到文档后:<br>分段的倒排索引</p>
<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>refresh: 刷新; 生效，重新打开索引;新建的索引生效, 以前的缓存失效;<br>flush: 冲刷; 刷盘，索引数据写入磁盘;<br>合并: 小分段合并成大分段; // 分段越多，查询越慢;<br>存储限流: 调节每秒写入的字节数;</p>
<h3 id="优化策略"><a href="#优化策略" class="headerlink" title="优化策略"></a>优化策略</h3><h4 id="刷新频率降低"><a href="#刷新频率降低" class="headerlink" title="刷新频率降低"></a>刷新频率降低</h4><p>缓存失效的频率降低，性能更高，新文档慢一些生效；<br>// 默认每秒刷新, index.refresh_interval</p>
<h4 id="刷盘频率降低"><a href="#刷盘频率降低" class="headerlink" title="刷盘频率降低"></a>刷盘频率降低</h4><p>IO消耗降低，性能更高，丢数据概率提高;<br>触发刷盘的时机:<br>1.内存缓存区已满;<br>2.固定间隔(定时器);<br>3.事务日志达到阈值;<br>因此调控的手段:<br>1.内存缓存区大小: indices.memory.index_buffer_size;<br>2.刷新间隔: index.translog.flush_threshold_period;<br>3.事务日志大小: index.translog.flush_threshold_size;</p>
<h3 id="合并策略优化"><a href="#合并策略优化" class="headerlink" title="合并策略优化"></a>合并策略优化</h3><p>合并的作用：</p>
<ol>
<li>真正删除文档;</li>
<li>分段越少，查询越快;</li>
</ol>
<p>触发合并的时机:</p>
<ol>
<li>索引文档;</li>
<li>更新、删除文档;</li>
</ol>
<p>合并相关配置:<br><code>index.merge.policy.segments_per_tier</code>:<br>每层的分段数量;<br>高=&gt;写性能越好，越低=&gt;读性能越好;<br><code>index.merge.policy.max_merge_at_once</code>:<br>每次合并多少分段; 设置为等于<code>segments_per_tier</code>即可;<br><code>index.merge.policy.max_merged_segment</code>:<br>分段的最大规模;<br>低=&gt;写性能好; 高=&gt;读性能好;<br><code>index.merge.scheduler.max_thread_count</code>:<br>合并用的最大线程数;</p>
<h3 id="存储限流"><a href="#存储限流" class="headerlink" title="存储限流"></a>存储限流</h3><p><code>indices.store.throttle.max_bytes_per_sec</code>:<br>最大IO吞吐量，默认20MB/s，默认只针对merge(合并分段);<br>(ssd的话，可以调大到100～200MB)</p>
<p><code>indices.store.throttle.type</code>:<br>限流类型；<code>none</code>: 不限流, <code>all</code>: 所有磁盘操作; 默认: <code>merge</code>。</p>
<h3 id="磁盘IO优化"><a href="#磁盘IO优化" class="headerlink" title="磁盘IO优化"></a>磁盘IO优化</h3><p>MMAPDirectory:<br>进程请求OS对磁盘文件进行内存映射(初始化开销);<br>也就是mmap，0拷贝，进程挂掉的话，内核会帮忙保存文件;</p>
<p>NIOFDirectory:<br>进程将磁盘文件复制到JVM堆中;<br>也就是常规文件访问，进程挂掉，则文件修改丢失;</p>
<p>相关配置:<br><code>index.store.type</code>: 默认<code>default</code>.<br>mmapfs: 只使用MMapDirectory, 静态索引，物理内存能放下索引时适用;<br>niofs: 只使用NIOFSDirectory,32位系统适用;</p>
<p>可以对单个索引配置，也可以配置成全局。</p>
<h2 id="缓存优化"><a href="#缓存优化" class="headerlink" title="缓存优化"></a>缓存优化</h2><p>ES的缓存分为:</p>
<ol>
<li>分片查询缓存: 缓存查询结果;</li>
<li>OS缓存: 缓存索引到内存;</li>
</ol>
<h2 id="过滤器缓存"><a href="#过滤器缓存" class="headerlink" title="过滤器缓存"></a>过滤器缓存</h2><p>过滤器缓存可以在query时，在filter用<code>_cache</code>:true/false配置。<br>过滤器缓存在各个节点上，内存占比配置:<br><code>indices.cache.filter.size</code>: 默认10%<br>缓存淘汰策略: LRU<br>缓存生存时间:<br><code>index.cache.filter.expire</code>: 30m  (表示30分钟过期)</p>
<p>比较简单的过滤器可以使用bitset来减少内存消耗；<br>比较复杂的过滤器则直接存储查询结果。<br>可以使用bitset的过滤器:<br>term,exists/missing,prefix</p>
<h2 id="字段过滤器"><a href="#字段过滤器" class="headerlink" title="字段过滤器"></a>字段过滤器</h2><p>索引：token -&gt; 文档 ; (又叫倒排索引)<br>字段: 文档 -&gt; 词条; (主要用于排序和聚集)</p>
<p>字段上可以用的过滤器:<br>terms过滤器<br>range过滤器</p>
<h2 id="预热器优化"><a href="#预热器优化" class="headerlink" title="预热器优化"></a>预热器优化</h2><p>可以在索引上定义预热器。<br>即将按日期倒序查询:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">curl -XPUT 'localhost:9200/get-together/event/_warmer/upcoming_events' -d '&#123;</span><br><span class="line">    "sort":[</span><br><span class="line">        &#123;</span><br><span class="line">            "date": &#123;"order":"desc"&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line">&#125;'</span><br></pre></td></tr></table></figure>
<p>即将查询热门分组:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">curl -XPUT 'localhost:9200/get-together/group/_warmer/top_tags' -d '&#123;</span><br><span class="line">    "aggs":&#123;</span><br><span class="line">        "top_tags":&#123;</span><br><span class="line">            "terms":&#123;</span><br><span class="line">                "field": "tags.verbatim"</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;'</span><br></pre></td></tr></table></figure>
<p>可以创建索引的时候直接定义预热器。</p>
<h2 id="脚本优化"><a href="#脚本优化" class="headerlink" title="脚本优化"></a>脚本优化</h2><p>如果只有数值型的操作，可以考虑用lucene表达式代替脚本；<br>性能：<br>不用脚本&gt;lucene表达式（js）&gt;java脚本&gt;其他脚本</p>
<h2 id="ES查询过程"><a href="#ES查询过程" class="headerlink" title="ES查询过程"></a>ES查询过程</h2><h3 id="topN查询"><a href="#topN查询" class="headerlink" title="topN查询"></a>topN查询</h3><p>比如取10个结果:<br>1.每个分片取得分前10的;<br>2.合并所有分片的结果(归并排序);</p>
<p>因此得分是在每个分片上算的（分片内得分）</p>
<h3 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h3><p>{<br>“from”: 400<br>,”size”: 100<br>}<br>这种需要400～500的结果，但实际会取前500个，然后扔掉前400个。</p>
<p>如果是顺序翻页需求，可以用scroll类型查询优化，查询的时候传递一个scroll=1m的参数，让ES等一分钟，以准备接收下一次翻页。这种情况下，每次ES都会返回一个scrollId。</p>
<h1 id="集群管理"><a href="#集群管理" class="headerlink" title="集群管理"></a>集群管理</h1><h2 id="模版"><a href="#模版" class="headerlink" title="模版"></a>模版</h2><p>可以配置某个前缀的索引都应用某个配置模版。<br>（比如模版里定义别名）</p>
<h3 id="多个模版的合并"><a href="#多个模版的合并" class="headerlink" title="多个模版的合并"></a>多个模版的合并</h3><p>多个模版可能匹配到同一个索引，这个时候多个模版的配置会合并。<br>合并的顺序按照order字段，0的先执行，然后1的覆盖0的，依此类推。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://xiaoyue26.github.io/2020/07/22/2020-07/ES%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0/" data-id="ckcy58mud0000msamcfgubxqi" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/elasticsearch/" rel="tag">elasticsearch</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/es/" rel="tag">es</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-2020-06/tcp调优" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/06/19/2020-06/tcp%E8%B0%83%E4%BC%98/" class="article-date">
  <time datetime="2020-06-19T09:44:55.000Z" itemprop="datePublished">2020-06-19</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/tcp/">tcp</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/06/19/2020-06/tcp%E8%B0%83%E4%BC%98/">tcp调优</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <h1 id="原理：linux如何处理新的tcp连接"><a href="#原理：linux如何处理新的tcp连接" class="headerlink" title="原理：linux如何处理新的tcp连接"></a>原理：linux如何处理新的tcp连接</h1><ol>
<li>触发时机: 客户端: 发起一个tcp连接（SYN）;</li>
</ol>
<p>服务端:<br>(相关参数: <code>net.ipv4.tcp_max_syn_backlog</code>)<br>TCP模块查看<code>max_syn_backlog</code>是否超阈值;<br>超阈值的话: 根据<code>tcp_abort_on_overflow</code>是丢弃还是reset;<br>未超的话: 放到半连接队列;</p>
<ol start="2">
<li>触发时机: 客户端: 回复服务端ACK<br>服务端:<br>(相关参数: <code>net.core.somaxconn</code>)<br>完全建立连接: 放到全连接队列; </li>
</ol>
<h2 id="内核调优"><a href="#内核调优" class="headerlink" title="内核调优"></a>内核调优</h2><ol>
<li><code>vim /etc/sysctl.conf</code> 在末尾添加：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">net.core.somaxconn &#x3D; 16384 # ESTABLISHED的连接队列最大</span><br><span class="line">net.ipv4.tcp_max_syn_backlog &#x3D; 65536 # SYN半开连接队列最大</span><br><span class="line">net.core.wmem_default&#x3D;8388608 # 默认发送窗口的字节大小,还有一个最大值的参数</span><br><span class="line">net.core.rmem_default&#x3D;8388608 # 默认接收窗口的字节大小,还有一个最大值的参数</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p><code>sysctl -p /etc/sysctl.conf</code></p>
</li>
<li><p><code>echo &quot;1&quot; &gt; /proc/sys/net/ipv4/tcp_abort_on_overflow</code> # 满了以后显式发送RST包给客户端</p>
</li>
<li><p>修改nginx配置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">listen 80 backlog&#x3D;16384;</span><br><span class="line"></span><br><span class="line">listen 443 backlog&#x3D;16384;</span><br></pre></td></tr></table></figure>
<p>就是server里面的配置，在80 后面加上backlog=16384</p>
</li>
<li><p><code>cd tnginx_1_0_0-1.0/bin/nginx -s reload</code></p>
</li>
<li><p>重启api服务(如果有)</p>
</li>
<li><p>确认配置生效 <code>ss -lnt</code></p>
</li>
</ol>
<h1 id="相关内核commit"><a href="#相关内核commit" class="headerlink" title="相关内核commit"></a>相关内核commit</h1><p>since Linux 5.4 it was increased to 4096 <a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=19f92a030ca6d772ab44b22ee6a01378a8cb32d4" target="_blank" rel="noopener">https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=19f92a030ca6d772ab44b22ee6a01378a8cb32d4</a></p>
<p>查看现有配置:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sysctl -a  | grep somaxconn</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://xiaoyue26.github.io/2020/06/19/2020-06/tcp%E8%B0%83%E4%BC%98/" data-id="ckbm1ztus0000jfam43bahz0n" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/tcp/" rel="tag">tcp</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-2020-06/jdk11下g1收集器使用" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/06/15/2020-06/jdk11%E4%B8%8Bg1%E6%94%B6%E9%9B%86%E5%99%A8%E4%BD%BF%E7%94%A8/" class="article-date">
  <time datetime="2020-06-15T01:37:21.000Z" itemprop="datePublished">2020-06-15</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/java/">java</a>►<a class="article-category-link" href="/categories/java/jvm/">jvm</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/06/15/2020-06/jdk11%E4%B8%8Bg1%E6%94%B6%E9%9B%86%E5%99%A8%E4%BD%BF%E7%94%A8/">jdk11下g1收集器使用</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <h1 id="WHAT-g1是什么"><a href="#WHAT-g1是什么" class="headerlink" title="WHAT: g1是什么?"></a>WHAT: g1是什么?</h1><p>g1是一个jdk9推荐默认使用的垃圾收集器。</p>
<h1 id="WHY-为什么要使用g1"><a href="#WHY-为什么要使用g1" class="headerlink" title="WHY: 为什么要使用g1"></a>WHY: 为什么要使用g1</h1><p>主要优点：收集高吞吐、没有内存碎片、收集时间可控。</p>
<p>G1出来之前，OLTP应用之前一般使用CMS收集器，达到暂停时间短的效果。<br>CMS: <a href="https://www.jianshu.com/p/fed80fdba376" target="_blank" rel="noopener">https://www.jianshu.com/p/fed80fdba376</a></p>
<p>CMS收集器的缺点:<br>1.有内存碎片: 标记清理算法容易留下碎片，可以用参数在几次full gc以后进行一次压缩；<code>-XX:CMSFullGCsBeforeCompaction=0</code>: 每次都压缩;<br>2.full gc风险(foreground): 业务线程请求分配内存，但是内存不够了，于是可能触发一次CMS GC，这个过程就必须要等待内存分配成功后业务线程才能继续往下面走，因此整个过程必须STW，所以这种CMS GC整个过程都是STW，相当于full gc了;</p>
<p>cms触发回收: <code>-XX:CMSInitiatingOccupancyFraction=75 -XX:+UseCMSInitiatingOccupancyOnly</code>: old区占75%的时候满足回收条件，检查这个条件的线程:<code>-XX:CMSWaitDuration=2000</code>(默认2秒)。</p>
<p>g1以前的大部分收集器包括cms，都需要程序员手动设置新生代和老生代，g1则会自动调节eden region和old region的占比，以达到设定的暂停时长目标，因此更加智能。<br>g1的目标是取代CMS，因此我们有必要了解一下g1。</p>
<h1 id="HOW-G1怎么工作的、原理"><a href="#HOW-G1怎么工作的、原理" class="headerlink" title="HOW: G1怎么工作的、原理"></a>HOW: G1怎么工作的、原理</h1><img src="/images/2020-06/g1_region.png" class="" width="800" height="1200" title="g1_region">

<p>g1以前的收集器是新生代+老生代的布局，g1则是先分&lt;=2048个region，然后这些region可以用于eden region\old region\humongous region\suvivor region。<br>相当于空间布局更加细致了。</p>
<p>eden: 和以前的新生代eden类似；<br>old: 和以前的老生代类似；<br>humongous：和以前的大对象直接进old区类似；<br>suvivor: 和以前的双缓冲区类似。</p>
<p>g1可以通过统计信息，动态调节eden region和old region的比例，达到设定的暂停时长目标。</p>
<h2 id="G1中的关键过程"><a href="#G1中的关键过程" class="headerlink" title="G1中的关键过程"></a>G1中的关键过程</h2><p>G1垃圾收集器工作过程中有几个关键的过程：<br>1.对象分配: 有内存使用才有内存的回收；<br>2.YGC;<br>3.全局并发标记周期;<br>4.Mixed GC;<br>5.FGC: 具体实现不是G1负责，只是作为兜底使用。</p>
<h3 id="对象分配"><a href="#对象分配" class="headerlink" title="对象分配"></a>对象分配</h3><p>大部分到eden，少部分直接到 Humongous region， 统计时算作old区占用。<br>Humongous: &gt;=0.5*region size的对象会直接分配一个独立的Humongous region。<br>相关参数: <code>-XX:G1HeapRegionSize=16M</code></p>
<h3 id="YGC"><a href="#YGC" class="headerlink" title="YGC"></a>YGC</h3><p>STW, 并发复制，一部分到old（年龄）；  Ygc末尾，重新计算edan区,survive区大小</p>
<h4 id="触发时机"><a href="#触发时机" class="headerlink" title="触发时机"></a>触发时机</h4><p>eden region用完。</p>
<h3 id="全局并发标记周期"><a href="#全局并发标记周期" class="headerlink" title="全局并发标记周期"></a>全局并发标记周期</h3><p>即concurrent marking cycle: 主要为old region/Humongous region回收服务。</p>
<h4 id="1-初始标记"><a href="#1-初始标记" class="headerlink" title="1.初始标记"></a>1.初始标记</h4><p>STW, initial mark,找根；</p>
<p>这个过程需要跟混YGC，在YGC的末尾触发，因为需要STW，而YGC也需要STW，为了减少STW的次数，就让初始标记阶段直接跟混YGC的STW。</p>
<p>理由也很简单，因为正常的服务YGC肯定比较频繁，比OLD区满的频率大多了。而且大部分增大old区的对象都在YGC之后从young区移动到old region，除了直接分配的大对象之外。而大对象毕竟是小概率、低频事件。</p>
<h4 id="2-并发扫描"><a href="#2-并发扫描" class="headerlink" title="2.并发扫描"></a>2.并发扫描</h4><p>并发扫描从新生代出发的直接可达性，完成后才能下一次YGC,不然白扫了</p>
<h4 id="3-并发标记"><a href="#3-并发标记" class="headerlink" title="3.并发标记"></a>3.并发标记</h4><p>扫描间接可达性；</p>
<h4 id="4-最终标记"><a href="#4-最终标记" class="headerlink" title="4.最终标记"></a>4.最终标记</h4><p>STW, 避免浮动垃圾；</p>
<h4 id="5-并发清理"><a href="#5-并发清理" class="headerlink" title="5.并发清理"></a>5.并发清理</h4><p>STW, 回收完全空闲的region。(比如直接回收Humongous region)<br>这个过程不会产生碎片，因为是整个region回收的。<br>并不是完全空闲的region的处理: 交给Mixed GC。</p>
<h3 id="Mixed-GC"><a href="#Mixed-GC" class="headerlink" title="Mixed GC"></a>Mixed GC</h3><h4 id="触发时机-1"><a href="#触发时机-1" class="headerlink" title="触发时机"></a>触发时机</h4><p>标记阶段结束后，可以知道old region有多少可以被回收；YGC之后,看浪费占比(可回收未回收),太浪费的话就MixedGC;</p>
<p>相关参数:</p>
<ol>
<li><code>G1HeapWastePercent=10</code>: YGC之后,看浪费占比(可回收未回收),太浪费的话就MixedGC;</li>
<li><code>G1MixedGCLiveThresholdPercent=85</code>: 超过85%占用率的region就不加入CSet了，性价比太低;</li>
<li><code>G1MixedGCCountTarget=8</code>: 连续可以进行多少次MixedGC;</li>
<li><code>G1OldCSetRegionThresholdPercent</code>: 一次Mixed最多选多少region进CSet;</li>
</ol>
<h3 id="FGC"><a href="#FGC" class="headerlink" title="FGC"></a>FGC</h3><p>G1不直接提供full gc，&lt; jdk10是调的serial old，我们用的jdk11是调并发的收集，都需要STW。</p>
<h4 id="触发时机-2"><a href="#触发时机-2" class="headerlink" title="触发时机"></a>触发时机</h4><p>由于标记阶段不能进行Mixed GC，所以如果标记阶段堆被塞满了，就会触发FGC。(一般是非STW阶段,也就是第二阶段并发扫描和第三阶段并发标记，因为STW阶段不会分配新的对象)</p>
<h3 id="Evacuation"><a href="#Evacuation" class="headerlink" title="Evacuation"></a>Evacuation</h3><p>非完全空闲的region的处理，都是压缩复制到另一个region，G1称这个为Evacuation。（翻译过来就是对象的疏散）</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>从上述过程可以总结占用、增多各种region的事件；回收、减少各种region的事件。<br>eden region增多: 普通小对象的分配;<br>eden region的减少: YGC;<br>Humongous region的增多: 大对象的分配，直接进H region;<br>Humongous region的减少: concurrent marking cycle的最后阶段（并发清理），回收完全空闲的region;<br>old region的增多: YGC末尾，随着对象年龄晋级到old region;<br>old region的减少: concurrent marking cycle的最后阶段（并发清理），回收完全空闲的region; 以及Mixed GC: 回收部分占用的region。</p>
<h1 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h1><h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><p>容器CPU: 4<br>容器内存: 8G<br>JDK: 11<br>JVM参数: 未设置</p>
<h2 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h2><p>通过命令:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nohup jstat -gcutil &lt;pid&gt; \</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> gcutil.log 2&gt;&amp;1 &amp; <span class="built_in">echo</span> $! &gt; gcutil.pid</span></span><br></pre></td></tr></table></figure>
<p>发现old区增长比young区快。</p>
<p>执行命令:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmap -histo:live &lt;pid&gt; | head</span><br></pre></td></tr></table></figure>
<p>触发FGC、STW，内存占用突然掉下来。</p>
<p>观察内存自然回收前一刻的内存占用，可以看到old区占用大概为43.49%。而默认的参数<code>-XX:InitiatingHeapOccupancyPercent=45</code>。<br>G1这里的<code>InitiatingHeapOccupancyPercent</code>指的是old区占整个堆的比例，和CMS的不同。也有资料认为这个是指整个堆的占用/总大小，但其实统计的时候都统计的是YGC以后的堆的占用/总大小，<br>也就等于old区的使用/整个堆的大小。</p>
<p>所以这种情况下young区增长比old区快的原因是大对象的分配。<br>大对象region的清理依赖标记阶段最后的清理，而标记阶段的初始mark依赖YGC的末尾。</p>
<p>最后因为没有几乎YGC，所以大对象很容易就一直堆积着、而且由于young区太大了，old区的占用很高也触发不了标记阈值。</p>
<h2 id="调优参数"><a href="#调优参数" class="headerlink" title="调优参数"></a>调优参数</h2><p>如果要维持old区在gcutil视角下不超过90%，可以通过简单的计算，将InitiatingHeapOccupancyPercent调整为37%。（仅当前case）</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Xmx4096M -Xms4096M -XX:G1HeapRegionSize=8M -XX:MetaspaceSize=512M -XX:MaxMetaspaceSize=512M -Xlog:gc*:gc.log -XX:InitiatingHeapOccupancyPercent=37</span><br></pre></td></tr></table></figure>

<img src="/images/2020-06/gcutil2.png" class="" width="800" height="1200" title="gcutil2">

<p>调整以后old区维持98%, YGC次数增多。<br>但这个参数仅第一次有用，因为之后G1会根据暂停时间目标来调整不同region的比例，因此并不能长期解决。</p>
<h3 id="调参2"><a href="#调参2" class="headerlink" title="调参2"></a>调参2</h3><p>我们这个case因为是空转服务，而且Eden区基本不使用，光怼Old区了（大对象）。可以通过调节大对象阈值，让Eden区增长速度稍微快于Old区(IHOP为45%)。</p>
<p>相同参数: <code>-Xmx4096M -Xms4096M -XX:MetaspaceSize=512M -XX:MaxMetaspaceSize=512M -Xlog:gc*:gc.log</code> </p>
<p>各种姿势的结果：</p>
<table>
<thead>
<tr>
<th>思路</th>
<th>gc耗时(ms)</th>
<th>YGC</th>
<th>Mixed GC</th>
<th>FGC</th>
<th>差异参数</th>
</tr>
</thead>
<tbody><tr>
<td>拒绝大对象</td>
<td>2260</td>
<td>31</td>
<td>0</td>
<td>0</td>
<td>-XX:G1HeapRegionSize=16M -XX:InitiatingHeapOccupancyPercent=37</td>
</tr>
<tr>
<td>拒绝大对象</td>
<td>5390</td>
<td>52</td>
<td>0</td>
<td>0</td>
<td>-XX:G1HeapRegionSize=32M -XX:InitiatingHeapOccupancyPercent=37</td>
</tr>
<tr>
<td>停顿小</td>
<td>5688</td>
<td>128</td>
<td>0</td>
<td>0</td>
<td>-XX:G1HeapRegionSize=8M -XX:InitiatingHeapOccupancyPercent=37 -XX:MaxGCPauseMillis=50</td>
</tr>
<tr>
<td>不让调IHOP</td>
<td>3507</td>
<td>128</td>
<td>1</td>
<td>0</td>
<td>-XX:G1HeapRegionSize=8M -XX:InitiatingHeapOccupancyPercent=37 -XX:-G1UseAdaptiveIHOP</td>
</tr>
</tbody></table>
<p>下面解释4个试验结果：</p>
<p>结果1： 16M的region，所以大于8M的对象会分配一个Humongous region，否则在edan区分配，由于Humongous region也在统计中算到了old region里头，所以我们这样操作以后会减少统计结果中old区的占用率。16M配置下，看gc.log已经完全没有了Humongous region，因此这样配置就肯定不会触发报警了。</p>
<p>结果2：32M的region，类似于16M的，0个Humongous region，但由于region比较大，碎片多，比较浪费, YGC比较多，gc耗时比较大；</p>
<p>结果3：由于G1会动态调整young区\old区的大小比例，young在5%~60%之间调整，如果young在60%，那么即使old区填满了也才40%，无法达到IHOP，也就无法通过IHOP触发标记阶段，只能通过YGC触发；因此这里我们把自动调整的关掉，这样young区就不会太大，就能触发IHOP的阈值了。这种情况下由于region大小没有调大，YGC次数没有太大变化；而由于没有使用自动调整IHOP，old区很满以后会触发标记阶段，然后G1发现回收young以后，浪费的空间仍然大于G1HeapWastePercent参数，于是就进行Mixed GC，回收old区。所以这种配置下有1次MixedGC。</p>
<p>结果4：这个思路也比较类似思路3，由于G1是根据停顿时间来调整young区/old区大小的，我们把停顿时间设定得超小，它就会把young区变小已达到停顿时间的要求，同时也会更频繁得YGC，Humongous可以在标记阶段的末尾得到清理，所以这种配置下也不会触发Old区的长期占用高的报警。同时由于停顿时间超小，YGC次数变得很高，总耗时也很高。</p>
<p>以上四种配置，真正在线上只有配置1是实用的。因此如果理解了G1的过程，其实调参可以只调很少。</p>
<h2 id="其他-Metaspace"><a href="#其他-Metaspace" class="headerlink" title="其他: Metaspace"></a>其他: Metaspace</h2><p>除了上述区域，还有一个元数据区域。通过<code>jstat -gcutil</code>可以看到它的占用率一般是在98.1%左右，比较高。但实际上元数据区的占用率是越高越高的，因为它的实际含义类似于(1-碎片率)，占用率98.1%，差不多相当于碎片率是1.9%。因为程序工作一段时间后，metaspace基本就不怎么增长了，所以基本不用我们操心，最多只需要将初始metaspace的大小设大一点，避免它增长到稳定之前触发full gc。可以先启动一次，看看稳定的时候metaspace的大小，然后向上取2的幂，设置大小。不要以为把这个值设大2倍，占用率会下降一半，metaspace是用多少申请多少的，所以即使设大了也不会影响占用率的。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:MetaspaceSize=512M -XX:MaxMetaspaceSize=512M</span><br></pre></td></tr></table></figure>
<p>元数据相关参见: <a href="http://lovestblog.cn/blog/2016/10/29/metaspace/" target="_blank" rel="noopener">http://lovestblog.cn/blog/2016/10/29/metaspace/</a></p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://www.oracle.com/cn/technical-resources/articles/java/g1gc.html" target="_blank" rel="noopener">https://www.oracle.com/cn/technical-resources/articles/java/g1gc.html</a><br><a href="https://www.jianshu.com/p/0f1f5adffdc1" target="_blank" rel="noopener">https://www.jianshu.com/p/0f1f5adffdc1</a><br><a href="https://tech.meituan.com/2016/09/23/g1.html" target="_blank" rel="noopener">https://tech.meituan.com/2016/09/23/g1.html</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://xiaoyue26.github.io/2020/06/15/2020-06/jdk11%E4%B8%8Bg1%E6%94%B6%E9%9B%86%E5%99%A8%E4%BD%BF%E7%94%A8/" data-id="ckbfu7dbm00009mam2tyihheu" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/" rel="tag">java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/jvm/" rel="tag">jvm</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-2020-06/mysql可重复读下用for-update导致的死锁" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/06/08/2020-06/mysql%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB%E4%B8%8B%E7%94%A8for-update%E5%AF%BC%E8%87%B4%E7%9A%84%E6%AD%BB%E9%94%81/" class="article-date">
  <time datetime="2020-06-08T01:45:39.000Z" itemprop="datePublished">2020-06-08</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/mysql/">mysql</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/06/08/2020-06/mysql%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB%E4%B8%8B%E7%94%A8for-update%E5%AF%BC%E8%87%B4%E7%9A%84%E6%AD%BB%E9%94%81/">mysql可重复读下用for update导致的死锁</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>试图用代码(JVM进程)来维持某列的唯一性。</p>
<h1 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h1><p>以下代码在可重复读隔离级别下执行，表中原来只有1~10的rank。假如A、B两个事务同时试图插入rank为21和22的rank；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createBannerDeadlock</span><span class="params">(Banner banner)</span> </span>&#123;</span><br><span class="line">        banner.recordCreate();</span><br><span class="line">        List&lt;Banner&gt; rankList = cscCenterBannerDAO.selectForUpdate(banner.getRank());</span><br><span class="line">        <span class="comment">// 无记录,A占据间隙锁rank(10,+), B占据间隙锁 (10,+)，gap锁之间不互斥</span></span><br><span class="line">        <span class="keyword">if</span> (!rankList.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"记录已存在"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            logger.info(<span class="string">"睡5秒钟"</span>);</span><br><span class="line">            Thread.sleep(MILLIS);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"中断"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        logger.info(<span class="string">"开始插入: &#123;&#125;"</span>, System.currentTimeMillis());</span><br><span class="line">        cscCenterBannerDAO.insert(banner); <span class="comment">// 都申请插入意向锁, 都需要等待别人的间隙锁释放；死锁</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>1.如果rank上没索引:<br>两个事务第一个for update就会互相阻塞(锁全表)，串行执行，没有死锁，两个插入都成功；<br>2.如果rank上有索引(普通索引或者唯一索引):<br>两个事务第一个for update不会互相阻塞(锁区间10~正无穷)，并行执行，有死锁，到最后真正插入的时候，两者都需要插入意向锁，然后都等待对方的gap锁释放，死锁；等待很久以后，一个成功一个失败(一个事务被回滚)；</p>
<p>死锁异常:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Deadlock found when trying to get lock; <span class="keyword">try</span> restarting transaction;</span><br></pre></td></tr></table></figure>


<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>两个原因导致了有索引的时候反而会死锁:<br>1.select for update的间隙锁之间不互斥,两个事务都能获得gap锁;<br>2.插入意向锁需要等待gap锁释放;</p>
<p>间隙锁相关: <a href="http://xiaoyue26.github.io/2018/05/26/2018-05/MVCC%E4%B8%8E%E9%97%B4%E9%9A%99%E9%94%81-mysql%E6%8B%BE%E9%81%97/">http://xiaoyue26.github.io/2018/05/26/2018-05/MVCC%E4%B8%8E%E9%97%B4%E9%9A%99%E9%94%81-mysql%E6%8B%BE%E9%81%97/</a><br>意向锁相关: <a href="http://xiaoyue26.github.io/2018/12/24/2018-12/mysql%E6%84%8F%E5%90%91%E9%94%81/">http://xiaoyue26.github.io/2018/12/24/2018-12/mysql%E6%84%8F%E5%90%91%E9%94%81/</a></p>
<h2 id="select-for-update的结果"><a href="#select-for-update的结果" class="headerlink" title="select for update的结果"></a>select for update的结果</h2><p>即使是同样的语句，也有可能有不同的加锁结果。<br>1.如果有唯一索引,命中了唯一记录: 行锁,互斥锁;<br>2.如果有唯一索引,没命中: gap锁，另一个事务也可以获得这个gap锁，但是不能插入数据；(后续有死锁可能)<br>3.如果有普通索引,命中了记录: 行锁+gap锁;(后续有死锁可能)<br>4.如果有普通索引,没有命中记录: gap锁,和情况2相同;(后续有死锁可能)<br>5.如果没有索引,直接锁全表，互斥，直接阻塞别的事务。（mysql的行锁是依赖索引的，这一点和oracle锁在数据块上不同；<br>因此如果没有索引或者没有用上索引，mysql就只能加表锁了。）</p>
<p>可见如果where条件没有命中记录的时候,如果有索引，反而可能有死锁风险。<br>除了select for update,其他进行当前读的语句(如delete)也可以获得gap锁，因此也有同样的烦恼。</p>
<p>那么都有哪些语句能获得gap锁呢？</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-locking.html#innodb-gap-locks" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/5.7/en/innodb-locking.html#innodb-gap-locks</a></p>
<h2 id="gap锁"><a href="#gap锁" class="headerlink" title="gap锁"></a>gap锁</h2><p>首先当然要可重复读和串行读才有gap锁。<br>然后根据上面的参考资料，gap锁只有一个目标:<br>就是防止别的事务在这个区间插入数据。</p>
<p>因此不同事务可以获得同一个区间的gap锁，因为这与上述目标并不冲突。两个事务可以获得这个区间的gap-S锁，gap-X锁，都可以。这一点和意向锁有点类似，只不过意向锁是加在表上的，gap锁是加在区间上的。</p>
<p>gap-S锁和gap-X锁没有区别。(因此select in share mode和select for update获得的gap锁本质是一样的，想要无锁读，就直接用select进行快照读。)</p>
<p>select in share mode/select for update/update/delete这4种语句是可能获取gap锁的。因此这4种当前读如果没有命中记录，而且又用到了索引，就会给死锁埋下风险。</p>
<h2 id="RC的优势"><a href="#RC的优势" class="headerlink" title="RC的优势"></a>RC的优势</h2><p>RC下: 扫描过但不匹配的记录不会加锁，或者是先加锁再释放，即semi-consistent read；<br>RR下: 扫描过记录都要加锁。</p>
<h2 id="RC的缺点"><a href="#RC的缺点" class="headerlink" title="RC的缺点"></a>RC的缺点</h2><p>1.RC有幻读;<br>2.RC需要搭配row模式binlog;</p>
<p>mysql5.0以前的statement模式binlog和RC搭配有bug，因此为了兼容性，一般默认隔离级别RR，binlog模式row。</p>
<p>因此:<br>RC搭配row模式binlog;<br>RR搭配statement模式binlog;</p>
<h2 id="RC和RR读的区别"><a href="#RC和RR读的区别" class="headerlink" title="RC和RR读的区别"></a>RC和RR读的区别</h2><blockquote>
<p> RR下，事务在第一个Read操作时，会建立Read View<br>RC下，事务在每次Read操作时，都会建立Read View</p>
</blockquote>
<p>所以:<br>读已提交: 总是读到最新提交的数据;<br>可重复读: 总是读到和第一次读的时候相同的数据,与事务开始时间无关。</p>
<h2 id="innodb的7种锁类型"><a href="#innodb的7种锁类型" class="headerlink" title="innodb的7种锁类型"></a>innodb的7种锁类型</h2><p>参考这里: <a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-locking.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/5.7/en/innodb-locking.html</a></p>
<p>行的读锁 S<br>行的写锁 X<br>表级：读意向锁 IS<br>表级：写意向锁 IX<br>(意向锁只影响和辅助表级操作，毕竟行级操作直接定位到具体行了，不需要意向锁的帮助。)<br>记录锁: Record Lock: 在索引上加锁。<br>gap锁: 区间内阻止插入的锁,当前读可能触发。<br>next-key锁: 记录锁+gap锁；<br>插入意向锁: 同区间insert可以并发,只要不重复;<br>自增锁: 如果是严格增模式,自增id会导致事务串行;</p>
<h2 id="查看当前锁的信息"><a href="#查看当前锁的信息" class="headerlink" title="查看当前锁的信息"></a>查看当前锁的信息</h2><p>InnoDB整体状态，其中包括锁的情况:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">engine</span> <span class="keyword">innodb</span> <span class="keyword">status</span></span><br></pre></td></tr></table></figure>
<p>只看锁信息:<br>mysql8.0.1以前:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 有事务在等的锁:</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> information_schema.innodb_locks;</span><br></pre></td></tr></table></figure>
<p>mysql8.0.1以后:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 所有的锁:</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> performance_schema.data_locks</span><br></pre></td></tr></table></figure>
<p>两者字段的对应关系: <a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-locks-table.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/8.0/en/innodb-locks-table.html</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://xiaoyue26.github.io/2020/06/08/2020-06/mysql%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB%E4%B8%8B%E7%94%A8for-update%E5%AF%BC%E8%87%B4%E7%9A%84%E6%AD%BB%E9%94%81/" data-id="ckb5u4aje0000rzamgw23h290" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/mysql/" rel="tag">mysql</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-2020-05/BeanCopier测评报告" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/05/05/2020-05/BeanCopier%E6%B5%8B%E8%AF%84%E6%8A%A5%E5%91%8A/" class="article-date">
  <time datetime="2020-05-05T09:38:53.000Z" itemprop="datePublished">2020-05-05</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/java/">java</a>►<a class="article-category-link" href="/categories/java/spring/">spring</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/05/05/2020-05/BeanCopier%E6%B5%8B%E8%AF%84%E6%8A%A5%E5%91%8A/">BeanCopier测评报告</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <h1 id="What-BeanCopier是什么"><a href="#What-BeanCopier是什么" class="headerlink" title="What: BeanCopier是什么?"></a>What: BeanCopier是什么?</h1><p>本文讨论的<code>BeanCopier</code>具体指的是:<br><code>org.springframework.cglib.beans.BeanCopier</code><br>, 此外用于对比的<code>BeanUtils</code>指的是:<br><code>org.springframework.beans.BeanUtils</code></p>
<p>其中spring使用<code>5.1.1.release</code>,所以cglib版本为<code>3.2.10</code>.</p>
<p>BeanCopier和BeanUtils都能用于对象之间浅拷贝成员字段。</p>
<h1 id="Why-背景"><a href="#Why-背景" class="headerlink" title="Why: 背景"></a>Why: 背景</h1><p>这里引用一下网上的说法:</p>
<blockquote>
<p>在做业务的时候，我们有时为了隔离变化，会将DAO查询出来的Entity，和对外提供的DTO隔离开来。大概90%的时候，它们的结构都是类似的，但是我们很不喜欢写很多冗长的b.setF1(a.getF1())这样的代码，于是我们需要BeanCopier来帮助我们。选择Cglib的BeanCopier进行Bean拷贝的理由是，其性能要比Spring的BeanUtils，Apache的BeanUtils和PropertyUtils要好很多，尤其是数据量比较大的情况下。</p>
</blockquote>
<h1 id="性能测评"><a href="#性能测评" class="headerlink" title="性能测评"></a>性能测评</h1><p>参考网上一些benchmark，如<a href="https://juejin.im/post/5dc2b293e51d456e65283e61" target="_blank" rel="noopener">https://juejin.im/post/5dc2b293e51d456e65283e61</a><br>beanCopier能比beanUtils快30～45倍。</p>
<table>
<thead>
<tr>
<th>场景</th>
<th>耗时</th>
<th>原理</th>
</tr>
</thead>
<tbody><tr>
<td>直接使用get&amp;set方法</td>
<td>22ms</td>
<td>直接调用</td>
</tr>
<tr>
<td>使用BeanCopiers（不使用Converter）</td>
<td>22ms</td>
<td>修改字节码</td>
</tr>
<tr>
<td>使用BeanCopiers（使用Converter）</td>
<td>249ms</td>
<td>修改字节码</td>
</tr>
<tr>
<td>使用BeanUtils</td>
<td>12983ms</td>
<td>反射</td>
</tr>
<tr>
<td>使用PropertyUtils（不使用Converter）</td>
<td>3922ms</td>
<td>反射</td>
</tr>
</tbody></table>
<p>因此如果我们不使用类型转换，使用BeanCopiers几乎没有性能损耗。这是因为cglib修改生成的字节码和get&amp;set几乎是一样的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MA</span>$$<span class="title">BeanCopierByCGLIB</span>$$<span class="title">d9c04262</span> <span class="keyword">extends</span> <span class="title">BeanCopier</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> MA$$BeanCopierByCGLIB$$d9c04262() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">copy</span><span class="params">(Object var1, Object var2, Converter var3)</span> </span>&#123;</span><br><span class="line">        MA var10000 = (MA)var2;</span><br><span class="line">        MA var10001 = (MA)var1;</span><br><span class="line">        var10000.setBooleanP(((MA)var1).isBooleanP());</span><br><span class="line">        var10000.setByteP(var10001.getByteP());</span><br><span class="line">        var10000.setCharP(var10001.getCharP());</span><br><span class="line">        var10000.setDoubleP(var10001.getDoubleP());</span><br><span class="line">        var10000.setFloatP(var10001.getFloatP());</span><br><span class="line">        var10000.setId(var10001.getId());</span><br><span class="line">        var10000.setIntP(var10001.getIntP());</span><br><span class="line">        var10000.setLongP(var10001.getLongP());</span><br><span class="line">        var10000.setName(var10001.getName());</span><br><span class="line">        var10000.setShortP(var10001.getShortP());</span><br><span class="line">        var10000.setStringP(var10001.getStringP());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="自测"><a href="#自测" class="headerlink" title="自测"></a>自测</h2><table>
<thead>
<tr>
<th></th>
<th>1kw次</th>
<th>1亿次</th>
</tr>
</thead>
<tbody><tr>
<td>beanUtils</td>
<td>8秒</td>
<td>91秒</td>
</tr>
<tr>
<td>beanCopier（无converter/有缓存）</td>
<td>0.5秒</td>
<td>4秒</td>
</tr>
<tr>
<td>beanCopier（无converter/无缓存）</td>
<td>1.1秒</td>
<td>10秒</td>
</tr>
<tr>
<td>beanCopier（无converter/懒汉式缓存）</td>
<td>3.3秒</td>
<td>30秒</td>
</tr>
</tbody></table>
<p>其中各个测试的相关代码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. beanUtils:</span></span><br><span class="line">BeanUtils.copyProperties(bean, vo);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 2. beanCopier（无converter/有缓存）:</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> BeanCopier MODEL_2_VO = BeanCopier.create(Banner<span class="class">.<span class="keyword">class</span></span></span><br><span class="line"><span class="class">            , <span class="title">BannerVO</span>.<span class="title">class</span>, <span class="title">false</span>)</span>;</span><br><span class="line">copier.copy(bean, vo, <span class="keyword">null</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 3. beanCopier（无converter/无缓存）:</span></span><br><span class="line">copier = BeanCopier.create(Banner<span class="class">.<span class="keyword">class</span>, <span class="title">BannerVO</span>.<span class="title">class</span>, <span class="title">false</span>)</span>;</span><br><span class="line">copier.copy(bean, vo, <span class="keyword">null</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 4. beanCopier（无converter/懒汉式缓存）:</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;String, BeanCopier&gt; MAP = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line">copier = MAP.computeIfAbsent(key, k -&gt; BeanCopier.create(Banner<span class="class">.<span class="keyword">class</span></span></span><br><span class="line"><span class="class">                , <span class="title">BannerVO</span>.<span class="title">class</span>, <span class="title">false</span>))</span>;</span><br><span class="line">copier.copy(bean, vo, <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure>

<h2 id="耗时组成"><a href="#耗时组成" class="headerlink" title="耗时组成"></a>耗时组成</h2><p>BeanUtils耗时组成:(主要为反射)</p>
<img src="/images/2020-05/beanUtils.png" class="" width="800" height="1200" title="beanUtils">

<p>BeanCopier（有缓存、无convert）耗时组成:（主要为调用构造函数(xxx::new)）</p>
<img src="/images/2020-05/beanCopier1.png" class="" width="800" height="1200" title="beanCopier1">

<p>beanCopier（无converter/懒汉式缓存）: 生成key和查询缓存花费了大量的时间，因此第四种写法是得不偿失的。</p>
<img src="/images/2020-05/beanCopier2.png" class="" width="800" height="1200" title="beanCopier2">

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>BeanCopier（无convert、有缓存）: 主要耗时是业务自身的代码(创建对象)，性能最优，可以考虑;</p>
<p>BeanCopier（无convert、无缓存）：不需要预创建，写法简洁，耗时增加不多，可以考虑。</p>
<p>BeanUtils: 反射调用占用了60%的代码，其中还涉及到查询concurrentHashMap中的bean定义，损耗较大。</p>
<h1 id="How-用法"><a href="#How-用法" class="headerlink" title="How: 用法"></a>How: 用法</h1><p>BeanCopier： 只拷贝名称和类型都相同的属性, 基本类型和装箱类型视为不同类型。</p>
<p>如果不符合上述规则，可以自定义converter。（否则可以将converter字段传null）</p>
<p>示例代码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> BeanCopier MODEL_2_VO = BeanCopier.create(Banner<span class="class">.<span class="keyword">class</span></span></span><br><span class="line"><span class="class">            , <span class="title">BannerVO</span>.<span class="title">class</span>, <span class="title">false</span>)</span>; <span class="comment">// 可以复用一个copier，提高一倍速度</span></span><br><span class="line"> </span><br><span class="line">banner = ... ; <span class="comment">// 例如从DAO获取到</span></span><br><span class="line">BannerVO vo = <span class="keyword">new</span> BannerVO();</span><br><span class="line">MODEL_2_VO.copy(b, vo, <span class="keyword">null</span>); <span class="comment">// converter可以直接传null</span></span><br></pre></td></tr></table></figure>


<h2 id="支持功能"><a href="#支持功能" class="headerlink" title="支持功能"></a>支持功能</h2><table>
<thead>
<tr>
<th>情况</th>
<th>Apache BeanUtils</th>
<th>Cglib BeanCopier</th>
<th>Spring BeanUtils</th>
</tr>
</thead>
<tbody><tr>
<td>非public类</td>
<td>不支持</td>
<td>支持</td>
<td>支持</td>
</tr>
<tr>
<td>基本类型与装箱类型，int-&gt;Integer，Integer-&gt;int</td>
<td>支持，可以copy</td>
<td>不支持，不copy</td>
<td>不支持，不copy</td>
</tr>
<tr>
<td>int-&gt;long，long-&gt;int，int-&gt;Long，Integer-&gt;long</td>
<td>不支持</td>
<td>不支持</td>
<td>不支持</td>
</tr>
<tr>
<td>源对象相同属性无get方法</td>
<td>不支持 不copy</td>
<td>不支持 不copy</td>
<td>不支持 不copy</td>
</tr>
<tr>
<td>目标对象相同属性无get方法</td>
<td>支持</td>
<td>不支持</td>
<td>支持</td>
</tr>
<tr>
<td>目标对象相同属性无set方法</td>
<td>不copy，不报错</td>
<td>报错</td>
<td>不copy，不报错</td>
</tr>
<tr>
<td>源对象相同属性无set方法</td>
<td>支持</td>
<td>支持</td>
<td>支持</td>
</tr>
<tr>
<td>目标对象相同属性set方法返回非void</td>
<td>不设置，其他正常属性可以copy</td>
<td>不设置，导致其他属性都无法copy</td>
<td>支持，能够copy</td>
</tr>
<tr>
<td>目标对象多字段</td>
<td>支持</td>
<td>支持</td>
<td>支持</td>
</tr>
<tr>
<td>目标对象少字段</td>
<td>支持</td>
<td>支持</td>
<td>支持</td>
</tr>
</tbody></table>
<p>此外一些较为复杂的情况BeanCopier会进行浅拷贝：</p>
<p>1.属性为对象；</p>
<p>2.属性为List&lt;自定义类&gt;；(注意范型的类型擦除)</p>
<p>当然前提还是源类和目标类中该属性的类型相同，如果不同只能自定义converter了。相应生成的字节码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">copy</span><span class="params">(Object var1, Object var2, Converter var3)</span> </span>&#123;</span><br><span class="line">        BeanB var10000 = (BeanB)var2;</span><br><span class="line">        BeanA var10001 = (BeanA)var1;</span><br><span class="line">        var10000.setAList(((BeanA)var1).getAList());</span><br><span class="line">        var10000.setName(var10001.getName());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>因此不能用BeanCopier做深拷贝。</p>
<p>对应我们考虑的场景，entity和VO之间拷贝数据，由于entity和VO一般不包含集合或者对象，而且没有修改数据的副作用，因此还是可以用的。</p>
<h1 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h1><h2 id="copy方法"><a href="#copy方法" class="headerlink" title="copy方法"></a>copy方法</h2><p>BeanCopier实例的copy方法是线程安全的，因为它是无状态的，相关讨论：<a href="https://cglib-devel.narkive.com/2cqPSUM1/cglib-and-thread-safeness" target="_blank" rel="noopener">https://cglib-devel.narkive.com/2cqPSUM1/cglib-and-thread-safeness</a></p>
<h2 id="create方法"><a href="#create方法" class="headerlink" title="create方法"></a>create方法</h2><p>BeanCopier的create方法底层会缓存生成过的字节码，因此不是无状态的，但是有用到synchronized进行线程安全的保护：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">create</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Class gen = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">synchronized</span> (source) &#123;</span><br><span class="line">        ClassLoader loader = getClassLoader();</span><br><span class="line">        Map cache2 = <span class="keyword">null</span>;</span><br><span class="line">        cache2 = (Map) source.cache.get(loader);</span><br><span class="line">...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/** 3.根据生成类，创建实例并返回 **/</span></span><br><span class="line">    <span class="keyword">return</span> firstInstance(gen);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于BeanCopier的create方法需要查询底层map中的缓存，因此当它生成过的copier非常多的时候，有理由猜测create性能会下降。</p>
<p>1.create方法由悲观锁(synchronized)保护: 并发高时，性能下降；</p>
<p>2.create方法底层有存储: 历史上生成过的copier非常多时，查询性能下降。</p>
<h1 id="类卸载"><a href="#类卸载" class="headerlink" title="类卸载"></a>类卸载</h1><p>资料2显示，BeanCopier增强的字节码缓存由一个两级map保存，第一级为WeakHashMap，第二级为HashMap，线程安全由synchronized保护。</p>
<p>第一级weakHashMap的key是classloader，因此类的卸载当classloader被回收时进行。</p>
<p>但类似的，如果是我们自己封装拷贝函数，也会面临字节码回收、metaspace占用的问题。</p>
<p>个人认为BeanCopier生成的字节码并不比自己手写的多很多，因此推荐使用BeanCopier。</p>
<p>可能的坑:</p>
<p>跨多个classloader的情况：<a href="https://stackoverflow.com/questions/20816197/use-cglib-beancopier-with-multiple-classloaders" target="_blank" rel="noopener">https://stackoverflow.com/questions/20816197/use-cglib-beancopier-with-multiple-classloaders</a></p>
<p>BeanCopier无法判断两个不同classloader加载的同名类是不同的类。所以如果使用不同classloader加载同名类，需要特别考虑。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://www.cnblogs.com/winner-0715/p/10117282.html" target="_blank" rel="noopener">https://www.cnblogs.com/winner-0715/p/10117282.html</a></p>
<p><a href="https://www.jianshu.com/p/f8b892e08d26" target="_blank" rel="noopener">https://www.jianshu.com/p/f8b892e08d26</a></p>
<p><a href="https://www.cnblogs.com/mengdd/p/3594608.html" target="_blank" rel="noopener">https://www.cnblogs.com/mengdd/p/3594608.html</a></p>
<p><a href="https://blog.csdn.net/xihuanyuye/article/details/89887913" target="_blank" rel="noopener">https://blog.csdn.net/xihuanyuye/article/details/89887913</a></p>
<p><a href="https://ningyu1.github.io/blog/20190322/113-object-copy.html" target="_blank" rel="noopener">https://ningyu1.github.io/blog/20190322/113-object-copy.html</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://xiaoyue26.github.io/2020/05/05/2020-05/BeanCopier%E6%B5%8B%E8%AF%84%E6%8A%A5%E5%91%8A/" data-id="ck9tq5tbb0000alamfplm0rxy" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/" rel="tag">java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/spring/" rel="tag">spring</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-2020-04/spring拾遗" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/04/19/2020-04/spring%E6%8B%BE%E9%81%97/" class="article-date">
  <time datetime="2020-04-19T00:58:37.000Z" itemprop="datePublished">2020-04-19</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/java/">java</a>►<a class="article-category-link" href="/categories/java/spring/">spring</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/04/19/2020-04/spring%E6%8B%BE%E9%81%97/">spring拾遗</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <h2 id="初始化顺序"><a href="#初始化顺序" class="headerlink" title="初始化顺序"></a>初始化顺序</h2><p>如果有多个init方法,执行顺序:</p>
<ol>
<li><code>@PostContrust</code>注解标注的方法; </li>
<li>继承<code>InitialBean</code>后自己实现的<code>afterPropertiesSet</code>方法;</li>
<li><code>@Bean(initMethod=&quot;xxx&quot;)</code>注解标注的方法;</li>
</ol>
<h2 id="销毁顺序"><a href="#销毁顺序" class="headerlink" title="销毁顺序"></a>销毁顺序</h2><p>如果有多个销毁方法,执行顺序:(与上面类似)</p>
<ol>
<li><code>@PreDestory</code>注解标注的方法; </li>
<li>继承<code>DisposableBean</code>后自己实现的<code>destory</code>方法;</li>
<li><code>@Bean(destoryMethod=&quot;xxx&quot;)</code>注解标注的方法;</li>
</ol>
<h2 id="spring异常风格"><a href="#spring异常风格" class="headerlink" title="spring异常风格"></a>spring异常风格</h2><p>全都用非受检(<code>runtimeException</code>),代码变得简洁,不需要到处声明异常、或<code>try catch</code>;<br>副作用: 使用者需要自己意识到会抛各种<code>BeanException</code>。</p>
<h2 id="spring偏向锁"><a href="#spring偏向锁" class="headerlink" title="spring偏向锁"></a>spring偏向锁</h2><p>由于需要使用兼容java5,使用了<code>synchronized</code>；<br>因此有偏向锁;<br>因此最好在main线程中初始化<code>applicationContext</code>，避免锁竞争，提高性能。</p>
<h2 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h2><p><code>@Autowired</code> 忽略静态字段;<br>接口回调注入: <code>implement xxxAware接口后</code>,会获得一个方法，可以从中得到、保存注入的对象。</p>
<p>强制的依赖: 构造器注入;<br>可选的依赖: setter注入; 字段注入; （时机、顺序不定、可循环）<br>配置类(声明类): 方法注入; <code>@Bean</code></p>
<p><code>@Autowired</code>的三个步骤:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 元信息解析: dependencyDescription;</span><br><span class="line">2. 依赖查找: beanFactory</span><br><span class="line">3. 依赖注入: 通过反射，注入到原字段。(所以很多都要求有setter)</span><br></pre></td></tr></table></figure>

<h2 id="提前注入"><a href="#提前注入" class="headerlink" title="提前注入"></a>提前注入</h2><p><code>@Bean</code>注解<code>static</code>方法时，会提前注入、加载。</p>
<h2 id="依赖注入和依赖查找来源区别"><a href="#依赖注入和依赖查找来源区别" class="headerlink" title="依赖注入和依赖查找来源区别"></a>依赖注入和依赖查找来源区别</h2><p>依赖注入的来源默认会多4个，多4个spring自己默认注册的:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">beanFactory</span><br><span class="line">applicationContext</span><br><span class="line">applicationEvenListener</span><br><span class="line">ResourceLoader</span><br></pre></td></tr></table></figure>
<p>这4个可以注入，但不能用<code>getBean</code>查找。<br>(只注册，不存到concurrentHashMap`)</p>
<p>大方向上，依赖注入4个来源：</p>
<ol>
<li>托管的bean; <code>definitionBean</code>, 启动以后不能注册; </li>
<li>单例对象; 启动以后还能注册;</li>
<li>手动注册的<code>resolvedDependency</code>;</li>
<li>外部化配置;</li>
</ol>
<h1 id="prototype"><a href="#prototype" class="headerlink" title="prototype"></a>prototype</h1><p>spring不完全管<code>prototype</code>生命周期;<br>只管单例;<br><code>prototype</code>销毁回调不执行,官方提到可以用<code>BeanPostProcessor</code>，但其实只能加初始化完成后的操作(此时大概率不需要销毁)，所以更合理的方式是用一个单例对象管理所有<code>prototype</code>(类似于领域里的<code>agg root</code>),在单例销毁时(实现<code>disposableBean</code>接口)，回调prototype的销毁;</p>
<p>单例和<code>prototype</code>均执行初始化回调。</p>
<h1 id="scope-request"><a href="#scope-request" class="headerlink" title="scope request"></a>scope request</h1><p><code>@RequestScope</code>：<br>request scope对象: Ioc里是单例，但是返回给前端时是不同的。(快速销毁)<br><code>@SessionScope</code>:<br>比request多一个锁。(避免同一个会话的并发)<br>同cookie时（同sessionid），返回前端的对象是相同的。(很长时间以后才销毁)<br>//tomcat默认session超时时间为30分钟，会序列化</p>
<p>jsp搜索范围：page-&gt; request -&gt; session -&gt; servletContext</p>
<p>可以<code>implements Scope</code>自定义scope.</p>
<h1 id="IocBean初始化"><a href="#IocBean初始化" class="headerlink" title="IocBean初始化"></a>IocBean初始化</h1><ol>
<li>beanDefinition加载;</li>
<li>合并父类元信息;</li>
<li>加载类; classLoader;</li>
<li>实例化; <code>instantiation</code> , 赋值: <code>populate</code></li>
<li>返回前可以拦截替换代理对象;</li>
<li>初始化</li>
</ol>
<p>赋值前可以通过<code>postProcessProperties</code>增加需要赋值的字段。虽然名字是<code>post</code>但其实是<code>before</code>.</p>
<h2 id="Aware接口回调顺序"><a href="#Aware接口回调顺序" class="headerlink" title="Aware接口回调顺序"></a>Aware接口回调顺序</h2><ol>
<li>beanNameAware</li>
<li>beanClassLoaderAware</li>
<li>beanfactoryAware</li>
<li>environmentAware</li>
<li>EmbeddedValueResolveAware</li>
<li>ResourceLoaderAware</li>
<li>ApplicationEventPublisherAware</li>
<li>MessageSourceAware</li>
<li>ApplicationcontextAware</li>
</ol>
<p>4-9是applicationContext有的。</p>
<h1 id="bean销毁"><a href="#bean销毁" class="headerlink" title="bean销毁"></a>bean销毁</h1><p>只是容器内销毁，并不意味着gc；</p>
<h1 id="beanPostProcesser"><a href="#beanPostProcesser" class="headerlink" title="beanPostProcesser"></a>beanPostProcesser</h1><p>可以有多个，spring用list存储，所以先添加的先执行(FIFO)。</p>
<h1 id="生命周期末期"><a href="#生命周期末期" class="headerlink" title="生命周期末期"></a>生命周期末期</h1><p>applicationContext关闭<br>gc<br>调用finalized方法</p>
<h1 id="生命周期完整"><a href="#生命周期完整" class="headerlink" title="生命周期完整"></a>生命周期完整</h1><p>注册<br>合并<br>实例化 前中后<br>赋值   前中后<br>aware回调<br>初始化 前中后<br>销毁  前中后<br>gc<br>finalize</p>
<h2 id="工具类"><a href="#工具类" class="headerlink" title="工具类"></a>工具类</h2><p><code>ObjectUtils.nullsafeEquals</code><br><code>StringUtils.xxx</code><br><code>NamedThreadLocal</code></p>
<h2 id="debug技巧"><a href="#debug技巧" class="headerlink" title="debug技巧"></a>debug技巧</h2><p>在底层打断点后，可以看方法调用栈。</p>
<h2 id="spring事务回滚"><a href="#spring事务回滚" class="headerlink" title="spring事务回滚"></a>spring事务回滚</h2><p>受检异常：不回滚；<br>非受检：例如<code>RuntimeException</code>回滚。</p>
<p>类内调用: 无事务(因为不经过代理加强)<br>类外调用：有事务</p>
<p>事务中新开线程： 新线程不能复用原连接(查不到未提交的数据)<br>解决方案：使用事务同步管理器:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TransactionSynchronizationManager.registerSynchronization(<span class="keyword">new</span> TransactionSynchronizationAdapter() &#123;</span><br></pre></td></tr></table></figure>


<h2 id="mysql中立刻触发事务提交的语句"><a href="#mysql中立刻触发事务提交的语句" class="headerlink" title="mysql中立刻触发事务提交的语句"></a>mysql中立刻触发事务提交的语句</h2><p>除了一些元数据操作，得注意新开一个事务也会触发原来的事务立即提交。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">FUNCTION</span>    </span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">PROCEDURE</span>    </span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span>    </span><br><span class="line"><span class="keyword">BEGIN</span>    </span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">DATABASE</span>    </span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span>    </span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span>    </span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span>    </span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span>    </span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">DATABASE</span>    </span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">FUNCTION</span>    </span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">INDEX</span>    </span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">PROCEDURE</span>    </span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span>    </span><br><span class="line"><span class="keyword">UNLOCK</span> <span class="keyword">TABLES</span>    </span><br><span class="line"><span class="keyword">LOAD</span> <span class="keyword">MASTER</span> <span class="keyword">DATA</span>    </span><br><span class="line"><span class="keyword">LOCK</span> <span class="keyword">TABLES</span>    </span><br><span class="line"><span class="keyword">RENAME</span> <span class="keyword">TABLE</span>    </span><br><span class="line"><span class="keyword">TRUNCATE</span> <span class="keyword">TABLE</span>    </span><br><span class="line"><span class="keyword">SET</span> AUTOCOMMIT=<span class="number">1</span>    </span><br><span class="line"><span class="keyword">START</span> <span class="keyword">TRANSACTION</span></span><br></pre></td></tr></table></figure>

<h2 id="BeanFactory初始化"><a href="#BeanFactory初始化" class="headerlink" title="BeanFactory初始化"></a>BeanFactory初始化</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ResouceLoader加载配置信息</span><br><span class="line">BeanDefintionReader解析配置信息，生成一个一个的BeanDefintion</span><br><span class="line">BeanDefintion由BeanDefintionRegistry管理起来</span><br><span class="line">BeanFactoryPostProcessor对配置信息进行加工(也就是处理配置的信息，一般通过PropertyPlaceholderConfigurer来实现)</span><br><span class="line">实例化Bean</span><br><span class="line">如果该Bean配置&#x2F;实现了InstantiationAwareBean，则调用对应的方法</span><br><span class="line">使用BeanWarpper来完成对象之间的属性配置(依赖)</span><br><span class="line">如果该Bean配置&#x2F;实现了Aware接口，则调用对应的方法</span><br><span class="line">如果该Bean配置了BeanPostProcessor的before方法，则调用</span><br><span class="line">如果该Bean配置了init-method或者实现InstantiationBean，则调用对应的方法</span><br><span class="line">如果该Bean配置了BeanPostProcessor的after方法，则调用</span><br><span class="line">将对象放入到HashMap中</span><br><span class="line">最后如果配置了destroy或者DisposableBean的方法，则执行销毁操作</span><br></pre></td></tr></table></figure>



      
    </div>
    <footer class="article-footer">
      <a data-url="http://xiaoyue26.github.io/2020/04/19/2020-04/spring%E6%8B%BE%E9%81%97/" data-id="ck96cxpqm00ljmaam3dze2ck1" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/" rel="tag">java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/spring/" rel="tag">spring</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-2020-03/利用UTF-8编码的特性进行优化" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/26/2020-03/%E5%88%A9%E7%94%A8UTF-8%E7%BC%96%E7%A0%81%E7%9A%84%E7%89%B9%E6%80%A7%E8%BF%9B%E8%A1%8C%E4%BC%98%E5%8C%96/" class="article-date">
  <time datetime="2020-03-26T08:29:11.000Z" itemprop="datePublished">2020-03-26</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/java/">java</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/26/2020-03/%E5%88%A9%E7%94%A8UTF-8%E7%BC%96%E7%A0%81%E7%9A%84%E7%89%B9%E6%80%A7%E8%BF%9B%E8%A1%8C%E4%BC%98%E5%8C%96/">利用UTF-8编码的特性进行优化</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <h1 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h1><p>做性能优化的时候，画出火焰图（<code>async-profiler</code>）来看，发现耗时很多花在了<code>utf-8</code>的编码解码上了,所以需要思考一下如何优化这部分。<br>(采样30秒:<code>./profiler.sh -d 30 -f profile.svg [pid]</code>)</p>
<img src="/images/2020-03/fire1.png" class="" width="800" height="1200" title="fire1">
<img src="/images/2020-03/fire2.png" class="" width="800" height="1200" title="fire2">

<h1 id="What-什么是UTF-8编码"><a href="#What-什么是UTF-8编码" class="headerlink" title="What: 什么是UTF-8编码"></a>What: 什么是UTF-8编码</h1><p>UTF-8编码就是对于字节流(一串二进制)的解释，解释成字符串。<br>类似的还有: ASCII编码，就是把1B字节解释成128种字符。(范围是0-127,包括英文字母、数字)</p>
<p>UTF-8编码下，一个字符可以由1B~4B二进制组成。</p>
<h2 id="UTF-8格式"><a href="#UTF-8格式" class="headerlink" title="UTF-8格式"></a>UTF-8格式</h2><p>合法的格式包括4种:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0xxxxxxx 				                0-127 (ASCII)</span><br><span class="line">110xxxxx 10xxxxxx 			            128-2047</span><br><span class="line">1110xxxx 10xxxxxx 10xxxxxx              2048-65535</span><br><span class="line">11110xxx 10xxxxxx 10xxxxxx 10xxxxxx 	65536-0x10ffff</span><br></pre></td></tr></table></figure>
<p>它的首字节的前缀码会指出这个字符会占用多少字节。<br>合法的前缀码有4种:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0X:    占1B;</span><br><span class="line">110X:  占2B;</span><br><span class="line">1110:  占3B;</span><br><span class="line">11110: 占4B;</span><br></pre></td></tr></table></figure>
<p>显然还有一种<code>10X</code>不在其中。这是因为<code>10X</code>不属于合法的首字节的前缀码，只能在第2、3、4个字节中出现。如果我们随机选择<code>utf-8</code>二进制流中的一个字节来看的话，可能的情况有5种:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0X:     首字节,这个字符总长1B</span><br><span class="line">10X:    非首字节.</span><br><span class="line">110X:   首字节,这个字符总长2B</span><br><span class="line">1110X:  首字节,这个字符总长3B</span><br><span class="line">11110X: 首字节,这个字符总长4B</span><br></pre></td></tr></table></figure>

<h3 id="utf-8特性"><a href="#utf-8特性" class="headerlink" title="utf-8特性"></a>utf-8特性</h3><ol>
<li>兼容性:  0-127和<code>ascii</code>码是一样的,而且在其他字节不可能出现,因此和<code>ascii</code>完全兼容;</li>
<li>自同步性: 基于上面讨论的前缀码特性,从任意位置开始读,可以定位到合法位置开始解码。</li>
</ol>
<h3 id="优化方案"><a href="#优化方案" class="headerlink" title="优化方案"></a>优化方案</h3><p>基于上述两点洞察，再考虑到我此次工作只需要解析字母数字部分，再直接分发二进制流即可。因此可以做两点优化:</p>
<ol>
<li>读取时: 不解码,直接理解二进制的每个字节;</li>
<li>利用自同步性: 并发解析; 原先只能顺序解码,并发解析可以从任意位置开始;</li>
<li>输出时: 不编码,直接输出二进制;</li>
</ol>
<h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><p>取消编码、解码后这部分耗时下降了12%;<br>并发处理则大幅提速,提速了一倍以上。</p>
<img src="/images/2020-03/res.png" class="" width="800" height="1200" title="res">


      
    </div>
    <footer class="article-footer">
      <a data-url="http://xiaoyue26.github.io/2020/03/26/2020-03/%E5%88%A9%E7%94%A8UTF-8%E7%BC%96%E7%A0%81%E7%9A%84%E7%89%B9%E6%80%A7%E8%BF%9B%E8%A1%8C%E4%BC%98%E5%8C%96/" data-id="ck96cxpqm00lgmaam9g05a433" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/" rel="tag">java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/utf8/" rel="tag">utf8</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%BC%96%E7%A0%81/" rel="tag">编码</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-2020-03/linux自连接" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/24/2020-03/linux%E8%87%AA%E8%BF%9E%E6%8E%A5/" class="article-date">
  <time datetime="2020-03-24T02:02:26.000Z" itemprop="datePublished">2020-03-24</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%BD%91%E7%BB%9C/">网络</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/24/2020-03/linux%E8%87%AA%E8%BF%9E%E6%8E%A5/">linux自连接</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <p>linux支持自连接，也就是同一个ip，同一个机器，自己起一个server、client互相连接。<br>例如使用命令:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc localhost $port -p $port</span><br></pre></td></tr></table></figure>
<p>对应TCP协议中的合法设定，同时打开:</p>
<img src="/images/2020-03/open_now.png" class="" width="800" height="1200" title="open_now">

<h2 id="误触可能"><a href="#误触可能" class="headerlink" title="误触可能"></a>误触可能</h2><p>虽然这是linux的一个feature，但是我们平时遇到这种情况一般是因为bug，也就是误触。</p>
<p>一种可能：<br>进程1: listen端口A，然后挂掉，释放端口A；<br>进程2: 源端口A, 连接端口A。</p>
<h2 id="触发bug条件"><a href="#触发bug条件" class="headerlink" title="触发bug条件"></a>触发bug条件</h2><p>listen端口选择了<code>net.ipv4.ip_local_port_range</code>范围；</p>
<p><code>net.ipv4.ip_local_port_range</code>范围里的端口是linux连接目标端口时，选择源端口的范围。可以通过修改<code>/etc/sysctl.conf</code>调整。（如果要调大connect并发度）</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 查看:</span><br><span class="line">cat /proc/sys/net/ipv4/ip_local_port_range</span><br><span class="line">// 生效:</span><br><span class="line">sysctl -p /etc/sysctl.conf</span><br></pre></td></tr></table></figure>
<p>因为connect使用的端口会从这个范围取，所以如果listen也用了这个范围，就很可能冲突，形成自连接。</p>
<h3 id="并发度"><a href="#并发度" class="headerlink" title="并发度"></a>并发度</h3><p>内核3.2以前:  需保证<code>源ip,源端口</code>2元组不同,并发度更低; (随机选择端口)<br>内核3.2以后:  需保证<code>源ip,源端口,目标ip,目标端口</code>4元组不同即可,并发度更大； (顺序选择端口)</p>
<h3 id="恶化bug条件"><a href="#恶化bug条件" class="headerlink" title="恶化bug条件"></a>恶化bug条件</h3><ol>
<li>使用连接池，自连接无法释放；</li>
<li>Linux内核&gt;=3.10: 2.6是随机选择端口,3.10是顺序递增选择；</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://xiaoyue26.github.io/2020/03/24/2020-03/linux%E8%87%AA%E8%BF%9E%E6%8E%A5/" data-id="ck96cxpqj00l4maamg8c9cfx2" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/tcp/" rel="tag">tcp</a></li></ul>

    </footer>
  </div>
  
</article>
 


  


  <nav id="page-nav">
    <a class="extend prev" rel="prev" href="/">&amp;laquo; 上一页</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/22/">22</a><a class="extend next" rel="next" href="/page/3/">下一页&amp;raquo;</a>
  </nav>
</section>
           
    <aside id="sidebar">
  
    

  
    
  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title recent-posts">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/02/24/2022-02/%E4%B8%BA%E4%BB%80%E4%B9%88%E5%85%88hash%E5%90%8E%E5%8A%A0%E5%AF%86%E7%9A%84%E6%96%B9%E6%B3%95%E5%AE%B9%E6%98%93%E9%81%AD%E9%81%87padding%E6%94%BB%E5%87%BB/">为什么先hash后加密的方法容易遭遇padding攻击</a>
          </li>
        
          <li>
            <a href="/2022/02/24/2022-02/keepalive/">http和tcp层面的keepAlive机制</a>
          </li>
        
          <li>
            <a href="/2022/02/18/2022-02/%E6%8B%A5%E5%A1%9E%E7%AE%97%E6%B3%95bbr/">quic中的拥塞算法bbr</a>
          </li>
        
          <li>
            <a href="/2022/02/17/2022-02/http3-quic%E4%BC%98%E7%BC%BA%E7%82%B9%E5%8F%8A%E5%8E%9F%E5%9B%A0/">http3_quic优缺点及原因</a>
          </li>
        
          <li>
            <a href="/2022/02/16/2022-02/http-range/">http_range</a>
          </li>
        
      </ul>
    </div>
  </div>

  
    

  
</aside>

      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-left">
      &copy; 2014 - 2022 风梦七&nbsp;|&nbsp;
      主题 <a href="https://github.com/giscafer/hexo-theme-cafe/" target="_blank">Cafe</a>
    </div>
     <div id="footer-right">
      联系方式&nbsp;|&nbsp;296671657@qq.com
    </div>
  </div>
</footer>
 
<script src="/jquery/jquery.min.js"></script>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">首页</a>
  
    <a href="/archives" class="mobile-nav-link">归档</a>
  
    <a href="/about" class="mobile-nav-link">关于</a>
  
</nav>
    <img class="back-to-top-btn" src="/images/fly-to-top.png"/>
<script>
// Elevator script included on the page, already.
window.onload = function() {
  var elevator = new Elevator({
    selector:'.back-to-top-btn',
    element: document.querySelector('.back-to-top-btn'),
    duration: 1000 // milliseconds
  });
}
</script>
      

  
    <script>
      var cloudTieConfig = {
        url: document.location.href, 
        sourceId: "",
        productKey: "e2fb4051c49842688ce669e634bc983f",
        target: "cloud-tie-wrapper"
      };
    </script>
    <script src="https://img1.ws.126.net/f2e/tie/yun/sdk/loader.js"></script>
    

  







<!-- author:forvoid begin -->
<!-- author:forvoid begin -->

<!-- author:forvoid end -->

<!-- author:forvoid end -->


  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      })
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      })
    </script>
    <script type="text/javascript" src="https://cdn.rawgit.com/mathjax/MathJax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


 
<script src="/js/is.js"></script>



  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>


<script src="/js/elevator.js"></script>

  </div>
</body>
</html>