<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>笔记本</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="笔记本">
<meta property="og:url" content="http://xiaoyue26.github.io/page/2/index.html">
<meta property="og:site_name" content="笔记本">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="风梦七">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="笔记本" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    
  
  
<link rel="stylesheet" href="/css/style.css">

  

<meta name="generator" content="Hexo 4.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    
    <div id="header-inner" class="inner">
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://xiaoyue26.github.io"></form>
      </div>
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">首页</a>
        
          <a class="main-nav-link" href="/archives">归档</a>
        
          <a class="main-nav-link" href="/about">关于</a>
        
      </nav>
      
    </div>
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">笔记本</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">风梦七</a>
        </h2>
      
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-2019-11/论文梗概-在线服务的实验评估面临的挑战" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/11/13/2019-11/%E8%AE%BA%E6%96%87%E6%A2%97%E6%A6%82-%E5%9C%A8%E7%BA%BF%E6%9C%8D%E5%8A%A1%E7%9A%84%E5%AE%9E%E9%AA%8C%E8%AF%84%E4%BC%B0%E9%9D%A2%E4%B8%B4%E7%9A%84%E6%8C%91%E6%88%98/" class="article-date">
  <time datetime="2019-11-13T02:37:58.000Z" itemprop="datePublished">2019-11-13</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E8%AE%BA%E6%96%87/">论文</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/11/13/2019-11/%E8%AE%BA%E6%96%87%E6%A2%97%E6%A6%82-%E5%9C%A8%E7%BA%BF%E6%9C%8D%E5%8A%A1%E7%9A%84%E5%AE%9E%E9%AA%8C%E8%AF%84%E4%BC%B0%E9%9D%A2%E4%B8%B4%E7%9A%84%E6%8C%91%E6%88%98/">[论文梗概]在线服务的实验评估面临的挑战</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <blockquote>
<p>论文原文: <a href="https://exp-platform.com/Documents/2019-FirstPracticalOnlineControlledExperimentsSummit_SIGKDDExplorations.pdf" target="_blank" rel="noopener">https://exp-platform.com/Documents/2019-FirstPracticalOnlineControlledExperimentsSummit_SIGKDDExplorations.pdf</a> </p>
</blockquote>
<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p><code>OEC</code>: Overall Evaluation Criterion/总体评价标准<br><code>OCEs</code>: Online controlled experiments/在线受控实验=A/B Tests</p>
<h1 id="挑战汇总"><a href="#挑战汇总" class="headerlink" title="挑战汇总"></a>挑战汇总</h1><ol>
<li>如何评估长期效应;</li>
<li>如何解决社交网络对实验的影响;</li>
<li>如何解决多次实验间的影响;</li>
<li>如何寻找OEC指标;</li>
<li>如何进行细分人群的实验(HTE模型);</li>
<li>如何确保数据质量、进行数据治理;</li>
<li>如何建立实验文化;</li>
<li>如何处理配置文件膨胀问题;</li>
</ol>
<h1 id="如何评估长期效应"><a href="#如何评估长期效应" class="headerlink" title="如何评估长期效应"></a>如何评估长期效应</h1><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><ol>
<li>大部分abtest持续两周内；</li>
<li>我们真正关心的是比两周更长的长期效应；</li>
</ol>
<p><strong>如何确保上述两者吻合？</strong></p>
<h2 id="长期效应：常见解决方案"><a href="#长期效应：常见解决方案" class="headerlink" title="长期效应：常见解决方案"></a>长期效应：常见解决方案</h2><h3 id="长期实验；"><a href="#长期实验；" class="headerlink" title="长期实验；"></a>长期实验；</h3><p>Twitter: 实验通常持续4周，从最后两周的数据开始统计。</p>
<h3 id="保留反向桶；-holdout"><a href="#保留反向桶；-holdout" class="headerlink" title="保留反向桶；(holdout)"></a>保留反向桶；(holdout)</h3><h3 id="代理指标"><a href="#代理指标" class="headerlink" title="代理指标"></a>代理指标</h3><p>Netflix: 使用logistic回归，寻找反映留存指标的代理指标。<br>LinkedIn: lifetime value模型；<br>Uber : macro-economic模型;<br>facebook: 分位数回归、GBDT</p>
<p><code>缺点</code>: 相关性!=因果关系<br><code>可能的歧路</code>：代理指标涨、长期指标不动。</p>
<p>bing/google: 心理学模型,从因果关系出发</p>
<h3 id="对用户学习效应进行建模"><a href="#对用户学习效应进行建模" class="headerlink" title="对用户学习效应进行建模"></a>对用户学习效应进行建模</h3><p>google: 用长期实验，观察用户学习的效应(参见原文论文[38])<br><strong>实验流程:</strong></p>
<ol>
<li>第一组：立刻使用B配置;</li>
<li>第二组：滞后一段时间后使用B配置;</li>
<li>第N组：依次类推。</li>
<li>随机组: 随机滞后。</li>
</ol>
<p>比较不同学习阶段的用户。</p>
<p><strong>结果:</strong> 得出指数曲线，预测长期的情况。</p>
<h1 id="如何解决社交网络对实验的影响"><a href="#如何解决社交网络对实验的影响" class="headerlink" title="如何解决社交网络对实验的影响"></a>如何解决社交网络对实验的影响</h1><h2 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h2><p>传统A/B test的假设： 实验间不相互影响；</p>
<p>假设不成立：</p>
<ol>
<li>社交网络影响；</li>
<li>多次反复实验残留效应影响。<br>对照组的用户可能与实验组认识/有交互，因此也受实验影响。</li>
</ol>
<p>问题：</p>
<ol>
<li>如何避免这个问题？（无法避免）</li>
<li>如何检测这个问题？（评估影响）</li>
</ol>
<h2 id="常见解决方案"><a href="#常见解决方案" class="headerlink" title="常见解决方案"></a>常见解决方案</h2><h3 id="生产者消费者模型"><a href="#生产者消费者模型" class="headerlink" title="生产者消费者模型"></a>生产者消费者模型</h3><p>LinkedIn： 生产者消费者模型<br>实验：<br>生产者：允许在帖子上打标签;<br>消费者：允许看到帖子的标签; </p>
<p>当95%的生产者可以打标签：可以测试50%的消费者是否允许看到标签的影响；<br>当95%的消费者可以看到标签: 可以测试50%的生产者是否打标签的影响。</p>
<p>类似的模型可以用于@功能。</p>
<h3 id="已知影响力模型"><a href="#已知影响力模型" class="headerlink" title="已知影响力模型"></a>已知影响力模型</h3><p>Link/facebook/谷歌： 用户影响力已知，将用户聚类成子网络。<br>实验在各个子网络进行。</p>
<p>相关论文： [20, 26, 9].<br><code>[20]</code>:<br><a href="http://www.unofficialgoogledatascience.com/2018/01/designing-ab-tests-in-collaboration.html" target="_blank" rel="noopener">http://www.unofficialgoogledatascience.com/2018/01/designing-ab-tests-in-collaboration.html</a></p>
<h3 id="一对一通信"><a href="#一对一通信" class="headerlink" title="一对一通信"></a>一对一通信</h3><p>对于1对1通信相关的feature:<br><strong>Linkin</strong>: 数据统计时分为4类:<br>1.实验组=&gt;实验组;<br>2.对照组=&gt;对照组;<br>3.实验组=&gt;对照组;<br>4.对照组=&gt;实验组;</p>
<p>Skype: 以会话为维度实验。每个用户都可能随机位于实验、对照组。</p>
<h3 id="市场影响"><a href="#市场影响" class="headerlink" title="市场影响"></a>市场影响</h3><p>实验结果受供求关系影响。(如打车)<br>忽视供求关系随机分组，可能会导致一些Bias。<br>Lyft： 构造小规模近似供求关系的市场，进行实验。</p>
<p>广告领域：预算窃取<br>实验组：窃取对照组预算(对照组的广告预算也花在了实验组)<br>当放量时，整体收入并没有达到预期幅度。<br>解决方案：按预算比例投放到实验组。</p>
<h1 id="挑战：多个实验之间的影响"><a href="#挑战：多个实验之间的影响" class="headerlink" title="挑战：多个实验之间的影响"></a>挑战：多个实验之间的影响</h1><h2 id="问题-2"><a href="#问题-2" class="headerlink" title="问题"></a>问题</h2><p>如果两个实验之间不是完全独立。<br>(例1个实验改变背景，1个实验改变字体颜色)</p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>微软、谷歌：相互影响(互斥)的实验放在同一层内，这一个层由一个团队负责(相关特性)；<br>微软：每天跑任务检测层间影响；</p>
<h1 id="挑战：如何寻找OEC指标"><a href="#挑战：如何寻找OEC指标" class="headerlink" title="挑战：如何寻找OEC指标"></a>挑战：如何寻找OEC指标</h1><h2 id="问题-3"><a href="#问题-3" class="headerlink" title="问题"></a>问题</h2><p>HiPPO: 工资最高的人说了算。<br>OEC: 数据驱动，核心指标说了算。</p>
<p>指标=OEC指标+其他护栏、诊断指标;<br>OEC指标: 决策;(KPI)<br>诊断指标: OEC指标为啥变化。</p>
<h2 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="OEC指标满足的条件"><a href="#OEC指标满足的条件" class="headerlink" title="OEC指标满足的条件"></a>OEC指标满足的条件</h3><ol>
<li>反映KPI;</li>
<li>难以作弊;</li>
<li>必须敏感;</li>
<li>计算的成本不能太高(可行性)、每天都要给至少上百个实验计算;(不能是只能打电话确认的指标)</li>
<li>考虑到影响KPI的各种场景;</li>
<li>能顾及到新的场景。</li>
</ol>
<h3 id="自己发现OEC"><a href="#自己发现OEC" class="headerlink" title="自己发现OEC"></a>自己发现OEC</h3><p>对于搜索引擎: 查询量不是好的OEC，查询量大可能是因为不准。<br>好的OEC: 每个用户的会话数。（不准的话，单次会话查询量很大、会话数少。）</p>
<p>一般来说：<br><strong>OEC指标属性</strong>:<br><code>HEART</code>: </p>
<blockquote>
<p>Happiness, Engagement, Adoption, Retention, and Task success</p>
</blockquote>
<p><strong>护栏指标</strong>：pv、vv、时长、延迟、七日用户数。</p>
<p>对于浏览类场景，找到HEART指标仍是挑战。<br>挑战：识别用户的目的。<br>目的1：快速找到特定东西；<br>目的2：不想找特定东西，只是想探索新东西；</p>
<p>对于目的1：点击次数越多越不好；<br>对于目的2：点击次数越多越好。<br>两者矛盾，因此存在挑战。</p>
<h3 id="权衡产品目标"><a href="#权衡产品目标" class="headerlink" title="权衡产品目标"></a>权衡产品目标</h3><p>我们潜意识假定产品目标是确定不变的、统一的。<br>然而这不是小问题。因此假定不一定总是成立。</p>
<ol>
<li>团队可能调整战略(例如每个阶段的盈利策略)；</li>
<li>每个局部的实际方向可能和总体不符。</li>
<li>多目标(指标)冲突。(收入与体验)</li>
</ol>
<h3 id="机器学习建立OEC"><a href="#机器学习建立OEC" class="headerlink" title="机器学习建立OEC"></a>机器学习建立OEC</h3><ol>
<li>基于用户行为，打分预测满意度；</li>
<li>组合多个指标，创造敏感又准确的OEC指标；</li>
</ol>
<p>缺点: 不可解释、难以发现误判。</p>
<h1 id="如何进行细分人群的实验"><a href="#如何进行细分人群的实验" class="headerlink" title="如何进行细分人群的实验"></a>如何进行细分人群的实验</h1><p>细分人群可能可以有更多洞察。</p>
<h2 id="常见的分类方法"><a href="#常见的分类方法" class="headerlink" title="常见的分类方法"></a>常见的分类方法</h2><ol>
<li>国家、使用语言；</li>
<li>活跃度;</li>
<li>设备和平台；</li>
<li>周中周末、新奇效应；</li>
<li>产品特定分类：<br>(1)linked: 招聘者、应聘者；<br>(2)Netflix: 不同网速；<br>(3)Airbnb: 是否曾经预定、渠道来源；</li>
</ol>
<h2 id="相关挑战和解决方案"><a href="#相关挑战和解决方案" class="headerlink" title="相关挑战和解决方案"></a>相关挑战和解决方案</h2><ol>
<li>计算规模变大; =&gt;按需分析: 某些需求可以用更高成本的分析方法；</li>
<li>样本变少; =&gt; 使用稀疏模型</li>
<li>分层的正交性依赖大样本; </li>
<li>实验者不是统计学专家,实验结果必须明确易懂； =&gt;用回归和聚类来简化结果。(Fused Lasso、Total Variation Regularization)</li>
<li>相关性!=因果关系: 细分人群的结果不同，但相应分类属性可能不是导致结果不同的原因，可能只是共线。<br>解决方案：可以从历史数据中寻求更多信息。</li>
</ol>
<h1 id="数据质量与数据治理"><a href="#数据质量与数据治理" class="headerlink" title="数据质量与数据治理"></a>数据质量与数据治理</h1><h2 id="问题-4"><a href="#问题-4" class="headerlink" title="问题"></a>问题</h2><p>实验可信度依赖数据质量。如何确保数据质量?</p>
<h2 id="解决方案-2"><a href="#解决方案-2" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="工业界测试"><a href="#工业界测试" class="headerlink" title="工业界测试"></a>工业界测试</h3><p>工业界测试： Ratio Mismatch test (见原文引用[13, 22, 23, 45])<br>抽样校验告警。</p>
<h3 id="数据规范"><a href="#数据规范" class="headerlink" title="数据规范"></a>数据规范</h3><p>Netflix\MSN\Bing：json<br>优点：拓展性好；<br>缺点: 格式变化很快；</p>
<p>Airbnb/facebook：每个实验自己设定格式、打点。(bring-your-own-data)<br>Microsoft Office: 事件日志；<br>其他: 固定部分列，预留json列。</p>
<h3 id="及时可靠的指标"><a href="#及时可靠的指标" class="headerlink" title="及时可靠的指标"></a>及时可靠的指标</h3><p>不断新增指标对实验平台的挑战。</p>
<p>LinkedIn/Facebook/Airbnb: 实验平台与指标框架分离，各个业务对自己的指标负责。实验平台仅负责从统计结果进行评估。<br>Microsoft/Google/Booking.com/Lyft:指标由实验团队从日志中统计。</p>
<p>LinkedIn:<br>指标委员会：批准新增、修改指标，确保指标质量；<br>某些公司：<br>指标必须经过验证敏感性、精确性，确定和实验结果有有意义的区别。<br>Booking.com：<br>自动检测比较两组独立数据。</p>
<h3 id="指标的ownership"><a href="#指标的ownership" class="headerlink" title="指标的ownership"></a>指标的ownership</h3><p>指标通常有特定的关注者和归属者。<br>微软：特定指标下降=&gt;通知指标归属者(含相关实验信息)。</p>
<p>其他公司：提供工具搜索：影响特定指标的实验。</p>
<h3 id="新分析方法"><a href="#新分析方法" class="headerlink" title="新分析方法"></a>新分析方法</h3><p>需要考虑:</p>
<ol>
<li>新方法适用场景;</li>
<li>新方法的计算、复杂性成本 &lt; 收益;</li>
<li>不同方法冲突时，相信哪一种；</li>
<li>保证正确解释结果；</li>
</ol>
<h1 id="如何建立实验文化"><a href="#如何建立实验文化" class="headerlink" title="如何建立实验文化"></a>如何建立实验文化</h1><p>日志、实验、实验记录、实验评估的文化。<br>原则:<br>谦逊: 直觉判断是贫瘠的(HIPPO)；<br>微软：只有1/3的创意在数据上有显著结果。</p>
<p>能接受实验效果不好。</p>
<h2 id="解决方案-建立规范的实验平台。"><a href="#解决方案-建立规范的实验平台。" class="headerlink" title="解决方案: 建立规范的实验平台。"></a>解决方案: 建立规范的实验平台。</h2><p>Booking.com： 将实验平台变得像游戏。</p>
<p>Yandex： 中央实验小组：由各个组的专家组成<br>Amazon： 类似，酒吧专家；（酒吧是Amazon的实验平台）<br>Twitter：实验牧羊人：50个牧羊人，一个星期值班时间，<br>Booking.com： 实验大使制度、同行评议制度（按钮：随机选择一个实验来评议）<br>微软：1~2个数据科学家跟着一个业务团队。随着业务团队接受培训、能力提高，数据科学家回到中心、转跟另一个业务团队。定期分享。<br>谷歌： checklist。每次实验填写：假设、指标、变化幅度。</p>
<h1 id="配置文件膨胀的挑战"><a href="#配置文件膨胀的挑战" class="headerlink" title="配置文件膨胀的挑战"></a>配置文件膨胀的挑战</h1><h2 id="问题-5"><a href="#问题-5" class="headerlink" title="问题"></a>问题</h2><p>随着实验越来越多，客户端要拉的配置文件越来越大。</p>
<h2 id="解决方案-3"><a href="#解决方案-3" class="headerlink" title="解决方案"></a>解决方案</h2><p>定期合代码，固化一些feature;</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://xiaoyue26.github.io/2019/11/13/2019-11/%E8%AE%BA%E6%96%87%E6%A2%97%E6%A6%82-%E5%9C%A8%E7%BA%BF%E6%9C%8D%E5%8A%A1%E7%9A%84%E5%AE%9E%E9%AA%8C%E8%AF%84%E4%BC%B0%E9%9D%A2%E4%B8%B4%E7%9A%84%E6%8C%91%E6%88%98/" data-id="ck96cxpqe00kkmaam2jzt1b6i" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AE%BA%E6%96%87/" rel="tag">论文</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-2019-11/java8笔记" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/11/03/2019-11/java8%E7%AC%94%E8%AE%B0/" class="article-date">
  <time datetime="2019-11-03T12:56:11.000Z" itemprop="datePublished">2019-11-03</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/java/">java</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/11/03/2019-11/java8%E7%AC%94%E8%AE%B0/">java8笔记</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <h1 id="lambda语法"><a href="#lambda语法" class="headerlink" title="lambda语法"></a>lambda语法</h1><p><code>i-&gt;{return &quot;xxx&quot;;}</code><br>本质上是借用匿名类来实现,并没有超脱原来的java的解题思路。</p>
<p>这种类似于传一个函数指针的模式，底层是<code>@FunctionalInterface</code>注解的接口，因此我们可以自己声明一个接口作为方法的行参:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line">   <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">GetIdataFunction</span> </span>&#123;</span><br><span class="line">       <span class="function"><span class="keyword">int</span> <span class="title">getI</span><span class="params">(<span class="keyword">int</span> i)</span></span>;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">default</span> String <span class="title">getInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="string">"找下标为i的数据"</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">searchMatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (matrix == <span class="keyword">null</span> || matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span> || target &lt; matrix[<span class="number">0</span>][<span class="number">0</span>]) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">int</span> lowerBound = getLowerBound(target, <span class="number">0</span>, matrix.length - <span class="number">1</span>, i -&gt; matrix[i][<span class="number">0</span>]);</span><br><span class="line">       <span class="keyword">if</span> (lowerBound &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">final</span> <span class="keyword">int</span> finalLowerBound = -lowerBound - <span class="number">2</span>;</span><br><span class="line">       <span class="keyword">int</span> x = getLowerBound(target, <span class="number">0</span>, matrix[<span class="number">0</span>].length - <span class="number">1</span>, i -&gt; matrix[finalLowerBound][i]);</span><br><span class="line">       <span class="keyword">return</span> x &gt;= <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getLowerBound</span><span class="params">(<span class="keyword">int</span> target, <span class="keyword">int</span> left, <span class="keyword">int</span> right, GetIdataFunction helper)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> mid;</span><br><span class="line">       <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">           mid = (left + right) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">           <span class="keyword">int</span> midVal = helper.getI(mid);</span><br><span class="line">           <span class="keyword">if</span> (target &lt; midVal) &#123;</span><br><span class="line">               right = mid - <span class="number">1</span>;</span><br><span class="line">           &#125; <span class="keyword">else</span> <span class="keyword">if</span> (target &gt; midVal) &#123;</span><br><span class="line">               left = mid + <span class="number">1</span>;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="keyword">return</span> mid;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> -left - <span class="number">1</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h1 id="现成的Function声明汇总"><a href="#现成的Function声明汇总" class="headerlink" title="现成的Function声明汇总"></a>现成的Function声明汇总</h1><p>java8给了一些统一的描述术语(DSL)来分类这些函数接口:</p>
<table>
<thead>
<tr>
<th>接口</th>
<th>lambda</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>Predicate&lt; T&gt;</td>
<td>T-&gt;boolean</td>
<td>类似于filter，接收T类型返回boolean</td>
</tr>
<tr>
<td>Consumer&lt; T&gt;</td>
<td>T-&gt;void</td>
<td>类似于foreach，接收T类型返回void</td>
</tr>
<tr>
<td>Function&lt; T,R&gt;</td>
<td>T-&gt;R</td>
<td>类似于Map，接收T类型返回R类型</td>
</tr>
<tr>
<td>Supplier&lt; T&gt;</td>
<td>()-&gt;T</td>
<td></td>
</tr>
<tr>
<td>UnaryOperator&lt; T&gt;</td>
<td>T-&gt;T</td>
<td></td>
</tr>
<tr>
<td>BinaryOperator&lt; T&gt;</td>
<td>(T,T)-&gt;T</td>
<td></td>
</tr>
<tr>
<td>BiPredicate&lt; L,R&gt;</td>
<td>(L,R)-&gt;boolean</td>
<td></td>
</tr>
<tr>
<td>BiConsumer&lt; T,U&gt;</td>
<td>(T,U)-&gt;void</td>
<td></td>
</tr>
<tr>
<td>BiFunction&lt; T,U,R&gt;</td>
<td>(T,U)-&gt;R</td>
<td></td>
</tr>
</tbody></table>
<p>常见的几种函数指针都可以用这些现成的声明，如果要抛异常，或者比较特殊的入参、出参，就自己用<code>@FunctionalInterface</code>注解声明个接口和相应方法即可。</p>
<p>此外，上述接口的T,R泛型都需要类、引用，因此如果要节省装箱开销，可以用相应的原始类型声明，比如一个<code>int-&gt;int</code>的变换，相应的接口就是<code>IntUnaryOperator</code>。<br>因此上一节中的代码可以简化成:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">searchMatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix == <span class="keyword">null</span> || matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span> || target &lt; matrix[<span class="number">0</span>][<span class="number">0</span>]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> lowerBound = getLowerBound(target, <span class="number">0</span>, matrix.length - <span class="number">1</span>, i -&gt; matrix[i][<span class="number">0</span>]);<span class="comment">// 闭包捕获matrix</span></span><br><span class="line">        <span class="keyword">if</span> (lowerBound &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> finalLowerBound = -lowerBound - <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> x = getLowerBound(target, <span class="number">0</span>, matrix[<span class="number">0</span>].length - <span class="number">1</span>, i -&gt; matrix[finalLowerBound][i]);<span class="comment">// 闭包捕获matrix和finalLowerBound</span></span><br><span class="line">        <span class="keyword">return</span> x &gt;= <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getLowerBound</span><span class="params">(<span class="keyword">int</span> target, <span class="keyword">int</span> left, <span class="keyword">int</span> right, IntUnaryOperator helper)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> mid;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            mid = (left + right) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> midVal = helper.applyAsInt(mid);</span><br><span class="line">            <span class="keyword">if</span> (target &lt; midVal) &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (target &gt; midVal) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -left - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


<p>其他的原始类型(免装箱)的现成有的声明如下:（要用的时候可以查表）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. Predicate&lt;T&gt; T-&gt;boolean :</span></span><br><span class="line">IntPredicate,LongPredicate, DoublePredicate</span><br><span class="line"><span class="comment">// 2. Consumer&lt;T&gt; T-&gt;void :</span></span><br><span class="line">IntConsumer,LongConsumer, DoubleConsumer</span><br><span class="line"><span class="comment">// 3. Function&lt;T,R&gt; T-&gt;R :</span></span><br><span class="line">IntFunction&lt;R&gt;,</span><br><span class="line">IntToDoubleFunction,</span><br><span class="line">IntToLongFunction,</span><br><span class="line">LongFunction&lt;R&gt;,</span><br><span class="line">LongToDoubleFunction,</span><br><span class="line">LongToIntFunction,</span><br><span class="line">DoubleFunction&lt;R&gt;,</span><br><span class="line">ToIntFunction&lt;T&gt;,</span><br><span class="line">ToDoubleFunction&lt;T&gt;,</span><br><span class="line">ToLongFunction&lt;T&gt; </span><br><span class="line"><span class="comment">// 4. Supplier&lt;T&gt; ()-&gt;T :</span></span><br><span class="line">BooleanSupplier,IntSupplier,LongSupplier,DoubleSupplier</span><br><span class="line"><span class="comment">// 5. UnaryOperator&lt;T&gt; T-&gt;T :</span></span><br><span class="line">IntUnaryOperator,</span><br><span class="line">LongUnaryOperator,</span><br><span class="line">DoubleUnaryOperator</span><br><span class="line"><span class="comment">// 6. BinaryOperator&lt;T&gt; (T,T)-&gt;T :</span></span><br><span class="line">IntBinaryOperator,</span><br><span class="line">LongBinaryOperator,</span><br><span class="line">DoubleBinaryOperator</span><br><span class="line"><span class="comment">// 7. BiConsumer&lt;T,U&gt; (T,U)-&gt;void :</span></span><br><span class="line">ObjIntConsumer&lt;T&gt;,</span><br><span class="line">ObjLongConsumer&lt;T&gt;,</span><br><span class="line">ObjDoubleConsumer&lt;T&gt;</span><br><span class="line"><span class="comment">// 8. BiFunction&lt;T,U,R&gt; (T,U)-&gt;R :</span></span><br><span class="line">ToIntBiFunction&lt;T,U&gt;,</span><br><span class="line">ToLongBiFunction&lt;T,U&gt;,</span><br><span class="line">ToDoubleBiFunction&lt;T,U&gt;</span><br></pre></td></tr></table></figure>

<h1 id="无状态"><a href="#无状态" class="headerlink" title="无状态"></a>无状态</h1><p>默认无状态的操作:  map,filter,collect; // 假如不使用外部变量(闭包)<br>有状态的操作: reduce,sum,max,sorted,distinct,skip,limit; // 有内部状态、初始值</p>
<p>// flatmap? </p>
<h1 id="原始类型流"><a href="#原始类型流" class="headerlink" title="原始类型流"></a>原始类型流</h1><p>原始类型流如: <code>IntStream</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">IntStream intStream = menu.stream().mapToInt(Dish::getCalories);</span><br><span class="line">Stream&lt; Integer&gt; stream = intStream.boxed();</span><br></pre></td></tr></table></figure>

<p>原始类型的Optional:<code>OptionalInt</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OptionalInt maxCalories = menu.stream().mapToInt(Dish::getCalories).max();</span><br></pre></td></tr></table></figure>

<h1 id="java中的蜂巢结构"><a href="#java中的蜂巢结构" class="headerlink" title="java中的蜂巢结构"></a>java中的蜂巢结构</h1><p>d3中有个蜂巢结构,java8中也可以有:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Dish.Type, Map&lt;CaloricLevel, List&lt;Dish&gt;&gt;&gt; dishesByTypeCaloricLevel = menu.stream().collect(</span><br><span class="line">groupingBy(Dish::getType,</span><br><span class="line">   groupingBy(dish -&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (dish.getCalories() &lt;= <span class="number">400</span>) <span class="keyword">return</span> CaloricLevel.DIET;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (dish.getCalories() &lt;= <span class="number">700</span>) <span class="keyword">return</span> CaloricLevel.NORMAL;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> CaloricLevel.FAT;</span><br><span class="line">    &#125;);</span><br><span class="line">));</span><br></pre></td></tr></table></figure>

<p>还可以分组计数:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Dish.Type, Long&gt; typesCount = menu.stream().collect(</span><br><span class="line">                    groupingBy(Dish::getType, counting()));</span><br></pre></td></tr></table></figure>


<h1 id="collectors中的characteristics"><a href="#collectors中的characteristics" class="headerlink" title="collectors中的characteristics"></a>collectors中的characteristics</h1><p>返回枚举值的list:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">UNORDERED: 结果不受顺序影响;</span><br><span class="line">CONCURRENT: 可以并行运行;</span><br><span class="line">IDENTITY_FINISH: 累加器和最后的结果类型是一样的,不需要再转换。</span><br></pre></td></tr></table></figure>
<p>一般是是返回后两者,因为一般都会希望维持顺序(如<code>toList</code>):</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Set&lt;Characteristics&gt; <span class="title">characteristics</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Collections.unmodifiableSet(EnumSet.of(</span><br><span class="line">    IDENTITY_FINISH, CONCURRENT));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果是生成质数这种,实现上依赖之前已经生成的质数,有状态,则不能并行。只返回一个<code>IDENTITY_FINISH</code>.</p>
<h1 id="Spliterator"><a href="#Spliterator" class="headerlink" title="Spliterator"></a>Spliterator</h1><p>Spliterator的特性:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ORDERED 元素有既定的顺序（例如List），因此Spliterator在遍历和划分时也会遵循这一顺序</span><br><span class="line">DISTINCT 对于任意一对遍历过的元素x和y，x.equals(y)返回false</span><br><span class="line">SORTED 遍历的元素按照一个预定义的顺序排序</span><br><span class="line">SIZED 该Spliterator由一个已知大小的源建立（例如Set），因此estimatedSize()返回的是准确值</span><br><span class="line">NONNULL 保证遍历的元素不会为null</span><br><span class="line">IMMUTABLE Spliterator的数据源不能修改。这意味着在遍历时不能添加、删除或修改任何元素</span><br><span class="line">CONCURRENT 该Spliterator的数据源可以被其他线程同时修改而无需同步</span><br><span class="line">SUBSIZED 该Spliterator和所有从它拆分出来的Spliterator都是SIZED</span><br></pre></td></tr></table></figure>
<p>DISTINCT和SORTED比较难达到;<br>一般是:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">characteristics</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ORDERED + SIZED + SUBSIZED + NONNULL + IMMUTABLE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><p>策略模式: 策略发生变化，只修改用到的函数。(例如输入校验策略)<br>模版方法: 修改一大段代码中其中一个函数的调用实现。(传入函数指针)<br>观察者模式: 例如GUI场景下，注册一大堆监听事件。(传入函数指针)</p>
<h2 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式:"></a>责任链模式:</h2><p>每个处理者可以增加后继处理节点,形成一个链表，每次处理的时候，调用下一个处理者。用lamda中的addThen的话:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">UnaryOperator&lt;String&gt; headerProcessing =</span><br><span class="line"> (String text) -&gt; <span class="string">"From Raoul, Mario and Alan: "</span> + text;</span><br><span class="line">UnaryOperator&lt;String&gt; spellCheckerProcessing =</span><br><span class="line"> (String text) -&gt; text.replaceAll(<span class="string">"labda"</span>, <span class="string">"lambda"</span>);</span><br><span class="line">Function&lt;String, String&gt; pipeline =</span><br><span class="line"> headerProcessing.andThen(spellCheckerProcessing);</span><br><span class="line">String result = pipeline.apply(<span class="string">"Aren't labdas really sexy?!!"</span>)</span><br></pre></td></tr></table></figure>
<h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><p>可以把构造函数放map里:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">static</span> Map&lt;String, Supplier&lt;Product&gt;&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line"> map.put(<span class="string">"loan"</span>, Loan::<span class="keyword">new</span>);</span><br><span class="line"> map.put(<span class="string">"stock"</span>, Stock::<span class="keyword">new</span>);</span><br><span class="line"> map.put(<span class="string">"bond"</span>, Bond::<span class="keyword">new</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="lamda方法的单元测试"><a href="#lamda方法的单元测试" class="headerlink" title="lamda方法的单元测试"></a>lamda方法的单元测试</h1><ol>
<li>存成成员变量(函数指针);</li>
<li>匿名方法粒度太小了，应该测试上层方法;</li>
</ol>
<h1 id="lambda的副作用"><a href="#lambda的副作用" class="headerlink" title="lambda的副作用"></a>lambda的副作用</h1><ol>
<li>出错信息模糊: 错误栈缺失准确的信息；</li>
</ol>
<h2 id="调试技巧"><a href="#调试技巧" class="headerlink" title="调试技巧"></a>调试技巧</h2><p>使用peek函数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; result =</span><br><span class="line"> numbers.stream()</span><br><span class="line"> .peek(x -&gt; System.out.println(<span class="string">"from stream: "</span> + x))</span><br><span class="line"> .map(x -&gt; x + <span class="number">17</span>)</span><br><span class="line"> .peek(x -&gt; System.out.println(<span class="string">"after map: "</span> + x))</span><br><span class="line"> .filter(x -&gt; x % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line"> .peek(x -&gt; System.out.println(<span class="string">"after filter: "</span> + x))</span><br><span class="line"> .limit(<span class="number">3</span>) <span class="comment">// 只取3个. </span></span><br><span class="line"> .peek(x -&gt; System.out.println(<span class="string">"after limit: "</span> + x))</span><br><span class="line"> .collect(toList());</span><br></pre></td></tr></table></figure>

<h1 id="3种兼容性"><a href="#3种兼容性" class="headerlink" title="3种兼容性"></a>3种兼容性</h1><p>二进制级兼容： 现有二进制执行文件能无缝链接；<br>源码级兼容：   现有程序能够成功编译通过；<br>函数行为级兼容：程序接受同样的输入能得到同样的结果。</p>
<p>接口中加入新的方法：<br>二进制级兼容：兼容;(不会被调用)<br>源码级兼容：不兼容;(不符合语法)<br>函数行为级兼容: 兼容;(不影响原有函数)</p>
<p>抽象类和有默认方法的接口区别：抽象类可以有成员、不能多继承。</p>
<p>默认方法的接口多继承优先级问题：</p>
<ol>
<li>类中的实现&gt; 接口中的;</li>
<li>子接口中实现&gt;父接口中的;</li>
<li>上述两种无法判断时,必须显式调用,声明调用的是哪个实现:<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// class C implement B,A</span></span><br><span class="line">B.<span class="keyword">super</span>.hello(); <span class="comment">// 显式调用B接口中的方法;</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h1 id="Option"><a href="#Option" class="headerlink" title="Option"></a>Option</h1><p>每次新建一个类的时候，所有引用类成员都尽量搞成<code>Option</code>.<br>如果可能为null,就搞成<code>Option</code>;<br>如果不可能为null,就维持朴素类型。// 比如构造时就自动填充确定值的final</p>
<p>相当于领域中将是否可选这个属性也封装了进去，而不是靠注释来弱约束。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化可以这样:</span></span><br><span class="line">Optional&lt;Car&gt; optCar = Optional.empty();</span><br><span class="line"><span class="comment">// 根据空或非空值创建: </span></span><br><span class="line">Optional&lt;Car&gt; optCar = Optional.ofNullable(car); <span class="comment">// 推荐初始化方式</span></span><br></pre></td></tr></table></figure>

<p>用了Optional以后,后续用Stream api处理(疯狂调用<code>flatMap</code>),整个过程就变成函数式,再也不需要null关键字。</p>
<p>对于可选成员(<code>Option&lt;T&gt;</code>): 调用<code>flatMap</code>;<br>对于必选成员(<code>final String</code>): 调用<code>map</code>;</p>
<p>Option的缺点: 无法序列化。<br>如果需要可以序列化的类,只能隐藏Option变量:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Optional&lt;Car&gt; <span class="title">getCarAsOptional</span><span class="params">()</span> </span>&#123;</span><br><span class="line">             <span class="keyword">return</span> Optional.ofNullable(car);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Optional不能滥用(不能序列化):(java Lambda（JSR-335）专家组考虑并拒绝了它)</p>
<blockquote>
<p>尽量避免将Optional用于类属性、方法参数及集合元素中，因为以上三种情况，完全可以使用null值来代替Optional，没有必要必须使用Optional，另外Optional本身为引用类型，大量使用Optional会出现类似(这样描述不完全准确)封箱、拆箱的操作，在一定程度上会影响JVM的堆内存及内存回收。<br>相关tip:<br><a href="https://segmentfault.com/a/1190000018936877?utm_source=tag-newest" target="_blank" rel="noopener">https://segmentfault.com/a/1190000018936877?utm_source=tag-newest</a></p>
</blockquote>
<ul>
<li>不要放进Map里，因为Optional不是作为值类型设计的，它的<code>equals、hashcode、==</code>方法都不能保证正确性(和唯一性有关的方法)。</li>
</ul>
<p>最后: POJO还是保持纯粹，这样也有向前先后兼容性。</p>
<h1 id="异步编程"><a href="#异步编程" class="headerlink" title="异步编程"></a>异步编程</h1><p>无法从线程失败中恢复的版本:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Future&lt;Double&gt; <span class="title">getPriceAsync</span><span class="params">(String product)</span> </span>&#123;     </span><br><span class="line">        CompletableFuture&lt;Double&gt; futurePrice = <span class="keyword">new</span> CompletableFuture&lt;&gt;();          </span><br><span class="line">        <span class="keyword">new</span> Thread( () -&gt; &#123;</span><br><span class="line">           <span class="keyword">double</span> price = calculatePrice(product);</span><br><span class="line">           futurePrice.complete(price);<span class="comment">// here</span></span><br><span class="line">        &#125;).start();</span><br><span class="line">       <span class="keyword">return</span> futurePrice;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>加上try catch:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">double</span> price = calculatePrice(product);</span><br><span class="line">    futurePrice.complete(price);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">    futurePrice.completeExceptionally(ex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>精简后:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Future&lt;Double&gt; <span class="title">getPriceAsync</span><span class="params">(String product)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> CompletableFuture.supplyAsync(() -&gt; calculatePrice(product));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="并行查询-无状态"><a href="#并行查询-无状态" class="headerlink" title="并行查询(无状态)"></a>并行查询(无状态)</h2><p>无状态:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">shops.parallelStream().map(shop-&gt;String.format(<span class="string">"%s price is %.2f"</span></span><br><span class="line">,shop.getName(), shop.getPrice(product)))).collect(ToList());</span><br></pre></td></tr></table></figure>

<p>定制Executor:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Executor executor =</span><br><span class="line">Executors.newFixedThreadPool(Math.min(shops.size(), <span class="number">100</span>),</span><br><span class="line">    <span class="keyword">new</span> ThreadFactory() &#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">       Thread t = <span class="keyword">new</span> Thread(r);</span><br><span class="line">        t.setDaemon(<span class="keyword">true</span>);<span class="comment">// 守护线程,主线程结束后关闭</span></span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>


<p>计算密集,无IO: 使用Stream接口; // 不加线程数<br>IO密集,计算简单: 使用<code>CompletableFuture</code>,自定义线程池; // 可以疯狂加线程</p>
<h1 id="时间api"><a href="#时间api" class="headerlink" title="时间api"></a>时间api</h1><h2 id="LocalDate和LocalTime"><a href="#LocalDate和LocalTime" class="headerlink" title="LocalDate和LocalTime"></a>LocalDate和LocalTime</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">LocalDate date = LocalDate.of(<span class="number">2014</span>, <span class="number">3</span>, <span class="number">18</span>);</span><br><span class="line">LocalDate today = LocalDate.now();</span><br><span class="line">LocalTime time = LocalTime.of(<span class="number">13</span>, <span class="number">45</span>, <span class="number">20</span>);</span><br><span class="line"><span class="comment">// 字符串:</span></span><br><span class="line">LocalDate date = LocalDate.parse(<span class="string">"2014-03-18"</span>);</span><br><span class="line">LocalTime time = LocalTime.parse(<span class="string">"13:45:20"</span>);</span><br></pre></td></tr></table></figure>
<h2 id="复合后-LocalDateTime"><a href="#复合后-LocalDateTime" class="headerlink" title="复合后: LocalDateTime"></a>复合后: LocalDateTime</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LocalDateTime dt1 = LocalDateTime.of(<span class="number">2014</span>, Month.MARCH, <span class="number">18</span>, <span class="number">13</span>, <span class="number">45</span>, <span class="number">20</span>); LocalDateTime dt2 = LocalDateTime.of(date, time);<span class="comment">// 复合localDate和localTime</span></span><br></pre></td></tr></table></figure>

<h2 id="unix时间-java-time-Instant"><a href="#unix时间-java-time-Instant" class="headerlink" title="unix时间: java.time.Instant"></a>unix时间: <code>java.time.Instant</code></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Instant.ofEpochSecond(<span class="number">3</span>);<span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<h2 id="时间间隔-Duration"><a href="#时间间隔-Duration" class="headerlink" title="时间间隔: Duration"></a>时间间隔: Duration</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Duration d1 = Duration.between(time1, time2);</span><br><span class="line">Duration d1 = Duration.between(dateTime1, dateTime2);</span><br><span class="line">Duration d2 = Duration.between(instant1, instant2);</span><br><span class="line">Duration threeMinutes = Duration.ofMinutes(<span class="number">3</span>);</span><br></pre></td></tr></table></figure>

<h2 id="天间隔-Period"><a href="#天间隔-Period" class="headerlink" title="天间隔: Period"></a>天间隔: Period</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Period tenDays = Period.between(LocalDate.of(<span class="number">2014</span>, <span class="number">3</span>, <span class="number">8</span>),</span><br><span class="line">                        LocalDate.of(<span class="number">2014</span>, <span class="number">3</span>, <span class="number">18</span>));</span><br><span class="line">Period tenDays = Period.ofDays(<span class="number">10</span>);</span><br></pre></td></tr></table></figure>

<p>上述类都是不可变的。// 线程安全</p>
<p>修改直接返回新变量:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LocalDate date2 = date1.withYear(<span class="number">2011</span>);</span><br><span class="line">LocalDate date2 = date1.plusWeeks(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<h2 id="个性化操作-TemporalAdjuster"><a href="#个性化操作-TemporalAdjuster" class="headerlink" title="个性化操作: TemporalAdjuster"></a>个性化操作: TemporalAdjuster</h2><p>下个周日、下个工作日、本月最后一天:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.time.temporal.TemporalAdjusters.*;</span><br><span class="line">LocalDate date1 = LocalDate.of(<span class="number">2014</span>, <span class="number">3</span>, <span class="number">18</span>);</span><br><span class="line">LocalDate date2 = date1.with(nextOrSame(DayOfWeek.SUNDAY));</span><br><span class="line">LocalDate date3 = date2.with(lastDayOfMonth());</span><br></pre></td></tr></table></figure>

<h2 id="格式化、格式转换"><a href="#格式化、格式转换" class="headerlink" title="格式化、格式转换"></a>格式化、格式转换</h2><h3 id="localData-lt-gt-String"><a href="#localData-lt-gt-String" class="headerlink" title="localData&lt;=&gt;String"></a>localData&lt;=&gt;String</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">LocalDate date = LocalDate.of(<span class="number">2014</span>, <span class="number">3</span>, <span class="number">18</span>);</span><br><span class="line">String s1 = date.format(DateTimeFormatter.BASIC_ISO_DATE); <span class="comment">// 20140318</span></span><br><span class="line">String s2 = date.format(DateTimeFormatter.ISO_LOCAL_DATE); <span class="comment">// 2014-03-18</span></span><br><span class="line"></span><br><span class="line">LocalDate date1 = LocalDate.parse(<span class="string">"20140318"</span>,</span><br><span class="line">                                 DateTimeFormatter.BASIC_ISO_DATE);</span><br><span class="line">LocalDate date2 = LocalDate.parse(<span class="string">"2014-03-18"</span>,</span><br><span class="line">                                 DateTimeFormatter.ISO_LOCAL_DATE);</span><br></pre></td></tr></table></figure>

<p>定制格式:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DateTimeFormatter formatter = DateTimeFormatter.ofPattern(<span class="string">"dd/MM/yyyy"</span>);</span><br><span class="line">LocalDate date1 = LocalDate.of(<span class="number">2014</span>, <span class="number">3</span>, <span class="number">18</span>);</span><br><span class="line">String formattedDate = date1.format(formatter);</span><br><span class="line">LocalDate date2 = LocalDate.parse(formattedDate, formatter);</span><br></pre></td></tr></table></figure>

<h2 id="时区"><a href="#时区" class="headerlink" title="时区"></a>时区</h2><p><code>java.time.ZoneId</code>和<code>ZonedDateTime</code>:<br>从LocalData转换到ZonedDateTime:(其他几个也一样)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ZoneId romeZone = ZoneId.of(<span class="string">"Europe/Rome"</span>);</span><br><span class="line"><span class="comment">// 或者: ZoneId zoneId = TimeZone.getDefault().toZoneId();</span></span><br><span class="line">LocalDate date = LocalDate.of(<span class="number">2014</span>, Month.MARCH, <span class="number">18</span>); <span class="number">6</span></span><br><span class="line">ZonedDateTime zdt1 = date.atStartOfDay(romeZone);</span><br></pre></td></tr></table></figure>

<img src="/images/2019-11/zonedDateTime.png" class="" width="800" height="1200" title="zonedDateTime">

<p>时区差: <code>ZoneOffset</code></p>
<p>其他日历系统: <code>ThaiBuddhistDate</code>,<code>MinguoDate</code>,<code>JapaneseDate</code>,<code>HijrahDate</code></p>
<h1 id="其他tips"><a href="#其他tips" class="headerlink" title="其他tips"></a>其他tips</h1><p>ConcurrentHashMap类：<br>用<code>mappingCount</code>方法代替<code>size</code>方法;<br><code>mappingCount</code>: 返回long;<br><code>size</code>: 返回int; (实际大小超过int时无效)</p>
<p>重复遍历流: 可以使用StreamForker,缺点本质上是存了内存。</p>
<h1 id="lambda底层实现"><a href="#lambda底层实现" class="headerlink" title="lambda底层实现"></a>lambda底层实现</h1><h2 id="匿名类的实现"><a href="#匿名类的实现" class="headerlink" title="匿名类的实现"></a>匿名类的实现</h2><p>匿名内部类底层是生成一个<code>class$1</code>的类。(外层类名+数字)<br>缺点： 每个类都需要加载、验证的操作，如果类太多，开销太大；</p>
<h2 id="查看字节码和常量池"><a href="#查看字节码和常量池" class="headerlink" title="查看字节码和常量池"></a>查看字节码和常量池</h2><p>使用命令:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javap -c -v ClassName</span><br></pre></td></tr></table></figure>


<h2 id="lambda的实现：-InvokeDynamic"><a href="#lambda的实现：-InvokeDynamic" class="headerlink" title="lambda的实现： InvokeDynamic"></a>lambda的实现： InvokeDynamic</h2><p>本质上是在所在类里新增了一个方法。将Lambda表达式的代码体填入到运行时动态创建的<code>静态方法</code>，就完成了Lambda表达式的字节码转换。<br>动态链接方法，然后用<code>InvokeDynamic</code>调用:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Lambda</span> </span>&#123;</span><br><span class="line">    Function&lt;Object, String&gt; f = [dynamic invocation of lambda$<span class="number">1</span>]</span><br><span class="line">     <span class="keyword">static</span> String lambda$<span class="number">1</span>(Object obj) &#123;</span><br><span class="line">        <span class="keyword">return</span> obj.toString();</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>优点:</p>
<ol>
<li>lamda相关字节码的生成推迟到使用的时候; (懒加载)</li>
<li>如果不是闭包：有类似于static final变量的缓存效果;(闭包的话,因为可能捕获不同的局部变量，不可以缓存)</li>
<li>没有额外的开销;<br>如果lambda是个闭包，也就是捕获了其他作用域内的变量(当然编译时会要求是final或者实质上是final)，也很简单，就是给这个函数加一个参数即可。</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://xiaoyue26.github.io/2019/11/03/2019-11/java8%E7%AC%94%E8%AE%B0/" data-id="ck96cxpqb00kcmaam9w6ucaoz" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/" rel="tag">java</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-2019-10/rust入门笔记-2" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/10/06/2019-10/rust%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0-2/" class="article-date">
  <time datetime="2019-10-06T10:58:26.000Z" itemprop="datePublished">2019-10-06</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/rust/">rust</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/10/06/2019-10/rust%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0-2/">rust入门笔记_2</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <h1 id="解引用强制多态（deref-coercions）"><a href="#解引用强制多态（deref-coercions）" class="headerlink" title="解引用强制多态（deref coercions）"></a>解引用强制多态（<code>deref coercions</code>）</h1><p><code>coercions</code>的意思就是强制多态。<br>解引用强制多态的意思通俗来说就是，编译器根据目标类型，自动调用<code>deref</code>方法解引用，搜索路径来达到目标类型，最终达到节省程序员编写成本，但最后运行时开销维持最小的目标。(语法糖成本为0)</p>
<h2 id="背景知识-智能指针的解引用"><a href="#背景知识-智能指针的解引用" class="headerlink" title="背景知识: 智能指针的解引用"></a>背景知识: 智能指针的解引用</h2><p>自定义的智能指针，实现<code>Deref trait</code>(解引用特性)后，就可以使用<code>*</code>操作符来解引用了。<br>例如:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::ops::Deref;</span><br><span class="line"></span><br><span class="line"># <span class="class"><span class="keyword">struct</span> <span class="title">MyBox</span></span>&lt;T&gt;(T);</span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; Deref <span class="keyword">for</span> MyBox&lt;T&gt; &#123;</span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">Target</span></span> = T;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">deref</span></span>(&amp;<span class="keyword">self</span>) -&gt; &amp;T &#123; <span class="comment">// 注意这里的返回值需要是引用,以便维持所有权</span></span><br><span class="line">        &amp;<span class="keyword">self</span>.<span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译器每次遇到<code>*</code>操作符，都会尝试调用复杂类型的<code>deref</code>方法来获得基本类型的引用，以便进行解引用，也就是代码等效于:<code>*(y.deref())</code>。</p>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> m = MyBox::new(<span class="built_in">String</span>::from(<span class="string">"Rust"</span>));</span><br><span class="line">hello(&amp;m); <span class="comment">// 这里hello的形参是&amp;str,实参是&amp;MyBox</span></span><br><span class="line"><span class="comment">// 强制解引用多态后，等效于调用了: hello(&amp;(*m)[..]);</span></span><br><span class="line"><span class="comment">// &amp;MyBox =通过deref=&gt; String =通过slice=&gt; &amp;str</span></span><br></pre></td></tr></table></figure>

<h2 id="更多解引用多态规则"><a href="#更多解引用多态规则" class="headerlink" title="更多解引用多态规则"></a>更多解引用多态规则</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>. 当 T: Deref&lt;Target=U&gt; 时从 &amp;T 到 &amp;U。 <span class="comment">// 不可变=&gt;不可变</span></span><br><span class="line"><span class="number">2</span>. 当 T: DerefMut&lt;Target=U&gt; 时从 &amp;<span class="keyword">mut</span> T 到 &amp;<span class="keyword">mut</span> U。 <span class="comment">// 可变=&gt;可变</span></span><br><span class="line"><span class="number">3</span>. 当 T: Deref&lt;Target=U&gt; 时从 &amp;<span class="keyword">mut</span> T 到 &amp;U。 <span class="comment">// 可变=&gt;不可变</span></span><br></pre></td></tr></table></figure>
<p>只会发生安全的转换，而<code>不可变=&gt;可变</code>这种属于不安全，因此不支持自动转换。</p>
<p>(上面的实例属于第一种。)</p>
<h1 id="析构函数-std-mem-drop"><a href="#析构函数-std-mem-drop" class="headerlink" title="(析构函数) std::mem::drop"></a>(析构函数) std::mem::drop</h1><p>自定义Drop trait:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="built_in">Drop</span> <span class="keyword">for</span> CustomSmartPointer &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">drop</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"Dropping CustomSmartPointer with data `&#123;&#125;`!"</span>, <span class="keyword">self</span>.data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定义以后drop函数不能显式调用，也不能禁用。<br>只能在离开作用域的时候自动调用。<br>如果要显式调用，只能使用标准库的函数<code>std::mem::drop</code>.<br>(默认预引入，可以直接调用drop)</p>
<h1 id="智能指针汇总"><a href="#智能指针汇总" class="headerlink" title="智能指针汇总"></a>智能指针汇总</h1><p>Box: 没有特殊功能,类似于java中的普通引用,让编译器能确定分配空间大小;<br>Rc: 多所有权、单线程、引用计数;<br>RefCell: 单所有权、单线程、引用计数、内部可变性;<br>Arc: 多所有权、多线程、引用计数;<br>Mutex: 单所有权、多线程、引用计数、内部可变性;<br>Week: 弱引用。</p>
<h1 id="多所有权、单线程、不可变：引用计数-gt-Rc"><a href="#多所有权、单线程、不可变：引用计数-gt-Rc" class="headerlink" title="多所有权、单线程、不可变：引用计数=&gt;Rc"></a>多所有权、单线程、不可变：引用计数=&gt;Rc<T></h1><p>多所有权示例: b,c都拥有a的所有权。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">List</span></span> &#123;</span><br><span class="line">    Cons(<span class="built_in">i32</span>, Rc&lt;List&gt;),</span><br><span class="line">    Nil,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> List::&#123;Cons, Nil&#125;;</span><br><span class="line"><span class="keyword">use</span> std::rc::Rc;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> a = Rc::new(Cons(<span class="number">5</span>, Rc::new(Cons(<span class="number">10</span>, Rc::new(Nil)))));</span><br><span class="line">    <span class="keyword">let</span> b = Cons(<span class="number">3</span>, Rc::clone(&amp;a));</span><br><span class="line">    <span class="keyword">let</span> c = Cons(<span class="number">4</span>, Rc::clone(&amp;a));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每次调用<code>Rc::clone</code>，都将引用计数加1.// 这里是浅拷贝<br>b: 3-&gt;5-&gt;10-&gt;Nil<br>c: 4-&gt;5-&gt;10-&gt;Nil</p>
<p>打印引用数:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> a = Rc::new(Cons(<span class="number">5</span>, Rc::new(Cons(<span class="number">10</span>, Rc::new(Nil)))));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"count after creating a = &#123;&#125;"</span>, Rc::strong_count(&amp;a));</span><br><span class="line">    <span class="keyword">let</span> b = Cons(<span class="number">3</span>, Rc::clone(&amp;a));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"count after creating b = &#123;&#125;"</span>, Rc::strong_count(&amp;a));</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> c = Cons(<span class="number">4</span>, Rc::clone(&amp;a));</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"count after creating c = &#123;&#125;"</span>, Rc::strong_count(&amp;a));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"count after c goes out of scope = &#123;&#125;"</span>, Rc::strong_count(&amp;a));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="单一所有权、单线程、内部可变：引用计数-gt-RefCell"><a href="#单一所有权、单线程、内部可变：引用计数-gt-RefCell" class="headerlink" title="单一所有权、单线程、内部可变：引用计数=&gt;RefCell"></a>单一所有权、单线程、内部可变：引用计数=&gt;RefCell<T></h1><h2 id="借用规则"><a href="#借用规则" class="headerlink" title="借用规则"></a>借用规则</h2><ol>
<li>每时每刻，要么有一个可变引用;要么有n个不可变引用；(这两者互斥)</li>
<li>引用必须总是有效的。</li>
</ol>
<p>对于引用和<code>Box&lt;T&gt;</code>: <code>编译时</code>进行借用规则检查；(编译错误)<br>对于<code>RefCell&lt;T&gt;</code>:   <code>运行时</code>进行借用规则检查；(<code>panic</code>)</p>
<p>引用和<code>Box&lt;T&gt;</code>: 第一级指针不可变，则级联得每一级都不可变。<br><code>RefCell</code>: 第一级指针不可变，第二级可以借用可变引用，然后修改；</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[cfg(test)]</span></span><br><span class="line"><span class="keyword">mod</span> tests &#123;</span><br><span class="line">    <span class="keyword">use</span> super::*;</span><br><span class="line">    <span class="keyword">use</span> std::cell::RefCell;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">MockMessenger</span></span> &#123;</span><br><span class="line">        sent_messages: RefCell&lt;<span class="built_in">Vec</span>&lt;<span class="built_in">String</span>&gt;&gt;,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">impl</span> MockMessenger &#123;</span><br><span class="line">        <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>() -&gt; MockMessenger &#123;</span><br><span class="line">            MockMessenger &#123; sent_messages: RefCell::new(<span class="built_in">vec!</span>[]) &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">impl</span> Messenger <span class="keyword">for</span> MockMessenger &#123;</span><br><span class="line">        <span class="function"><span class="keyword">fn</span> <span class="title">send</span></span>(&amp;<span class="keyword">self</span>, message: &amp;<span class="built_in">str</span>) &#123;</span><br><span class="line">        <span class="comment">// 注意这里的borrow_mut，借出可变:</span></span><br><span class="line">            <span class="keyword">self</span>.sent_messages.borrow_mut().push(<span class="built_in">String</span>::from(message));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">it_sends_an_over_75_percent_warning_message</span></span>() &#123;</span><br><span class="line">        <span class="comment">// --snip--</span></span><br><span class="line">#         <span class="keyword">let</span> mock_messenger = MockMessenger::new();</span><br><span class="line">#         <span class="keyword">let</span> <span class="keyword">mut</span> limit_tracker = LimitTracker::new(&amp;mock_messenger, <span class="number">100</span>);</span><br><span class="line">#         limit_tracker.set_value(<span class="number">75</span>);</span><br><span class="line">        <span class="comment">// 注意这里的borrow，借出不可变:</span></span><br><span class="line">        <span class="built_in">assert_eq!</span>(mock_messenger.sent_messages.borrow().len(), <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>borrow</code> 方法返回 <code>Ref</code> 类型的智能指针；<br><code>borrow_mut</code> 方法返回 <code>RefMut</code> 类型的智能指针。</p>
<p>这两个类型都实现了 <code>Deref</code> 所以可以当作常规引用对待。<br>借用规则在运行时检查，例如同时借出两个可变引用将会panic:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> one_borrow = <span class="keyword">self</span>.sent_messages.borrow_mut();</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> two_borrow = <span class="keyword">self</span>.sent_messages.borrow_mut();</span><br></pre></td></tr></table></figure>
<p>底层原理依然是引用计数。</p>
<h2 id="结合Rc和RefCell"><a href="#结合Rc和RefCell" class="headerlink" title="结合Rc和RefCell"></a>结合Rc和RefCell</h2><p>结合Rc和RefCell的话，就可以结合多所有权和单所有权，不可变和可变:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">List</span></span> &#123;</span><br><span class="line">    Cons(Rc&lt;RefCell&lt;<span class="built_in">i32</span>&gt;&gt;, Rc&lt;List&gt;),<span class="comment">// 注意这里</span></span><br><span class="line">    Nil,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> List::&#123;Cons, Nil&#125;;</span><br><span class="line"><span class="keyword">use</span> std::rc::Rc;</span><br><span class="line"><span class="keyword">use</span> std::cell::RefCell;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> value = Rc::new(RefCell::new(<span class="number">5</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> a = Rc::new(Cons(Rc::clone(&amp;value), Rc::new(Nil)));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> b = Cons(Rc::new(RefCell::new(<span class="number">6</span>)), Rc::clone(&amp;a));</span><br><span class="line">    <span class="keyword">let</span> c = Cons(Rc::new(RefCell::new(<span class="number">10</span>)), Rc::clone(&amp;a));</span><br><span class="line"></span><br><span class="line">    *value.borrow_mut() += <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"a after = &#123;:?&#125;"</span>, a);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"b after = &#123;:?&#125;"</span>, b);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"c after = &#123;:?&#125;"</span>, c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>混合使用<code>Rc</code>和<code>RefCell</code>可以构造循环引用，造成内存泄露。<br>可以用弱引用来消除这一隐患: 将 <code>Rc&lt;T&gt;</code> 变为 <code>Weak&lt;T&gt;</code>。</p>
<h1 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h1><p><a href="https://rustlang-cn.org/office/rust/book/smart-pointers/ch15-06-reference-cycles.html" target="_blank" rel="noopener">https://rustlang-cn.org/office/rust/book/smart-pointers/ch15-06-reference-cycles.html</a></p>
<h1 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h1><h2 id="线程模型"><a href="#线程模型" class="headerlink" title="线程模型"></a>线程模型</h2><p>rust标准库提供1:1线程，有其他第三方库提供M:N的。<br>创建线程: <code>thread::spawn</code>+闭包：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"><span class="keyword">use</span> std::time::Duration;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> handle = thread::spawn(|| &#123;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span>..<span class="number">10</span> &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">"hi number &#123;&#125; from the spawned thread!"</span>, i);</span><br><span class="line">            thread::sleep(Duration::from_millis(<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span>..<span class="number">5</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"hi number &#123;&#125; from the main thread!"</span>, i);</span><br><span class="line">        thread::sleep(Duration::from_millis(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    handle.join().unwrap();<span class="comment">// 阻塞等待子线程</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>子线程中可以捕获主线程的变量，获得所有权. 使用<code>move</code>，以免主线程把它drop了：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> v = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> handle = thread::spawn(<span class="keyword">move</span> || &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"Here's a vector: &#123;:?&#125;"</span>, v);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    handle.join().unwrap();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="消息传递-channel"><a href="#消息传递-channel" class="headerlink" title="消息传递: channel"></a>消息传递: channel</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"><span class="keyword">use</span> std::sync::mpsc;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> (tx, rx) = mpsc::channel();</span><br><span class="line">    <span class="comment">// tx: 发送者</span></span><br><span class="line">    <span class="comment">// rx: 接收者</span></span><br><span class="line">    thread::spawn(<span class="keyword">move</span> || &#123;</span><br><span class="line">        <span class="keyword">let</span> val = <span class="built_in">String</span>::from(<span class="string">"hi"</span>);</span><br><span class="line">        tx.send(val).unwrap();<span class="comment">// 单所有权,发送后不能再使用val</span></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> received = rx.recv().unwrap();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Got: &#123;&#125;"</span>, received);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>mpsc： 多生产者、单消费者<br>recv： 阻塞接收<br>try_recv: 非阻塞接收，立即返回</p>
<p>这里之所以是多生产者，是因为可以把生产者无限克隆出去，然后发送消息：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> tx1 = mpsc::Sender::clone(&amp;tx);</span><br></pre></td></tr></table></figure>

<h2 id="共享状态并发"><a href="#共享状态并发" class="headerlink" title="共享状态并发"></a>共享状态并发</h2><h2 id="互斥器-mutex"><a href="#互斥器-mutex" class="headerlink" title="互斥器(mutex)"></a>互斥器(mutex)</h2><p>rust中的锁是一种特殊的智能指针，通过重载drop trait来确保离开作用域的时候释放锁。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::sync::Mutex;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> m = Mutex::new(<span class="number">5</span>);</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> num = m.lock().unwrap();</span><br><span class="line">        *num = <span class="number">6</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"m = &#123;:?&#125;"</span>, m);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于多个线程都需要访问同一个锁，因此需要多所有权的智能指针，并且能够并发使用：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Rc&lt;T&gt;: 单线程，多所有权；</span><br><span class="line">Arc&lt;T&gt;: 多线程，多所有权。</span><br></pre></td></tr></table></figure>
<p>并发访问的例子:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::sync::&#123;Mutex, Arc&#125;;</span><br><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> counter = Arc::new(Mutex::new(<span class="number">0</span>));<span class="comment">// 智能指针包装</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> handles = <span class="built_in">vec!</span>[];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="number">0</span>..<span class="number">10</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> counter = Arc::clone(&amp;counter);<span class="comment">// 克隆来增加引用计数</span></span><br><span class="line">        <span class="keyword">let</span> handle = thread::spawn(<span class="keyword">move</span> || &#123; </span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut</span> num = counter.lock().unwrap();</span><br><span class="line"></span><br><span class="line">            *num += <span class="number">1</span>; <span class="comment">// move+离开作用域,引用-1</span></span><br><span class="line">        &#125;);</span><br><span class="line">        handles.push(handle);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> handle <span class="keyword">in</span> handles &#123;</span><br><span class="line">        handle.join().unwrap();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Result: &#123;&#125;"</span>, *counter.lock().unwrap());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里可以看出Mutex具有内部可变性。同时可以用Mutex构造死锁(循环依赖)。</p>
<h2 id="Send与Sync的trait"><a href="#Send与Sync的trait" class="headerlink" title="Send与Sync的trait"></a>Send与Sync的trait</h2><p>rust中用两个trait来标记所有权在线程中的转移以及引用的多线程访问: </p>
<blockquote>
<p><code>Send trait</code>:  支持多线程<code>所有权</code>转移,所有权在线程之间转移; 除Rc<T>以外的大部分类型是Send trait;<br><code>Sync trait</code>:  支持多线程访问, 线程之间可以共享值的<code>引用</code>；<br>除Rc<T>以外的大部分类型是Sync trait;</p>
</blockquote>
<p><code>unsafe rust</code>中的裸指针也没有实现这两个trait.</p>
<p>绝大部分情况不需要手动实现send与sync的trait。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://xiaoyue26.github.io/2019/10/06/2019-10/rust%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0-2/" data-id="ck96cxpqb00k9maamb1qe6pmi" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/rust/" rel="tag">rust</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-2019-09/rust入门笔记-1" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/09/22/2019-09/rust%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0-1/" class="article-date">
  <time datetime="2019-09-22T11:20:21.000Z" itemprop="datePublished">2019-09-22</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/rust/">rust</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/09/22/2019-09/rust%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0-1/">rust入门笔记_1</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <p>周末无事看看tidb开发者说很好用的rust，觉得很有趣，原来现代编程语言就是这种感觉，有一些细节上的简化。</p>
<p>文档参见: <a href="https://rustlang-cn.org/office/rust/book/getting-started/ch01-03-hello-cargo.html" target="_blank" rel="noopener">https://rustlang-cn.org/office/rust/book/getting-started/ch01-03-hello-cargo.html</a></p>
<p>源码:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Hello, world!"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译和运行:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rustc main.rs</span><br><span class="line">./main</span><br></pre></td></tr></table></figure>

<p>用<code>cargo</code>(类似于<code>maven</code>)</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cargo new hello_cargo # 创建项目</span><br><span class="line">cargo build # 生成debug程序</span><br><span class="line">cargo run # 运行debug程序, 会自动build</span><br><span class="line">cargo check # 仅检查语法</span><br><span class="line"></span><br><span class="line">cargo build --release # 生成优化后的程序(release)</span><br><span class="line"><span class="meta">#</span><span class="bash"> 类似的可以猜到run release程序的命令:</span></span><br><span class="line">cargo run --rebase # 运行relase，会自动检测改动重新编译</span><br></pre></td></tr></table></figure>
<p>可以看到专门提供了一个<code>cargo check</code>命令来避免编译、只是检查语法，看来网上大家说rust编译慢很可能是真的。</p>
<h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> foo = <span class="number">5</span>; <span class="comment">// 不可变</span></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> bar = <span class="number">5</span>; <span class="comment">// 可变</span></span><br></pre></td></tr></table></figure>

<p>类方法/静态函数: 在rust中叫<code>关联函数</code>（associated function）;</p>
<h1 id="crate-库"><a href="#crate-库" class="headerlink" title="crate: 库"></a>crate: 库</h1><p>类似于mvn的中央仓库: <a href="https://crates.io/" target="_blank" rel="noopener">https://crates.io/</a><br><code>crate</code>不是创建的意思，差了一个字母，是rust的库的意思。</p>
<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><p><code>i32</code>: 32位数字；<br><code>u32</code>: 32位无符号数字；<br><code>i64</code>: 64位数字等等。</p>
<p><code>Rust</code>默认使用<code>i32</code>.<br>但是如果你用<code>u32</code>类型和一个变量<code>a</code>比较,Rust会推断出a也是<code>u32</code>类型.</p>
<h1 id="let关键字"><a href="#let关键字" class="headerlink" title="let关键字"></a>let关键字</h1><p><code>let</code>类似于js里的<code>let</code>，用来定义一个变量，而且支持<code>shadowing</code>。<br>比如一开始定义了一个string类型的a;<br>后来转换成数字以后，可以直接</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a:<span class="built_in">u32</span> = a.guess.trim().parse()</span><br><span class="line">        .expect(<span class="string">"Please type a number!"</span>);</span><br></pre></td></tr></table></figure>
<p>新的定义会覆盖以前的，这样就不用定义两个变量了（一个string_a,一个u32_a）。<br>原理上其实底层是生成了两个变量，因此可以把<code>let mut</code>覆盖成<code>let</code>，或者把不可变的覆盖成可变的。实测了一下确实也是可以的。</p>
<h1 id="match关键字"><a href="#match关键字" class="headerlink" title="match关键字"></a>match关键字</h1><p>match和scala里的一样</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">match</span> xxx &#123;</span><br><span class="line">        Ordering::Less =&gt; <span class="built_in">println!</span>(<span class="string">"Too small!"</span>),</span><br><span class="line">        Ordering::Greater =&gt; <span class="built_in">println!</span>(<span class="string">"Too big!"</span>),</span><br><span class="line">        Ordering::Equal =&gt; <span class="built_in">println!</span>(<span class="string">"You win!"</span>),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="通用概念-与其他编程语言核心对应的"><a href="#通用概念-与其他编程语言核心对应的" class="headerlink" title="通用概念(与其他编程语言核心对应的)"></a>通用概念(与其他编程语言核心对应的)</h1><h2 id="关键字转义"><a href="#关键字转义" class="headerlink" title="关键字转义"></a>关键字转义</h2><p>比如<code>match</code>在rust中是一个关键字,所以如果恰好有一个函数叫这个名字，需要转义以后才能调用：(用<code>r#</code>前缀)</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">r#<span class="keyword">match</span>(); <span class="comment">// 调用名为 'match' 的函数</span></span><br></pre></td></tr></table></figure>

<h2 id="不可变"><a href="#不可变" class="headerlink" title="不可变"></a>不可变</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> MAX_POINTS: <span class="built_in">u32</span> = <span class="number">100_000</span>; <span class="comment">// 不可变,直接赋值;</span></span><br><span class="line"><span class="keyword">let</span> a = get_val(); <span class="comment">// 不可变,可以运行时赋值;</span></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> a = xxx;   <span class="comment">// 可变。</span></span><br></pre></td></tr></table></figure>

<h2 id="数据类型-1"><a href="#数据类型-1" class="headerlink" title="数据类型"></a>数据类型</h2><p>rust会尝试推断数据类型，推断不出来则会报错；</p>
<p>标量: 整型、浮点型、布尔类型和字符类型;</p>
<table>
<thead>
<tr>
<th>长度</th>
<th>有符号</th>
<th>无符号</th>
</tr>
</thead>
<tbody><tr>
<td>8-bit</td>
<td>i8</td>
<td>u8</td>
</tr>
<tr>
<td>16-bit</td>
<td>i16</td>
<td>u16</td>
</tr>
<tr>
<td>32-bit</td>
<td>i32</td>
<td>u32</td>
</tr>
<tr>
<td>64-bit</td>
<td>i64</td>
<td>u64</td>
</tr>
<tr>
<td>arch</td>
<td>isize</td>
<td>usize</td>
</tr>
</tbody></table>
<p>这里的<code>arch</code>: 64 位架构上它们是 64 位的， 32 位架构上它们是 32 位的。<br><code>isize</code>和<code>usize</code>主要作为索引类型。</p>
<p>赋值的时候: (还能在中间随意加横杠<code>_</code>):</p>
<table>
<thead>
<tr>
<th>数字字面值</th>
<th>例子</th>
</tr>
</thead>
<tbody><tr>
<td>Decimal</td>
<td>98_222</td>
</tr>
<tr>
<td>Hex</td>
<td>0xff</td>
</tr>
<tr>
<td>Octal</td>
<td>0o77</td>
</tr>
<tr>
<td>Binary</td>
<td>0b1111_0000</td>
</tr>
<tr>
<td>Byte (u8 only)</td>
<td>b’A’</td>
</tr>
</tbody></table>
<p><code>57u8</code>表示57，数据类型是<code>u8</code>；</p>
<p>数字溢出: debug版检查溢出并报错；<br>release版会进行溢出。<br>可以用<code>Wrapping</code>类型来使用溢出特性，以免被debug版本报错。</p>
<p><code>f32</code>: 32位浮点数;<br><code>f64</code>: 64位浮点数. (默认类型,现代cpu下性能与f32几乎一样)<br><code>bool</code>: 布尔值。<br><code>char</code>: Unicode字符。</p>
<h2 id="元组和数组"><a href="#元组和数组" class="headerlink" title="元组和数组"></a>元组和数组</h2><p>元组下标从0开始(和scala不同,scala从1开始)</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> tup: (<span class="built_in">i32</span>, <span class="built_in">f64</span>, <span class="built_in">u8</span>) = (<span class="number">500</span>, <span class="number">6.4</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">let</span> five_hundred = x.<span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>数组:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="comment">// 或:</span></span><br><span class="line"><span class="keyword">let</span> a: [<span class="built_in">i32</span>; <span class="number">5</span>] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br></pre></td></tr></table></figure>


<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>用fn声明. </p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    another_function(<span class="number">5</span>, <span class="number">6</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">another_function</span></span>(x: <span class="built_in">i32</span>, y: <span class="built_in">i32</span>) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"The value of x is: &#123;&#125;"</span>, x);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"The value of y is: &#123;&#125;"</span>, y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">five</span></span>() -&gt; <span class="built_in">i32</span> &#123; <span class="comment">// 返回i32类型</span></span><br><span class="line">    <span class="number">5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h2><p>表达式的结尾没有分号</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> y = &#123;</span><br><span class="line">        <span class="keyword">let</span> x = <span class="number">3</span>;</span><br><span class="line">        x + <span class="number">1</span> <span class="comment">// 没有分号</span></span><br><span class="line">    &#125;;</span><br><span class="line"><span class="comment">// y=4</span></span><br></pre></td></tr></table></figure>
<h2 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h2><p>loop,while,for</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> result = <span class="keyword">loop</span> &#123;</span><br><span class="line">    counter += <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> counter == <span class="number">10</span> &#123;</span><br><span class="line">        <span class="keyword">break</span> counter * <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">assert_eq!</span>(result, <span class="number">20</span>);</span><br><span class="line"><span class="keyword">while</span> index &lt; <span class="number">5</span> &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"the value is: &#123;&#125;"</span>, a[index]);</span><br><span class="line">    index = index + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> a = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>];</span><br><span class="line"><span class="keyword">for</span> element <span class="keyword">in</span> a.iter() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"the value is: &#123;&#125;"</span>, element);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> number <span class="keyword">in</span> (<span class="number">1</span>..<span class="number">4</span>).rev() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;!"</span>, number);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="ownership-所有权"><a href="#ownership-所有权" class="headerlink" title="ownership 所有权"></a>ownership 所有权</h1><p>rust无需gc。<br>要学习的点包括: 借用、slice、内存布局。</p>
<blockquote>
<p>所有权：管理堆数据</p>
</blockquote>
<p>所有权的三大法则: </p>
<blockquote>
<ol>
<li>Rust中的每一个值都有一个被称为其 所有者（owner）的变量。</li>
<li>值有且只有一个所有者。</li>
<li>当所有者（变量）离开作用域，这个值将被丢弃。</li>
</ol>
</blockquote>
<p>创建一个堆上的变量:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="keyword">let</span> s = <span class="built_in">String</span>::from(<span class="string">"hello"</span>);</span><br><span class="line">s.push_str(<span class="string">", world!"</span>); <span class="comment">// 追加</span></span><br><span class="line">&#125;<span class="comment">// rust自动调用s的drop,回收内存(类似于free\RAII模式)</span></span><br></pre></td></tr></table></figure>
<p>s的大小运行时可变，因此它显然分配在堆上。(栈每个slot大小相同)</p>
<h2 id="浅拷贝、深拷贝、移动"><a href="#浅拷贝、深拷贝、移动" class="headerlink" title="浅拷贝、深拷贝、移动"></a>浅拷贝、深拷贝、移动</h2><p>rust对复杂类型默认是移动;<br>基本类型直接深拷贝。<br>rust没有浅拷贝、只有移动。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 移动:</span></span><br><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">String</span>::from(<span class="string">"hello"</span>);</span><br><span class="line"><span class="keyword">let</span> s2 = s1;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">"&#123;&#125;, world!"</span>, s1); <span class="comment">// fail,s1已经无效,被移动为s2了。</span></span><br><span class="line"><span class="comment">// 深拷贝:</span></span><br><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">String</span>::from(<span class="string">"hello"</span>);</span><br><span class="line"><span class="keyword">let</span> s2 = s1.clone();</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">"s1 = &#123;&#125;, s2 = &#123;&#125;"</span>, s1, s2);</span><br><span class="line"><span class="comment">// 基本类型:</span></span><br><span class="line"><span class="keyword">let</span> x = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">let</span> y = x;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">"x = &#123;&#125;, y = &#123;&#125;"</span>, x, y);</span><br></pre></td></tr></table></figure>
<p>总结就是:<br>浅拷贝: 无;<br>深拷贝: 显式调用<code>clone</code>、或者是基本类型;<br>移动:   复杂类型;</p>
<p>如果一个类型拥有<code>Copy trait</code>,<br>一个旧的变量在将其赋值给其他变量后仍然可用。<br>rust的逻辑是，如果发现一个类型没有实现<code>Copy</code>，它就进行<code>move</code>。</p>
<p>除了用等号，调用函数时也会发生移动或者深拷贝。<br>例如:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="built_in">String</span>::from(<span class="string">"hello"</span>);  <span class="comment">// s 进入作用域</span></span><br><span class="line">takes_ownership(s);             <span class="comment">// s 的值移动到函数里 ...</span></span><br><span class="line">                                <span class="comment">// ... 所以到这里s不再有效</span></span><br></pre></td></tr></table></figure>
<p>函数return的时候也类似于等号，也会发生移动或者深拷贝，因此可以用return再取回所有权。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="built_in">String</span>::from(<span class="string">"hello"</span>);</span><br><span class="line"><span class="keyword">let</span> s = takes_back_ownership(s);</span><br></pre></td></tr></table></figure>
<p>可以用<code>&amp;</code>号来简化这个过程:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">String</span>::from(<span class="string">"hello"</span>);</span><br><span class="line"><span class="keyword">let</span> len = calculate_length(&amp;s1); <span class="comment">// 多一个&amp;来取回所有权</span></span><br></pre></td></tr></table></figure>
<p>这里<code>calculate_length</code>函数没有所有权，因此是借用了s1变量。</p>
<h2 id="借用"><a href="#借用" class="headerlink" title="借用"></a>借用</h2><p>函数借用变量s,不拥有所有权。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> s = <span class="built_in">String</span>::from(<span class="string">"hello"</span>);</span><br><span class="line">    change(&amp;<span class="keyword">mut</span> s);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">change</span></span>(some_string: &amp;<span class="keyword">mut</span> <span class="built_in">String</span>) &#123;</span><br><span class="line">    some_string.push_str(<span class="string">", world"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>借用并且要修改的话，要显式写上<code>&amp;mut</code>.</p>
<h3 id="借用的竞态"><a href="#借用的竞态" class="headerlink" title="借用的竞态"></a>借用的竞态</h3><p>rust默认禁止竞态,编译不予通过:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> s = <span class="built_in">String</span>::from(<span class="string">"hello"</span>);</span><br><span class="line"><span class="keyword">let</span> r1 = &amp;<span class="keyword">mut</span> s;</span><br><span class="line"><span class="keyword">let</span> r2 = &amp;<span class="keyword">mut</span> s;<span class="comment">// 如果后续都用的话报错,两个变量都借用了s,而且都是可写，有竞态,在同一作用域内。</span></span><br><span class="line"><span class="comment">// 只读引用的话可以有多个:</span></span><br><span class="line"><span class="keyword">let</span> r1 = &amp;s; <span class="comment">// no problem</span></span><br><span class="line"><span class="keyword">let</span> r2 = &amp;s; <span class="comment">// no problem</span></span><br><span class="line"><span class="keyword">let</span> r3 = &amp;<span class="keyword">mut</span> s; <span class="comment">// BIG PROBLEM 有只读引用的时候，也不能再有可写引用</span></span><br></pre></td></tr></table></figure>
<p>借用结束的话可以消除竞态:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> a = <span class="built_in">String</span>::from(<span class="string">"hello world"</span>);</span><br><span class="line"><span class="keyword">let</span> b = &amp;a[<span class="number">0</span>..<span class="number">4</span>];</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, b);</span><br><span class="line">append_a(&amp;<span class="keyword">mut</span> a);<span class="comment">// 这里没问题,因为b后面没有用到。</span></span><br><span class="line"><span class="comment">// println!("&#123;&#125;", b); // 这里会报错，因为b的作用域和a的有交叉。</span></span><br></pre></td></tr></table></figure>

<h3 id="悬挂指针"><a href="#悬挂指针" class="headerlink" title="悬挂指针"></a>悬挂指针</h3><p>Rust 中编译器确保永远不会有悬挂指针。<br>构造悬挂指针: </p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> reference_to_nothing = dangle();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">dangle</span></span>() -&gt; &amp;<span class="built_in">String</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> s = <span class="built_in">String</span>::from(<span class="string">"hello"</span>);</span><br><span class="line">    &amp;s <span class="comment">// 编译失败</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="slice"><a href="#slice" class="headerlink" title="slice"></a>slice</h2><p>slice的类型多一个&amp;,属于不可变引用。<br>比如string的slice类型: <code>&amp;str</code>，<br>字符串的字面量的类型：<code>str</code><br>slice语法很简单:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="built_in">String</span>::from(<span class="string">"hello"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> slice = &amp;s[<span class="number">0</span>..<span class="number">2</span>];</span><br><span class="line"><span class="keyword">let</span> slice = &amp;s[..<span class="number">2</span>];</span><br><span class="line"><span class="keyword">let</span> slice = &amp;s[<span class="number">0</span>..len]; <span class="comment">// 整个字符串</span></span><br><span class="line"><span class="keyword">let</span> slice = &amp;s[..]; <span class="comment">// 省略头尾</span></span><br><span class="line"><span class="comment">// 包含右端点:</span></span><br><span class="line"><span class="keyword">let</span> hello = &amp;s[<span class="number">0</span>..=<span class="number">4</span>];</span><br></pre></td></tr></table></figure>
<p>用slice的好处是可以预防错误，因为持有了不可变引用，其他试图修改s的操作就会被阻止，因为修改s的时候会申请可变引用，根据上一节中的竞态阻止，申请可变引用会失败。</p>
<h3 id="数组的slice"><a href="#数组的slice" class="headerlink" title="数组的slice"></a>数组的slice</h3><p>类型是 <code>&amp;[i32]</code></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">let</span> slice = &amp;a[<span class="number">1</span>..<span class="number">3</span>];</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">"&#123;:?&#125;"</span>,slice);</span><br></pre></td></tr></table></figure>

<h2 id="结构体struct"><a href="#结构体struct" class="headerlink" title="结构体struct"></a>结构体struct</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># <span class="class"><span class="keyword">struct</span> <span class="title">User</span></span> &#123;</span><br><span class="line">#     username: <span class="built_in">String</span>,</span><br><span class="line">#     email: <span class="built_in">String</span>,</span><br><span class="line">#     sign_in_count: <span class="built_in">u64</span>,</span><br><span class="line">#     active: <span class="built_in">bool</span>,</span><br><span class="line"># &#125;</span><br><span class="line">#</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> user1 = User &#123;</span><br><span class="line">    email: <span class="built_in">String</span>::from(<span class="string">"someone@example.com"</span>),</span><br><span class="line">    username: <span class="built_in">String</span>::from(<span class="string">"someusername123"</span>),</span><br><span class="line">    active: <span class="literal">true</span>,</span><br><span class="line">    sign_in_count: <span class="number">1</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">user1.email = <span class="built_in">String</span>::from(<span class="string">"anotheremail@example.com"</span>);</span><br></pre></td></tr></table></figure>
<p>以前写代码经常会有<code>this.email=email</code>这种机械重复的代码，rust提供了简写省略的方法。<br>构造函数的简写: (<code>new</code>)</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">build_user</span></span>(email: <span class="built_in">String</span>, username: <span class="built_in">String</span>) -&gt; User &#123;</span><br><span class="line">    User &#123;</span><br><span class="line">        email, <span class="comment">// 这里省略了同名输入变量</span></span><br><span class="line">        username,</span><br><span class="line">        active: <span class="literal">true</span>,</span><br><span class="line">        sign_in_count: <span class="number">1</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类似的，结构体的update也有相应的简写:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> user2 = User &#123;</span><br><span class="line">    email: <span class="built_in">String</span>::from(<span class="string">"another@example.com"</span>),</span><br><span class="line">    username: <span class="built_in">String</span>::from(<span class="string">"anotherusername567"</span>),</span><br><span class="line">    ..user1 <span class="comment">// 这句话的意思是其他变量都按user1的值来赋值就好</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>结构体的实例方法和类方法区别在于有没有第一个<code>&amp;self</code>参数,方法可以位于不同<code>impl</code>块中:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"># <span class="meta">#[derive(Debug)]</span></span><br><span class="line"># <span class="class"><span class="keyword">struct</span> <span class="title">Rectangle</span></span> &#123;</span><br><span class="line">#     width: <span class="built_in">u32</span>,</span><br><span class="line">#     height: <span class="built_in">u32</span>,</span><br><span class="line"># &#125;</span><br><span class="line">#</span><br><span class="line"><span class="keyword">impl</span> Rectangle &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">area</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">u32</span> &#123; <span class="comment">// 实例方法</span></span><br><span class="line">        <span class="keyword">self</span>.width * <span class="keyword">self</span>.height</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Rectangle &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">can_hold</span></span>(&amp;<span class="keyword">self</span>, other: &amp;Rectangle) -&gt; <span class="built_in">bool</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.width &gt; other.width &amp;&amp; <span class="keyword">self</span>.height &gt; other.height</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> Rectangle &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">square</span></span>(size: <span class="built_in">u32</span>) -&gt; Rectangle &#123;<span class="comment">// 关联方法、类方法</span></span><br><span class="line">        Rectangle &#123; width: size, height: size &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="自动解引用功能"><a href="#自动解引用功能" class="headerlink" title="自动解引用功能"></a>自动解引用功能</h2><p>统一<code>obj.xxx()</code>操作和<code>obj-&gt;xxx()</code>.<br>rust自动解引用:</p>
<blockquote>
<p>当使用 object.something() 调用方法时，Rust 会自动为 object 添加 &amp;、&amp;mut 或 * 以便使 object 与方法签名匹配。</p>
</blockquote>
<h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><p>枚举可以直接绑定数据类型：(类似于一种<code>typedef</code>)</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">IpAddr</span></span> &#123;</span><br><span class="line">    V4(<span class="built_in">u8</span>, <span class="built_in">u8</span>, <span class="built_in">u8</span>, <span class="built_in">u8</span>),</span><br><span class="line">    V6(<span class="built_in">String</span>),</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> home = IpAddr::V4(<span class="number">127</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">let</span> loopback = IpAddr::V6(<span class="built_in">String</span>::from(<span class="string">"::1"</span>));</span><br></pre></td></tr></table></figure>
<p>也可以作为朴素的数据(数字):</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># <span class="class"><span class="keyword">enum</span> <span class="title">IpAddrKind</span></span> &#123;</span><br><span class="line">#     V4,</span><br><span class="line">#     V6,</span><br><span class="line"># &#125;</span><br><span class="line">#</span><br><span class="line"><span class="keyword">let</span> four = IpAddrKind::V4;</span><br><span class="line"><span class="keyword">let</span> six = IpAddrKind::V6;</span><br></pre></td></tr></table></figure>
<p><code>Option</code>也是一种枚举类型。</p>
<h2 id="match"><a href="#match" class="headerlink" title="match"></a>match</h2><p>match的时候可以自动unapply枚举型:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">match</span> x &#123;</span><br><span class="line">        <span class="literal">None</span> =&gt; <span class="literal">None</span>,</span><br><span class="line">        <span class="literal">Some</span>(i) =&gt; <span class="literal">Some</span>(i + <span class="number">1</span>),</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 更复杂:</span></span><br><span class="line"># <span class="meta">#[derive(Debug)]</span> <span class="comment">// 支持直接打印</span></span><br><span class="line"># <span class="class"><span class="keyword">enum</span> <span class="title">UsState</span></span> &#123;</span><br><span class="line">#    Alabama,</span><br><span class="line">#    Alaska,</span><br><span class="line"># &#125;</span><br><span class="line">#</span><br><span class="line"># <span class="class"><span class="keyword">enum</span> <span class="title">Coin</span></span> &#123;</span><br><span class="line">#    Penny,</span><br><span class="line">#    Nickel,</span><br><span class="line">#    Dime,</span><br><span class="line">#    Quarter(UsState),</span><br><span class="line"># &#125;</span><br><span class="line">#</span><br><span class="line"><span class="keyword">match</span> coin &#123;</span><br><span class="line">        Coin::Penny =&gt; <span class="number">1</span>,</span><br><span class="line">        Coin::Nickel =&gt; <span class="number">5</span>,</span><br><span class="line">        Coin::Dime =&gt; <span class="number">10</span>,</span><br><span class="line">        Coin::Quarter(state) =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">"State quarter from &#123;:?&#125;!"</span>, state);</span><br><span class="line">            <span class="number">25</span></span><br><span class="line">        &#125;,</span><br><span class="line">        _ =&gt; (), </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里类似于最后default兜底的值是<code>_</code>,返回值是<code>()</code>也就是<code>unit</code>类型。<br><code>if let</code>是match的语法糖:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> Coin::Quarter(state) = coin &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"State quarter from &#123;:?&#125;!"</span>, state);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    count += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="包"><a href="#包" class="headerlink" title="包"></a>包</h1><p>package: 包。cargo的功能.<code>cargo new</code>生成,带有<code>Cargo.toml</code>文件;里面可以有多个库。<br>Crates： 库。很多模块构成的库；(或者程序)<br>Modules: 模块。</p>
<p>包默认生成的库：</p>
<ol>
<li><code>src/main.rs</code>; (程序、数量任意)</li>
<li><code>src/lib.rs</code>;  (库、最多1个)</li>
</ol>
<h1 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h1><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mod</span> sound &#123;<span class="comment">// 同包下可以访问</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">mod</span> instrument &#123;<span class="comment">// 公有</span></span><br><span class="line">        <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">clarinet</span></span>() &#123;<span class="comment">// 公有</span></span><br><span class="line">            <span class="comment">// 函数体</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="comment">// 绝对路径</span></span><br><span class="line">    crate::sound::instrument::clarinet();</span><br><span class="line">    <span class="comment">// 相对路径</span></span><br><span class="line">    sound::instrument::clarinet();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="super相对路径"><a href="#super相对路径" class="headerlink" title="super相对路径"></a>super相对路径</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mod</span> sound &#123;</span><br><span class="line">    <span class="keyword">mod</span> instrument &#123;</span><br><span class="line">        <span class="function"><span class="keyword">fn</span> <span class="title">clarinet</span></span>() &#123;</span><br><span class="line">            super::breathe_in();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">breathe_in</span></span>() &#123;</span><br><span class="line">        <span class="comment">// 函数体</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="use关键字引用"><a href="#use关键字引用" class="headerlink" title="use关键字引用"></a>use关键字引用</h2><p>类似于<code>import</code></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> crate::sound::instrument;</span><br><span class="line"><span class="comment">// 相对路径引入:</span></span><br><span class="line"><span class="keyword">use</span> self::sound::instrument; <span class="comment">// 一般还是用绝对路径引入</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 同名冲突处理: 使用as重命名</span></span><br><span class="line"><span class="keyword">use</span> std::fmt::<span class="built_in">Result</span>;</span><br><span class="line"><span class="keyword">use</span> std::io::<span class="built_in">Result</span> <span class="keyword">as</span> IoResult;</span><br></pre></td></tr></table></figure>
<p>默认use引入的项变成了私有，可以再加上pub让引入的项维持公有:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">use</span> crate::sound::instrument;</span><br></pre></td></tr></table></figure>

<h2 id="访问修饰符pub"><a href="#访问修饰符pub" class="headerlink" title="访问修饰符pub"></a>访问修饰符pub</h2><p>枚举<code>enum</code>: 一旦pub，则所有字段pub;<br>结构体<code>struct</code>: 必须显式设定每个字段为pub，默认是private;</p>
<h2 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h2><p>每个mod放在自己的同名文件中，其他文件中要用的时候，声明一下即可:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mod</span> sound;</span><br></pre></td></tr></table></figure>
<p>末尾是分号。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://xiaoyue26.github.io/2019/09/22/2019-09/rust%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0-1/" data-id="ck96cxpq700jtmaamfyfe6f5b" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/rust/" rel="tag">rust</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-2019-09/JNI如何优雅引用so文件" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/09/08/2019-09/JNI%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E5%BC%95%E7%94%A8so%E6%96%87%E4%BB%B6/" class="article-date">
  <time datetime="2019-09-08T10:55:58.000Z" itemprop="datePublished">2019-09-08</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/java/">java</a>►<a class="article-category-link" href="/categories/java/%E6%80%A7%E8%83%BD/">性能</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/09/08/2019-09/JNI%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E5%BC%95%E7%94%A8so%E6%96%87%E4%BB%B6/">JNI如何优雅引用so文件</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <p>JNI背景知识参见: <a href="http://xiaoyue26.github.io/2019/09/07/2019-09/JNI%E6%80%BB%E7%BB%93/">http://xiaoyue26.github.io/2019/09/07/2019-09/JNI%E6%80%BB%E7%BB%93/</a></p>
<p>总之假设我们到了临门一脚想要引用so文件到时候,方法有很多种,大致分为两大类:</p>
<ol>
<li>预先把so文件部署到运行的机器特定目录,代码里使用绝对路径加载;</li>
<li>把so文件打包到resource目录,运行时用相对路径加载。</li>
</ol>
<p>主要推荐绝对路径的姿势2和相对路径的姿势5.</p>
<h2 id="优劣势"><a href="#优劣势" class="headerlink" title="优劣势:"></a>优劣势:</h2><h3 id="绝对路径"><a href="#绝对路径" class="headerlink" title="绝对路径:"></a>绝对路径:</h3><ul>
<li>多个java程序可以引用同一个so文件,不用都打包到jar包里,降低jar包大小;  </li>
<li>可以灵活切换so文件实现,不用重新打包jar包, 符合c++中动态链接库的思想。</li>
</ul>
<h3 id="相对路径"><a href="#相对路径" class="headerlink" title="相对路径:"></a>相对路径:</h3><ul>
<li>一般一个so文件就一个java程序使用,相对路径用起来省心,不用配置多个运行环境. </li>
<li>比较符合jvm平台无关的思想,当然so文件肯定是平台有关的。一般so文件是某个公开库,不是我们自己写的,也不需要修改其实现。</li>
</ul>
<p>目前我个人使用的是第5种姿势。</p>
<h2 id="绝对路径-1"><a href="#绝对路径-1" class="headerlink" title="绝对路径"></a>绝对路径</h2><p>姿势1: 直接写死:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.load(<span class="string">"/opt/ld_path/libtest.so"</span>);</span><br></pre></td></tr></table></figure>
<p>姿势2: 结合环境变量,这里第一行代码可以在运行时由命令<code>java -Djava.library.path=/opt/ld_path</code>代替:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">System.setProperty(<span class="string">"java.library.path"</span>, <span class="string">"/opt/ld_path"</span>);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    Field sysPath = ClassLoader.class.getDeclaredField("sys_paths");</span><br><span class="line">    sysPath.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    sysPath.set(<span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">// System.out.println(System.mapLibraryName("dynamic"));</span></span><br><span class="line">    System.loadLibrary(<span class="string">"dynamic"</span>);</span><br><span class="line">    <span class="comment">// 注意mac需要.dylib结尾的依赖文件</span></span><br><span class="line">    <span class="comment">// linux需要.so结尾的依赖文件</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (NoSuchFieldException | IllegalAccessException e) &#123;</span><br><span class="line">    System.out.println(<span class="string">"error"</span>);</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="相对路径-仅在ide里可用的方法"><a href="#相对路径-仅在ide里可用的方法" class="headerlink" title="相对路径: 仅在ide里可用的方法"></a>相对路径: 仅在ide里可用的方法</h2><blockquote>
<p>这两种方法都需要首先把<code>libdynamic.so</code>文件放到<code>resource</code>目录。</p>
</blockquote>
<p>姿势3:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">URL url = JNIDyn.class.getClassLoader().getResource("libdynamic.so");</span><br><span class="line">System.load(url.getPath());</span><br></pre></td></tr></table></figure>
<p>姿势4:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ClassPathResource resource = <span class="keyword">new</span> ClassPathResource(<span class="string">"libdynamic.so"</span>);</span><br><span class="line"><span class="comment">// System.out.println(resource.getPath());</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    File file = resource.getFile();</span><br><span class="line">    System.load(file.getAbsolutePath());</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="相对路径-ide和jar包都能用的方法"><a href="#相对路径-ide和jar包都能用的方法" class="headerlink" title="相对路径: ide和jar包都能用的方法"></a>相对路径: ide和jar包都能用的方法</h2><p>姿势5: </p>
<blockquote>
<p>需要首先把<code>libdynamic.so</code>文件放到<code>resource</code>目录。</p>
</blockquote>
<p>然后需要创建<code>NativeUtils</code>工具类;<br>加载代码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        NativeUtils.loadLibraryFromJar(<span class="string">"/libnative.so"</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里使用到的<code>NativeUtils</code>源码如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NativeUtils</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_PREFIX_LENGTH = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String NATIVE_FOLDER_PATH_PREFIX = <span class="string">"nativeutils"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> File temporaryDir;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">NativeUtils</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loadLibraryFromJar</span><span class="params">(String path)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == path || !path.startsWith(<span class="string">"/"</span>)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"The path has to be absolute (start with '/')."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        String[] parts = path.split(<span class="string">"/"</span>);</span><br><span class="line">        String filename = (parts.length &gt; <span class="number">1</span>) ? parts[parts.length - <span class="number">1</span>] : <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (filename == <span class="keyword">null</span> || filename.length() &lt; MIN_PREFIX_LENGTH) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"The filename has to be at least 3 characters long."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (temporaryDir == <span class="keyword">null</span>) &#123;</span><br><span class="line">            temporaryDir = createTempDirectory(NATIVE_FOLDER_PATH_PREFIX);</span><br><span class="line">            temporaryDir.deleteOnExit();</span><br><span class="line">        &#125;</span><br><span class="line">        File temp = <span class="keyword">new</span> File(temporaryDir, filename);</span><br><span class="line">        <span class="keyword">try</span> (InputStream is = NativeUtils<span class="class">.<span class="keyword">class</span>.<span class="title">getResourceAsStream</span>(<span class="title">path</span>)) </span>&#123;</span><br><span class="line">            Files.copy(is, temp.toPath(), StandardCopyOption.REPLACE_EXISTING);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            temp.delete();</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NullPointerException e) &#123;</span><br><span class="line">            temp.delete();</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> FileNotFoundException(<span class="string">"File "</span> + path + <span class="string">" was not found inside JAR."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.load(temp.getAbsolutePath());</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (isPosixCompliant()) &#123;</span><br><span class="line">                temp.delete();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                temp.deleteOnExit();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isPosixCompliant</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> FileSystems.getDefault()</span><br><span class="line">                    .supportedFileAttributeViews()</span><br><span class="line">                    .contains(<span class="string">"posix"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileSystemNotFoundException</span><br><span class="line">                | ProviderNotFoundException</span><br><span class="line">                | SecurityException e) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> File <span class="title">createTempDirectory</span><span class="params">(String prefix)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        String tempDir = System.getProperty(<span class="string">"java.io.tmpdir"</span>);</span><br><span class="line">        File generatedDir = <span class="keyword">new</span> File(tempDir, prefix + System.nanoTime());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!generatedDir.mkdir())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Failed to create temp directory "</span> + generatedDir.getName());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> generatedDir;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://xiaoyue26.github.io/2019/09/08/2019-09/JNI%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E5%BC%95%E7%94%A8so%E6%96%87%E4%BB%B6/" data-id="ck96cxpq600jomaam0b6r19z1" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JNI/" rel="tag">JNI</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/" rel="tag">java</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-2019-09/springboot包结构" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/09/08/2019-09/springboot%E5%8C%85%E7%BB%93%E6%9E%84/" class="article-date">
  <time datetime="2019-09-08T10:32:14.000Z" itemprop="datePublished">2019-09-08</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/java/">java</a>►<a class="article-category-link" href="/categories/java/spring/">spring</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/09/08/2019-09/springboot%E5%8C%85%E7%BB%93%E6%9E%84/">springboot包结构</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <h1 id="使用springboot打包插件"><a href="#使用springboot打包插件" class="headerlink" title="使用springboot打包插件"></a>使用springboot打包插件</h1><p>如果用springboot插件进行打包以后,包结构会发生变化:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mainClass</span>&gt;</span>com.tencent.xxx.Application<span class="tag">&lt;/<span class="name">mainClass</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">goal</span>&gt;</span>repackage<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>springboot打包的jar包用<code>tar -xvf</code>解压以后,大致结构如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">+-META-INF</span><br><span class="line">|  +-MANIFEST.MF</span><br><span class="line">|  +-maven</span><br><span class="line">|     +-pom.xml</span><br><span class="line">|     +-pom.properties</span><br><span class="line">+-org</span><br><span class="line">|  +-springframework</span><br><span class="line">|     +-boot</span><br><span class="line">|        +-loader</span><br><span class="line">|           +-&lt;spring boot loader classes&gt;</span><br><span class="line">+-BOOT-INF</span><br><span class="line">   +-classes</span><br><span class="line">   |  +-com</span><br><span class="line">   |     +-tencent</span><br><span class="line">   |        +-xxx.class</span><br><span class="line">   |  +-其他src&#x2F;main&#x2F;resource路径下的文件</span><br><span class="line">   +-lib</span><br><span class="line">      +-依赖的jar包</span><br></pre></td></tr></table></figure>
<p>可以看出主要分为三部分:<br><code>META-INF</code>文件夹: 元数据信息;<br><code>org</code>文件夹: springboot框架相关的class和依赖;<br><code>BOOT-INF</code>: 我们写的代码、resource以及引入的相关依赖。</p>
<p>其中比较重要的是元数据信息中的<code>MANIFEST.MF</code>:</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">Manifest-Version:</span> <span class="number">1.0</span></span><br><span class="line"><span class="attr">Archiver-Version:</span> <span class="string">Plexus</span> <span class="string">Archiver</span></span><br><span class="line"><span class="attr">Built-By:</span> <span class="string">mengqifeng</span></span><br><span class="line"><span class="attr">Start-Class:</span> <span class="string">com.tencent.xxx.Application</span></span><br><span class="line"><span class="attr">Spring-Boot-Classes:</span> <span class="string">BOOT-INF/classes/</span></span><br><span class="line"><span class="attr">Spring-Boot-Lib:</span> <span class="string">BOOT-INF/lib/</span></span><br><span class="line"><span class="attr">Spring-Boot-Version:</span> <span class="number">2.2</span><span class="number">.0</span><span class="string">.M4</span></span><br><span class="line"><span class="attr">Created-By:</span> <span class="string">Apache</span> <span class="string">Maven</span> <span class="number">3.5</span><span class="number">.3</span></span><br><span class="line"><span class="attr">Build-Jdk:</span> <span class="number">1.8</span><span class="string">.0_161</span></span><br><span class="line"><span class="attr">Main-Class:</span> <span class="string">org.springframework.boot.loader.JarLauncher</span></span><br></pre></td></tr></table></figure>
<p>这里可以看出springboot的入口类是<code>org.springframework.boot.loader.JarLauncher</code>。<br>先启动它这个类(main-class)，然后反射调用我们的类(start-class)。</p>
<p>此外由于这里看出lib文件夹的目录是<code>/BOOT-INF/class/lib</code>,我们可以手动在pom文件中修改resource文件的打包路径,对准这个目录放进去就可以作为库文件依赖了:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src\main\resources\lib<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">targetPath</span>&gt;</span>/BOOT-INF/class/lib<span class="tag">&lt;/<span class="name">targetPath</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.jar<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="默认的maven包结构"><a href="#默认的maven包结构" class="headerlink" title="默认的maven包结构"></a>默认的maven包结构</h1><p>如果把<code>xxx.jar.original</code>解压开的话,能得到springboot<code>repackage</code>以前的包结构。<br>此时只有两部分,元数据信息和我们写的代码(字节码和资源文件),没有依赖库:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+-META-INF</span><br><span class="line">|  +-MANIFEST.MF</span><br><span class="line">|  +-maven</span><br><span class="line">|     +-pom.xml</span><br><span class="line">|     +-pom.properties</span><br><span class="line">+-com(我们写的代码)以及其他src&#x2F;main&#x2F;resource路径下的文件</span><br></pre></td></tr></table></figure>

<p>元数据信息中的<code>MANIFEST.MF</code>内容也少一些:</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">Manifest-Version:</span> <span class="number">1.0</span></span><br><span class="line"><span class="attr">Archiver-Version:</span> <span class="string">Plexus</span> <span class="string">Archiver</span></span><br><span class="line"><span class="attr">Built-By:</span> <span class="string">mengqifeng</span></span><br><span class="line"><span class="attr">Created-By:</span> <span class="string">Apache</span> <span class="string">Maven</span> <span class="number">3.5</span><span class="number">.3</span></span><br><span class="line"><span class="attr">Build-Jdk:</span> <span class="number">1.8</span><span class="string">.0_161</span></span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://xiaoyue26.github.io/2019/09/08/2019-09/springboot%E5%8C%85%E7%BB%93%E6%9E%84/" data-id="ck96cxpq700jwmaaman5t7jxy" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/" rel="tag">java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/maven/" rel="tag">maven</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/spring/" rel="tag">spring</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-2019-09/JNI总结" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/09/07/2019-09/JNI%E6%80%BB%E7%BB%93/" class="article-date">
  <time datetime="2019-09-07T10:20:10.000Z" itemprop="datePublished">2019-09-07</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/java/">java</a>►<a class="article-category-link" href="/categories/java/%E6%80%A7%E8%83%BD/">性能</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/09/07/2019-09/JNI%E6%80%BB%E7%BB%93/">JNI总结</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <h1 id="what-JNI是啥"><a href="#what-JNI是啥" class="headerlink" title="what: JNI是啥"></a>what: JNI是啥</h1><p><code>JNI(Java Native Interface)</code>是java访问<code>native</code>方法的接口规范。<br>所谓<code>native</code>方法一般是c/c++代码。（也可以是汇编）<br>java实现了一个JNI框架来让java和其他语言互调，java方法可以调JNI接口声明了的native方法，native方法也可以创建、使用java对象。<br>JNI接口规范主要按照<code>c</code>语言，不像<code>c++</code>一样改写方法名。<br>因此实际编码中需要用<code>extern c</code>来维持方法名的纯净。</p>
<p>编译方法:<br>c++: <code>print(int)</code>=&gt;<code>print_int</code>;<br>c: <code>print</code>.<br>所以我们需要c这种风格的。(不支持重载)</p>
<h1 id="why-为啥要使用JNI"><a href="#why-为啥要使用JNI" class="headerlink" title="why: 为啥要使用JNI"></a>why: 为啥要使用JNI</h1><p>使用的场景包括:</p>
<ol>
<li>有些现成的代码是c/c++的，需要在java中调用; （比如一些平台相关的、SIMD操作、或其他java中没有的库）</li>
<li>c/c++版本的代码也许有巨大的性能优势。</li>
</ol>
<h1 id="HOW-JNI如何工作"><a href="#HOW-JNI如何工作" class="headerlink" title="HOW: JNI如何工作"></a>HOW: JNI如何工作</h1><h2 id="如何使用JNI"><a href="#如何使用JNI" class="headerlink" title="如何使用JNI"></a>如何使用JNI</h2><p>两种方法： 静态注册和动态加载。</p>
<h3 id="静态注册"><a href="#静态注册" class="headerlink" title="静态注册"></a>静态注册</h3><p>假设我们要在java中调用c的方法,大致分为6个步骤:</p>
<ol>
<li>在java中声明一个<code>native</code>方法,但是不实现;</li>
<li>编译java字节码,生成<code>class</code>文件;(<code>javac</code>命令)</li>
<li>用class文件生成<code>.h</code>的文件头;(<code>javah</code>命令)</li>
<li>创建<code>.c</code>文件实现<code>.h</code>文件头中声明的方法;</li>
<li>编译<code>.c</code>，<code>.h</code>文件生成动态链接库<code>.so</code>;</li>
<li>在<code>java</code>中加载<code>.so</code>文件,使用第一步中声明的方法。</li>
</ol>
<p>相关命令:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:.</span><br><span class="line">javac HelloWorld.java</span><br><span class="line">javah HelloWorld</span><br><span class="line">gcc -fPIC -I /usr/lib/jvm/jdk/include -I /usr/lib/jvm/jdk/include/linux -shared libHelloWorld.c -o libHelloWorld.so</span><br><span class="line">export LD_LIBRARY_PATH=.:$LD_LIBRARY_PATH # 为了找到so文件</span><br><span class="line">java -Djava.library.path=. HelloWorld  # 也是为了找到so文件(二选一即可)</span><br></pre></td></tr></table></figure>

<h3 id="动态加载"><a href="#动态加载" class="headerlink" title="动态加载"></a>动态加载</h3><p>利用<code>RegisterNatives</code>方法来注册Java方法与JNI函数的映射。</p>
<ol>
<li>利用结构体<code>JNINativeMethod</code>数组记录 Java 方法与 JNI 函数的对应关系</li>
<li>实现 <code>JNI_OnLoad</code> 方法，在加载动态库后，执行动态注册</li>
<li>调用 <code>FindClass</code> 方法，获取Java对象</li>
<li>调用 <code>RegisterNatives</code>方法，传入 Java 对象、<code>JNINativeMethod</code>;</li>
<li>数组及注册方法数完成注册；</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下是c++版本的,c语言版本的话很简单,只要把:</span></span><br><span class="line"><span class="comment">// env-&gt;改成(*env)-&gt;</span></span><br><span class="line"><span class="comment">// 调用的方法参数第一个参数加上env即可。</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> JNI_CLASS_PAPT <span class="meta-string">"com/xxx"</span></span></span><br><span class="line"><span class="function">JNIEXPORT jstring JNICALL <span class="title">native_test</span><span class="params">(JNIEnv *env, jobject instance)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> env-&gt;NewStringUTF(<span class="string">"hello world"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> JNINativeMethod g_methods[] = &#123;</span><br><span class="line">        <span class="comment">// Java层方法、参数类型、native方法</span></span><br><span class="line">        &#123;<span class="string">"get_hello_world"</span>, <span class="string">"()Ljava/lang/String;"</span>, (<span class="keyword">void</span>*)native_test&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 动态库加载时回调方法</span></span><br><span class="line"><span class="function">jint <span class="title">JNI_OnLoad</span><span class="params">(JavaVM *vm, <span class="keyword">void</span> *reserved)</span> </span>&#123;</span><br><span class="line">    JNIEnv *env = <span class="literal">NULL</span>;</span><br><span class="line">    vm-&gt;GetEnv((<span class="keyword">void</span>**)&amp;env, JNI_VERSION_1_8);</span><br><span class="line">    jclass clazz= env-&gt;FindClass(JNI_CLASS_PAPT);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 注册Java和natvie方法映射表</span></span><br><span class="line">    env-&gt;RegisterNatives(clazz</span><br><span class="line">    , g_methods</span><br><span class="line">    , <span class="keyword">sizeof</span>(g_methods)/<span class="keyword">sizeof</span>(g_methods[<span class="number">0</span>]));</span><br><span class="line">    <span class="keyword">return</span> JNI_VERSION_1_8;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参见<code>jni.h</code>中的<code>JNINativeMethod</code>结构体:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* name; <span class="comment">// java方法名</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* signature;<span class="comment">// java方法签名</span></span><br><span class="line">    <span class="keyword">void</span>*       fnPtr; <span class="comment">// c函数指针</span></span><br><span class="line">&#125; JNINativeMethod;</span><br></pre></td></tr></table></figure>


<h2 id="JNI原理"><a href="#JNI原理" class="headerlink" title="JNI原理"></a>JNI原理</h2><p>本质其实就是JVM使用了so动态链接库中的函数，所以关键在于函数名的映射。<br>一个典型的<code>native</code>方法的签名如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// native方法的签名由类名(含包名,点换成下划线)和方法名拼接而成:</span></span><br><span class="line">JNIEXPORT <span class="keyword">void</span> JNICALL Java_packname_classname_methodname</span><br><span class="line">  (JNIEnv *env, jobject obj)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*Implement Native Method Here*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可见，JVM调用native方法的时候，需要传递一个<code>JNIEnv</code>指针和一个<code>jobject</code>指针。</p>
<blockquote>
<p>JNIEnv: 包含访问JVM的接口，可以进行native数组和java数组转换，字符串转换，对象实例化、抛异常等等java能做的事情；</p>
</blockquote>
<blockquote>
<p>jobject: 声明native方法的java对象。</p>
</blockquote>
<p>每一个Java线程对应一个<code>JNIEnv</code>。<br><code>JNIEnv</code>指针仅在native方法当前线程中有效；如果手动保存到其他地方，然后在其他线程中想要使用，需要调用<code>AttachCurrentThread</code>来挂靠当前线程到jvm，使用完毕后调用<code>DetachCurrentThread</code>脱离jvm。<br>挂靠样例:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. </span></span><br><span class="line">JNIEnv *env;</span><br><span class="line">(*g_vm)-&gt;AttachCurrentThread (g_vm, (<span class="keyword">void</span> **) &amp;env, <span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">// 2. 脱离:</span></span><br><span class="line">(*g_vm)-&gt;DetachCurrentThread (g_vm);</span><br></pre></td></tr></table></figure>



<h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p>native和java的基本类型能自动互转，复杂类型（数组、数组、对象）则要使用<code>JNIEnv</code>显式地进行转换。</p>
<p>字符串转换(C++版本):</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span></span><br><span class="line">JNIEXPORT <span class="keyword">void</span> JNICALL Java_ClassName_MethodName</span><br><span class="line">  (JNIEnv *env, jobject obj, jstring javaString)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// java字符串=&gt;c字符串</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *nativeString = env-&gt;GetStringUTFChars(javaString, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// do something with nativeString</span></span><br><span class="line">    <span class="comment">// 释放:</span></span><br><span class="line">    env-&gt;ReleaseStringUTFChars(javaString, nativeString);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>c语言版本就是参数多了<code>env</code>参数:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">JNIEXPORT <span class="keyword">void</span> JNICALL Java_ClassName_MethodName</span><br><span class="line">  (JNIEnv *env, jobject obj, jstring javaString)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 转换:</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *nativeString = (*env)-&gt;GetStringUTFChars(env, javaString, <span class="number">0</span>);</span><br><span class="line"><span class="comment">// 释放:</span></span><br><span class="line">    (*env)-&gt;ReleaseStringUTFChars(env, javaString, nativeString);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="基本类型的映射"><a href="#基本类型的映射" class="headerlink" title="基本类型的映射"></a>基本类型的映射</h2><table>
<thead>
<tr>
<th>native类型</th>
<th>Java类型</th>
<th>描述</th>
<th>java类型签名（signature）</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>unsigned char</td>
<td>jboolean</td>
<td>unsigned 8位</td>
<td>Z</td>
<td></td>
</tr>
<tr>
<td>signed char</td>
<td>jbyte</td>
<td>signed 8位</td>
<td>B</td>
<td></td>
</tr>
<tr>
<td>unsigned short</td>
<td>jchar</td>
<td>unsigned 16位</td>
<td>C</td>
<td></td>
</tr>
<tr>
<td>short</td>
<td>jshort</td>
<td>signed 16位</td>
<td>S</td>
<td></td>
</tr>
<tr>
<td>long</td>
<td>jint</td>
<td>signed 32位</td>
<td>I</td>
<td></td>
</tr>
<tr>
<td>long long__int64</td>
<td>jlong</td>
<td>signed 64位</td>
<td>J</td>
<td></td>
</tr>
<tr>
<td>float</td>
<td>jfloat</td>
<td>32位</td>
<td>F</td>
<td></td>
</tr>
<tr>
<td>double</td>
<td>jdouble</td>
<td>64位</td>
<td>D</td>
<td></td>
</tr>
<tr>
<td>void</td>
<td>void</td>
<td></td>
<td>V</td>
<td></td>
</tr>
</tbody></table>
<p>string类的类型签名: <code>Ljava/lang/String;</code><br>整型数组的类型签名: <code>[I</code><br><code>int[][]</code>的签名: <code>[[I</code></p>
<h1 id="JNI代码中调用java对象方法"><a href="#JNI代码中调用java对象方法" class="headerlink" title="JNI代码中调用java对象方法"></a>JNI代码中调用java对象方法</h1><h2 id="1-调用实例方法"><a href="#1-调用实例方法" class="headerlink" title="1. 调用实例方法"></a>1. 调用实例方法</h2><p>首先我们有env和obj，步骤是：</p>
<blockquote>
<ol>
<li>用env、obj获取class对象cls;</li>
<li>用env、cls和方法签名反射获得方法引用mid;</li>
<li>用env、obj、mid调用方法。</li>
</ol>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">JNIEXPORT <span class="keyword">void</span> JNICALL  <span class="title">Java_InstanceMethodCall_nativeMethod</span><span class="params">(JNIEnv *env, jobject obj)</span> </span>&#123; </span><br><span class="line">     jclass cls = (*env)-&gt;GetObjectClass(env, obj);  </span><br><span class="line">     jmethodID mid =  (*env)-&gt;GetMethodID(env, cls, <span class="string">"callback"</span>, <span class="string">"()V"</span>);  </span><br><span class="line">     <span class="keyword">if</span> (mid == <span class="literal">NULL</span>) &#123; </span><br><span class="line">         <span class="keyword">return</span>; <span class="comment">/* method not found */</span> </span><br><span class="line">     &#125; </span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">"In C\n"</span>); </span><br><span class="line">     (*env)-&gt;CallVoidMethod(env, obj, mid);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-调用静态方法"><a href="#2-调用静态方法" class="headerlink" title="2. 调用静态方法"></a>2. 调用静态方法</h2><p>前两步和刚才一样,第三部把Obj换成cls即可:</p>
<ol>
<li>获取cls;</li>
<li>获取mid;</li>
<li>用env、cls、mid调用静态方法。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">JNIEXPORT <span class="keyword">void</span> JNICALL  <span class="title">Java_StaticMethodCall_nativeMethod</span><span class="params">(JNIEnv *env, jobject obj)</span> </span>&#123; </span><br><span class="line">     jclass cls = (*env)-&gt;GetObjectClass(env, obj); </span><br><span class="line">     jmethodID mid =  </span><br><span class="line">         (*env)-&gt;GetStaticMethodID(env, cls, <span class="string">"callback"</span>, <span class="string">"()V"</span>); </span><br><span class="line">     <span class="keyword">if</span> (mid == <span class="literal">NULL</span>) &#123; </span><br><span class="line">         <span class="keyword">return</span>;  <span class="comment">/* method not found */</span> </span><br><span class="line">     &#125; </span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">"In C\n"</span>); </span><br><span class="line">     (*env)-&gt;CallStaticVoidMethod(env, cls, mid);  <span class="comment">// 这里是cls</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="JNI需要注意的点"><a href="#JNI需要注意的点" class="headerlink" title="JNI需要注意的点"></a>JNI需要注意的点</h1><ol>
<li>native方法自己管理内存,jvm不gc这部分;</li>
<li>JNI调用开销较大，不宜频繁调用;（java数组、字符串都会线性拷贝）</li>
<li>JNI方法平台有关,移植性差;</li>
<li>c代码里显式释放内存;</li>
<li>字符编码问题。</li>
</ol>
<p>第四点一般是获取和释放成对使用：(多少get就有多少delete或release)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GetObjectField&#x3D;&gt;DeleteLocalRef</span><br><span class="line">GetStringUTFChars&#x3D;&gt;ReleaseStringUTFChars</span><br></pre></td></tr></table></figure>

<p>最后一个字符编码问题:<br>JNI里的这几个函数实际上用的是修改版本的<code>UTF-8</code>，并不完全等效于<code>UTF-8</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">NewStringUTF</span><br><span class="line">GetStringUTFLength</span><br><span class="line">GetStringUTFChars</span><br><span class="line">ReleaseStringUTFChars</span><br><span class="line">GetStringUTFRegion</span><br></pre></td></tr></table></figure>
<p>用户应当使用这几个函数,先创建UTF-16，然后安全地转换成标准<code>UTF-8</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">NewString</span><br><span class="line">GetStringLength</span><br><span class="line">GetStringChars</span><br><span class="line">ReleaseStringChars</span><br><span class="line">GetStringRegion</span><br><span class="line">GetStringCritical</span><br><span class="line">ReleaseStringCritical</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://xiaoyue26.github.io/2019/09/07/2019-09/JNI%E6%80%BB%E7%BB%93/" data-id="ck96cxpq400jlmaam08ly4o8b" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JNI/" rel="tag">JNI</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/" rel="tag">java</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-2019-09/静态链接库和动态链接库" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/09/04/2019-09/%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93%E5%92%8C%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93/" class="article-date">
  <time datetime="2019-09-04T02:24:06.000Z" itemprop="datePublished">2019-09-04</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/java/">java</a>►<a class="article-category-link" href="/categories/java/%E6%80%A7%E8%83%BD/">性能</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/09/04/2019-09/%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93%E5%92%8C%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93/">静态链接库和动态链接库</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <h2 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h2><p><code>JNI</code>的时候发现要使用<code>so</code>文件、动态链接库，那么究竟什么是动态链接库呢？</p>
<p>参考:<br><a href="https://www.zhihu.com/question/20484931" target="_blank" rel="noopener">https://www.zhihu.com/question/20484931</a></p>
<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>库有两种：静态库和动态库。<br>静态库: <code>.a</code>,<code>.lib</code>;<br>动态库：<code>.so</code>,<code>.dll</code>;<br><code>windows</code>:<code>.lib</code>,<code>.dll</code>;<br><code>linux</code>:<code>.a</code>,<code>.so</code>;</p>
<p>非库:<br>生成<code>.o</code>文件: <code>g++ -c hellospeak.cpp</code>;<br>// 只产生编译的代码(没有链接link)<br>生成<code>.out</code>文件: <code>g++ hellospeak.cpp speak.cpp -o hellospeak</code>;<br>// 执行完整的编译过程，并且生成一个a.out文件。</p>
<h1 id="链接过程"><a href="#链接过程" class="headerlink" title="链接过程"></a>链接过程</h1><p>源文件(<code>.h</code>,<code>.cpp</code>)<br>=&gt;预编译=&gt;编译=&gt;汇编<br>=&gt;<strong>链接</strong><br>=&gt;可执行文件</p>
<p>这里我们主要关心<strong>链接</strong>阶段。</p>
<h2 id="静态库"><a href="#静态库" class="headerlink" title="静态库"></a>静态库</h2><p>链接阶段:<br>汇编生成的<code>.o</code>+引用的库=&gt; 可执行文件;</p>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ol>
<li>静态库在内存中可能造成空间浪费。<br>如100个进程都使用了静态库A，则内存中有100份占用。</li>
<li>更新库不灵活。</li>
</ol>
<h2 id="动态库-又称共享库"><a href="#动态库-又称共享库" class="headerlink" title="动态库(又称共享库)"></a>动态库(又称共享库)</h2><p>链接阶段：<br>不加入引用的库。推迟到运行时。<br>运行时：<br>动态加载<code>.so</code>,<code>.dll</code>文件。</p>
<h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h3><p>多了运行时计算符号链接的开销，但是这个开销不大。</p>
<p>所以jni只能使用动态链接库。(linux的话就是<code>so</code>文件)</p>
<h2 id="gcc相关参数"><a href="#gcc相关参数" class="headerlink" title="gcc相关参数"></a>gcc相关参数</h2><p><a href="https://colobu.com/2018/08/28/15-Most-Frequently-Used-GCC-Compiler-Command-Line-Options/" target="_blank" rel="noopener">https://colobu.com/2018/08/28/15-Most-Frequently-Used-GCC-Compiler-Command-Line-Options/</a></p>
<p><code>-fPIC</code>: 产生位置无关的代码；<br><code>-shared</code>: 产生共享库;(动态库)<br>例子:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc -c -Wall -Werror -fPIC Cfile.c</span><br><span class="line">gcc -shared -o libCfile.so Cfile.o</span><br></pre></td></tr></table></figure>

<p><code>-static</code>: 生成静态链接的文件<br>例子:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc main.c -static -o main -lpthread</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://xiaoyue26.github.io/2019/09/04/2019-09/%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93%E5%92%8C%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93/" data-id="ck96cxpq900k4maamdzml6iii" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JNI/" rel="tag">JNI</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/" rel="tag">java</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-2019-09/CriticalNative-降低JNI开销" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/09/01/2019-09/CriticalNative-%E9%99%8D%E4%BD%8EJNI%E5%BC%80%E9%94%80/" class="article-date">
  <time datetime="2019-09-01T08:41:03.000Z" itemprop="datePublished">2019-09-01</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/java/">java</a>►<a class="article-category-link" href="/categories/java/%E6%80%A7%E8%83%BD/">性能</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/09/01/2019-09/CriticalNative-%E9%99%8D%E4%BD%8EJNI%E5%BC%80%E9%94%80/">CriticalNative:降低JNI开销</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <h1 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h1><p><code>Android</code>中有<code>@CriticalNative</code>注解:<br><a href="https://source.android.google.cn/devices/tech/dalvik/improvements" target="_blank" rel="noopener">https://source.android.google.cn/devices/tech/dalvik/improvements</a><br>里面说到:</p>
<blockquote>
<p>@FastNative 可以使原生方法的性能提升高达 2 倍，@CriticalNative 则可以提升高达4倍。 </p>
</blockquote>
<p>那么这是怎么做到的呢？</p>
<h1 id="native方法"><a href="#native方法" class="headerlink" title="native方法"></a>native方法</h1><p>调用native方法时,JVM的工作步骤:<br>(源码: <a href="http://hg.openjdk.java.net/jdk8u/jdk8u/hotspot/file/4d9931ebf861/src/cpu/x86/vm/sharedRuntime_x86_64.cpp#l1723" target="_blank" rel="noopener">http://hg.openjdk.java.net/jdk8u/jdk8u/hotspot/file/4d9931ebf861/src/cpu/x86/vm/sharedRuntime_x86_64.cpp#l1723</a>)</p>
<blockquote>
<ol>
<li>创建栈帧;</li>
<li>根据ABI移动参数到寄存器或者栈;(ABI: 应用二进制接口)</li>
<li>封装对象引用到JNI handlers;</li>
<li>获取静态方法的<code>JNIEnv*</code>和<code>jclass</code>,把他们作为额外参数传递;</li>
<li>检查是否调用<code>method_entry</code>的trace函数; </li>
<li>检查是否调用对象锁;（<code>synchronized</code>）(optinal)</li>
<li>检查native方法是否已经链接;(懒加载函数检查、链接)</li>
<li>线程状态从<code>in_java</code>转变为<code>in_native</code>;</li>
<li>调用native方法;</li>
<li>检查是否需要safepoint;</li>
<li>线程状态转回<code>in_java</code>;</li>
<li>解锁对象锁;(optional)</li>
<li>notify <code>method_exit</code>;(optional)</li>
<li>将对象结果解出，重置JNI handlers;</li>
<li>处理JNI异常;</li>
<li>移除栈帧。</li>
</ol>
</blockquote>
<p>开销比较大,主要是用于各种参数拷贝,尤其是遇到数组，需要来回拷贝、检查。</p>
<p>此时，如果是足够简单的native方法,可以用<code>Critical Natives</code>来降低开销。</p>
<h1 id="Critical-Native方法"><a href="#Critical-Native方法" class="headerlink" title="Critical Native方法"></a>Critical Native方法</h1><p><code>Critical Natives</code>方法是需要满足下列约束的<code>native</code>方法:</p>
<blockquote>
<ol>
<li>必须是static且没有synchronized; (省掉上一节的6、12步)</li>
<li>参数类型必须是基本类型或基本类型的数组;(省掉上一节中的对象相关3、14)</li>
<li>具体实现不能调用JNI函数(也就是不使用<code>JNIEnv* env</code>和<code>jclass cls</code>,既然不使用就不用传给它了),不能分配java对象或者抛出异常;(省掉上一节中的4、15)</li>
<li>不能运行太长时间.(因为它会阻塞gc)</li>
</ol>
</blockquote>
<p>基于这个原理的话, <code>critical native</code>方法比普通<code>native</code>方法快的原因其实是节省了一些调用开始和结束的开销，因此如果被调用的方法如果是时间占用的大头的话，其实这个优化幅度就很小了。<br>反之如果是频繁调用的方法，而且每次调用的数据量很小，此时调用开销和执行开销是同量级，那么累计的优化幅度就会很大。<br>（比如只是长度为16的数组计算的话，计算力提升可以达到2～3倍。）</p>
<p>满足上述约束以后,<code>Critical Natives</code>方法还需要进行下列声明:</p>
<blockquote>
<ol>
<li>方法名以<code>JavaCritical_</code>开头;</li>
<li>没有额外的<code>JNIEnv*</code>和<code>jclass</code>参数;(因为是static方法,自然也就没有jobject参数了)</li>
<li>java数组传递的时候用两个参数: 数组长度、数组引用(基本类型)。<br>// 这样不再需要调用<code>GetArrayLength</code>、<code>GetByteArrayElements</code>等函数。</li>
</ol>
</blockquote>
<p>此外critical natives方法变成临界区。<br><code>native</code>方法示例:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">JNIEXPORT jint JNICALL</span><br><span class="line">Java_com_package_MyClass_nativeMethod(JNIEnv* env, jclass klass, jbyteArray <span class="built_in">array</span>) &#123;</span><br><span class="line">    jboolean isCopy;</span><br><span class="line">    jint length = (*env)-&gt;GetArrayLength(env, <span class="built_in">array</span>);</span><br><span class="line">    jbyte* buf = (*env)-&gt;GetByteArrayElements(env, <span class="built_in">array</span>, &amp;isCopy);</span><br><span class="line">    jint result = <span class="built_in">process</span>(buf, length);</span><br><span class="line">    (*env)-&gt;ReleaseByteArrayElements(env, <span class="built_in">array</span>, buf, JNI_ABORT);</span><br><span class="line">    <span class="keyword">return</span> result;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Critical Natives</code>方法示例:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">JNIEXPORT jint JNICALL</span><br><span class="line">JavaCritical_com_package_MyClass_nativeMethod(jint length, jbyte* buf) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">process</span>(buf, length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>critical</code>版本的方法是JIT需要的(默认是调用超过1500次,可以调JIT参数<code>-XX:CompileThreshold=invocations</code>);<br>普通<code>native</code>版本的方法是解释器需要的;</p>
<p>因此实际用的时候，这俩版本的代码都要写上。比如是这样的:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;jni.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(jbyte* <span class="built_in">array</span>, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">        result += <span class="built_in">array</span>[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Class:     com_tencent_xxx_test_Natives</span></span><br><span class="line"><span class="comment"> * Method:    javaCriticalImpl</span></span><br><span class="line"><span class="comment"> * Signature: ([B)I</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">JNIEXPORT jint JNICALL Java_com_tencent_xxx_test_Natives_javaCriticalImpl</span><br><span class="line">  (JNIEnv* env, jclass cls, jbyteArray <span class="built_in">array</span>)&#123;</span><br><span class="line">  jboolean isCopy;</span><br><span class="line">  jint length = (*env)-&gt;GetArrayLength(env, <span class="built_in">array</span>);</span><br><span class="line">  jbyte* buf = (jbyte*) (*env)-&gt;GetPrimitiveArrayCritical(env, <span class="built_in">array</span>, &amp;isCopy);</span><br><span class="line">  jint result = sum(buf, length);</span><br><span class="line">  (*env)-&gt;ReleasePrimitiveArrayCritical(env, <span class="built_in">array</span>, buf, JNI_ABORT);</span><br><span class="line">  <span class="comment">// 有副作用的c函数用0; 无副作用的c函数直接用JNI_ABORT.</span></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">JNIEXPORT jint JNICALL</span><br><span class="line">JavaCritical_com_tencent_xxx_test_Natives_javaCriticalImpl(jint length, jbyte* buf) &#123;</span><br><span class="line">    <span class="keyword">return</span> sum(buf, length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>(之所以这么繁琐的原因是这个特性和Unsafe一样是jdk内部使用的,没有公开发布给普通程序员,正式发布估计要到jdk10了)</p>
<p>参考:<br><a href="http://cr.openjdk.java.net/~jrose/panama/native-call-primitive.html" target="_blank" rel="noopener">http://cr.openjdk.java.net/~jrose/panama/native-call-primitive.html</a><br><a href="http://mail.openjdk.java.net/pipermail/panama-dev/2015-December/000225.html" target="_blank" rel="noopener">http://mail.openjdk.java.net/pipermail/panama-dev/2015-December/000225.html</a><br><a href="https://stackoverflow.com/questions/36298111/is-it-possible-to-use-sun-misc-unsafe-to-call-c-functions-without-jni/36309652#36309652" target="_blank" rel="noopener">https://stackoverflow.com/questions/36298111/is-it-possible-to-use-sun-misc-unsafe-to-call-c-functions-without-jni/36309652#36309652</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://xiaoyue26.github.io/2019/09/01/2019-09/CriticalNative-%E9%99%8D%E4%BD%8EJNI%E5%BC%80%E9%94%80/" data-id="ck96cxpq200jgmaam80lnhwyz" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JNI/" rel="tag">JNI</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/" rel="tag">java</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-2019-09/程序计算加速之SIMD相关概念" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/09/01/2019-09/%E7%A8%8B%E5%BA%8F%E8%AE%A1%E7%AE%97%E5%8A%A0%E9%80%9F%E4%B9%8BSIMD%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/" class="article-date">
  <time datetime="2019-09-01T08:27:04.000Z" itemprop="datePublished">2019-09-01</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/java/">java</a>►<a class="article-category-link" href="/categories/java/%E6%80%A7%E8%83%BD/">性能</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/09/01/2019-09/%E7%A8%8B%E5%BA%8F%E8%AE%A1%E7%AE%97%E5%8A%A0%E9%80%9F%E4%B9%8BSIMD%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/">程序计算加速之SIMD相关概念</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <h1 id="What-什么是SIMD"><a href="#What-什么是SIMD" class="headerlink" title="What: 什么是SIMD"></a>What: 什么是SIMD</h1><p>SIMD全称<code>Single Instruction Multiple Data</code>，单指令多数据流，是一种采用一个控制器来控制多个处理器，同时对一组数据（又称“数据向量”）中的每一个分别执行相同的操作从而实现空间上的并行性的技术。</p>
<p>也就是说SIMD需要CPU指令集的支持，才能用一条指令就同时并行计算多个数据。当然了，这里同时计算时运用的是同一种运算，比如都是加法。</p>
<h1 id="WHY-为什么要使用SIMD"><a href="#WHY-为什么要使用SIMD" class="headerlink" title="WHY: 为什么要使用SIMD"></a>WHY: 为什么要使用SIMD</h1><p>能并行计算肯定是要比串行计算快的。<br>SIMD是cpu层面的加速，当然还有gpu层面的加速比如cuda编程。<br>如果需要大量浮点数计算、矩阵计算，比如游戏场景、机器学习场景下都是需要这些加速技术的。</p>
<h1 id="不同版本和历史"><a href="#不同版本和历史" class="headerlink" title="不同版本和历史"></a>不同版本和历史</h1><p>既然说到cpu，肯定绕不开intel和AMD。<br>最早是intel推出的，利用了多余的寄存器来加速多媒体运算，后来逐渐标准化：</p>
<h2 id="缩写"><a href="#缩写" class="headerlink" title="缩写:"></a>缩写:</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MMX(可能是MultiMedia eXtension的缩写)</span><br><span class="line">SSE(Streaming SIMD Extensions)</span><br><span class="line">AVX(Advanced Vcetor Extension) : 对SSE的后续扩展，主要分为AVX、AVX2、AVX512三种。在目前常见的机器上，大多只支持到AVX系列。</span><br></pre></td></tr></table></figure>
<h2 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">MMX: intel, Pentium;</span><br><span class="line">SSE: intel, Pentium 3;</span><br><span class="line">SSE2: intel, Pentium 4;</span><br><span class="line">SSE3: intel, Pentium 4;</span><br><span class="line">SSE4: intel, Core 2 Duo; 128位。</span><br><span class="line">SSE5: AMD;</span><br><span class="line">AVX:  intel, 因为SSE5被AMD抢先出了,intel恼羞成怒改名叫AVX了; 支持256位。</span><br><span class="line">AVX2: intel, 加入了整形支持。支持256位。</span><br><span class="line">AVX512: intel, 支持521位。</span><br></pre></td></tr></table></figure>

<h1 id="HOW：-如何使用SIMD"><a href="#HOW：-如何使用SIMD" class="headerlink" title="HOW： 如何使用SIMD"></a>HOW： 如何使用SIMD</h1><h2 id="JAVA中使用"><a href="#JAVA中使用" class="headerlink" title="JAVA中使用"></a>JAVA中使用</h2><p>jdk8的话，可以<code>jinfo -flag &lt;pid&gt;</code>一下，这三个其实是默认配置(java8):</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-XX:UseAVX&#x3D;2</span><br><span class="line">-XX:UseSSE&#x3D;5</span><br><span class="line">-XX:+UseSSE42Intrinsics</span><br></pre></td></tr></table></figure>

<p>可以受益的操作：<br>加减乘除、乘累加。<br>所以jvm是默认会对一些代码进行SIMD优化，具体方法是自己构造数组，比如本来只是要统计一个数组的总和，用一个局部变量即可，可以改成用一个长度为8的局部数组（或者16、具体长度需要benchmark才知道最优，要符合cpu的SIMD支持长度），然后在8个位置上分别求和，最后把局部数组求和得到答案，这种代码会比直接求和快1倍。</p>
<p>上述trick自然是非常间接地使用了，直接使用SIMD的库还在开发中：<br><a href="https://openjdk.java.net/jeps/338" target="_blank" rel="noopener">https://openjdk.java.net/jeps/338</a><br>估计要等到java10以后才能用上了。<br>也有一些国外的scala库(LMS)： <a href="https://astojanov.github.io/blog/2017/12/20/scala-simd.html?tdsourcetag=s_pcqq_aiomsg" target="_blank" rel="noopener">https://astojanov.github.io/blog/2017/12/20/scala-simd.html?tdsourcetag=s_pcqq_aiomsg</a><br>但不知道靠谱不靠谱。</p>
<p>直接使用的库在C语言中是有的，叫做<code>SIMD Intrinsics</code>：<br><a href="https://software.intel.com/sites/landingpage/IntrinsicsGuide/#techs=MMX,SSE,SSE2,SSE3,SSSE3,SSE4_1,SSE4_2,AVX,AVX2,FMA,AVX_512" target="_blank" rel="noopener">https://software.intel.com/sites/landingpage/IntrinsicsGuide/#techs=MMX,SSE,SSE2,SSE3,SSSE3,SSE4_1,SSE4_2,AVX,AVX2,FMA,AVX_512</a><br>比如<code>_mm_set_ps1</code>函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">???-ss后缀的操作: 4个操作数中有一个参加运算；</span><br><span class="line">???-ps后缀的操作：4个操作数都参加运算。</span><br></pre></td></tr></table></figure>
<p>因此我们可以用JNI调用来使用SIMD。<br>为了一定程度上减少JNI开销的话，可以使用<code>CriticalNative</code>。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://www.cnblogs.com/lgxZJ/p/8688430.html" target="_blank" rel="noopener">https://www.cnblogs.com/lgxZJ/p/8688430.html</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://xiaoyue26.github.io/2019/09/01/2019-09/%E7%A8%8B%E5%BA%8F%E8%AE%A1%E7%AE%97%E5%8A%A0%E9%80%9F%E4%B9%8BSIMD%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/" data-id="ck96cxpq900k1maam7l1r7igy" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/SIMD/" rel="tag">SIMD</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/" rel="tag">java</a></li></ul>

    </footer>
  </div>
  
</article>
 


  


  <nav id="page-nav">
    <a class="extend prev" rel="prev" href="/">&amp;laquo; 上一页</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/20/">20</a><a class="extend next" rel="next" href="/page/3/">下一页&amp;raquo;</a>
  </nav>
</section>
           
    <aside id="sidebar">
  
    

  
    
  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title recent-posts">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/04/19/2020-04/spring%E6%8B%BE%E9%81%97/">spring拾遗</a>
          </li>
        
          <li>
            <a href="/2020/03/26/2020-03/%E5%88%A9%E7%94%A8UTF-8%E7%BC%96%E7%A0%81%E7%9A%84%E7%89%B9%E6%80%A7%E8%BF%9B%E8%A1%8C%E4%BC%98%E5%8C%96/">利用UTF-8编码的特性进行优化</a>
          </li>
        
          <li>
            <a href="/2020/03/24/2020-03/linux%E8%87%AA%E8%BF%9E%E6%8E%A5/">linux自连接</a>
          </li>
        
          <li>
            <a href="/2020/03/23/2020-03/redis%E5%A4%A7key%E9%97%AE%E9%A2%98/">redis大key问题</a>
          </li>
        
          <li>
            <a href="/2020/03/23/2020-03/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/">分布式事务</a>
          </li>
        
      </ul>
    </div>
  </div>

  
    

  
</aside>

      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-left">
      &copy; 2014 - 2020 风梦七&nbsp;|&nbsp;
      主题 <a href="https://github.com/giscafer/hexo-theme-cafe/" target="_blank">Cafe</a>
    </div>
     <div id="footer-right">
      联系方式&nbsp;|&nbsp;296671657@qq.com
    </div>
  </div>
</footer>
 
<script src="/jquery/jquery.min.js"></script>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">首页</a>
  
    <a href="/archives" class="mobile-nav-link">归档</a>
  
    <a href="/about" class="mobile-nav-link">关于</a>
  
</nav>
    <img class="back-to-top-btn" src="/images/fly-to-top.png"/>
<script>
// Elevator script included on the page, already.
window.onload = function() {
  var elevator = new Elevator({
    selector:'.back-to-top-btn',
    element: document.querySelector('.back-to-top-btn'),
    duration: 1000 // milliseconds
  });
}
</script>
      

  
    <script>
      var cloudTieConfig = {
        url: document.location.href, 
        sourceId: "",
        productKey: "e2fb4051c49842688ce669e634bc983f",
        target: "cloud-tie-wrapper"
      };
    </script>
    <script src="https://img1.ws.126.net/f2e/tie/yun/sdk/loader.js"></script>
    

  







<!-- author:forvoid begin -->
<!-- author:forvoid begin -->

<!-- author:forvoid end -->

<!-- author:forvoid end -->


  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      })
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      })
    </script>
    <script type="text/javascript" src="https://cdn.rawgit.com/mathjax/MathJax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


 
<script src="/js/is.js"></script>



  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>


<script src="/js/elevator.js"></script>

  </div>
</body>
</html>