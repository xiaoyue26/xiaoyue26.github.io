<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>笔记本</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="笔记本">
<meta property="og:url" content="http://xiaoyue26.github.io/page/2/index.html">
<meta property="og:site_name" content="笔记本">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="风梦七">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="笔记本" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    
  
  
<link rel="stylesheet" href="/css/style.css">

  

<meta name="generator" content="Hexo 4.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    
    <div id="header-inner" class="inner">
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://xiaoyue26.github.io"></form>
      </div>
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">首页</a>
        
          <a class="main-nav-link" href="/archives">归档</a>
        
          <a class="main-nav-link" href="/about">关于</a>
        
      </nav>
      
    </div>
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">笔记本</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">风梦七</a>
        </h2>
      
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-2022-03/中断梳理" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/03/14/2022-03/%E4%B8%AD%E6%96%AD%E6%A2%B3%E7%90%86/" class="article-date">
  <time datetime="2022-03-14T09:52:23.000Z" itemprop="datePublished">2022-03-14</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/java/">java</a>►<a class="article-category-link" href="/categories/java/%E6%80%A7%E8%83%BD/">性能</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/03/14/2022-03/%E4%B8%AD%E6%96%AD%E6%A2%B3%E7%90%86/">java方法是否可中断梳理</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <h1 id="常见方法的中断相关汇总"><a href="#常见方法的中断相关汇总" class="headerlink" title="常见方法的中断相关汇总"></a>常见方法的中断相关汇总</h1><table>
<thead>
<tr>
<th>调用方法</th>
<th>是否可以中断</th>
<th>是否释放资源(锁)</th>
<th>是否释放cpu</th>
</tr>
</thead>
<tbody><tr>
<td><code>synchronized</code></td>
<td>不可中断</td>
<td>不释放</td>
<td>释放</td>
</tr>
<tr>
<td><code>lock</code></td>
<td>不可中断</td>
<td>不释放</td>
<td>释放</td>
</tr>
<tr>
<td><code>tryLock</code></td>
<td>可以中断</td>
<td>不释放</td>
<td>释放</td>
</tr>
<tr>
<td><code>lockInterruptibly</code></td>
<td>可以中断</td>
<td>不释放</td>
<td>释放</td>
</tr>
<tr>
<td><code>InterruptibleChannel</code></td>
<td>可以中断</td>
<td>不释放</td>
<td>释放</td>
</tr>
<tr>
<td><code>Thread.sleep</code></td>
<td>可以中断</td>
<td>不释放</td>
<td>释放</td>
</tr>
<tr>
<td><code>thread.join()</code></td>
<td>可以中断</td>
<td>释放thread对象的锁，其他不释放</td>
<td>释放</td>
</tr>
<tr>
<td><code>object.wait()</code></td>
<td>可以中断</td>
<td>释放</td>
<td>释放</td>
</tr>
<tr>
<td><code>condition.await()</code></td>
<td>可以中断</td>
<td>释放</td>
<td>释放</td>
</tr>
</tbody></table>
<p>其中<code>thread.join</code>底层其实是调用了thread对象的<code>wait</code>方法，之后一般被jvm的<code>notify</code>唤醒。<br>源码参考:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">join</span><span class="params">(<span class="keyword">long</span> millis)</span> <span class="comment">// 方法上有synchronized</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> base = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">long</span> now = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (millis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"timeout value is negative"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (millis == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">                wait(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">                <span class="keyword">long</span> delay = millis - now;</span><br><span class="line">                <span class="keyword">if</span> (delay &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                wait(delay); <span class="comment">// 实际调用的是wait,由notify唤醒</span></span><br><span class="line">                now = System.currentTimeMillis() - base;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><em>总结</em><br><code>lock</code>,<code>synchronized</code>容易死锁，因为不可中断。<br>尽量用表格下方的方法，性能会高些。</p>
<h1 id="内核态"><a href="#内核态" class="headerlink" title="内核态"></a>内核态</h1><h2 id="What-什么是内核态"><a href="#What-什么是内核态" class="headerlink" title="What: 什么是内核态"></a>What: 什么是内核态</h2><p>访问不属于自己的内存（用户空间、虚拟内存地址）时，<br>需要系统调用，进入cpu特权模式，因此需要切换到内核态；</p>
<p><em>切换到内核态时是否一定要释放cpu?</em><br>只是把寄存器保存到进程内核栈而已，进程cpu并不需要释放；</p>
<p><em>进程切换、线程切换是否需要切换内核态？</em><br>进程切换、线程切换：需要用到内核里的数据结构，因此需要进入内核态；</p>
<h1 id="操作系统线程库"><a href="#操作系统线程库" class="headerlink" title="操作系统线程库"></a>操作系统线程库</h1><p>1）POSIX Pthreads：可以作为用户或内核库提供，作为 POSIX 标准的扩展<br>2）Win32 线程：用于 Window 操作系统的内核级线程库</p>
<h2 id="java的线程库"><a href="#java的线程库" class="headerlink" title="java的线程库"></a>java的线程库</h2><p>Java 线程 API 通常采用宿主系统的线程库来实现。<br>也就是说在 Win 系统上，Java 线程 API 通常采用 Win API 来实现；<br>在 UNIX 类系统上，采用 Pthread 来实现。</p>
<p>具体到hotpot实现，则JVM线程跟内核轻量级进程一一对应。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://xiaoyue26.github.io/2022/03/14/2022-03/%E4%B8%AD%E6%96%AD%E6%A2%B3%E7%90%86/" data-id="cl0qj2eb80000lxama0cn89sj" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E4%B8%AD%E6%96%AD/" rel="tag">中断</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%86%85%E6%A0%B8%E6%80%81/" rel="tag">内核态</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%BA%BF%E7%A8%8B/" rel="tag">线程</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-2022-03/mp4格式" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/03/13/2022-03/mp4%E6%A0%BC%E5%BC%8F/" class="article-date">
  <time datetime="2022-03-13T09:45:02.000Z" itemprop="datePublished">2022-03-13</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E9%9F%B3%E8%A7%86%E9%A2%91/">音视频</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/03/13/2022-03/mp4%E6%A0%BC%E5%BC%8F/">mp4格式</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <h1 id="WHAT-MP4"><a href="#WHAT-MP4" class="headerlink" title="WHAT: MP4"></a>WHAT: MP4</h1><p>一种封装格式(容器格式)，封装视频和音频、还有海报、字幕和元数据等；</p>
<p>常见的封装格式: MKV,AVI,MP4</p>
<p>MP4文件格式又被称为 MPEG-4 Part 14，出自 MPEG-4 标准第 14 部分。</p>
<h1 id="MP4格式"><a href="#MP4格式" class="headerlink" title="MP4格式"></a>MP4格式</h1><p>协议分为两阶段:<br>(1)<code>MPEG-4 Part 12</code>: 定义ISO基础媒体文件格式，存储基于时间的媒体内容；<br>(2)<code>MPEG-4 Part 14</code>: 在<code>MPEG-4 Part 12</code>基础上拓展，实际定义了MP4；<br>实际格式:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    Box</span><br><span class="line">    ,Box:[Box,Box:[Box]]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>多个box组成，box可嵌套；</p>
<h2 id="Box"><a href="#Box" class="headerlink" title="Box"></a>Box</h2><p>不同的Box类型:<br>(1)<code>ftyp</code>: <code>File Type Box</code>; 描述MP4规范与版本；最好用什么版本来解析、兼容哪些版本的解析；<br>(2)<code>moov</code>: <code>Movie Box</code>; 媒体的<code>metadata</code>信息；1个；<br>    next_track_ID: 下一个轨道的id;(如果要新增)<br>    volume: 播放音量;<br>单轨属性:<br>    layer: 视频轨道的叠加顺序，数字越小越靠近观看者;<br>    alternate_group：track的分组ID，同个分组里的track，只能有一个track处于播放状态;<br>    width、height：视频的宽高<br>(3)<code>mdat</code>: Media Data Box；实际媒体数据；多个；<br>(4)…其他box类型；</p>
<h3 id="moov"><a href="#moov" class="headerlink" title="moov"></a>moov</h3><p><code>ffmpeg</code>默认情况下生成<code>moov</code>是在<code>mdat</code>写完成之后再写入，所以moov是在mdat的后面，使用faststart参数可以将moov移到mdat前面。<br>(moov在前面的话，首帧渲染速度会更快一点)</p>
<figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i out.flv -c copy -movflags faststart out2.mp4</span><br></pre></td></tr></table></figure>

<h3 id="媒体数据结构划分"><a href="#媒体数据结构划分" class="headerlink" title="媒体数据结构划分"></a>媒体数据结构划分</h3><p>MP4媒体数据 -&gt; <code>chunk</code> -&gt; <code>sample</code> -&gt; 帧</p>
<h5 id="H264编码中的帧"><a href="#H264编码中的帧" class="headerlink" title="H264编码中的帧:"></a>H264编码中的帧:</h5><p>I帧: 关键帧；存的是完整的JPEG数据；<br>P帧: 前向预测编码帧；存的是与之前帧的差别；（参考别的帧）<br>B帧: 双向预测内插编码帧；双向差别，存的是和前帧、后帧的差别；（所以压缩率比P帧高，cpu占用高）</p>
<p>对于B帧，视频帧的解码顺序和渲染顺序不一致。（先解前后，才解中间；而渲染是顺序来的）</p>
<p>// H.265是一种视频压缩标准，仅需H.264的一半带宽即可播放相同质量的视频。</p>
<h5 id="H264流格式"><a href="#H264流格式" class="headerlink" title="H264流格式"></a>H264流格式</h5><p>1。<code>Annex-B</code><br>用<code>0x00000001</code>分割；<br>2。<code>RTP</code><br>长度+数据的格式；</p>
<h1 id="fmp4"><a href="#fmp4" class="headerlink" title="fmp4"></a>fmp4</h1><p>mp4: 点播<br>fmp4: 直播</p>
<p>时长: mp4固定,fmp4不固定（边生成边播）；<br>元数据: <code>mp4</code>-&gt;<code>moov box</code>;<br>       <code>fmp4</code>-&gt;<code>moof box</code>,和<code>mdat</code>通常结对出现；（流式）</p>
<h1 id="mp4相关工具"><a href="#mp4相关工具" class="headerlink" title="mp4相关工具"></a>mp4相关工具</h1><p>在线解析mp4的工具: <a href="https://gpac.github.io/mp4box.js/test/filereader.html" target="_blank" rel="noopener">https://gpac.github.io/mp4box.js/test/filereader.html</a><br>mp4dump、mp4edit、mp4encrypt等工具: <a href="http://www.bento4.com/" target="_blank" rel="noopener">http://www.bento4.com/</a><br><a href="https://github.com/gpac/gpac/wiki/MP4Box" target="_blank" rel="noopener">https://github.com/gpac/gpac/wiki/MP4Box</a><br>gpac：开源的多媒体工具包，包括用于MP4打包的mp4box等。<a href="https://github.com/gpac/gpac" target="_blank" rel="noopener">https://github.com/gpac/gpac</a><br>mp4v2：提供了API来创建和修改mp4文件。<a href="https://code.google.com/archive/p/mp4v2/" target="_blank" rel="noopener">https://code.google.com/archive/p/mp4v2/</a></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://segmentfault.com/a/1190000039270533" target="_blank" rel="noopener">https://segmentfault.com/a/1190000039270533</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://xiaoyue26.github.io/2022/03/13/2022-03/mp4%E6%A0%BC%E5%BC%8F/" data-id="cl0p3ck6y00006xjk2nw2cuhy" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/h264/" rel="tag">h264</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/mp4/" rel="tag">mp4</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%82%B9%E6%92%AD/" rel="tag">点播</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%9B%B4%E6%92%AD/" rel="tag">直播</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-2022-03/ss命令" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/03/13/2022-03/ss%E5%91%BD%E4%BB%A4/" class="article-date">
  <time datetime="2022-03-13T02:02:13.000Z" itemprop="datePublished">2022-03-13</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/http/">http</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/03/13/2022-03/ss%E5%91%BD%E4%BB%A4/">ss命令</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <h1 id="ss命令"><a href="#ss命令" class="headerlink" title="ss命令"></a>ss命令</h1><p><code>Socket Statistics</code><br>权威参考: <a href="https://man7.org/linux/man-pages/man8/ss.8.html" target="_blank" rel="noopener">https://man7.org/linux/man-pages/man8/ss.8.html</a></p>
<h2 id="查看tcp连接的统计信息"><a href="#查看tcp连接的统计信息" class="headerlink" title="查看tcp连接的统计信息:"></a>查看tcp连接的统计信息:</h2><figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ss -t | head</span><br></pre></td></tr></table></figure>
<p>可以看到tcp连接的状态、收发情况、双方地址:</p>
<figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">State      Recv-Q Send-Q Local Address:Port                 Peer Address:Port</span><br><span class="line">CLOSE-WAIT 1      0      10.28.234.170:64540                10.36.41.26:14326</span><br></pre></td></tr></table></figure>

<h2 id="Sockets摘要信息"><a href="#Sockets摘要信息" class="headerlink" title="Sockets摘要信息:"></a>Sockets摘要信息:</h2><figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ss -s</span><br></pre></td></tr></table></figure>

<h2 id="查看已建立的http"><a href="#查看已建立的http" class="headerlink" title="查看已建立的http"></a>查看已建立的http</h2><figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ss -o state established '( dport = :http or sport = :http )'</span><br></pre></td></tr></table></figure>

<h3 id="查看监听的端口"><a href="#查看监听的端口" class="headerlink" title="查看监听的端口"></a>查看监听的端口</h3><figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ss -l</span><br></pre></td></tr></table></figure>

<h3 id="查看进程占用的端口"><a href="#查看进程占用的端口" class="headerlink" title="查看进程占用的端口"></a>查看进程占用的端口</h3><figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ss -tnlp  | grep pid=97</span><br></pre></td></tr></table></figure>

<h3 id="状态过滤"><a href="#状态过滤" class="headerlink" title="状态过滤"></a>状态过滤</h3><figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ss -4 state time-wait # 仅显示ipv4</span><br><span class="line">ss -6 # 仅显示ipv6</span><br></pre></td></tr></table></figure>
<p>状态的枚举可以通过 <code>ss -h</code>查看帮助来获取。</p>
<h3 id="查看内存占用"><a href="#查看内存占用" class="headerlink" title="查看内存占用"></a>查看内存占用</h3><p>用<code>ss -m</code>即可，具体输出的格式的定义如下：</p>
<figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">skmem:(r&lt;rmem_alloc&gt;,rb&lt;rcv_buf&gt;,t&lt;wmem_alloc&gt;,tb&lt;snd_buf&gt;,</span><br><span class="line">                            f&lt;fwd_alloc&gt;,w&lt;wmem_queued&gt;,o&lt;opt_mem&gt;,</span><br><span class="line">                            bl&lt;back_log&gt;,d&lt;sock_drop&gt;)</span><br><span class="line"></span><br><span class="line">      &lt;rmem_alloc&gt;</span><br><span class="line">            the memory allocated for receiving packet</span><br><span class="line"></span><br><span class="line">      &lt;rcv_buf&gt;</span><br><span class="line">             the total memory can be allocated for receiving</span><br><span class="line">             packet</span><br><span class="line"></span><br><span class="line">      &lt;wmem_alloc&gt;</span><br><span class="line">             the memory used for sending packet (which has been</span><br><span class="line">             sent to layer 3)</span><br><span class="line"></span><br><span class="line">      &lt;snd_buf&gt;</span><br><span class="line">             the total memory can be allocated for sending</span><br><span class="line">             packet</span><br><span class="line"></span><br><span class="line">      &lt;fwd_alloc&gt;</span><br><span class="line">             the memory allocated by the socket as cache, but</span><br><span class="line">             not used for receiving/sending packet yet. If need</span><br><span class="line">             memory to send/receive packet, the memory in this</span><br><span class="line">             cache will be used before allocate additional</span><br><span class="line">             memory.</span><br><span class="line"></span><br><span class="line">      &lt;wmem_queued&gt;</span><br><span class="line">             The memory allocated for sending packet (which has</span><br><span class="line">             not been sent to layer 3)</span><br><span class="line"></span><br><span class="line">      &lt;ropt_mem&gt;</span><br><span class="line">             The memory used for storing socket option, e.g.,</span><br><span class="line">             the key for TCP MD5 signature</span><br><span class="line"></span><br><span class="line">      &lt;back_log&gt;</span><br><span class="line">             The memory used for the sk backlog queue. On a</span><br><span class="line">             process context, if the process is receiving</span><br><span class="line">             packet, and a new packet is received, it will be</span><br><span class="line">             put into the sk backlog queue, so it can be</span><br><span class="line">             received by the process immediately</span><br><span class="line"></span><br><span class="line">      &lt;sock_drop&gt;</span><br><span class="line">             the number of packets dropped before they are de-</span><br><span class="line">             multiplexed into the socket</span><br></pre></td></tr></table></figure>











      
    </div>
    <footer class="article-footer">
      <a data-url="http://xiaoyue26.github.io/2022/03/13/2022-03/ss%E5%91%BD%E4%BB%A4/" data-id="cl0omuqlp0001i2jk6uos50i6" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ss/" rel="tag">ss</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/tcp/" rel="tag">tcp</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-2022-03/UDP批处理优化-GSO-GRO" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/03/13/2022-03/UDP%E6%89%B9%E5%A4%84%E7%90%86%E4%BC%98%E5%8C%96-GSO-GRO/" class="article-date">
  <time datetime="2022-03-13T01:59:14.000Z" itemprop="datePublished">2022-03-13</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/http/">http</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/03/13/2022-03/UDP%E6%89%B9%E5%A4%84%E7%90%86%E4%BC%98%E5%8C%96-GSO-GRO/">UDP批处理优化-GSO/GRO</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <h1 id="GSO和GRO"><a href="#GSO和GRO" class="headerlink" title="GSO和GRO"></a>GSO和GRO</h1><p>GSO: <code>Generic Segmentation Offload</code><br>发送端；推迟发送端网络包分片，提高大包发送性能；<br>GRO: <code>Generic Receive Offload</code><br>接受端；提早合并到达网卡的小包；提高接受性能；</p>
<h2 id="GSO原理"><a href="#GSO原理" class="headerlink" title="GSO原理"></a>GSO原理</h2><p>before:<br>刚开始就分片，每个小分片参与后续的IP层、链路层、网卡驱动的系统调用；<br>after:<br>在网卡发送前再分片，减少系统调用。<br>// 1。 网卡支持：由网卡分片；<br>// 2。 网卡不支持：发送到网卡前一刻，内核做分片；</p>
<h1 id="GRO"><a href="#GRO" class="headerlink" title="GRO"></a>GRO</h1><p>GRO类似于GSO，都是在离网卡最近的地方做分片、合并之类的事情。（批处理）</p>
<h1 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h1><p>cpu消耗：降低<br>网络吞吐优化：25%<br>系统调用次数降低：97%<br>系统耗时降低：90%</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://xiaoyue26.github.io/2022/03/13/2022-03/UDP%E6%89%B9%E5%A4%84%E7%90%86%E4%BC%98%E5%8C%96-GSO-GRO/" data-id="cl0omuqlj0000i2jkdvgbebwf" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/gpo/" rel="tag">gpo</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/gso/" rel="tag">gso</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/udp/" rel="tag">udp</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-2022-02/为什么先hash后加密的方法容易遭遇padding攻击" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/02/24/2022-02/%E4%B8%BA%E4%BB%80%E4%B9%88%E5%85%88hash%E5%90%8E%E5%8A%A0%E5%AF%86%E7%9A%84%E6%96%B9%E6%B3%95%E5%AE%B9%E6%98%93%E9%81%AD%E9%81%87padding%E6%94%BB%E5%87%BB/" class="article-date">
  <time datetime="2022-02-24T12:35:13.000Z" itemprop="datePublished">2022-02-24</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/http/">http</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/02/24/2022-02/%E4%B8%BA%E4%BB%80%E4%B9%88%E5%85%88hash%E5%90%8E%E5%8A%A0%E5%AF%86%E7%9A%84%E6%96%B9%E6%B3%95%E5%AE%B9%E6%98%93%E9%81%AD%E9%81%87padding%E6%94%BB%E5%87%BB/">为什么先hash后加密的方法容易遭遇padding攻击</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <h1 id="tls1-2实际加密方式"><a href="#tls1-2实际加密方式" class="headerlink" title="tls1.2实际加密方式"></a>tls1.2实际加密方式</h1><p>实际上加密算法是需要padding的，最早的padding方法是:<br><code>AES(text+MAC(text)+padding)</code><br>后来因为这种方式容易遭遇padding攻击，因此tls1.3采用了更安全的padding方法:<br>先<code>E=AES(text+padding)</code><br>然后： <code>E+MAC(E)</code></p>
<blockquote>
<p>padding攻击，通过反复修改部分内容、并触发解密过程，从而探测猜测加密算法的密钥；</p>
</blockquote>
<h1 id="Why"><a href="#Why" class="headerlink" title="Why"></a>Why</h1><p><code>padding oracle attack</code>:<br><a href="https://zh.wikipedia.org/wiki/%E5%AF%86%E6%96%87%E5%A1%AB%E5%A1%9E%E6%94%BB%E5%87%BB" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/%E5%AF%86%E6%96%87%E5%A1%AB%E5%A1%9E%E6%94%BB%E5%87%BB</a><br>从攻击方式可以看出，攻击者主要是以<br>1。修改最后1个字节；<br>2。触发解密，根据服务器返回（可能是耗时差异，也可能是返回错误），判断填充是否正确；<br>这种模式进行攻击。<br>所以如果在第2步，减少触发解密步骤的频率，则可以提供攻击难度。</p>
<p>回顾加密传输的两种处理步骤:<br>(1)hash-&gt;padding-&gt;加密;<br>(2)padding-&gt;加密-&gt;hash;</p>
<p>对应的解密步骤:<br>(1)解密-&gt;去掉padding-&gt;检查hash;<br>(2)检查hash-&gt;解密-&gt;去掉padding;</p>
<p>第1种方案：第一步就触发解密，容易被攻击；<br>第2种方案: 如果hash检查失败，就不会往后走解密逻辑了，因此攻击的难度提高了 。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://xiaoyue26.github.io/2022/02/24/2022-02/%E4%B8%BA%E4%BB%80%E4%B9%88%E5%85%88hash%E5%90%8E%E5%8A%A0%E5%AF%86%E7%9A%84%E6%96%B9%E6%B3%95%E5%AE%B9%E6%98%93%E9%81%AD%E9%81%87padding%E6%94%BB%E5%87%BB/" data-id="cl00qhivt0000d2amdeia72dj" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/AES/" rel="tag">AES</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/HMAC/" rel="tag">HMAC</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/HTTP/" rel="tag">HTTP</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/RSA/" rel="tag">RSA</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/SSL/" rel="tag">SSL</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/TLS/" rel="tag">TLS</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-2022-02/keepalive" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/02/24/2022-02/keepalive/" class="article-date">
  <time datetime="2022-02-24T11:18:55.000Z" itemprop="datePublished">2022-02-24</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/http/">http</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/02/24/2022-02/keepalive/">http和tcp层面的keepAlive机制</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <h1 id="What-keepAlive机制是什么"><a href="#What-keepAlive机制是什么" class="headerlink" title="What: keepAlive机制是什么"></a>What: keepAlive机制是什么</h1><h2 id="HTTP层面"><a href="#HTTP层面" class="headerlink" title="HTTP层面"></a>HTTP层面</h2><p>http1.0是短连接，每次http请求都建立tcp连接然后断开；（3次握手4次挥手）<br>http1.1为了优化性能，推出keepAlive机制，同域名的多个http请求可以复用同一个tcp连接，也就是让tcp连接不每次断开，keepAlive。<br>对于http协议来说，就是在header里标示这种需求: <code>Connection: Keep-Alive</code></p>
<p>HTTP层面实际做的事情: header里标示keepAlive，然后通信双方不主动关闭tcp连接。<br>// http没有发送多余的保活、探活报文；</p>
<h2 id="TCP层面"><a href="#TCP层面" class="headerlink" title="TCP层面"></a>TCP层面</h2><blockquote>
<p>背景<br>TCP层面本来没必要做keepAlive，毕竟一个连接没有被关闭默认就是alive的。<br>但因为实际使用的时候，空闲的tcp连接会被 防火墙、负载均衡、代理软件 等中间节点掐断，<br>而且一般它们掐断空闲tcp连接的时候并不会向客户端发送任何报文提醒，因此客户端是无感知的。<br>这种情况可能产生 <code>Broken Pipe</code>错误。<br>为了避免这种情况，windows和linux内核在实现tcp的时候，加上了keepAlive机制。</p>
</blockquote>
<p>TCP层面的keepAlive实际做的事情: 发送keepAlive报文，返回对端的存活性；<br>两个作用：</p>
<ol>
<li>保活: 发送心跳报文，防止tcp连接被识别为空闲连接; // 防止被别人掐断；</li>
<li>探活: 探测对方的存活性，如果对方真的不在了，也不能浪费资源维持连接； // 主动自己断开；</li>
</ol>
<p>本质上就是：要断开连接的话，还是自己来吧，不让别人代劳了，不然别人掐了也不告诉我，凭空增加了我的异常；</p>
<h1 id="How-如何配置tcp层面的keepAlive"><a href="#How-如何配置tcp层面的keepAlive" class="headerlink" title="How: 如何配置tcp层面的keepAlive"></a>How: 如何配置tcp层面的keepAlive</h1><h2 id="保活-keepAlive间隔配置"><a href="#保活-keepAlive间隔配置" class="headerlink" title="保活: keepAlive间隔配置"></a>保活: keepAlive间隔配置</h2><p>linux内核tcp的keepAlive报文间隔默认是2小时； (<code>net.ipv4.tcp_keepalive_time</code>)<br>实际应该参考常见的”掐断连接凶手”的空闲连接配置，设置短一些。<br>比如：<br>F5: 空闲5分钟掐断；<br>GoogleCloud防火墙：空闲10分钟掐断；</p>
<p>所以可以考虑配置成5分钟keepAlive一次</p>
<h2 id="探活-主动断开相关的配置："><a href="#探活-主动断开相关的配置：" class="headerlink" title="探活: 主动断开相关的配置："></a>探活: 主动断开相关的配置：</h2><p><code>net.ipv4.tcp_keepalive_intvl</code>: 对端不正常的话，多久重试1次； 比如75秒；<br><code>net.ipv4.tcpkeepaliveprobes</code>: 最多重试几次以后断开； 比如9次以后主动断开；</p>
<h2 id="Http层面KeepAlive配置"><a href="#Http层面KeepAlive配置" class="headerlink" title="Http层面KeepAlive配置"></a>Http层面KeepAlive配置</h2><p>HTTP的头部：<br>1。 End-to-end头部：头部会被中间的代理原样转发；如Host等大部分Header；<br>2。 Hop-by-hop头部：只到下一跳节点；如KeepAlive头部；<br>因此要考虑Http请求链路上每一跳(比如Nginx)的KeepAlive配置，才能达到整个http请求涉及到的tcp连接都不自动断开。</p>
<h1 id="HTTP层面的keepAlive和tcp层面的keepAlive关系"><a href="#HTTP层面的keepAlive和tcp层面的keepAlive关系" class="headerlink" title="HTTP层面的keepAlive和tcp层面的keepAlive关系"></a>HTTP层面的keepAlive和tcp层面的keepAlive关系</h1><p>如果没有tcp层面的keepAlive，http层面希望的连接不断开，可能无法实现；<br>可能被中间的节点（比如防火墙、负载均衡、NAT代理）掐断。</p>
<p>如果tcp层面的keepAlive配置正确，http层面的keepAlive才能正常完成。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://support.f5.com/csp/article/K13004262" target="_blank" rel="noopener">https://support.f5.com/csp/article/K13004262</a><br><a href="https://cloud.tencent.com/developer/news/696654" target="_blank" rel="noopener">https://cloud.tencent.com/developer/news/696654</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://xiaoyue26.github.io/2022/02/24/2022-02/keepalive/" data-id="cl00eue9s00009nam7rs7a3vh" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/http/" rel="tag">http</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/keepalive/" rel="tag">keepalive</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/tcp/" rel="tag">tcp</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-2022-02/拥塞算法bbr" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/02/18/2022-02/%E6%8B%A5%E5%A1%9E%E7%AE%97%E6%B3%95bbr/" class="article-date">
  <time datetime="2022-02-18T11:01:21.000Z" itemprop="datePublished">2022-02-18</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/http/">http</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/02/18/2022-02/%E6%8B%A5%E5%A1%9E%E7%AE%97%E6%B3%95bbr/">quic中的拥塞算法bbr</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <h1 id="BBR"><a href="#BBR" class="headerlink" title="BBR"></a>BBR</h1><p>BBR = <code>Bottleneck Bandwidth and Round-trip time</code> </p>
<h1 id="拥塞控制算法"><a href="#拥塞控制算法" class="headerlink" title="拥塞控制算法"></a>拥塞控制算法</h1><p>tcp默认使用cubic算法做拥塞控制;<br>谷歌的quic开发了新的拥塞控制算法，吞吐量更大，更能利用带宽开发了新的拥塞控制算法<code>bbr</code>,<code>bbr_v2</code>;</p>
<h1 id="CUBIC-vs-BBR"><a href="#CUBIC-vs-BBR" class="headerlink" title="CUBIC vs BBR"></a>CUBIC vs BBR</h1><p>cubic vs bbr:</p>
<img src="/images/2022-02/cubic_vs_bbr.png" class="" width="400" height="600" title="cubic_vs_bbr">
<p>可以看到tcp默认的cubic拥塞控制算法频繁上下调整滑动窗口大小，锯齿状；<br>而bbr倾向于平稳发送，在实际带宽比较平稳的场景下，吞吐量更大。（图中折线下方的面积更大）</p>
<p>原来tcp为什么没有解决这个问题：<br>(1)tcp在linux内核里，升级太困难了。<br>(2)tcp的一些约束导致rtt算不准。比如ack delay、重传包的seq number不变。</p>
<blockquote>
<p>cubic: 基于丢包；锯齿形吞吐；事件驱动； tcp的重传包seqId不变，rtt算不准；<br>BBR: 基于延迟； 有平滑区间；根据rtt建立对带宽（窗口大小）的模型，再加上定时器；<br>quic的重传包，seqId增加，rtt算得准。区分了具体的重传类型。<br>需要注意：tcp的ack delay时间影响rtt计算；(默认40ms)</p>
</blockquote>
<p>BBR的思想：<br>当rtt开始增长的时候，就达到了最大带宽。</p>
<p>cubic：把缓存塞满一直到丢包；<br>对丢包率的容忍非常低，即使只有极少的丢包，吞吐量也会急剧下降。</p>
<blockquote>
<p>缓冲膨胀<br>指的网络设备或者系统不必要地设计了过大的缓冲区。<br>当网络链路拥塞时，就会发生缓冲膨胀，从而导致数据包在这些超大缓冲区中长时间排队。<br>在先进先出队列系统中，过大的缓冲区会导致更长的队列和更高的延迟，并且不会提高网络吞吐量。<br>由于BBR并不会试图填满缓冲区，所以在避免缓冲区膨胀方面往往会有更好的表现。</p>
</blockquote>
<p>弱网环境,引入1.5%的丢包：<br>cubic：吞吐量下降99.7%<br>bbr: 吞吐量下降45%</p>
<h1 id="BBR的缺点"><a href="#BBR的缺点" class="headerlink" title="BBR的缺点"></a>BBR的缺点</h1><p>1。wifi环境网速变慢；<br>2。网络公平性下降: 挤占cubic算法带宽；<br>3。重传率会更高；<br>4。bbr对于rrt的测量是包级别的，可能容易受波动影响，可以考虑统计学上进行优化；</p>
<p>bbr的平稳发送时期本质上假设网络环境有一段时间是平稳的，因此比cubic抖动少，大部分情况下实际情况确实如此。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://aws.amazon.com/cn/blogs/china/talking-about-network-optimization-from-the-flow-control-algorithm/" target="_blank" rel="noopener">https://aws.amazon.com/cn/blogs/china/talking-about-network-optimization-from-the-flow-control-algorithm/</a><br>bbr思想：<a href="https://blog.csdn.net/dog250/article/details/52962727" target="_blank" rel="noopener">https://blog.csdn.net/dog250/article/details/52962727</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://xiaoyue26.github.io/2022/02/18/2022-02/%E6%8B%A5%E5%A1%9E%E7%AE%97%E6%B3%95bbr/" data-id="ckzsbgao00000qqam1le61y3c" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/bbr/" rel="tag">bbr</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/cubic/" rel="tag">cubic</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/http/" rel="tag">http</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/" rel="tag">java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/quic/" rel="tag">quic</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/spring/" rel="tag">spring</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-2022-02/http3-quic优缺点及原因" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/02/17/2022-02/http3-quic%E4%BC%98%E7%BC%BA%E7%82%B9%E5%8F%8A%E5%8E%9F%E5%9B%A0/" class="article-date">
  <time datetime="2022-02-17T02:09:02.000Z" itemprop="datePublished">2022-02-17</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/http/">http</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/02/17/2022-02/http3-quic%E4%BC%98%E7%BC%BA%E7%82%B9%E5%8F%8A%E5%8E%9F%E5%9B%A0/">http3_quic优缺点及原因</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <h1 id="WHAT-HTTP3-QUIC是什么？"><a href="#WHAT-HTTP3-QUIC是什么？" class="headerlink" title="WHAT: HTTP3/QUIC是什么？"></a>WHAT: HTTP3/QUIC是什么？</h1><p>QUIC: <code>Quick UDP Internet Connections</code><br>谷歌主导的网络协议，用udp代替tcp来作为http的传输协议。<br>HTTP3就是<code>HTTP over QUIC</code>。</p>
<img src="/images/2022-02/quic_struct.png" class="" width="800" height="1200" title="quic_struct">
<p>如上图所示是http2和http over quic的对比。<br>可以看到图中的分层不是完全对齐的，这是因为以前的分层方式不合理，影响了性能，因此quic重新划分了更合理的分层结构。<br>原来的tcp(传输层)和tls(会话层)要分别建立连接，增加了不必要的rtt。<br>quic在tls1.3的基础上，统一建立连接，然后再基于udp传输。<br>QUIC层的分层:<br>UDP层: 只管传输，不管连接；<br>Connection层: 复杂建连相关、拥塞控制(bbr_v2)、安全(tls1.3)；通过cid来确认唯一连接;<br>Stream层: 负责多路复用；基于Connection层，通过StreamID进行唯一流确认，stream对stream frame进行传输管理;</p>
<p>使用TCP的协议: SPDY/HTTP2<br>使用UDP的协议: quic/HTTP3</p>
<h1 id="WHY-QUIC的优点-为啥要使用QUIC"><a href="#WHY-QUIC的优点-为啥要使用QUIC" class="headerlink" title="WHY: QUIC的优点(为啥要使用QUIC)"></a>WHY: QUIC的优点(为啥要使用QUIC)</h1><ul>
<li>连接迁移优化</li>
<li>队头阻塞优化</li>
<li>拥塞控制优化</li>
<li>握手优化</li>
</ul>
<p>quic的优点其实也对应着解决了以前http协议栈中的几个缺点。</p>
<h2 id="连接迁移功能"><a href="#连接迁移功能" class="headerlink" title="连接迁移功能"></a>连接迁移功能</h2><h3 id="以前tcp的缺点"><a href="#以前tcp的缺点" class="headerlink" title="以前tcp的缺点"></a>以前tcp的缺点</h3><p>移动客户端ip变化以后，连接断开，需要重新握手、创建新的连接。<br>我们日常生活中坐车、旅行等场景下，用手机上网，经过不同的基站，移动网络切换是比较常见的场景，<br>因此可能会经历频繁的连接重建，体验较差。</p>
<blockquote>
<p>为什么tcp有这个缺点:<br>tcp用通信双方的ip+port(4元组)来标示一个连接，因此客户端ip变了的话，连接就变了。<br>tcp很老了，最早的时候手机还不普及，固定电脑的ip基本上不会变。</p>
</blockquote>
<p><code>http over quic</code>则可以在客户端ip变化时，依然保持连接不断，减少了rtt，提高了体验；</p>
<h3 id="quic如何解决这个问题的"><a href="#quic如何解决这个问题的" class="headerlink" title="quic如何解决这个问题的"></a>quic如何解决这个问题的</h3><p>上面有说的tcp这个缺点的原因是标示连接唯一性的方式，所以很自然的思路是用别的方式来标示连接唯一性。<br>quic的方法是用connectionId（cid,64位）来唯一确定一个连接，客户端ip变化以后，cid不变，因此连接可以不断开。</p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>对于quic server:<br>如果根据客户端ip路由，连接迁移会失败；得根据cid路由；<br>一般得路由到同主机、同进程，才能保证连接迁移成功。<br>或者把连接相关的有状态信息存储在分布式缓存中(比如把session ticket存储在redis中)。</p>
<p>quic协议考虑到cid对于路由的重要性，因此cid是明文存储的。</p>
<h2 id="解决了队头阻塞问题-多路复用功能增强"><a href="#解决了队头阻塞问题-多路复用功能增强" class="headerlink" title="解决了队头阻塞问题(多路复用功能增强)"></a>解决了队头阻塞问题(多路复用功能增强)</h2><img src="/images/2022-02/quic_multi_stream.png" class="" width="800" height="1200" title="quic_multi_stream">
<h3 id="以前tcp的缺点-1"><a href="#以前tcp的缺点-1" class="headerlink" title="以前tcp的缺点"></a>以前tcp的缺点</h3><p>tcp队头阻塞的原因:<br>窗口更新机制: 滑动窗口的更新依赖于最左边的包的ack，如果队头的包一直没有ack，窗口不往后滑;<br>拥塞控制算法: 丢包以后启动丢包重传,窗口变小;<br>这些最终表现是tcp层面的队头阻塞。</p>
<ul>
<li>http1.0: 明文短连接，多个tcp连接；</li>
<li>http1.1: keepalive机制，长连接，复用同一个tcp连接，降低了建立连接的开销（节省了握手时间）；<br>客户端:pipeline机制，可以并行发；<br>服务端:必须顺序回，有队头阻塞；（同域名下的请求复用同一个连接，但必须排队）</li>
<li>http2: 用stream层解决http层面的队头阻塞（让同域名下的请求不排队了，间隔进行），但是还是有tcp层面的队头阻塞;<h3 id="quic如何解决这个问题的-1"><a href="#quic如何解决这个问题的-1" class="headerlink" title="quic如何解决这个问题的"></a>quic如何解决这个问题的</h3>解决TCP层面的队头阻塞，本质上是要开发一个新的流量控制、拥塞控制的整套方案放在UDP层之上。<br>quic的改进:<br>(1)窗口更新机制: 当已经读取的数据大于最大接收窗口的一半时，发送WINDOW_UPDATE帧告诉发送者，接收窗口已经更新。<br>(2)拥塞控制算法: 由于底层是udp，没有拥塞控制算法，因此quic需要实现拥塞控制算法。<br>quic在应用层实现拥塞控制算法，如bbr,bbr_v2，核心思想是用rtt来预测带宽情况。<br>tcp用丢包事件来判断带宽情况，比较不准。但tcp之所以这么傻，也是因为tcp中的一些约束，很难准确判断rtt的大小。<br>比如seq number机制，重传的时候无法判断是超时重传的包还是第一个包经过很长时间收到了，因为seq number相同。<br>quic的seq number改进: 通过streamId+offset, packet number的机制，重传的包packet number递增，这样可以算准rtt。</li>
</ul>
<h2 id="吞吐量更大（新拥塞控制算法）"><a href="#吞吐量更大（新拥塞控制算法）" class="headerlink" title="吞吐量更大（新拥塞控制算法）"></a>吞吐量更大（新拥塞控制算法）</h2><p>接上一节，quic开发了新的拥塞控制算法，吞吐量更大，更能利用带宽：<br>cubic vs bbr:</p>
<img src="/images/2022-02/cubic_vs_bbr.png" class="" width="400" height="600" title="cubic_vs_bbr">
<p>可以看到tcp默认的cubic拥塞控制算法频繁上下调整滑动窗口大小，锯齿状；<br>而bbr倾向于平稳发送，在实际带宽比较平稳的场景下，吞吐量更大。（图中折线下方的面积更大）</p>
<p>原来tcp为什么没有解决这个问题：<br>(1)tcp在linux内核里，升级太困难了。<br>(2)参考上一节，tcp的一些约束导致rtt算不准。比如ack delay、重传包的seq number不变。</p>
<h2 id="耗时短。握手-rtt减少；重连-0RTT特性。"><a href="#耗时短。握手-rtt减少；重连-0RTT特性。" class="headerlink" title="耗时短。握手-rtt减少；重连-0RTT特性。"></a>耗时短。握手-rtt减少；重连-0RTT特性。</h2><p>原来https over tcp的缺点:<br>(1)握手阶段: tls层和tcp层重复建立连接；<br>(2)握手阶段: tls1.2需要考虑历史包袱，考虑达到最大兼容性，握手需要2RTT;<br>(3)重连阶段: tls1.2需要一次握手;</p>
<h3 id="quic如何解决这个问题的-2"><a href="#quic如何解决这个问题的-2" class="headerlink" title="quic如何解决这个问题的"></a>quic如何解决这个问题的</h3><p>(1)握手阶段合并: 只建立一次连接，省掉tcp握手的1rtt。<br>将建立连接这件事统一放在quic层里，udp只专心做传输的事情。<br>(2)握手阶段: 1RTT。运气不好的话还是2RTT。<br>参考tls1.3，去掉不安全的算法，在客户端预置一些密码套件。<br>第一个握手客户端就直接选定加密协议，并生成相应的随机数，相当于跳过了tls1.2第一个rtt的协商；<br>如果服务端不支持，则使用HelloRetryRequest继续。<br>大部分情况下，都可以省掉第一次的rtt;<br>(3)重连阶段: 0 RTT。<br>参考tls1.3的session ticket(quic叫server config)，客户端和服务端都缓存之前握手协商好的配置。<br>重连的时候，客户端直接把配置和数据一起发给服务端。</p>
<h4 id="0RTT的前提："><a href="#0RTT的前提：" class="headerlink" title="0RTT的前提："></a>0RTT的前提：</h4><p>1。client不清缓存；（过期前）<br>2。通过cid路由到同一个server进程；<br>(或者服务端对于server config有统一缓存)<br>缺点：牺牲了一定时间内的前向安全；（过期时间内）</p>
<h1 id="QUIC的缺点"><a href="#QUIC的缺点" class="headerlink" title="QUIC的缺点"></a>QUIC的缺点</h1><h2 id="CPU开销大"><a href="#CPU开销大" class="headerlink" title="CPU开销大"></a>CPU开销大</h2><p>http over quic与http over tcp相比，cpu开销可能会更大。<br>如果没有特别优化，单机qps可能下降50%。<br>主要有以下几个原因：</p>
<h3 id="内核态vs用户态"><a href="#内核态vs用户态" class="headerlink" title="内核态vs用户态"></a>内核态vs用户态</h3><p>(1)原来拥塞控制在tcp，在内核，执行在内核态，性能更高；<br>解决方案: 暂时没想到;<br>(2)quic限定udp报文大小&lt;=1mtu(IPV6下为1350，IPV4下为1370)。<br>由于包的大小不能很大 =&gt; 因此包的数量会较多=&gt; 系统调用很多 =&gt; 性能下降。<br>解决方案:<br>(2.1)批处理；用sendmmsg，一次系统调用发多个udp包；<br>(2.2)网卡GSO offload方案，降低cpu消耗;</p>
<blockquote>
<p>quic对包的大小有两个限制<br>(1) initial包&gt;=1200: 预防UDP攻击；（反射攻击）<br>如果数据本身不足1200，用padding方式填充到1200字节。<br>反射攻击:<br>  被利用服务器输出流量与输入流量的比值我们称之为放大系数。<br>  这个系数与被利用服务器所提供的 UDP 服务有关。<br>  之前提到的利用 Memcache 漏洞的 DRDoS 攻击，可以获得稳定的 60000 倍放大系数。<br>  而我们日常使用的 DNS 则可以轻松的获得 50 倍的放大系数。<br>  由放大系数反推，我们可以知道，如果一个 UDP 服务被利用以后，放大系数小于等于1的话，则不存在利用价值.<br>  因为这个时候，只从带宽流量方面考虑的话，还不如直接利用攻击主机对被攻击服务器进行攻击效率高。 </p>
<p>(2)&lt;=1MTU(IPV6下为1350，IPV4下为1370):<br>IP层是没有超时重传机制的，如果IP层对一个数据包进行了分片，只要有一个分片丢失了，只能依赖于传输层进行重传。<br>结果是所有的分片都要重传一遍，这个代价有点大。<br>由此可见，IP分片会大大降低传输层传送数据的成功率，所以我们要避免IP分片。</p>
</blockquote>
<h3 id="加解密开销大"><a href="#加解密开销大" class="headerlink" title="加解密开销大"></a>加解密开销大</h3><p>谷歌fork的openssl分支：boringSSL（笑死）<br>具体原因不太清楚，可能是谷歌选择的加解密算法比较安全、计算开销比较大。<br>也有可能是开源实现里，选择密码编码学算法比较普通，没有给生产环境级别的优化。</p>
<p>解决方案：<br>如果在生产环境使用，需要相应修改加密套件。</p>
<h2 id="容易被拦截"><a href="#容易被拦截" class="headerlink" title="容易被拦截"></a>容易被拦截</h2><p>因为一些运营商不待见udp。<br>根据腾讯的文档：<a href="https://toutiao.io/posts/tixau8w/preview" target="_blank" rel="noopener">https://toutiao.io/posts/tixau8w/preview</a><br>QUIC失败率较高的三个省份为：贵州、广西和新疆；<br>失败率较高的运营商为：教育网和长城宽带。</p>
<p>解决方案：<br>需要支持降级到普通https。</p>
<h2 id="nginx支持不全"><a href="#nginx支持不全" class="headerlink" title="nginx支持不全"></a>nginx支持不全</h2><p>比如nginx reload会断开已建立的quic连接.(因为对ng来说是udp)</p>
<p>解决方案：<br>需要修改nginx内核。</p>
<ul>
<li>内核逻辑调试工具<br>systemtap 内核逻辑调试工具,查看内核调用栈<br>内核的timewait监控: /proc/net/netstat中 的 TCPTimeWaitOverflow<br>Broken pipe(32) tcp_max_tw_buckets</li>
</ul>
<h1 id="QUIC应用场景"><a href="#QUIC应用场景" class="headerlink" title="QUIC应用场景"></a>QUIC应用场景</h1><p>弱网环境：因为quic的拥塞控制算法bbr在丢包时性能更好；<br>        因为quic的重连、建连rtt少；<br>对安全重视的环境：因为tls1.3更安全；<br>移动端：因为连接迁移功能；<br>并发请求多的应用: 因为quic没有tcp层的队头阻塞，多路复用更彻底;</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>可以参考谷歌开源的chromium中的quic协议栈，以及相应的server demo。<br>谷歌浏览器内核支持quic，其他浏览器内核就不一定了。<br>谷歌: <a href="https://www.chromium.org/quic/" target="_blank" rel="noopener">https://www.chromium.org/quic/</a><br>腾讯：<a href="https://zhuanlan.zhihu.com/p/32560981" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/32560981</a><br>微博: <a href="https://www.infoq.cn/article/2018%2F03%2Fweibo-quic" target="_blank" rel="noopener">https://www.infoq.cn/article/2018%2F03%2Fweibo-quic</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://xiaoyue26.github.io/2022/02/17/2022-02/http3-quic%E4%BC%98%E7%BC%BA%E7%82%B9%E5%8F%8A%E5%8E%9F%E5%9B%A0/" data-id="ckzqp6ooc0000n2am93597kv9" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/http/" rel="tag">http</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/http3/" rel="tag">http3</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/" rel="tag">java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/quic/" rel="tag">quic</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/spring/" rel="tag">spring</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-2022-02/http-range" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/02/16/2022-02/http-range/" class="article-date">
  <time datetime="2022-02-16T09:27:26.000Z" itemprop="datePublished">2022-02-16</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/http/">http</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/02/16/2022-02/http-range/">http_range</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <h1 id="http协议header中的range相关"><a href="#http协议header中的range相关" class="headerlink" title="http协议header中的range相关"></a>http协议header中的range相关</h1><p>客户端可以在http请求的header中指定请求资源的范围(range)，如果服务端支持的话，就可以只返回部分数据，节约网络资源。<br>如果服务端实现了这部分协议，客户端就可以进行断点续传、多线程下载、在线播放视频修改进度等功能了。<br>应用场景：<br>1。在线播放视频：调整进度；（seek offset）<br>2。下载文件：多线程下载、断点续传。</p>
<h2 id="检查服务端是否支持"><a href="#检查服务端是否支持" class="headerlink" title="检查服务端是否支持"></a>检查服务端是否支持</h2><p>可以通过命令:</p>
<figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -I https://cdn.com/xxx.png</span><br></pre></td></tr></table></figure>
<p>来检查服务端是否支持。<br>如果支持,服务端的回复是bytes：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Accept-Ranges: bytes</span><br></pre></td></tr></table></figure>
<p>如果不支持，服务端的回复是none:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Accept-Ranges: none</span><br></pre></td></tr></table></figure>
<p>(<code>curl -I</code>只显示header; <code>curl -i</code>显示header和body)</p>
<h2 id="实际应用中的回复"><a href="#实际应用中的回复" class="headerlink" title="实际应用中的回复"></a>实际应用中的回复</h2><p>客户端发送:</p>
<figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -i -H "Range: bytes=0-1023" https://cdn.com/xxx.png</span><br></pre></td></tr></table></figure>
<p>服务端正常回复206(单个区间的话):</p>
<figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 206 Partial Content</span><br><span class="line">Content-Type: image/png</span><br><span class="line">Content-Length: 1024</span><br><span class="line">Connection: keep-alive</span><br><span class="line">ETag: "2F4AF992F06D75CA7BE353ED2A981C45"</span><br><span class="line">Date: Tue, 01 Feb 2022 15:54:43 GMT</span><br><span class="line">Last-Modified: Tue, 25 Jan 2022 15:54:42 GMT</span><br><span class="line">Expires: Tue, 08 Feb 2022 15:54:43 GMT</span><br><span class="line">Age: 579015</span><br><span class="line">Cache-Control: max-age=604800</span><br><span class="line">Content-Range: bytes 0-1023/9404</span><br><span class="line">Accept-Ranges: bytes</span><br></pre></td></tr></table></figure>

<p>如果range不合法的话，服务端回复:</p>
<figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 416 Requested Range Not Satisfiable</span><br></pre></td></tr></table></figure>
<p>如果服务端不支持range请求，会回复200，并且返回全部数据:</p>
<figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br></pre></td></tr></table></figure>

<p>其他Range相关的一些姿势可以参考：<br><a href="https://www.greenbytes.de/tech/webdav/draft-ietf-httpbis-p5-range-latest.html#rule.ranges-specifier" target="_blank" rel="noopener">https://www.greenbytes.de/tech/webdav/draft-ietf-httpbis-p5-range-latest.html#rule.ranges-specifier</a><br>实际还可以指定多区间，指定末尾100个字节（<code>Range: bytes=-100</code>），<br>还可以用<code>If-Range</code>避免文件发生变更的情况：<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/If-Range" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/If-Range</a><br>只有Last-Modified或者ETag字段验证通过的时候，才处理<code>Range</code>请求，否则返回200（整个文件）。</p>
<h1 id="实现：spring中"><a href="#实现：spring中" class="headerlink" title="实现：spring中"></a>实现：spring中</h1><h2 id="方案1，交给spring接管"><a href="#方案1，交给spring接管" class="headerlink" title="方案1，交给spring接管"></a>方案1，交给spring接管</h2><p>如果是本地机器中的资源，可以封装成<code>FileSystemResource</code>；<br>如果要从别的地方获取byte数组，可以封装成<code>ByteArrayResource</code>;<br>状态直接写200(OK),spring会自动转成206。<br>示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/v3/csc/center/range"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CscCenterRangeController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/load"</span>)</span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResponseEntity&lt;ByteArrayResource&gt; <span class="title">load</span><span class="params">(@RequestParam(value = <span class="string">"fileKey"</span>)</span> String fileKey) </span>&#123;</span><br><span class="line">        String res = <span class="string">"1234"</span>;</span><br><span class="line">        <span class="keyword">final</span> HttpHeaders responseHeaders = <span class="keyword">new</span> HttpHeaders();</span><br><span class="line">        <span class="comment">// responseHeaders.add("Content-Type", "video/mp4");</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ResponseEntity&lt;&gt;(<span class="keyword">new</span> ByteArrayResource(res.getBytes()), responseHeaders, HttpStatus.OK);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/load-file"</span>)</span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResponseEntity&lt;FileSystemResource&gt; <span class="title">loadFile</span><span class="params">(@RequestParam(value = <span class="string">"fileKey"</span>)</span> String fileKey) </span>&#123;</span><br><span class="line">        String filePathString = <span class="string">"/Users/fengmengqi/Documents/DH_scret.png"</span>;</span><br><span class="line">        <span class="keyword">final</span> HttpHeaders responseHeaders = <span class="keyword">new</span> HttpHeaders();</span><br><span class="line">        <span class="comment">// responseHeaders.add("Content-Type", "video/mp4");</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ResponseEntity&lt;&gt;(<span class="keyword">new</span> FileSystemResource(filePathString), responseHeaders, HttpStatus.OK);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>缺点是spring似乎没有实现Range协议中的<code>If-Range</code>头。</p>
<h2 id="方案2，在spring提供的HttpRange类基础上实现"><a href="#方案2，在spring提供的HttpRange类基础上实现" class="headerlink" title="方案2，在spring提供的HttpRange类基础上实现"></a>方案2，在spring提供的HttpRange类基础上实现</h2><p>可以参考<code>org.springframework.web.servlet.resource.ResourceHttpRequestHandler#handleRequest</code><br>在HttpRange类的基础上实现自定义的Range相关协议，这样可以增添<code>If-Range</code>的功能。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Range_requests" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Range_requests</a><br><a href="https://www.greenbytes.de/tech/webdav/draft-ietf-httpbis-p5-range-latest.html#rule.ranges-specifier" target="_blank" rel="noopener">https://www.greenbytes.de/tech/webdav/draft-ietf-httpbis-p5-range-latest.html#rule.ranges-specifier</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://xiaoyue26.github.io/2022/02/16/2022-02/http-range/" data-id="ckzpdkrwo000090am6k5w85je" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/http/" rel="tag">http</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/" rel="tag">java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/spring/" rel="tag">spring</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-2022-01/voip-rtc" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/01/21/2022-01/voip-rtc/" class="article-date">
  <time datetime="2022-01-21T06:14:50.000Z" itemprop="datePublished">2022-01-21</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/rtc/">rtc</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/01/21/2022-01/voip-rtc/">VoIP和RTC</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <h1 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h1><h2 id="VoIP"><a href="#VoIP" class="headerlink" title="VoIP"></a>VoIP</h2><p>VoIP: <code>Voice over Internet Protocol</code><br>基于IP的语音传输。只是概念，不对应具体协议栈、有不同实现。<br>别名：IP电话、互联网电话、宽带电话、宽带电话服务。<br>VoIP可用于包括VoIP电话、智能手机、个人计算机在内的诸多互联网接入设备，通过蜂窝网络、Wi-Fi进行通话及发送短信。</p>
<p>VoIP的实现迭代:<br>(1)DSL/cable调制解调器<br>(2)Wifi/3G<br>(3)LTE<br>(4)RCS</p>
<h2 id="V-VoIP"><a href="#V-VoIP" class="headerlink" title="V.VoIP"></a>V.VoIP</h2><p><code>Video over IP</code><br>一些V.VoIP的基本要素包括信令、媒体引擎、会话描述协议（SDP）、实时传输协议/实时控制协议（RTP/RTCP）、<br>网络地址转换（NAT）、安全协议、服务质量（QoS），以及其余电话组件。<br>V.VoIP实质上是封装了全部这一切，再加上用户界面，包括拨号、通信录/联系人列表和呼叫历史记录（未接/已接/已拨电话），<br>以提供一个完整的V.VoIP客户端。</p>
<h2 id="RTC"><a href="#RTC" class="headerlink" title="RTC"></a>RTC</h2><p>RTC: <code>Real-Time Communications</code><br>RTC也就是实时交流。一般是指音\视频。日常生活中的例子包括：微信通话、视频会议、直播PK连麦、在线教育。</p>
<p>上述两种概念，都看重”端到端延时”指标，大致定义如下:</p>
<img src="/images/2022-01/voip_transfer.png" class="" width="800" height="1200" title="transfer">
<p>从这个流程，可以看出相比于普通文本传输，主要是多了和音视频相关的”采集”、”处理”、”编码”等操作。<br>其中的”网络”部分，由于VoIP是从电话网络演化而来，主要侧重于原来的电话网到IP网络；<br>RTC则主要侧重于IP网络。</p>
<h2 id="SIP协议"><a href="#SIP协议" class="headerlink" title="SIP协议"></a>SIP协议</h2><p><code>Session initialization Protocol</code><br>一种信令协议。<br>VoIP的具体实现的其中一部分的协议，主要做控制层（信令），基于文本。（RFC 2543, RFC 3261~3265）大致开始于1999年。</p>
<h2 id="WebRTC"><a href="#WebRTC" class="headerlink" title="WebRTC"></a>WebRTC</h2><p>谷歌收购GIPS引擎，与GTalk通信库合并，2011年纳入Chrome体系并开源，命名为WebRTC。<br>2012年获各大浏览器厂商支持，纳入W3C标准。</p>
<img src="/images/2022-01/web_rtc_sip.png" class="" width="800" height="1200" title="web_rtc_sip.png">

<p>WebRTC的架构大致如下，主要是给前端提供了封装好的API，屏蔽底层硬件。：</p>
<img src="/images/2022-01/webrtc.png" class="" width="800" height="1200" title="webrtc">

<p>绝大部分浏览器的新版本都支持webRTC:</p>
<img src="/images/2022-01/webrtc_support.png" class="" width="800" height="1200" title="webrtc_support.png">

<h2 id="RTMP"><a href="#RTMP" class="headerlink" title="RTMP"></a>RTMP</h2><p>RTMP: 是Real Time Messaging Protocol的简称，<br>基于 <em>TCP</em> 协议，用来进⾏实时数据通信的⽹络协议，<br>推流到CDN即用的是RTMP;</p>
<h2 id="SRS"><a href="#SRS" class="headerlink" title="SRS"></a>SRS</h2><p><code>Simple Realtime Server</code><br>互联网直播服务器集群的开源框架;<br><a href="https://github.com/ossrs/srs/wiki/v2_CN_Home" target="_blank" rel="noopener">https://github.com/ossrs/srs/wiki/v2_CN_Home</a></p>
<h1 id="发展历史"><a href="#发展历史" class="headerlink" title="发展历史"></a>发展历史</h1><h2 id="1996～2004：H323"><a href="#1996～2004：H323" class="headerlink" title="1996～2004：H323"></a>1996～2004：H323</h2><p>电话线上网时代；</p>
<h3 id="H-323标准"><a href="#H-323标准" class="headerlink" title="H.323标准"></a>H.323标准</h3><p>ITU（国际电信联盟）推出，<br>基于传统 PSTN 架构（Public Switched Telephone Network，公共交换电话网）。<br>(MCU+RTP)<br>H.323标准的VOIP网络中：<br>用户呼叫021号码：先送到上海、再到目的地；<br>在SIP中：直接查，无短途长途之分。</p>
<p>场景：PC语音会议；<br>优点：达到了可通话的质量；<br>缺点：MCU是中心化的，拓展性有上限。有合流成本。</p>
<h2 id="2001～2007-P2P-Mesh"><a href="#2001～2007-P2P-Mesh" class="headerlink" title="2001～2007: P2P/Mesh"></a>2001～2007: P2P/Mesh</h2><p>IETF, SIP(UDP + HTTP) 软交换</p>
<p>Skype: 超级节点+P2P/Mesh通信， 通信质量接近PSTN网络;<br>GTalk: 谷歌山寨的Skype</p>
<p>瑞典GIPS公司：开发出3A算法；<br>GIPS被谷歌收购，GIPS与 GTalk 的libjingle合并成为早期WebRTC一部分。</p>
<p>场景：社交IM的1v1通信；<br>优点：轻量级、架构拓展性强；<br>缺点：跨运营商无法保证Qos，去中心化后无法监控、管控；</p>
<h2 id="2003～2012-SFU"><a href="#2003～2012-SFU" class="headerlink" title="2003～2012: SFU"></a>2003～2012: SFU</h2><p>MMO RPG游戏兴起；</p>
<p>场景：游戏频道语音沟通、直播聊天室。<br>优点：架构简洁、实时性强，无需中心化合流聚合；<br>缺点：客户端下行压力大，互动人数有最大上限；</p>
<h2 id="SFU-vs-MCU"><a href="#SFU-vs-MCU" class="headerlink" title="SFU vs MCU"></a>SFU vs MCU</h2><p>SFU : Selective Forwarding Unit, 上行一路流，下行N路流，服务端仅转发。客户端压力大。<br>MCU: MultiPoint Control Unit, 中心化，上行下行都一路流，服务端负责合流。服务端压力大。</p>
<img src="/images/2022-01/sfu_mcu.png" class="" width="800" height="1200" title="sfu_mcu.png">

<h1 id="基础评估指标"><a href="#基础评估指标" class="headerlink" title="基础评估指标"></a>基础评估指标</h1><h2 id="性能相关："><a href="#性能相关：" class="headerlink" title="性能相关："></a>性能相关：</h2><ul>
<li>功耗</li>
<li>cpu/gpu/内存占用</li>
<li>引发降频时间(手机)<h2 id="屏幕分享相关"><a href="#屏幕分享相关" class="headerlink" title="屏幕分享相关"></a>屏幕分享相关</h2></li>
<li>清晰度&amp;分辨率</li>
<li>色彩准确度</li>
<li>相对静止场景最低码率</li>
<li>相对运动场景流畅度（文档滚动、局部动画）<br>基础端到端延时(&lt;1s)<h2 id="音频相关"><a href="#音频相关" class="headerlink" title="音频相关"></a>音频相关</h2></li>
<li>频宽</li>
<li>基础音质（POLQA评分&gt;2.5）</li>
<li>基础端到端延时</li>
<li>3A(增益控制、噪声一直、回声抵消)<h2 id="视频相关"><a href="#视频相关" class="headerlink" title="视频相关"></a>视频相关</h2></li>
<li>基础画质</li>
<li>基础流畅度（帧率、帧间隔）</li>
<li>基础端到端延时</li>
<li>音画同步</li>
</ul>
<h1 id="直播过程"><a href="#直播过程" class="headerlink" title="直播过程"></a>直播过程</h1><h2 id="对于主播："><a href="#对于主播：" class="headerlink" title="对于主播："></a>对于主播：</h2><p>1。申请开始直播:http; // 返回ok<br>2。获取推流目标:信令服务器 -&gt; 创建房间-&gt; 获取当前位置合适的MCU节点；<br>3。KTP推流到MCU节点；（UDP）<br>4。MCU存到SRS(经过RTMP转码);</p>
<h2 id="对于用户-拉数据"><a href="#对于用户-拉数据" class="headerlink" title="对于用户,拉数据:"></a>对于用户,拉数据:</h2><p>用户 -(flv over http)-&gt; CDN -&gt; Router -&gt; SRS</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://segmentfault.com/a/1190000040760567" target="_blank" rel="noopener">https://segmentfault.com/a/1190000040760567</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://xiaoyue26.github.io/2022/01/21/2022-01/voip-rtc/" data-id="ckyo0y0pf0000sdamb78d2vl7" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/rtc/" rel="tag">rtc</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/voip/" rel="tag">voip</a></li></ul>

    </footer>
  </div>
  
</article>
 


  


  <nav id="page-nav">
    <a class="extend prev" rel="prev" href="/">&amp;laquo; 上一页</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/24/">24</a><a class="extend next" rel="next" href="/page/3/">下一页&amp;raquo;</a>
  </nav>
</section>
           
    <aside id="sidebar">
  
    

  
    
  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title recent-posts">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/10/03/2022-10/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%94%BB%E5%87%BB-md/">java反序列化攻击</a>
          </li>
        
          <li>
            <a href="/2022/09/27/2022-09/sql%E6%B3%A8%E5%85%A5%E6%94%BB%E5%87%BB/">sql注入攻击</a>
          </li>
        
          <li>
            <a href="/2022/09/26/2022-09/%E5%B7%B2%E7%9F%A5%E6%98%8E%E6%96%87%E7%A0%B4%E8%A7%A3zip/">已知明文破解zip</a>
          </li>
        
          <li>
            <a href="/2022/09/26/2022-09/jwt%E7%A0%B4%E8%A7%A3/">jwt破解</a>
          </li>
        
          <li>
            <a href="/2022/09/25/2022-09/nc%E5%91%BD%E4%BB%A4%E7%AC%94%E8%AE%B0/">nc命令笔记</a>
          </li>
        
      </ul>
    </div>
  </div>

  
    

  
</aside>

      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-left">
      &copy; 2014 - 2022 风梦七&nbsp;|&nbsp;
      主题 <a href="https://github.com/giscafer/hexo-theme-cafe/" target="_blank">Cafe</a>
    </div>
     <div id="footer-right">
      联系方式&nbsp;|&nbsp;296671657@qq.com
    </div>
  </div>
</footer>
 
<script src="/jquery/jquery.min.js"></script>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">首页</a>
  
    <a href="/archives" class="mobile-nav-link">归档</a>
  
    <a href="/about" class="mobile-nav-link">关于</a>
  
</nav>
    <img class="back-to-top-btn" src="/images/fly-to-top.png"/>
<script>
// Elevator script included on the page, already.
window.onload = function() {
  var elevator = new Elevator({
    selector:'.back-to-top-btn',
    element: document.querySelector('.back-to-top-btn'),
    duration: 1000 // milliseconds
  });
}
</script>
      

  
    <script>
      var cloudTieConfig = {
        url: document.location.href, 
        sourceId: "",
        productKey: "e2fb4051c49842688ce669e634bc983f",
        target: "cloud-tie-wrapper"
      };
    </script>
    <script src="https://img1.ws.126.net/f2e/tie/yun/sdk/loader.js"></script>
    

  







<!-- author:forvoid begin -->
<!-- author:forvoid begin -->

  <link rel="stylesheet" href="https://jjeejj.github.io/css/gitment.css">
  <script src="https://www.wenjunjiang.win/js/gitment.js"></script>
  <script>
  var gitment = new Gitment({
    // id: '页面 ID', // 可选。默认为 location.href
    owner: 'xiaoyue26',
    repo: 'xiaoyue26.github.io',
    oauth: {
    client_id: 'cfe53b938f0d4c782371',
    client_secret: 'f96e68ae1103e7500c106aa3656a8bb31fe0ee99',
    }
  })
  gitment.render(document.getElementById("gitment_comments"))
</script>


<!-- author:forvoid end -->

<!-- author:forvoid begin -->

<!-- author:forvoid end -->

<!-- author:forvoid end -->


  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      })
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      })
    </script>
    <script type="text/javascript" src="https://cdn.rawgit.com/mathjax/MathJax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


 
<script src="/js/is.js"></script>



  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>


<script src="/js/elevator.js"></script>

  </div>
</body>
</html>