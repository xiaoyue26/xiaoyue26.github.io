<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>笔记本</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="笔记本">
<meta property="og:url" content="http://xiaoyue26.github.io/page/4/index.html">
<meta property="og:site_name" content="笔记本">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="风梦七">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="笔记本" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    
  
  
<link rel="stylesheet" href="/css/style.css">

  

<meta name="generator" content="Hexo 4.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    
    <div id="header-inner" class="inner">
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://xiaoyue26.github.io"></form>
      </div>
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">首页</a>
        
          <a class="main-nav-link" href="/archives">归档</a>
        
          <a class="main-nav-link" href="/about">关于</a>
        
      </nav>
      
    </div>
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">笔记本</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">风梦七</a>
        </h2>
      
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-2020-03/redis大key问题" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/23/2020-03/redis%E5%A4%A7key%E9%97%AE%E9%A2%98/" class="article-date">
  <time datetime="2020-03-23T06:22:37.000Z" itemprop="datePublished">2020-03-23</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/redis/">redis</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/23/2020-03/redis%E5%A4%A7key%E9%97%AE%E9%A2%98/">redis大key问题</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <ol start="0">
<li>为啥不能有大key;</li>
<li>有一些方法，避免大key;</li>
<li>有大key，安全删除大key;</li>
</ol>
<h1 id="what：-什么是大key问题"><a href="#what：-什么是大key问题" class="headerlink" title="what： 什么是大key问题"></a>what： 什么是大key问题</h1><p>就是一个key的value特别大，比如一个hashmap中存了超多k,v;<br>或者一个列表key中存了超长列表，等等；<br>多大算大： hashmap中有100w的k,v =&gt; 1s延迟；<br>删除大Key的时间复杂度: O(N), N代表大key里的值数量，因为redis是单线程一个个删。<br>所以删大key也会卡qps。</p>
<h2 id="开发规范"><a href="#开发规范" class="headerlink" title="开发规范"></a>开发规范</h2><h3 id="单key大小"><a href="#单key大小" class="headerlink" title="单key大小"></a>单key大小</h3><p>Redis限制每个String类型value大小不超过512MB， 实际开发中，不要超过10KB，否则会对CPU和网卡造成极大负载。 hash、list、set、zset元素个数不要超过5000。</p>
<p>理论上限: 每个hashset里头元素数量&lt; 2^32. </p>
<h3 id="key的数量"><a href="#key的数量" class="headerlink" title="key的数量"></a>key的数量</h3><p>官方评测： 单实例2.5亿<br>理论上限: 32位，2^32。约40亿</p>
<h2 id="测试删除大key"><a href="#测试删除大key" class="headerlink" title="测试删除大key"></a>测试删除大key</h2><p>可以用<code>slowlog</code>命令来查看删除耗时:</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DEL big_key1</span><br><span class="line">SLOWLOG GET <span class="number">2</span></span><br></pre></td></tr></table></figure>


<h1 id="why-为啥不能有大key"><a href="#why-为啥不能有大key" class="headerlink" title="why: 为啥不能有大key"></a>why: 为啥不能有大key</h1><p>redis的基础假设是每个操作都很快，所以设计成单线程处理；<br>所以如果有大key，基础设计就不成立了，会阻塞；</p>
<p>问题： </p>
<ol>
<li>数据倾斜，部分redis分片节点存储占用很高；</li>
<li>查询突然很慢，qps降低；</li>
</ol>
<h1 id="How-如何避免大key"><a href="#How-如何避免大key" class="headerlink" title="How: 如何避免大key"></a>How: 如何避免大key</h1><p>分治法，加一些key前缀\后置分解（如时间、哈希前缀、用户id后缀）;</p>
<h1 id="安全删除大key"><a href="#安全删除大key" class="headerlink" title="安全删除大key"></a>安全删除大key</h1><ol>
<li>首先要找到大key才能删除;</li>
<li>如何删除；</li>
</ol>
<h2 id="找到大key、删除大Key"><a href="#找到大key、删除大Key" class="headerlink" title="找到大key、删除大Key"></a>找到大key、删除大Key</h2><h3 id="当版本-lt-4-0"><a href="#当版本-lt-4-0" class="headerlink" title="当版本&lt;4.0"></a>当版本&lt;4.0</h3><p> 1、导出rdb文件分析: <code>bgsave</code>, <code>redis-rdb-tool</code>;<br> 2、命令: <code>redis-cli --bigkeys</code>,找出最大的key；<br> 3、自己写脚本扫描;<br> 4、单个key查看: <code>debug object key</code>： 查看某个key序列化后的长度，每次看1个key的信息,比较没效率。</p>
<h3 id="删除大Key"><a href="#删除大Key" class="headerlink" title="删除大Key:"></a>删除大Key:</h3><p>分解删除操作：<br>list: 逐步ltrim;<br>zset: 逐步zremrangebyscore;<br>hset: hscan出500个，然后hdel删除；<br>set: sscan扫描出500个，然后srem删除；<br>依次类推；</p>
<h3 id="当版本-gt-4-0"><a href="#当版本-gt-4-0" class="headerlink" title="当版本&gt;=4.0"></a>当版本&gt;=4.0</h3><h4 id="寻找大key"><a href="#寻找大key" class="headerlink" title="寻找大key"></a>寻找大key</h4><p>命令: <code>memory usage</code></p>
<h4 id="删除大key：-lazyfree机制"><a href="#删除大key：-lazyfree机制" class="headerlink" title="删除大key： lazyfree机制"></a>删除大key： lazyfree机制</h4><p><code>unlink</code>命令：代替DEL命令；<br>会把对应的大key放到<code>BIO_LAZY_FREE</code>后台线程任务队列，然后在后台异步删除；</p>
<p>类似的异步删除命令:</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">flushdb async: 异步清空数据库</span><br><span class="line">flushall async: 异步清空所有数据库</span><br></pre></td></tr></table></figure>
<p>异步删除配置:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">slave-lazy-flush: slave接受完rdb文件后，异步清空数据库；</span><br><span class="line">lazyfree-lazy-eviction: 异步淘汰key;</span><br><span class="line">lazyfree-lazy-expire:   异步key过期;</span><br><span class="line">lazyfree-lazy-server-del: 异步内部删除key；生效于rename命令</span><br><span class="line">## rename命令: RENAME mykey new_name </span><br><span class="line">## 如果new_name已经存在，会先删除new_name，此时触发上述lazy机制</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://xiaoyue26.github.io/2020/03/23/2020-03/redis%E5%A4%A7key%E9%97%AE%E9%A2%98/" data-id="ck96cxpqk00l8maam082dboea" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/redis/" rel="tag">redis</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-2020-03/分布式事务" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/23/2020-03/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/" class="article-date">
  <time datetime="2020-03-23T06:20:40.000Z" itemprop="datePublished">2020-03-23</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/java/">java</a>►<a class="article-category-link" href="/categories/java/%E5%B9%B6%E5%8F%91/">并发</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/23/2020-03/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/">分布式事务</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <blockquote>
<p>参考:<br><a href="https://segmentfault.com/a/1190000016397619#item-1-1" target="_blank" rel="noopener">https://segmentfault.com/a/1190000016397619#item-1-1</a><br><a href="https://www.cnblogs.com/duanxz/p/5226316.html" target="_blank" rel="noopener">https://www.cnblogs.com/duanxz/p/5226316.html</a></p>
</blockquote>
<p>文中提到的主要是微信支付数据库层面的分布式事务优化。</p>
<h2 id="优化前"><a href="#优化前" class="headerlink" title="优化前"></a>优化前</h2><p>架构上分为:<br>客户端;<br>CN: Coordinator,协调节点, 类似于对外的服务接口、代理，帮忙协调锁资源;<br>GTM： Global Transaction Manager, 类似于全局锁，全局事务管理器<br>DN: 具体数据节点; </p>
<p>逻辑很简单，就是CN每次向GTM申请锁，确保分布式事务的安全；<br>CN估计有多个，可能是react模式。<br>这种锁就像直接synchronized了全局，并发纯靠GTM单点纵向拓展。</p>
<h2 id="优化后"><a href="#优化后" class="headerlink" title="优化后"></a>优化后</h2><p>锁下放到DN层。</p>
<h1 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h1><p>分布式事务： 多个子系统一致成功、或一致失败回滚。</p>
<p>4种类型: </p>
<ol>
<li>优先考虑避免分布式事务：可以将两个子系统的数据库表放在同一个从库下时：直接使用mysql事务，避免分布式事务;</li>
<li>无法放在同一个从库下时: 使用TCC;</li>
<li>特殊限制下: TCC+MQ;</li>
<li>只要求最终一致性时: 使用MQ异步处理，反复重试。</li>
</ol>
<p>2PC和TCC的区别:<br>2PC: 数据库层，性能差(数据库锁)；<br>TCC: 应用层，性能高，开发成本高(需要保证幂等性)。</p>
<h1 id="TCC"><a href="#TCC" class="headerlink" title="TCC"></a>TCC</h1><p>TCC： Try-Cancel-Commit<br>开源实现: <code>ByteTCC</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1、Try：尝试执行业务。</span><br><span class="line">完成所有业务检查(一致性)</span><br><span class="line">预留必须业务资源(准隔离性)</span><br><span class="line"></span><br><span class="line">2、Confirm：确认执行业务。</span><br><span class="line">真正执行业务</span><br><span class="line">不做任何业务检查</span><br><span class="line">只使用Try阶段预留的业务资源</span><br><span class="line"></span><br><span class="line">3、Cancel：取消执行业务</span><br><span class="line">释放Try阶段预留的业务资源</span><br></pre></td></tr></table></figure>
<p>其中Confirm和cancel接口需要是幂等的。</p>
<img src="/images/2020-03/tcc.png" class="" width="800" height="1200" title="tcc">
<p>每个子事务实现TCC的几个幂等接口。</p>
<ol>
<li>使用try锁定资源;</li>
<li>所有子事务: 写redo日志(持久化)\undo日志(回滚), 执行操作;</li>
<li>所有子事务: commit提交;</li>
<li>失败则cancel取消。</li>
</ol>
<h2 id="特例"><a href="#特例" class="headerlink" title="特例"></a>特例</h2><p>最后一个子事务可以只实现TryCommit合并:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">IF(代金券.Try) &#123;</span><br><span class="line">    IF(现金支付.TryAndCommit) &#123;</span><br><span class="line">        代金券.Commit</span><br><span class="line">    &#125;  &#123;</span><br><span class="line">        代金券.Cancel</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="特殊限制下"><a href="#特殊限制下" class="headerlink" title="特殊限制下"></a>特殊限制下</h1><p>超强一致性：两个从库之间转账。<br>特殊限制： </p>
<p>加钱: 可以try\commit\cancel;<br>减钱: 不能try，只能tryCommit(也就是一步到位,不能打日志反复重试(不让记录redo log(什么？你想记录用户的密码？))，不能cancel(有undo日志也无法回滚)),能失败。</p>
<h3 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h3><p>方案1： 从库A先+100，然后从库B-100，最后都提交。<br>方案2： 从库B先-100，然后从库A+100，最后都提交。</p>
<p>方案1, 需要平台先垫钱，肯定是不行的。<br>方案2, 如果-100的操作是无法try的(比如依赖银行系统)，只能直接tryCommit，也就是只能位于末尾，否则就无法符合TCC的模式了。</p>
<p>方案3：<br>从库A+100:  Try;<br>从库B-100： TryCommit;<br>从库A+100:  Commit;</p>
<p>方案3可行，略麻烦。<br>方案3的简化：<br>从库B-100: TryCommit;<br>发布事件到MQ;<br>从库A订阅事件，反复重试+100。 </p>
<h1 id="最终一致性"><a href="#最终一致性" class="headerlink" title="最终一致性"></a>最终一致性</h1><p>将只需要最终一致性的子事务全部放在MQ中。<br>(类似发通知之类的事件)<br>发布事件到MQ，反复异步重试直到成功（削峰、错峰重试(随机探测)）</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://xiaoyue26.github.io/2020/03/23/2020-03/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/" data-id="ck96cxpql00lcmaamb3uahuf3" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/" rel="tag">分布式事务</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%B9%B6%E5%8F%91/" rel="tag">并发</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-2020-01/ThreadLocal的线性探测" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/01/12/2020-01/ThreadLocal%E7%9A%84%E7%BA%BF%E6%80%A7%E6%8E%A2%E6%B5%8B/" class="article-date">
  <time datetime="2020-01-12T10:01:31.000Z" itemprop="datePublished">2020-01-12</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/java/">java</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/01/12/2020-01/ThreadLocal%E7%9A%84%E7%BA%BF%E6%80%A7%E6%8E%A2%E6%B5%8B/">ThreadLocal的线性探测</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <p>参考:<br><a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1306581251653666" target="_blank" rel="noopener">https://www.liaoxuefeng.com/wiki/1252599548343744/1306581251653666</a><br><a href="http://songkun.me/2019/10/26/2019-10-26-java-threadlocal-hash-clash/" target="_blank" rel="noopener">http://songkun.me/2019/10/26/2019-10-26-java-threadlocal-hash-clash/</a><br><a href="https://juejin.im/post/5d43e415e51d4561db5e39ed" target="_blank" rel="noopener">https://juejin.im/post/5d43e415e51d4561db5e39ed</a></p>
<h1 id="避免ThreadLocal的内存泄露"><a href="#避免ThreadLocal的内存泄露" class="headerlink" title="避免ThreadLocal的内存泄露"></a>避免ThreadLocal的内存泄露</h1><p>参考上述资料,ThreadLocal是存在线程自己的变量,只不过用threadLocalMap把这个线程所有的ThreadLocal变量都集中存储了,key用的是ThreadLocal对象,value用的是对象T,也就是实际的数据。<br>由于key用的是弱引用,因此使用ThreadLocal时,使用结束时一定要进行<code>remove()</code>,否则会导致内存泄露。</p>
<p>这里的内存泄露有3重含义:</p>
<h2 id="局部ThreadLocal变量"><a href="#局部ThreadLocal变量" class="headerlink" title="局部ThreadLocal变量"></a>局部ThreadLocal变量</h2><p>这个数据语义上已经不用了,而且语法上ThreadLocal变量也已经离开作用域，也回收了,key变成了null;但由于ThreadLocal设计实现上的缺陷,ThreadLocalMap中的key变成null,value却不是null,依然强引用了数据,所以不能自动回收,需要程序员手动处理:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    threadLocalUser.set(user);</span><br><span class="line">    ...</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    threadLocalUser.remove();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="static-ThreadLocal变量"><a href="#static-ThreadLocal变量" class="headerlink" title="static ThreadLocal变量"></a>static ThreadLocal变量</h2><p>这个数据语义上已经不用了,但语法上这个ThreadLocal是static，没有离开作用域,<br>因此理论上还能访问到,设计上的生命周期太过于长了。 这种属于设计缺陷。也需要程序员手动处理,代码同上,也是调用<code>remove()</code>方法。</p>
<h2 id="搭配线程池的ThreadLocal变量"><a href="#搭配线程池的ThreadLocal变量" class="headerlink" title="搭配线程池的ThreadLocal变量"></a>搭配线程池的ThreadLocal变量</h2><p>这个数据本意上已经不用了,  如果不是线程池的线程，如果只是上述两种情况，也只会内存泄露一段时间，等到线程销毁的时候，就会释放相应的threadlocalMap和内存。<br>但如果搭配线程池使用，这里的ThreadLocalMap和ThreadLocal变量都会继续使用,永不释放内存。<br>因此程序语义变为不同任务都共享这个threadLocal变量，很可能有语义错误。<br>保险起见,也是同上,调用<code>remove()</code>方法即可。</p>
<h1 id="remove方法背后-ThreadLocalMap的实现机制"><a href="#remove方法背后-ThreadLocalMap的实现机制" class="headerlink" title="remove方法背后: ThreadLocalMap的实现机制"></a>remove方法背后: ThreadLocalMap的实现机制</h1><p>remove方法的语义很简单,就是将ThreadLocalMap的对应key/value都删除。<br>实际底层实现却并不简单,涉及到性能考虑=&gt;线性探测法=&gt;删除时rehash的连锁反应,导致实现较为特殊。</p>
<h2 id="斐波那契哈希"><a href="#斐波那契哈希" class="headerlink" title="斐波那契哈希"></a>斐波那契哈希</h2><p>ThreadLocalMap希望尽可能提高性能,因此使用斐波那契哈希,使用魔法数0x61c88647,为每一个ThreadLocal变量涉及了尽可能均匀、理论无碰撞的完美哈希，同时辅助以rehash扩容，来保证碰撞和线性探测死循环尽可能不发生。</p>
<h2 id="线性探测与删除"><a href="#线性探测与删除" class="headerlink" title="线性探测与删除"></a>线性探测与删除</h2><p>ThreadLocalMap处理哈希冲突时使用的是线性探测法,因此删除key的时候不能直接简单把entry置为null; 它采用的方法是把后续每个不为null的entry进行rehash, 放在合适的位置,保证不会因为删除导致线性探测失效中断。这里会把整个哈希表的数组看作循环队列,一直rehash到null的entry,因为当前的entry一定是null,而且负载因子不会太高,而且是单线程,因此一定不会死循环,有终止条件。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">expungeStaleEntry</span><span class="params">(<span class="keyword">int</span> staleSlot)</span> </span>&#123;</span><br><span class="line">  Entry[] tab = table;</span><br><span class="line">  <span class="keyword">int</span> len = tab.length;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 删除对应位置的entry</span></span><br><span class="line">  tab[staleSlot].value = <span class="keyword">null</span>;</span><br><span class="line">  tab[staleSlot] = <span class="keyword">null</span>;</span><br><span class="line">  size--;</span><br><span class="line"></span><br><span class="line">  Entry e;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// rehash过程,直到entry为null</span></span><br><span class="line">  <span class="keyword">for</span> (i = nextIndex(staleSlot, len);(e = tab[i]) != <span class="keyword">null</span>; i = nextIndex(i, len)) &#123;</span><br><span class="line">    ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">    <span class="comment">// k为空,证明已经被垃圾回收了</span></span><br><span class="line">    <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">        e.value = <span class="keyword">null</span>;</span><br><span class="line">        tab[i] = <span class="keyword">null</span>;</span><br><span class="line">        size--;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> h = k.threadLocalHashCode &amp; (len - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 判断当前元素是否处于"真正"应该待的位置</span></span><br><span class="line">        <span class="keyword">if</span> (h != i) &#123;</span><br><span class="line">            tab[i] = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">// 线性探测</span></span><br><span class="line">            <span class="keyword">while</span> (tab[h] != <span class="keyword">null</span>)</span><br><span class="line">                h = nextIndex(h, len);</span><br><span class="line">            tab[h] = e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>综上, 理论上每次删除都会进行局部链的rehash,但是由于斐波那契哈希设计上是绝对均匀，因此这个”局部链”的长度理论上是非常短甚至是0.<br>此外, 除了这种rehash的方法,还可以对entry进行delete标记来确保线性探测不会中断。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://xiaoyue26.github.io/2020/01/12/2020-01/ThreadLocal%E7%9A%84%E7%BA%BF%E6%80%A7%E6%8E%A2%E6%B5%8B/" data-id="ck96cxpqi00l0maam9guw40yb" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/" rel="tag">java</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-2019-12/长连接相关" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/12/29/2019-12/%E9%95%BF%E8%BF%9E%E6%8E%A5%E7%9B%B8%E5%85%B3/" class="article-date">
  <time datetime="2019-12-29T09:22:38.000Z" itemprop="datePublished">2019-12-29</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/tcp/">tcp</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/12/29/2019-12/%E9%95%BF%E8%BF%9E%E6%8E%A5%E7%9B%B8%E5%85%B3/">长连接相关</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <h1 id="WHAT-什么是长连接"><a href="#WHAT-什么是长连接" class="headerlink" title="WHAT: 什么是长连接"></a>WHAT: 什么是长连接</h1><p>长连接: TCP， 默认不断开，用keep alive心跳包保活;<br>持久连接: HTTP 1.1+ keep alive, 默认断开。<br>短连接: 普通HTTP</p>
<h1 id="WHY-长连接有什么好处-为什么要使用长连接"><a href="#WHY-长连接有什么好处-为什么要使用长连接" class="headerlink" title="WHY: 长连接有什么好处? 为什么要使用长连接"></a>WHY: 长连接有什么好处? 为什么要使用长连接</h1><ol>
<li>不同域名可以复用一个长连接; （HTTP不行）</li>
<li>不依赖DNS，节省DNS开销、避免DNS劫持;（HTTP不行）</li>
<li>减少握手时间开销；</li>
<li>可以push消息; </li>
</ol>
<h1 id="HOW-如何实现一个好的长连接-难点何在"><a href="#HOW-如何实现一个好的长连接-难点何在" class="headerlink" title="HOW: 如何实现一个好的长连接? (难点何在)"></a>HOW: 如何实现一个好的长连接? (难点何在)</h1><h2 id="难点1-长连接断开"><a href="#难点1-长连接断开" class="headerlink" title="难点1 长连接断开"></a>难点1 长连接断开</h2><p>导致断开的原因:</p>
<ol>
<li>各个环节的超时时间不匹配; – 动态探测合适的超时时间；</li>
<li>后台服务; – 或者服务主备切换</li>
<li>app后台进程挂了;  – app保活课题</li>
<li>切换网络;  </li>
</ol>
<h2 id="难点2-机器资源"><a href="#难点2-机器资源" class="headerlink" title="难点2 机器资源"></a>难点2 机器资源</h2><p>1亿长连接:<br>10w / 台 =&gt; 1000台机器<br>200w / 台 =&gt; 50台机器</p>
<p>20%活跃度=&gt; 总共需要2kw连接;<br>2000w =&gt; 10台~200台; </p>
<h3 id="连接限制"><a href="#连接限制" class="headerlink" title="连接限制:"></a>连接限制:</h3><ol>
<li>网卡限制: 网卡带宽、每秒通信量; </li>
<li>内核限制: 每个进程最大打开文件句柄数; (NR_OPEN =100w)</li>
<li>内存限制: TCP的发送、输出缓冲;</li>
</ol>
<p>假设一台机器抗200w个连接，则网卡需要:<br>200w<em>1KB/s = 2000MB/s = 16 Gps<br>假设平均20%活跃，则</em>0.2 = 3.2 Gps<br>依此类推内存。</p>
<h2 id="难点3-惊群效应"><a href="#难点3-惊群效应" class="headerlink" title="难点3 惊群效应"></a>难点3 惊群效应</h2><p>cpu: 100%<br><code>thundering herd</code>： 唤醒一群进程，只有一个进程工作，其他的又继续睡；反复这个流程。</p>
<blockquote>
<p>多进程（多线程）在同时阻塞等待同一个事件的时候（休眠状态），如果等待的这个事件发生，那么他就会唤醒等待的所有进程（或者线程），但是最终却只能有一个进程（线程）获得这个时间的“控制权”，对该事件进行处理，而其他进程（线程）获取“控制权”失败，只能重新进入休眠状态，这种现象和性能浪费就叫做惊群效应。</p>
</blockquote>
<h2 id="实现要点"><a href="#实现要点" class="headerlink" title="实现要点"></a>实现要点</h2><ol>
<li>处理好上述长连接断开的4个原因，保证服务质量；</li>
<li>进行断开重连： 监控+重连。</li>
<li>架构容灾：<img src="/images/2019-12/long_tcp.png" class="" width="400" height="600" title="long_tcp">
(1) 多地部署接入点;<br>(2) 长连接失败则降级到udp\http；</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://xiaoyue26.github.io/2019/12/29/2019-12/%E9%95%BF%E8%BF%9E%E6%8E%A5%E7%9B%B8%E5%85%B3/" data-id="ck96cxpqh00kwmaam43bt582d" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/tcp/" rel="tag">tcp</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%95%BF%E8%BF%9E%E6%8E%A5/" rel="tag">长连接</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-2019-12/分布式限流-redis-令牌桶" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/12/28/2019-12/%E5%88%86%E5%B8%83%E5%BC%8F%E9%99%90%E6%B5%81-redis-%E4%BB%A4%E7%89%8C%E6%A1%B6/" class="article-date">
  <time datetime="2019-12-28T13:34:45.000Z" itemprop="datePublished">2019-12-28</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/redis/">redis</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/12/28/2019-12/%E5%88%86%E5%B8%83%E5%BC%8F%E9%99%90%E6%B5%81-redis-%E4%BB%A4%E7%89%8C%E6%A1%B6/">分布式限流: redis+令牌桶</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <p>限流一般有漏桶和令牌桶两种实现，详情网上很多资料。<br>一般都会选用令牌桶算法，比较灵活，可以支持预热、容忍一定突发流量、预支一部分流量的弹性。</p>
<h1 id="单进程限流"><a href="#单进程限流" class="headerlink" title="单进程限流"></a>单进程限流</h1><p>单个jvm限流有现成的库，谷歌的guava库提供了<code>RateLimiter</code>,底层实现上有两个，一个是能容忍突发的实现，一个是能提供预热功能的实现；通过create时提供不同的参数来获得。</p>
<h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><h3 id="朴素解法"><a href="#朴素解法" class="headerlink" title="朴素解法"></a>朴素解法</h3><p>如果按照令牌桶算法朴素的定义来实现的话，一个很自然的思路就是增加一个定时线程、进程，然后不断生成新的token; </p>
<h4 id="朴素解法的缺点"><a href="#朴素解法的缺点" class="headerlink" title="朴素解法的缺点"></a>朴素解法的缺点</h4><p>重度依赖这个定时线程，如果定时程序挂了，所有工作线程就被卡住了，风险较大。<br>如果给定时线程加监控，又会需要监控的监控，那就变成俄罗斯套娃了。</p>
<h3 id="guava库中的解法"><a href="#guava库中的解法" class="headerlink" title="guava库中的解法"></a>guava库中的解法</h3><p>需要访问者多输入一个参数: 当前时钟。<br><code>lazy eval</code>: 每次取token的时候才计算当前”应该”有多少token。<br>基于时钟来计算: 当前时钟下, 过去了多久没有生成token，应该生成多少新的token。<br>核心代码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Updates &#123;<span class="doctag">@code</span> storedPermits&#125; and &#123;<span class="doctag">@code</span> nextFreeTicketMicros&#125; based on the current time.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">resync</span><span class="params">(<span class="keyword">long</span> nowMicros)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// if nextFreeTicket is in the past, resync to now</span></span><br><span class="line">    <span class="keyword">if</span> (nowMicros &gt; nextFreeTicketMicros) &#123;</span><br><span class="line">      storedPermits = min(maxPermits,</span><br><span class="line">          storedPermits</span><br><span class="line">            + (nowMicros - nextFreeTicketMicros) / coolDownIntervalMicros());</span><br><span class="line">      nextFreeTicketMicros = nowMicros;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h3 id="guava库中解法的优点"><a href="#guava库中解法的优点" class="headerlink" title="guava库中解法的优点"></a>guava库中解法的优点</h3><p>开销更低: 去掉了定时线程的开销;<br>健壮性更高: 每个线程都可以承担生成新token的任务;</p>
<h3 id="guava库中解法的缺点"><a href="#guava库中解法的缺点" class="headerlink" title="guava库中解法的缺点"></a>guava库中解法的缺点</h3><p>每个线程的时钟得对齐。但这一点在单进程场景下很好保证。</p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.google.common.util.concurrent.RateLimiter;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">run1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        RateLimiter limiter = RateLimiter.create(<span class="number">5</span>);<span class="comment">// 令牌桶</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"get 1 tokens: "</span> + limiter.acquire() + <span class="string">"s"</span></span><br><span class="line">            );</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 3秒预热期: 预热期内限频较严格: 1.3s , 0.9s , 0.6s // 线性提速</span></span><br><span class="line"><span class="comment">     * 预热期后: 正式达到1秒2个的额定速度.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">run2</span><span class="params">()</span> </span>&#123;<span class="comment">// 预热测试</span></span><br><span class="line">        RateLimiter r = RateLimiter.create(<span class="number">2</span>, <span class="number">3</span>, TimeUnit.SECONDS);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"get 1 tokens: "</span> + r.acquire(<span class="number">1</span>) + <span class="string">"s"</span>);</span><br><span class="line">            System.out.println(<span class="string">"get 1 tokens: "</span> + r.acquire(<span class="number">1</span>) + <span class="string">"s"</span>);</span><br><span class="line">            System.out.println(<span class="string">"get 1 tokens: "</span> + r.acquire(<span class="number">1</span>) + <span class="string">"s"</span>);</span><br><span class="line">            System.out.println(<span class="string">"get 1 tokens: "</span> + r.acquire(<span class="number">1</span>) + <span class="string">"s"</span>);</span><br><span class="line">            System.out.println(<span class="string">"end"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">run3</span><span class="params">()</span> </span>&#123;<span class="comment">// 突发测试</span></span><br><span class="line">        RateLimiter r = RateLimiter.create(<span class="number">5</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"get 5 tokens: "</span> + r.acquire(<span class="number">5</span>) + <span class="string">"s"</span>);</span><br><span class="line">            System.out.println(<span class="string">"get 1 tokens: "</span> + r.acquire(<span class="number">1</span>) + <span class="string">"s"</span>);<span class="comment">// 每次都负责还债</span></span><br><span class="line">            System.out.println(<span class="string">"get 1 tokens: "</span> + r.acquire(<span class="number">1</span>) + <span class="string">"s"</span>);</span><br><span class="line">            System.out.println(<span class="string">"get 1 tokens: "</span> + r.acquire(<span class="number">1</span>) + <span class="string">"s"</span>);</span><br><span class="line">            System.out.println(<span class="string">"end"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h1 id="分布式限流"><a href="#分布式限流" class="headerlink" title="分布式限流"></a>分布式限流</h1><p>如果是多实例的情况下,下游处理能力有上限时(例如物料有限),需要对整体有一个限流。<br>可以参考guava的实现,实现一个基于redis的，有一定弹性的令牌桶实现:<br>(由于是借鉴guava的实现，所以有相同的依赖: 所有进程、机器的时钟对齐)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">tokenLimitDemo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        DefaultRedisScript&lt;Long&gt; lua = <span class="keyword">new</span> DefaultRedisScript&lt;&gt;();</span><br><span class="line">        lua.setResultType(Long<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        lua.setScriptSource(<span class="keyword">new</span> ResourceScriptSource(<span class="keyword">new</span></span><br><span class="line">                ClassPathResource(<span class="string">"tokenLimiter.lua"</span>)));</span><br><span class="line">        List&lt;String&gt; keys = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        keys.add(<span class="string">"test_ip"</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            Long res = (Long) redisTemplate.execute(lua, keys</span><br><span class="line">                    , <span class="string">"1"</span></span><br><span class="line">                    , String.valueOf(System.currentTimeMillis())</span><br><span class="line">            );</span><br><span class="line">            <span class="keyword">if</span> (res != <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">"waiting"</span>);</span><br><span class="line">                    Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                    i--;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(res);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>相应的lua脚本: </p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 令牌桶算法:</span></span><br><span class="line"><span class="comment">-- 1. 校验输入:</span></span><br><span class="line"><span class="keyword">local</span> need_token = <span class="built_in">tonumber</span>(ARGV[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">local</span> req_time = <span class="built_in">tonumber</span>(ARGV[<span class="number">2</span>])</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">type</span>(need_token) ~= <span class="string">"number"</span> <span class="keyword">or</span> <span class="built_in">type</span>(req_time) ~= <span class="string">"number"</span> <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 2. 校验redis:</span></span><br><span class="line"><span class="keyword">local</span> key = KEYS[<span class="number">1</span>]</span><br><span class="line"><span class="keyword">local</span> info = redis.<span class="built_in">pcall</span>(<span class="string">"HMGET"</span>, key, <span class="string">"last_time"</span>, <span class="string">"cur_token_num"</span>, <span class="string">"max_token"</span>, <span class="string">"rate"</span>)</span><br><span class="line"><span class="keyword">local</span> last_time = <span class="built_in">tonumber</span>(info[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">local</span> cur_token_num = <span class="built_in">tonumber</span>(info[<span class="number">2</span>])</span><br><span class="line"><span class="keyword">local</span> max_token = <span class="built_in">tonumber</span>(info[<span class="number">3</span>])</span><br><span class="line"><span class="keyword">local</span> rate = <span class="built_in">tonumber</span>(info[<span class="number">4</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">type</span>(last_time) ~= <span class="string">"number"</span> <span class="keyword">then</span> <span class="comment">-- init</span></span><br><span class="line">    last_time = req_time</span><br><span class="line">    max_token = <span class="number">2</span> <span class="comment">-- 最大token弹性</span></span><br><span class="line">    cur_token_num = max_token <span class="comment">-- 假设已经预热完毕</span></span><br><span class="line">    rate = <span class="number">1</span></span><br><span class="line">    <span class="comment">-- 初始化redis:</span></span><br><span class="line">    redis.<span class="built_in">pcall</span>(<span class="string">"HMSET"</span>, key, <span class="string">"last_time"</span>, req_time, <span class="string">"cur_token_num"</span>, cur_token_num)</span><br><span class="line">    redis.<span class="built_in">pcall</span>(<span class="string">"HMSET"</span>, key, <span class="string">"max_token"</span>, max_token, <span class="string">"rate"</span>, rate)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 3. 处理请求:</span></span><br><span class="line"><span class="keyword">local</span> result = <span class="number">0</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">tonumber</span>(need_token) &gt; <span class="built_in">tonumber</span>(max_token) <span class="keyword">then</span></span><br><span class="line">    result = <span class="number">0</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> new_gen_token = <span class="built_in">math</span>.<span class="built_in">floor</span>((req_time - last_time) / <span class="number">1000</span>) * rate</span><br><span class="line"><span class="keyword">local</span> cur_token_num = <span class="built_in">math</span>.<span class="built_in">min</span>(cur_token_num + new_gen_token, max_token)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">tonumber</span>(need_token) &gt; <span class="built_in">tonumber</span>(cur_token_num) <span class="keyword">then</span></span><br><span class="line">    result = <span class="number">0</span></span><br><span class="line"><span class="keyword">else</span> <span class="comment">-- do consume token</span></span><br><span class="line">    cur_token_num = cur_token_num - need_token</span><br><span class="line">    result = <span class="number">1</span></span><br><span class="line">    <span class="comment">-- 保存进度:</span></span><br><span class="line">    redis.<span class="built_in">pcall</span>(<span class="string">"HMSET"</span>, key, <span class="string">"last_time"</span>, req_time, <span class="string">"cur_token_num"</span>, cur_token_num)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>



      
    </div>
    <footer class="article-footer">
      <a data-url="http://xiaoyue26.github.io/2019/12/28/2019-12/%E5%88%86%E5%B8%83%E5%BC%8F%E9%99%90%E6%B5%81-redis-%E4%BB%A4%E7%89%8C%E6%A1%B6/" data-id="ck96cxpqg00ksmaamhw2t7jgz" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/redis/" rel="tag">redis</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-2019-12/RTP-RTCP协议" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/12/02/2019-12/RTP-RTCP%E5%8D%8F%E8%AE%AE/" class="article-date">
  <time datetime="2019-12-02T02:09:59.000Z" itemprop="datePublished">2019-12-02</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%BD%91%E7%BB%9C/">网络</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/12/02/2019-12/RTP-RTCP%E5%8D%8F%E8%AE%AE/">RTP/RTCP协议</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <h1 id="实时传输协议RTP-RTCP"><a href="#实时传输协议RTP-RTCP" class="headerlink" title="实时传输协议RTP/RTCP"></a>实时传输协议RTP/RTCP</h1><p>参考:<br><a href="https://www.jianshu.com/p/631273bc9847" target="_blank" rel="noopener">https://www.jianshu.com/p/631273bc9847</a></p>
<p>底层理论上也不一定用tcp/udp,实际上为了性能大多用udp。</p>
<p>RTP:  <code>Real-time Transport Protocol</code><br>RTCP: <code>RTP Control Protocol</code></p>
<img src="/images/2019-12/RTCP.jpg" class="" width="800" height="1200" title="RTCP">

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RTP: 用udp来传数据；      (偶数端口)</span><br><span class="line">RTCP: 用udp来传控制信息； (奇数端口, 一般是RTP的端口+1) 服务质量的监视与反馈、媒体间的同步，以及多播组中成员的标识</span><br></pre></td></tr></table></figure>

<h2 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h2><p>交换机级别： 组播协议，一对多<br>多对多可以转换成一对多。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://xiaoyue26.github.io/2019/12/02/2019-12/RTP-RTCP%E5%8D%8F%E8%AE%AE/" data-id="ck96cxpqf00komaam9mr7eo2r" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/RTP/" rel="tag">RTP</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-2019-11/利用序列样本超越A-B-Test-interleaving和多臂老虎机" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/11/13/2019-11/%E5%88%A9%E7%94%A8%E5%BA%8F%E5%88%97%E6%A0%B7%E6%9C%AC%E8%B6%85%E8%B6%8AA-B-Test-interleaving%E5%92%8C%E5%A4%9A%E8%87%82%E8%80%81%E8%99%8E%E6%9C%BA/" class="article-date">
  <time datetime="2019-11-13T06:13:15.000Z" itemprop="datePublished">2019-11-13</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E8%AE%BA%E6%96%87/">论文</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/11/13/2019-11/%E5%88%A9%E7%94%A8%E5%BA%8F%E5%88%97%E6%A0%B7%E6%9C%AC%E8%B6%85%E8%B6%8AA-B-Test-interleaving%E5%92%8C%E5%A4%9A%E8%87%82%E8%80%81%E8%99%8E%E6%9C%BA/">利用序列样本超越A/B Test: interleaving和多臂老虎机</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <blockquote>
<p>interleaving实验: 快速找到最优解;<br>多臂老虎机: 降低实验成本;</p>
</blockquote>
<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>经典统计分析的样本: 农业统计中样本是同时产生的。<br>在线服务中的样本: 序列样本,在线服务中样本是依次到达的;</p>
<p>利用这个特性,可以有比传统统计分析方法成本更小、更灵活的实验方法。<br>序列样本环境下的假设检验,在相同显著性和检验力下,经典t检验结束更早,需要样本更少。</p>
<h1 id="Interleaving实验"><a href="#Interleaving实验" class="headerlink" title="Interleaving实验"></a>Interleaving实验</h1><p><code>交错实验</code><br>优先确定哪个方案更好,而不是统计出具体效果好多少.<br>参考: <a href="https://zhuanlan.zhihu.com/p/31770319" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/31770319</a><br><code>优点</code>: 更少的样本达到与Abtest相同的偏向结果；<br><code>缺点</code>： 无法知道究竟有多好的效果；（比如A组究竟能提高多少阅读时长）</p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>用<code>Interleaving</code>+<code>ABtest</code>两阶段完成整个评估。</p>
<p><code>要点</code>：抛硬币交错，保证公平。<br><code>灵敏度</code>： 高于AB；<br><code>准确度</code>： 与AB有很强的相关性；<br><code>场景</code>： 排名算法</p>
<img src="/images/2019-11/right.jpg" class="" width="800" height="1200" title="right">


<h2 id="案例-Netflix的方法"><a href="#案例-Netflix的方法" class="headerlink" title="案例: Netflix的方法"></a>案例: Netflix的方法</h2><p>第一阶段: 快速筛选,从众多算法中挑选出最有前途的排名算法;<br>第二阶段，进行传统的A/B测试,以测量长期效应;</p>
<img src="/images/2019-11/interleaving.jpg" class="" width="800" height="1200" title="interleaving">

<h2 id="使用条件"><a href="#使用条件" class="headerlink" title="使用条件"></a>使用条件</h2><ol>
<li>指标对排序算法的质量非常敏感;</li>
<li>对第二阶段进行准确预测：第一阶段衡量的指标与A/B 评估的指标正相关；</li>
</ol>
<h3 id="指标示例"><a href="#指标示例" class="headerlink" title="指标示例"></a>指标示例</h3><p>传统AB指标: 留存、观看时长；<br>交错测试指标: 观看时长比例；</p>
<h1 id="MAB-多臂老虎机"><a href="#MAB-多臂老虎机" class="headerlink" title="MAB: 多臂老虎机"></a>MAB: 多臂老虎机</h1><p>参考: <a href="http://www.fengjunchen.com/%E9%80%82%E7%94%A8%E4%BA%8E%E5%9C%A8%E7%BA%BF%E6%9C%8D%E5%8A%A1%E7%9A%84ab%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95%E8%AE%BA/" target="_blank" rel="noopener">http://www.fengjunchen.com/%E9%80%82%E7%94%A8%E4%BA%8E%E5%9C%A8%E7%BA%BF%E6%9C%8D%E5%8A%A1%E7%9A%84ab%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95%E8%AE%BA/</a></p>
<h2 id="What-什么是多臂老虎机"><a href="#What-什么是多臂老虎机" class="headerlink" title="What: 什么是多臂老虎机"></a>What: 什么是多臂老虎机</h2><p>一种在线实验的方法，特点是兼顾实验结果和实验成本，不会让差劲的方案暴露给用户太久。</p>
<p>在线上进行大规模实验的时候，可能会影响用户体验，从而影响用户留存等关键业务指标。因此我们希望在实验过程中，尽可能降低差方案曝光的频率。为了达到这个目的,大致有两种思路:<br>思路1: 动态结束;一旦A方案胜出,立即停止实验,采用A方案;<br>思路2: 非均衡分组;在优势方案下多分配用户.(多臂老虎机)</p>
<p>使用场景: 序列样本/在线服务</p>
<h3 id="背景-1"><a href="#背景-1" class="headerlink" title="背景"></a>背景</h3><blockquote>
<p>Bandit: 老虎机</p>
</blockquote>
<img src="/images/2019-11/mab.jpg" class="" width="400" height="600" title="mab">
<p>多臂老虎机问题:<br>老虎机有N个摇杆,每个得到奖励的概率为p1~pN;<br>假设可以拉很多次摇杆，使用什么策略可以使总收益最大化?</p>
<h4 id="一种可能的思路"><a href="#一种可能的思路" class="headerlink" title="一种可能的思路"></a>一种可能的思路</h4><p>先抽样统计收益较好的摇杆,然后利用统计解决快速调整策略。<br>也就是分两个阶段:</p>
<ol>
<li>探索规律;</li>
<li>利用规律;</li>
</ol>
<h3 id="汤普森抽样"><a href="#汤普森抽样" class="headerlink" title="汤普森抽样"></a>汤普森抽样</h3><p>在每个周期计算”摇杆i是最优摇杆”的后验概率,作为下一个周期随机分配摇杆的依据。</p>
<p>优点: 灵活性、扩展性、保证实验过程坑用户比例最小;<br>缺点: 没有人公开发表过简单靠谱的停止条件。</p>
<h4 id="PVR-停止条件的解决方案"><a href="#PVR-停止条件的解决方案" class="headerlink" title="PVR: 停止条件的解决方案"></a>PVR: 停止条件的解决方案</h4><p><code>google analytics</code>: PVR(潜在剩余价值)。<br>定义分界线为a,分界概率为b:</p>
<blockquote>
<p>P(潜在最优收益&gt;(1+a%)*目前最优收益) &lt; b</p>
</blockquote>
<p>google analytics的参数设置是<code>a=0.01,b=0.05</code>,即潜在最优收益比目前最优收益大1%的概率不到5%。</p>
<h3 id="PVR方案的缺点"><a href="#PVR方案的缺点" class="headerlink" title="PVR方案的缺点"></a>PVR方案的缺点</h3><p>即使A/B方案没有任何区别,PVR也会导致相当一部分实验在有限时间内终止。<br>第一类错误的概率随时间延长增加。</p>
<img src="/images/2019-11/error2.jpg" class="" width="800" height="1200" title="error2">
<p>scott: 线上实验不需要考虑第一类错误，因为代价极小；而第二类错误是致命的。</p>
<h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><p>谷歌analytics/yahoo/bing: 汤普森抽样的贝叶斯解法<br>论文: <a href="http://quinonero.net/Publications/AdPredictorICML2010-final.pdf" target="_blank" rel="noopener">http://quinonero.net/Publications/AdPredictorICML2010-final.pdf</a><br>数学要求: 超精深<br>相关图灵书: 《Bandit Algorithms for Website Optimization》</p>
<img src="/images/2019-11/mab_book.jpg" class="" width="400" height="600" title="mab_book">
<p>相关论文： <a href="http://www.economics.uci.edu/~ivan/asmb.874.pdf" target="_blank" rel="noopener">http://www.economics.uci.edu/~ivan/asmb.874.pdf</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://xiaoyue26.github.io/2019/11/13/2019-11/%E5%88%A9%E7%94%A8%E5%BA%8F%E5%88%97%E6%A0%B7%E6%9C%AC%E8%B6%85%E8%B6%8AA-B-Test-interleaving%E5%92%8C%E5%A4%9A%E8%87%82%E8%80%81%E8%99%8E%E6%9C%BA/" data-id="ck96cxpqd00kgmaam8k871wzq" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AE%BA%E6%96%87/" rel="tag">论文</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-2019-11/论文梗概-在线服务的实验评估面临的挑战" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/11/13/2019-11/%E8%AE%BA%E6%96%87%E6%A2%97%E6%A6%82-%E5%9C%A8%E7%BA%BF%E6%9C%8D%E5%8A%A1%E7%9A%84%E5%AE%9E%E9%AA%8C%E8%AF%84%E4%BC%B0%E9%9D%A2%E4%B8%B4%E7%9A%84%E6%8C%91%E6%88%98/" class="article-date">
  <time datetime="2019-11-13T02:37:58.000Z" itemprop="datePublished">2019-11-13</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E8%AE%BA%E6%96%87/">论文</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/11/13/2019-11/%E8%AE%BA%E6%96%87%E6%A2%97%E6%A6%82-%E5%9C%A8%E7%BA%BF%E6%9C%8D%E5%8A%A1%E7%9A%84%E5%AE%9E%E9%AA%8C%E8%AF%84%E4%BC%B0%E9%9D%A2%E4%B8%B4%E7%9A%84%E6%8C%91%E6%88%98/">[论文梗概]在线服务的实验评估面临的挑战</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <blockquote>
<p>论文原文: <a href="https://exp-platform.com/Documents/2019-FirstPracticalOnlineControlledExperimentsSummit_SIGKDDExplorations.pdf" target="_blank" rel="noopener">https://exp-platform.com/Documents/2019-FirstPracticalOnlineControlledExperimentsSummit_SIGKDDExplorations.pdf</a> </p>
</blockquote>
<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p><code>OEC</code>: Overall Evaluation Criterion/总体评价标准<br><code>OCEs</code>: Online controlled experiments/在线受控实验=A/B Tests</p>
<h1 id="挑战汇总"><a href="#挑战汇总" class="headerlink" title="挑战汇总"></a>挑战汇总</h1><ol>
<li>如何评估长期效应;</li>
<li>如何解决社交网络对实验的影响;</li>
<li>如何解决多次实验间的影响;</li>
<li>如何寻找OEC指标;</li>
<li>如何进行细分人群的实验(HTE模型);</li>
<li>如何确保数据质量、进行数据治理;</li>
<li>如何建立实验文化;</li>
<li>如何处理配置文件膨胀问题;</li>
</ol>
<h1 id="如何评估长期效应"><a href="#如何评估长期效应" class="headerlink" title="如何评估长期效应"></a>如何评估长期效应</h1><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><ol>
<li>大部分abtest持续两周内；</li>
<li>我们真正关心的是比两周更长的长期效应；</li>
</ol>
<p><strong>如何确保上述两者吻合？</strong></p>
<h2 id="长期效应：常见解决方案"><a href="#长期效应：常见解决方案" class="headerlink" title="长期效应：常见解决方案"></a>长期效应：常见解决方案</h2><h3 id="长期实验；"><a href="#长期实验；" class="headerlink" title="长期实验；"></a>长期实验；</h3><p>Twitter: 实验通常持续4周，从最后两周的数据开始统计。</p>
<h3 id="保留反向桶；-holdout"><a href="#保留反向桶；-holdout" class="headerlink" title="保留反向桶；(holdout)"></a>保留反向桶；(holdout)</h3><h3 id="代理指标"><a href="#代理指标" class="headerlink" title="代理指标"></a>代理指标</h3><p>Netflix: 使用logistic回归，寻找反映留存指标的代理指标。<br>LinkedIn: lifetime value模型；<br>Uber : macro-economic模型;<br>facebook: 分位数回归、GBDT</p>
<p><code>缺点</code>: 相关性!=因果关系<br><code>可能的歧路</code>：代理指标涨、长期指标不动。</p>
<p>bing/google: 心理学模型,从因果关系出发</p>
<h3 id="对用户学习效应进行建模"><a href="#对用户学习效应进行建模" class="headerlink" title="对用户学习效应进行建模"></a>对用户学习效应进行建模</h3><p>google: 用长期实验，观察用户学习的效应(参见原文论文[38])<br><strong>实验流程:</strong></p>
<ol>
<li>第一组：立刻使用B配置;</li>
<li>第二组：滞后一段时间后使用B配置;</li>
<li>第N组：依次类推。</li>
<li>随机组: 随机滞后。</li>
</ol>
<p>比较不同学习阶段的用户。</p>
<p><strong>结果:</strong> 得出指数曲线，预测长期的情况。</p>
<h1 id="如何解决社交网络对实验的影响"><a href="#如何解决社交网络对实验的影响" class="headerlink" title="如何解决社交网络对实验的影响"></a>如何解决社交网络对实验的影响</h1><h2 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h2><p>传统A/B test的假设： 实验间不相互影响；</p>
<p>假设不成立：</p>
<ol>
<li>社交网络影响；</li>
<li>多次反复实验残留效应影响。<br>对照组的用户可能与实验组认识/有交互，因此也受实验影响。</li>
</ol>
<p>问题：</p>
<ol>
<li>如何避免这个问题？（无法避免）</li>
<li>如何检测这个问题？（评估影响）</li>
</ol>
<h2 id="常见解决方案"><a href="#常见解决方案" class="headerlink" title="常见解决方案"></a>常见解决方案</h2><h3 id="生产者消费者模型"><a href="#生产者消费者模型" class="headerlink" title="生产者消费者模型"></a>生产者消费者模型</h3><p>LinkedIn： 生产者消费者模型<br>实验：<br>生产者：允许在帖子上打标签;<br>消费者：允许看到帖子的标签; </p>
<p>当95%的生产者可以打标签：可以测试50%的消费者是否允许看到标签的影响；<br>当95%的消费者可以看到标签: 可以测试50%的生产者是否打标签的影响。</p>
<p>类似的模型可以用于@功能。</p>
<h3 id="已知影响力模型"><a href="#已知影响力模型" class="headerlink" title="已知影响力模型"></a>已知影响力模型</h3><p>Link/facebook/谷歌： 用户影响力已知，将用户聚类成子网络。<br>实验在各个子网络进行。</p>
<p>相关论文： [20, 26, 9].<br><code>[20]</code>:<br><a href="http://www.unofficialgoogledatascience.com/2018/01/designing-ab-tests-in-collaboration.html" target="_blank" rel="noopener">http://www.unofficialgoogledatascience.com/2018/01/designing-ab-tests-in-collaboration.html</a></p>
<h3 id="一对一通信"><a href="#一对一通信" class="headerlink" title="一对一通信"></a>一对一通信</h3><p>对于1对1通信相关的feature:<br><strong>Linkin</strong>: 数据统计时分为4类:<br>1.实验组=&gt;实验组;<br>2.对照组=&gt;对照组;<br>3.实验组=&gt;对照组;<br>4.对照组=&gt;实验组;</p>
<p>Skype: 以会话为维度实验。每个用户都可能随机位于实验、对照组。</p>
<h3 id="市场影响"><a href="#市场影响" class="headerlink" title="市场影响"></a>市场影响</h3><p>实验结果受供求关系影响。(如打车)<br>忽视供求关系随机分组，可能会导致一些Bias。<br>Lyft： 构造小规模近似供求关系的市场，进行实验。</p>
<p>广告领域：预算窃取<br>实验组：窃取对照组预算(对照组的广告预算也花在了实验组)<br>当放量时，整体收入并没有达到预期幅度。<br>解决方案：按预算比例投放到实验组。</p>
<h1 id="挑战：多个实验之间的影响"><a href="#挑战：多个实验之间的影响" class="headerlink" title="挑战：多个实验之间的影响"></a>挑战：多个实验之间的影响</h1><h2 id="问题-2"><a href="#问题-2" class="headerlink" title="问题"></a>问题</h2><p>如果两个实验之间不是完全独立。<br>(例1个实验改变背景，1个实验改变字体颜色)</p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>微软、谷歌：相互影响(互斥)的实验放在同一层内，这一个层由一个团队负责(相关特性)；<br>微软：每天跑任务检测层间影响；</p>
<h1 id="挑战：如何寻找OEC指标"><a href="#挑战：如何寻找OEC指标" class="headerlink" title="挑战：如何寻找OEC指标"></a>挑战：如何寻找OEC指标</h1><h2 id="问题-3"><a href="#问题-3" class="headerlink" title="问题"></a>问题</h2><p>HiPPO: 工资最高的人说了算。<br>OEC: 数据驱动，核心指标说了算。</p>
<p>指标=OEC指标+其他护栏、诊断指标;<br>OEC指标: 决策;(KPI)<br>诊断指标: OEC指标为啥变化。</p>
<h2 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="OEC指标满足的条件"><a href="#OEC指标满足的条件" class="headerlink" title="OEC指标满足的条件"></a>OEC指标满足的条件</h3><ol>
<li>反映KPI;</li>
<li>难以作弊;</li>
<li>必须敏感;</li>
<li>计算的成本不能太高(可行性)、每天都要给至少上百个实验计算;(不能是只能打电话确认的指标)</li>
<li>考虑到影响KPI的各种场景;</li>
<li>能顾及到新的场景。</li>
</ol>
<h3 id="自己发现OEC"><a href="#自己发现OEC" class="headerlink" title="自己发现OEC"></a>自己发现OEC</h3><p>对于搜索引擎: 查询量不是好的OEC，查询量大可能是因为不准。<br>好的OEC: 每个用户的会话数。（不准的话，单次会话查询量很大、会话数少。）</p>
<p>一般来说：<br><strong>OEC指标属性</strong>:<br><code>HEART</code>: </p>
<blockquote>
<p>Happiness, Engagement, Adoption, Retention, and Task success</p>
</blockquote>
<p><strong>护栏指标</strong>：pv、vv、时长、延迟、七日用户数。</p>
<p>对于浏览类场景，找到HEART指标仍是挑战。<br>挑战：识别用户的目的。<br>目的1：快速找到特定东西；<br>目的2：不想找特定东西，只是想探索新东西；</p>
<p>对于目的1：点击次数越多越不好；<br>对于目的2：点击次数越多越好。<br>两者矛盾，因此存在挑战。</p>
<h3 id="权衡产品目标"><a href="#权衡产品目标" class="headerlink" title="权衡产品目标"></a>权衡产品目标</h3><p>我们潜意识假定产品目标是确定不变的、统一的。<br>然而这不是小问题。因此假定不一定总是成立。</p>
<ol>
<li>团队可能调整战略(例如每个阶段的盈利策略)；</li>
<li>每个局部的实际方向可能和总体不符。</li>
<li>多目标(指标)冲突。(收入与体验)</li>
</ol>
<h3 id="机器学习建立OEC"><a href="#机器学习建立OEC" class="headerlink" title="机器学习建立OEC"></a>机器学习建立OEC</h3><ol>
<li>基于用户行为，打分预测满意度；</li>
<li>组合多个指标，创造敏感又准确的OEC指标；</li>
</ol>
<p>缺点: 不可解释、难以发现误判。</p>
<h1 id="如何进行细分人群的实验"><a href="#如何进行细分人群的实验" class="headerlink" title="如何进行细分人群的实验"></a>如何进行细分人群的实验</h1><p>细分人群可能可以有更多洞察。</p>
<h2 id="常见的分类方法"><a href="#常见的分类方法" class="headerlink" title="常见的分类方法"></a>常见的分类方法</h2><ol>
<li>国家、使用语言；</li>
<li>活跃度;</li>
<li>设备和平台；</li>
<li>周中周末、新奇效应；</li>
<li>产品特定分类：<br>(1)linked: 招聘者、应聘者；<br>(2)Netflix: 不同网速；<br>(3)Airbnb: 是否曾经预定、渠道来源；</li>
</ol>
<h2 id="相关挑战和解决方案"><a href="#相关挑战和解决方案" class="headerlink" title="相关挑战和解决方案"></a>相关挑战和解决方案</h2><ol>
<li>计算规模变大; =&gt;按需分析: 某些需求可以用更高成本的分析方法；</li>
<li>样本变少; =&gt; 使用稀疏模型</li>
<li>分层的正交性依赖大样本; </li>
<li>实验者不是统计学专家,实验结果必须明确易懂； =&gt;用回归和聚类来简化结果。(Fused Lasso、Total Variation Regularization)</li>
<li>相关性!=因果关系: 细分人群的结果不同，但相应分类属性可能不是导致结果不同的原因，可能只是共线。<br>解决方案：可以从历史数据中寻求更多信息。</li>
</ol>
<h1 id="数据质量与数据治理"><a href="#数据质量与数据治理" class="headerlink" title="数据质量与数据治理"></a>数据质量与数据治理</h1><h2 id="问题-4"><a href="#问题-4" class="headerlink" title="问题"></a>问题</h2><p>实验可信度依赖数据质量。如何确保数据质量?</p>
<h2 id="解决方案-2"><a href="#解决方案-2" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="工业界测试"><a href="#工业界测试" class="headerlink" title="工业界测试"></a>工业界测试</h3><p>工业界测试： Ratio Mismatch test (见原文引用[13, 22, 23, 45])<br>抽样校验告警。</p>
<h3 id="数据规范"><a href="#数据规范" class="headerlink" title="数据规范"></a>数据规范</h3><p>Netflix\MSN\Bing：json<br>优点：拓展性好；<br>缺点: 格式变化很快；</p>
<p>Airbnb/facebook：每个实验自己设定格式、打点。(bring-your-own-data)<br>Microsoft Office: 事件日志；<br>其他: 固定部分列，预留json列。</p>
<h3 id="及时可靠的指标"><a href="#及时可靠的指标" class="headerlink" title="及时可靠的指标"></a>及时可靠的指标</h3><p>不断新增指标对实验平台的挑战。</p>
<p>LinkedIn/Facebook/Airbnb: 实验平台与指标框架分离，各个业务对自己的指标负责。实验平台仅负责从统计结果进行评估。<br>Microsoft/Google/Booking.com/Lyft:指标由实验团队从日志中统计。</p>
<p>LinkedIn:<br>指标委员会：批准新增、修改指标，确保指标质量；<br>某些公司：<br>指标必须经过验证敏感性、精确性，确定和实验结果有有意义的区别。<br>Booking.com：<br>自动检测比较两组独立数据。</p>
<h3 id="指标的ownership"><a href="#指标的ownership" class="headerlink" title="指标的ownership"></a>指标的ownership</h3><p>指标通常有特定的关注者和归属者。<br>微软：特定指标下降=&gt;通知指标归属者(含相关实验信息)。</p>
<p>其他公司：提供工具搜索：影响特定指标的实验。</p>
<h3 id="新分析方法"><a href="#新分析方法" class="headerlink" title="新分析方法"></a>新分析方法</h3><p>需要考虑:</p>
<ol>
<li>新方法适用场景;</li>
<li>新方法的计算、复杂性成本 &lt; 收益;</li>
<li>不同方法冲突时，相信哪一种；</li>
<li>保证正确解释结果；</li>
</ol>
<h1 id="如何建立实验文化"><a href="#如何建立实验文化" class="headerlink" title="如何建立实验文化"></a>如何建立实验文化</h1><p>日志、实验、实验记录、实验评估的文化。<br>原则:<br>谦逊: 直觉判断是贫瘠的(HIPPO)；<br>微软：只有1/3的创意在数据上有显著结果。</p>
<p>能接受实验效果不好。</p>
<h2 id="解决方案-建立规范的实验平台。"><a href="#解决方案-建立规范的实验平台。" class="headerlink" title="解决方案: 建立规范的实验平台。"></a>解决方案: 建立规范的实验平台。</h2><p>Booking.com： 将实验平台变得像游戏。</p>
<p>Yandex： 中央实验小组：由各个组的专家组成<br>Amazon： 类似，酒吧专家；（酒吧是Amazon的实验平台）<br>Twitter：实验牧羊人：50个牧羊人，一个星期值班时间，<br>Booking.com： 实验大使制度、同行评议制度（按钮：随机选择一个实验来评议）<br>微软：1~2个数据科学家跟着一个业务团队。随着业务团队接受培训、能力提高，数据科学家回到中心、转跟另一个业务团队。定期分享。<br>谷歌： checklist。每次实验填写：假设、指标、变化幅度。</p>
<h1 id="配置文件膨胀的挑战"><a href="#配置文件膨胀的挑战" class="headerlink" title="配置文件膨胀的挑战"></a>配置文件膨胀的挑战</h1><h2 id="问题-5"><a href="#问题-5" class="headerlink" title="问题"></a>问题</h2><p>随着实验越来越多，客户端要拉的配置文件越来越大。</p>
<h2 id="解决方案-3"><a href="#解决方案-3" class="headerlink" title="解决方案"></a>解决方案</h2><p>定期合代码，固化一些feature;</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://xiaoyue26.github.io/2019/11/13/2019-11/%E8%AE%BA%E6%96%87%E6%A2%97%E6%A6%82-%E5%9C%A8%E7%BA%BF%E6%9C%8D%E5%8A%A1%E7%9A%84%E5%AE%9E%E9%AA%8C%E8%AF%84%E4%BC%B0%E9%9D%A2%E4%B8%B4%E7%9A%84%E6%8C%91%E6%88%98/" data-id="ck96cxpqe00kkmaam2jzt1b6i" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AE%BA%E6%96%87/" rel="tag">论文</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-2019-11/java8笔记" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/11/03/2019-11/java8%E7%AC%94%E8%AE%B0/" class="article-date">
  <time datetime="2019-11-03T12:56:11.000Z" itemprop="datePublished">2019-11-03</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/java/">java</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/11/03/2019-11/java8%E7%AC%94%E8%AE%B0/">java8笔记</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <h1 id="lambda语法"><a href="#lambda语法" class="headerlink" title="lambda语法"></a>lambda语法</h1><p><code>i-&gt;{return &quot;xxx&quot;;}</code><br>本质上是借用匿名类来实现,并没有超脱原来的java的解题思路。</p>
<p>这种类似于传一个函数指针的模式，底层是<code>@FunctionalInterface</code>注解的接口，因此我们可以自己声明一个接口作为方法的行参:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line">   <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">GetIdataFunction</span> </span>&#123;</span><br><span class="line">       <span class="function"><span class="keyword">int</span> <span class="title">getI</span><span class="params">(<span class="keyword">int</span> i)</span></span>;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">default</span> String <span class="title">getInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="string">"找下标为i的数据"</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">searchMatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (matrix == <span class="keyword">null</span> || matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span> || target &lt; matrix[<span class="number">0</span>][<span class="number">0</span>]) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">int</span> lowerBound = getLowerBound(target, <span class="number">0</span>, matrix.length - <span class="number">1</span>, i -&gt; matrix[i][<span class="number">0</span>]);</span><br><span class="line">       <span class="keyword">if</span> (lowerBound &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">final</span> <span class="keyword">int</span> finalLowerBound = -lowerBound - <span class="number">2</span>;</span><br><span class="line">       <span class="keyword">int</span> x = getLowerBound(target, <span class="number">0</span>, matrix[<span class="number">0</span>].length - <span class="number">1</span>, i -&gt; matrix[finalLowerBound][i]);</span><br><span class="line">       <span class="keyword">return</span> x &gt;= <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getLowerBound</span><span class="params">(<span class="keyword">int</span> target, <span class="keyword">int</span> left, <span class="keyword">int</span> right, GetIdataFunction helper)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> mid;</span><br><span class="line">       <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">           mid = (left + right) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">           <span class="keyword">int</span> midVal = helper.getI(mid);</span><br><span class="line">           <span class="keyword">if</span> (target &lt; midVal) &#123;</span><br><span class="line">               right = mid - <span class="number">1</span>;</span><br><span class="line">           &#125; <span class="keyword">else</span> <span class="keyword">if</span> (target &gt; midVal) &#123;</span><br><span class="line">               left = mid + <span class="number">1</span>;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="keyword">return</span> mid;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> -left - <span class="number">1</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h1 id="现成的Function声明汇总"><a href="#现成的Function声明汇总" class="headerlink" title="现成的Function声明汇总"></a>现成的Function声明汇总</h1><p>java8给了一些统一的描述术语(DSL)来分类这些函数接口:</p>
<table>
<thead>
<tr>
<th>接口</th>
<th>lambda</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>Predicate&lt; T&gt;</td>
<td>T-&gt;boolean</td>
<td>类似于filter，接收T类型返回boolean</td>
</tr>
<tr>
<td>Consumer&lt; T&gt;</td>
<td>T-&gt;void</td>
<td>类似于foreach，接收T类型返回void</td>
</tr>
<tr>
<td>Function&lt; T,R&gt;</td>
<td>T-&gt;R</td>
<td>类似于Map，接收T类型返回R类型</td>
</tr>
<tr>
<td>Supplier&lt; T&gt;</td>
<td>()-&gt;T</td>
<td></td>
</tr>
<tr>
<td>UnaryOperator&lt; T&gt;</td>
<td>T-&gt;T</td>
<td></td>
</tr>
<tr>
<td>BinaryOperator&lt; T&gt;</td>
<td>(T,T)-&gt;T</td>
<td></td>
</tr>
<tr>
<td>BiPredicate&lt; L,R&gt;</td>
<td>(L,R)-&gt;boolean</td>
<td></td>
</tr>
<tr>
<td>BiConsumer&lt; T,U&gt;</td>
<td>(T,U)-&gt;void</td>
<td></td>
</tr>
<tr>
<td>BiFunction&lt; T,U,R&gt;</td>
<td>(T,U)-&gt;R</td>
<td></td>
</tr>
</tbody></table>
<p>常见的几种函数指针都可以用这些现成的声明，如果要抛异常，或者比较特殊的入参、出参，就自己用<code>@FunctionalInterface</code>注解声明个接口和相应方法即可。</p>
<p>此外，上述接口的T,R泛型都需要类、引用，因此如果要节省装箱开销，可以用相应的原始类型声明，比如一个<code>int-&gt;int</code>的变换，相应的接口就是<code>IntUnaryOperator</code>。<br>因此上一节中的代码可以简化成:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">searchMatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix == <span class="keyword">null</span> || matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span> || target &lt; matrix[<span class="number">0</span>][<span class="number">0</span>]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> lowerBound = getLowerBound(target, <span class="number">0</span>, matrix.length - <span class="number">1</span>, i -&gt; matrix[i][<span class="number">0</span>]);<span class="comment">// 闭包捕获matrix</span></span><br><span class="line">        <span class="keyword">if</span> (lowerBound &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> finalLowerBound = -lowerBound - <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> x = getLowerBound(target, <span class="number">0</span>, matrix[<span class="number">0</span>].length - <span class="number">1</span>, i -&gt; matrix[finalLowerBound][i]);<span class="comment">// 闭包捕获matrix和finalLowerBound</span></span><br><span class="line">        <span class="keyword">return</span> x &gt;= <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getLowerBound</span><span class="params">(<span class="keyword">int</span> target, <span class="keyword">int</span> left, <span class="keyword">int</span> right, IntUnaryOperator helper)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> mid;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            mid = (left + right) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> midVal = helper.applyAsInt(mid);</span><br><span class="line">            <span class="keyword">if</span> (target &lt; midVal) &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (target &gt; midVal) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -left - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


<p>其他的原始类型(免装箱)的现成有的声明如下:（要用的时候可以查表）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. Predicate&lt;T&gt; T-&gt;boolean :</span></span><br><span class="line">IntPredicate,LongPredicate, DoublePredicate</span><br><span class="line"><span class="comment">// 2. Consumer&lt;T&gt; T-&gt;void :</span></span><br><span class="line">IntConsumer,LongConsumer, DoubleConsumer</span><br><span class="line"><span class="comment">// 3. Function&lt;T,R&gt; T-&gt;R :</span></span><br><span class="line">IntFunction&lt;R&gt;,</span><br><span class="line">IntToDoubleFunction,</span><br><span class="line">IntToLongFunction,</span><br><span class="line">LongFunction&lt;R&gt;,</span><br><span class="line">LongToDoubleFunction,</span><br><span class="line">LongToIntFunction,</span><br><span class="line">DoubleFunction&lt;R&gt;,</span><br><span class="line">ToIntFunction&lt;T&gt;,</span><br><span class="line">ToDoubleFunction&lt;T&gt;,</span><br><span class="line">ToLongFunction&lt;T&gt; </span><br><span class="line"><span class="comment">// 4. Supplier&lt;T&gt; ()-&gt;T :</span></span><br><span class="line">BooleanSupplier,IntSupplier,LongSupplier,DoubleSupplier</span><br><span class="line"><span class="comment">// 5. UnaryOperator&lt;T&gt; T-&gt;T :</span></span><br><span class="line">IntUnaryOperator,</span><br><span class="line">LongUnaryOperator,</span><br><span class="line">DoubleUnaryOperator</span><br><span class="line"><span class="comment">// 6. BinaryOperator&lt;T&gt; (T,T)-&gt;T :</span></span><br><span class="line">IntBinaryOperator,</span><br><span class="line">LongBinaryOperator,</span><br><span class="line">DoubleBinaryOperator</span><br><span class="line"><span class="comment">// 7. BiConsumer&lt;T,U&gt; (T,U)-&gt;void :</span></span><br><span class="line">ObjIntConsumer&lt;T&gt;,</span><br><span class="line">ObjLongConsumer&lt;T&gt;,</span><br><span class="line">ObjDoubleConsumer&lt;T&gt;</span><br><span class="line"><span class="comment">// 8. BiFunction&lt;T,U,R&gt; (T,U)-&gt;R :</span></span><br><span class="line">ToIntBiFunction&lt;T,U&gt;,</span><br><span class="line">ToLongBiFunction&lt;T,U&gt;,</span><br><span class="line">ToDoubleBiFunction&lt;T,U&gt;</span><br></pre></td></tr></table></figure>

<h1 id="无状态"><a href="#无状态" class="headerlink" title="无状态"></a>无状态</h1><p>默认无状态的操作:  map,filter,collect; // 假如不使用外部变量(闭包)<br>有状态的操作: reduce,sum,max,sorted,distinct,skip,limit; // 有内部状态、初始值</p>
<p>// flatmap? </p>
<h1 id="原始类型流"><a href="#原始类型流" class="headerlink" title="原始类型流"></a>原始类型流</h1><p>原始类型流如: <code>IntStream</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">IntStream intStream = menu.stream().mapToInt(Dish::getCalories);</span><br><span class="line">Stream&lt; Integer&gt; stream = intStream.boxed();</span><br></pre></td></tr></table></figure>

<p>原始类型的Optional:<code>OptionalInt</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OptionalInt maxCalories = menu.stream().mapToInt(Dish::getCalories).max();</span><br></pre></td></tr></table></figure>

<h1 id="java中的蜂巢结构"><a href="#java中的蜂巢结构" class="headerlink" title="java中的蜂巢结构"></a>java中的蜂巢结构</h1><p>d3中有个蜂巢结构,java8中也可以有:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Dish.Type, Map&lt;CaloricLevel, List&lt;Dish&gt;&gt;&gt; dishesByTypeCaloricLevel = menu.stream().collect(</span><br><span class="line">groupingBy(Dish::getType,</span><br><span class="line">   groupingBy(dish -&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (dish.getCalories() &lt;= <span class="number">400</span>) <span class="keyword">return</span> CaloricLevel.DIET;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (dish.getCalories() &lt;= <span class="number">700</span>) <span class="keyword">return</span> CaloricLevel.NORMAL;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> CaloricLevel.FAT;</span><br><span class="line">    &#125;);</span><br><span class="line">));</span><br></pre></td></tr></table></figure>

<p>还可以分组计数:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Dish.Type, Long&gt; typesCount = menu.stream().collect(</span><br><span class="line">                    groupingBy(Dish::getType, counting()));</span><br></pre></td></tr></table></figure>


<h1 id="collectors中的characteristics"><a href="#collectors中的characteristics" class="headerlink" title="collectors中的characteristics"></a>collectors中的characteristics</h1><p>返回枚举值的list:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">UNORDERED: 结果不受顺序影响;</span><br><span class="line">CONCURRENT: 可以并行运行;</span><br><span class="line">IDENTITY_FINISH: 累加器和最后的结果类型是一样的,不需要再转换。</span><br></pre></td></tr></table></figure>
<p>一般是是返回后两者,因为一般都会希望维持顺序(如<code>toList</code>):</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Set&lt;Characteristics&gt; <span class="title">characteristics</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Collections.unmodifiableSet(EnumSet.of(</span><br><span class="line">    IDENTITY_FINISH, CONCURRENT));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果是生成质数这种,实现上依赖之前已经生成的质数,有状态,则不能并行。只返回一个<code>IDENTITY_FINISH</code>.</p>
<h1 id="Spliterator"><a href="#Spliterator" class="headerlink" title="Spliterator"></a>Spliterator</h1><p>Spliterator的特性:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ORDERED 元素有既定的顺序（例如List），因此Spliterator在遍历和划分时也会遵循这一顺序</span><br><span class="line">DISTINCT 对于任意一对遍历过的元素x和y，x.equals(y)返回false</span><br><span class="line">SORTED 遍历的元素按照一个预定义的顺序排序</span><br><span class="line">SIZED 该Spliterator由一个已知大小的源建立（例如Set），因此estimatedSize()返回的是准确值</span><br><span class="line">NONNULL 保证遍历的元素不会为null</span><br><span class="line">IMMUTABLE Spliterator的数据源不能修改。这意味着在遍历时不能添加、删除或修改任何元素</span><br><span class="line">CONCURRENT 该Spliterator的数据源可以被其他线程同时修改而无需同步</span><br><span class="line">SUBSIZED 该Spliterator和所有从它拆分出来的Spliterator都是SIZED</span><br></pre></td></tr></table></figure>
<p>DISTINCT和SORTED比较难达到;<br>一般是:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">characteristics</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ORDERED + SIZED + SUBSIZED + NONNULL + IMMUTABLE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><p>策略模式: 策略发生变化，只修改用到的函数。(例如输入校验策略)<br>模版方法: 修改一大段代码中其中一个函数的调用实现。(传入函数指针)<br>观察者模式: 例如GUI场景下，注册一大堆监听事件。(传入函数指针)</p>
<h2 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式:"></a>责任链模式:</h2><p>每个处理者可以增加后继处理节点,形成一个链表，每次处理的时候，调用下一个处理者。用lamda中的addThen的话:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">UnaryOperator&lt;String&gt; headerProcessing =</span><br><span class="line"> (String text) -&gt; <span class="string">"From Raoul, Mario and Alan: "</span> + text;</span><br><span class="line">UnaryOperator&lt;String&gt; spellCheckerProcessing =</span><br><span class="line"> (String text) -&gt; text.replaceAll(<span class="string">"labda"</span>, <span class="string">"lambda"</span>);</span><br><span class="line">Function&lt;String, String&gt; pipeline =</span><br><span class="line"> headerProcessing.andThen(spellCheckerProcessing);</span><br><span class="line">String result = pipeline.apply(<span class="string">"Aren't labdas really sexy?!!"</span>)</span><br></pre></td></tr></table></figure>
<h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><p>可以把构造函数放map里:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">static</span> Map&lt;String, Supplier&lt;Product&gt;&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line"> map.put(<span class="string">"loan"</span>, Loan::<span class="keyword">new</span>);</span><br><span class="line"> map.put(<span class="string">"stock"</span>, Stock::<span class="keyword">new</span>);</span><br><span class="line"> map.put(<span class="string">"bond"</span>, Bond::<span class="keyword">new</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="lamda方法的单元测试"><a href="#lamda方法的单元测试" class="headerlink" title="lamda方法的单元测试"></a>lamda方法的单元测试</h1><ol>
<li>存成成员变量(函数指针);</li>
<li>匿名方法粒度太小了，应该测试上层方法;</li>
</ol>
<h1 id="lambda的副作用"><a href="#lambda的副作用" class="headerlink" title="lambda的副作用"></a>lambda的副作用</h1><ol>
<li>出错信息模糊: 错误栈缺失准确的信息；</li>
</ol>
<h2 id="调试技巧"><a href="#调试技巧" class="headerlink" title="调试技巧"></a>调试技巧</h2><p>使用peek函数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; result =</span><br><span class="line"> numbers.stream()</span><br><span class="line"> .peek(x -&gt; System.out.println(<span class="string">"from stream: "</span> + x))</span><br><span class="line"> .map(x -&gt; x + <span class="number">17</span>)</span><br><span class="line"> .peek(x -&gt; System.out.println(<span class="string">"after map: "</span> + x))</span><br><span class="line"> .filter(x -&gt; x % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line"> .peek(x -&gt; System.out.println(<span class="string">"after filter: "</span> + x))</span><br><span class="line"> .limit(<span class="number">3</span>) <span class="comment">// 只取3个. </span></span><br><span class="line"> .peek(x -&gt; System.out.println(<span class="string">"after limit: "</span> + x))</span><br><span class="line"> .collect(toList());</span><br></pre></td></tr></table></figure>

<h1 id="3种兼容性"><a href="#3种兼容性" class="headerlink" title="3种兼容性"></a>3种兼容性</h1><p>二进制级兼容： 现有二进制执行文件能无缝链接；<br>源码级兼容：   现有程序能够成功编译通过；<br>函数行为级兼容：程序接受同样的输入能得到同样的结果。</p>
<p>接口中加入新的方法：<br>二进制级兼容：兼容;(不会被调用)<br>源码级兼容：不兼容;(不符合语法)<br>函数行为级兼容: 兼容;(不影响原有函数)</p>
<p>抽象类和有默认方法的接口区别：抽象类可以有成员、不能多继承。</p>
<p>默认方法的接口多继承优先级问题：</p>
<ol>
<li>类中的实现&gt; 接口中的;</li>
<li>子接口中实现&gt;父接口中的;</li>
<li>上述两种无法判断时,必须显式调用,声明调用的是哪个实现:<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// class C implement B,A</span></span><br><span class="line">B.<span class="keyword">super</span>.hello(); <span class="comment">// 显式调用B接口中的方法;</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h1 id="Option"><a href="#Option" class="headerlink" title="Option"></a>Option</h1><p>每次新建一个类的时候，所有引用类成员都尽量搞成<code>Option</code>.<br>如果可能为null,就搞成<code>Option</code>;<br>如果不可能为null,就维持朴素类型。// 比如构造时就自动填充确定值的final</p>
<p>相当于领域中将是否可选这个属性也封装了进去，而不是靠注释来弱约束。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化可以这样:</span></span><br><span class="line">Optional&lt;Car&gt; optCar = Optional.empty();</span><br><span class="line"><span class="comment">// 根据空或非空值创建: </span></span><br><span class="line">Optional&lt;Car&gt; optCar = Optional.ofNullable(car); <span class="comment">// 推荐初始化方式</span></span><br></pre></td></tr></table></figure>

<p>用了Optional以后,后续用Stream api处理(疯狂调用<code>flatMap</code>),整个过程就变成函数式,再也不需要null关键字。</p>
<p>对于可选成员(<code>Option&lt;T&gt;</code>): 调用<code>flatMap</code>;<br>对于必选成员(<code>final String</code>): 调用<code>map</code>;</p>
<p>Option的缺点: 无法序列化。<br>如果需要可以序列化的类,只能隐藏Option变量:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Optional&lt;Car&gt; <span class="title">getCarAsOptional</span><span class="params">()</span> </span>&#123;</span><br><span class="line">             <span class="keyword">return</span> Optional.ofNullable(car);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Optional不能滥用(不能序列化):(java Lambda（JSR-335）专家组考虑并拒绝了它)</p>
<blockquote>
<p>尽量避免将Optional用于类属性、方法参数及集合元素中，因为以上三种情况，完全可以使用null值来代替Optional，没有必要必须使用Optional，另外Optional本身为引用类型，大量使用Optional会出现类似(这样描述不完全准确)封箱、拆箱的操作，在一定程度上会影响JVM的堆内存及内存回收。<br>相关tip:<br><a href="https://segmentfault.com/a/1190000018936877?utm_source=tag-newest" target="_blank" rel="noopener">https://segmentfault.com/a/1190000018936877?utm_source=tag-newest</a></p>
</blockquote>
<ul>
<li>不要放进Map里，因为Optional不是作为值类型设计的，它的<code>equals、hashcode、==</code>方法都不能保证正确性(和唯一性有关的方法)。</li>
</ul>
<p>最后: POJO还是保持纯粹，这样也有向前先后兼容性。</p>
<h1 id="异步编程"><a href="#异步编程" class="headerlink" title="异步编程"></a>异步编程</h1><p>无法从线程失败中恢复的版本:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Future&lt;Double&gt; <span class="title">getPriceAsync</span><span class="params">(String product)</span> </span>&#123;     </span><br><span class="line">        CompletableFuture&lt;Double&gt; futurePrice = <span class="keyword">new</span> CompletableFuture&lt;&gt;();          </span><br><span class="line">        <span class="keyword">new</span> Thread( () -&gt; &#123;</span><br><span class="line">           <span class="keyword">double</span> price = calculatePrice(product);</span><br><span class="line">           futurePrice.complete(price);<span class="comment">// here</span></span><br><span class="line">        &#125;).start();</span><br><span class="line">       <span class="keyword">return</span> futurePrice;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>加上try catch:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">double</span> price = calculatePrice(product);</span><br><span class="line">    futurePrice.complete(price);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">    futurePrice.completeExceptionally(ex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>精简后:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Future&lt;Double&gt; <span class="title">getPriceAsync</span><span class="params">(String product)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> CompletableFuture.supplyAsync(() -&gt; calculatePrice(product));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="并行查询-无状态"><a href="#并行查询-无状态" class="headerlink" title="并行查询(无状态)"></a>并行查询(无状态)</h2><p>无状态:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">shops.parallelStream().map(shop-&gt;String.format(<span class="string">"%s price is %.2f"</span></span><br><span class="line">,shop.getName(), shop.getPrice(product)))).collect(ToList());</span><br></pre></td></tr></table></figure>

<p>定制Executor:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Executor executor =</span><br><span class="line">Executors.newFixedThreadPool(Math.min(shops.size(), <span class="number">100</span>),</span><br><span class="line">    <span class="keyword">new</span> ThreadFactory() &#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">       Thread t = <span class="keyword">new</span> Thread(r);</span><br><span class="line">        t.setDaemon(<span class="keyword">true</span>);<span class="comment">// 守护线程,主线程结束后关闭</span></span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>


<p>计算密集,无IO: 使用Stream接口; // 不加线程数<br>IO密集,计算简单: 使用<code>CompletableFuture</code>,自定义线程池; // 可以疯狂加线程</p>
<h1 id="时间api"><a href="#时间api" class="headerlink" title="时间api"></a>时间api</h1><h2 id="LocalDate和LocalTime"><a href="#LocalDate和LocalTime" class="headerlink" title="LocalDate和LocalTime"></a>LocalDate和LocalTime</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">LocalDate date = LocalDate.of(<span class="number">2014</span>, <span class="number">3</span>, <span class="number">18</span>);</span><br><span class="line">LocalDate today = LocalDate.now();</span><br><span class="line">LocalTime time = LocalTime.of(<span class="number">13</span>, <span class="number">45</span>, <span class="number">20</span>);</span><br><span class="line"><span class="comment">// 字符串:</span></span><br><span class="line">LocalDate date = LocalDate.parse(<span class="string">"2014-03-18"</span>);</span><br><span class="line">LocalTime time = LocalTime.parse(<span class="string">"13:45:20"</span>);</span><br></pre></td></tr></table></figure>
<h2 id="复合后-LocalDateTime"><a href="#复合后-LocalDateTime" class="headerlink" title="复合后: LocalDateTime"></a>复合后: LocalDateTime</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LocalDateTime dt1 = LocalDateTime.of(<span class="number">2014</span>, Month.MARCH, <span class="number">18</span>, <span class="number">13</span>, <span class="number">45</span>, <span class="number">20</span>); LocalDateTime dt2 = LocalDateTime.of(date, time);<span class="comment">// 复合localDate和localTime</span></span><br></pre></td></tr></table></figure>

<h2 id="unix时间-java-time-Instant"><a href="#unix时间-java-time-Instant" class="headerlink" title="unix时间: java.time.Instant"></a>unix时间: <code>java.time.Instant</code></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Instant.ofEpochSecond(<span class="number">3</span>);<span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<h2 id="时间间隔-Duration"><a href="#时间间隔-Duration" class="headerlink" title="时间间隔: Duration"></a>时间间隔: Duration</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Duration d1 = Duration.between(time1, time2);</span><br><span class="line">Duration d1 = Duration.between(dateTime1, dateTime2);</span><br><span class="line">Duration d2 = Duration.between(instant1, instant2);</span><br><span class="line">Duration threeMinutes = Duration.ofMinutes(<span class="number">3</span>);</span><br></pre></td></tr></table></figure>

<h2 id="天间隔-Period"><a href="#天间隔-Period" class="headerlink" title="天间隔: Period"></a>天间隔: Period</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Period tenDays = Period.between(LocalDate.of(<span class="number">2014</span>, <span class="number">3</span>, <span class="number">8</span>),</span><br><span class="line">                        LocalDate.of(<span class="number">2014</span>, <span class="number">3</span>, <span class="number">18</span>));</span><br><span class="line">Period tenDays = Period.ofDays(<span class="number">10</span>);</span><br></pre></td></tr></table></figure>

<p>上述类都是不可变的。// 线程安全</p>
<p>修改直接返回新变量:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LocalDate date2 = date1.withYear(<span class="number">2011</span>);</span><br><span class="line">LocalDate date2 = date1.plusWeeks(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<h2 id="个性化操作-TemporalAdjuster"><a href="#个性化操作-TemporalAdjuster" class="headerlink" title="个性化操作: TemporalAdjuster"></a>个性化操作: TemporalAdjuster</h2><p>下个周日、下个工作日、本月最后一天:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.time.temporal.TemporalAdjusters.*;</span><br><span class="line">LocalDate date1 = LocalDate.of(<span class="number">2014</span>, <span class="number">3</span>, <span class="number">18</span>);</span><br><span class="line">LocalDate date2 = date1.with(nextOrSame(DayOfWeek.SUNDAY));</span><br><span class="line">LocalDate date3 = date2.with(lastDayOfMonth());</span><br></pre></td></tr></table></figure>

<h2 id="格式化、格式转换"><a href="#格式化、格式转换" class="headerlink" title="格式化、格式转换"></a>格式化、格式转换</h2><h3 id="localData-lt-gt-String"><a href="#localData-lt-gt-String" class="headerlink" title="localData&lt;=&gt;String"></a>localData&lt;=&gt;String</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">LocalDate date = LocalDate.of(<span class="number">2014</span>, <span class="number">3</span>, <span class="number">18</span>);</span><br><span class="line">String s1 = date.format(DateTimeFormatter.BASIC_ISO_DATE); <span class="comment">// 20140318</span></span><br><span class="line">String s2 = date.format(DateTimeFormatter.ISO_LOCAL_DATE); <span class="comment">// 2014-03-18</span></span><br><span class="line"></span><br><span class="line">LocalDate date1 = LocalDate.parse(<span class="string">"20140318"</span>,</span><br><span class="line">                                 DateTimeFormatter.BASIC_ISO_DATE);</span><br><span class="line">LocalDate date2 = LocalDate.parse(<span class="string">"2014-03-18"</span>,</span><br><span class="line">                                 DateTimeFormatter.ISO_LOCAL_DATE);</span><br></pre></td></tr></table></figure>

<p>定制格式:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DateTimeFormatter formatter = DateTimeFormatter.ofPattern(<span class="string">"dd/MM/yyyy"</span>);</span><br><span class="line">LocalDate date1 = LocalDate.of(<span class="number">2014</span>, <span class="number">3</span>, <span class="number">18</span>);</span><br><span class="line">String formattedDate = date1.format(formatter);</span><br><span class="line">LocalDate date2 = LocalDate.parse(formattedDate, formatter);</span><br></pre></td></tr></table></figure>

<h2 id="时区"><a href="#时区" class="headerlink" title="时区"></a>时区</h2><p><code>java.time.ZoneId</code>和<code>ZonedDateTime</code>:<br>从LocalData转换到ZonedDateTime:(其他几个也一样)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ZoneId romeZone = ZoneId.of(<span class="string">"Europe/Rome"</span>);</span><br><span class="line"><span class="comment">// 或者: ZoneId zoneId = TimeZone.getDefault().toZoneId();</span></span><br><span class="line">LocalDate date = LocalDate.of(<span class="number">2014</span>, Month.MARCH, <span class="number">18</span>); <span class="number">6</span></span><br><span class="line">ZonedDateTime zdt1 = date.atStartOfDay(romeZone);</span><br></pre></td></tr></table></figure>

<img src="/images/2019-11/zonedDateTime.png" class="" width="800" height="1200" title="zonedDateTime">

<p>时区差: <code>ZoneOffset</code></p>
<p>其他日历系统: <code>ThaiBuddhistDate</code>,<code>MinguoDate</code>,<code>JapaneseDate</code>,<code>HijrahDate</code></p>
<h1 id="其他tips"><a href="#其他tips" class="headerlink" title="其他tips"></a>其他tips</h1><p>ConcurrentHashMap类：<br>用<code>mappingCount</code>方法代替<code>size</code>方法;<br><code>mappingCount</code>: 返回long;<br><code>size</code>: 返回int; (实际大小超过int时无效)</p>
<p>重复遍历流: 可以使用StreamForker,缺点本质上是存了内存。</p>
<h1 id="lambda底层实现"><a href="#lambda底层实现" class="headerlink" title="lambda底层实现"></a>lambda底层实现</h1><h2 id="匿名类的实现"><a href="#匿名类的实现" class="headerlink" title="匿名类的实现"></a>匿名类的实现</h2><p>匿名内部类底层是生成一个<code>class$1</code>的类。(外层类名+数字)<br>缺点： 每个类都需要加载、验证的操作，如果类太多，开销太大；</p>
<h2 id="查看字节码和常量池"><a href="#查看字节码和常量池" class="headerlink" title="查看字节码和常量池"></a>查看字节码和常量池</h2><p>使用命令:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javap -c -v ClassName</span><br></pre></td></tr></table></figure>


<h2 id="lambda的实现：-InvokeDynamic"><a href="#lambda的实现：-InvokeDynamic" class="headerlink" title="lambda的实现： InvokeDynamic"></a>lambda的实现： InvokeDynamic</h2><p>本质上是在所在类里新增了一个方法。将Lambda表达式的代码体填入到运行时动态创建的<code>静态方法</code>，就完成了Lambda表达式的字节码转换。<br>动态链接方法，然后用<code>InvokeDynamic</code>调用:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Lambda</span> </span>&#123;</span><br><span class="line">    Function&lt;Object, String&gt; f = [dynamic invocation of lambda$<span class="number">1</span>]</span><br><span class="line">     <span class="keyword">static</span> String lambda$<span class="number">1</span>(Object obj) &#123;</span><br><span class="line">        <span class="keyword">return</span> obj.toString();</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>优点:</p>
<ol>
<li>lamda相关字节码的生成推迟到使用的时候; (懒加载)</li>
<li>如果不是闭包：有类似于static final变量的缓存效果;(闭包的话,因为可能捕获不同的局部变量，不可以缓存)</li>
<li>没有额外的开销;<br>如果lambda是个闭包，也就是捕获了其他作用域内的变量(当然编译时会要求是final或者实质上是final)，也很简单，就是给这个函数加一个参数即可。</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://xiaoyue26.github.io/2019/11/03/2019-11/java8%E7%AC%94%E8%AE%B0/" data-id="ck96cxpqb00kcmaam9w6ucaoz" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/" rel="tag">java</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-2019-10/rust入门笔记-2" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/10/06/2019-10/rust%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0-2/" class="article-date">
  <time datetime="2019-10-06T10:58:26.000Z" itemprop="datePublished">2019-10-06</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/rust/">rust</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/10/06/2019-10/rust%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0-2/">rust入门笔记_2</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <h1 id="解引用强制多态（deref-coercions）"><a href="#解引用强制多态（deref-coercions）" class="headerlink" title="解引用强制多态（deref coercions）"></a>解引用强制多态（<code>deref coercions</code>）</h1><p><code>coercions</code>的意思就是强制多态。<br>解引用强制多态的意思通俗来说就是，编译器根据目标类型，自动调用<code>deref</code>方法解引用，搜索路径来达到目标类型，最终达到节省程序员编写成本，但最后运行时开销维持最小的目标。(语法糖成本为0)</p>
<h2 id="背景知识-智能指针的解引用"><a href="#背景知识-智能指针的解引用" class="headerlink" title="背景知识: 智能指针的解引用"></a>背景知识: 智能指针的解引用</h2><p>自定义的智能指针，实现<code>Deref trait</code>(解引用特性)后，就可以使用<code>*</code>操作符来解引用了。<br>例如:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::ops::Deref;</span><br><span class="line"></span><br><span class="line"># <span class="class"><span class="keyword">struct</span> <span class="title">MyBox</span></span>&lt;T&gt;(T);</span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; Deref <span class="keyword">for</span> MyBox&lt;T&gt; &#123;</span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">Target</span></span> = T;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">deref</span></span>(&amp;<span class="keyword">self</span>) -&gt; &amp;T &#123; <span class="comment">// 注意这里的返回值需要是引用,以便维持所有权</span></span><br><span class="line">        &amp;<span class="keyword">self</span>.<span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译器每次遇到<code>*</code>操作符，都会尝试调用复杂类型的<code>deref</code>方法来获得基本类型的引用，以便进行解引用，也就是代码等效于:<code>*(y.deref())</code>。</p>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> m = MyBox::new(<span class="built_in">String</span>::from(<span class="string">"Rust"</span>));</span><br><span class="line">hello(&amp;m); <span class="comment">// 这里hello的形参是&amp;str,实参是&amp;MyBox</span></span><br><span class="line"><span class="comment">// 强制解引用多态后，等效于调用了: hello(&amp;(*m)[..]);</span></span><br><span class="line"><span class="comment">// &amp;MyBox =通过deref=&gt; String =通过slice=&gt; &amp;str</span></span><br></pre></td></tr></table></figure>

<h2 id="更多解引用多态规则"><a href="#更多解引用多态规则" class="headerlink" title="更多解引用多态规则"></a>更多解引用多态规则</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>. 当 T: Deref&lt;Target=U&gt; 时从 &amp;T 到 &amp;U。 <span class="comment">// 不可变=&gt;不可变</span></span><br><span class="line"><span class="number">2</span>. 当 T: DerefMut&lt;Target=U&gt; 时从 &amp;<span class="keyword">mut</span> T 到 &amp;<span class="keyword">mut</span> U。 <span class="comment">// 可变=&gt;可变</span></span><br><span class="line"><span class="number">3</span>. 当 T: Deref&lt;Target=U&gt; 时从 &amp;<span class="keyword">mut</span> T 到 &amp;U。 <span class="comment">// 可变=&gt;不可变</span></span><br></pre></td></tr></table></figure>
<p>只会发生安全的转换，而<code>不可变=&gt;可变</code>这种属于不安全，因此不支持自动转换。</p>
<p>(上面的实例属于第一种。)</p>
<h1 id="析构函数-std-mem-drop"><a href="#析构函数-std-mem-drop" class="headerlink" title="(析构函数) std::mem::drop"></a>(析构函数) std::mem::drop</h1><p>自定义Drop trait:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="built_in">Drop</span> <span class="keyword">for</span> CustomSmartPointer &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">drop</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"Dropping CustomSmartPointer with data `&#123;&#125;`!"</span>, <span class="keyword">self</span>.data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定义以后drop函数不能显式调用，也不能禁用。<br>只能在离开作用域的时候自动调用。<br>如果要显式调用，只能使用标准库的函数<code>std::mem::drop</code>.<br>(默认预引入，可以直接调用drop)</p>
<h1 id="智能指针汇总"><a href="#智能指针汇总" class="headerlink" title="智能指针汇总"></a>智能指针汇总</h1><p>Box: 没有特殊功能,类似于java中的普通引用,让编译器能确定分配空间大小;<br>Rc: 多所有权、单线程、引用计数;<br>RefCell: 单所有权、单线程、引用计数、内部可变性;<br>Arc: 多所有权、多线程、引用计数;<br>Mutex: 单所有权、多线程、引用计数、内部可变性;<br>Week: 弱引用。</p>
<h1 id="多所有权、单线程、不可变：引用计数-gt-Rc"><a href="#多所有权、单线程、不可变：引用计数-gt-Rc" class="headerlink" title="多所有权、单线程、不可变：引用计数=&gt;Rc"></a>多所有权、单线程、不可变：引用计数=&gt;Rc<T></h1><p>多所有权示例: b,c都拥有a的所有权。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">List</span></span> &#123;</span><br><span class="line">    Cons(<span class="built_in">i32</span>, Rc&lt;List&gt;),</span><br><span class="line">    Nil,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> List::&#123;Cons, Nil&#125;;</span><br><span class="line"><span class="keyword">use</span> std::rc::Rc;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> a = Rc::new(Cons(<span class="number">5</span>, Rc::new(Cons(<span class="number">10</span>, Rc::new(Nil)))));</span><br><span class="line">    <span class="keyword">let</span> b = Cons(<span class="number">3</span>, Rc::clone(&amp;a));</span><br><span class="line">    <span class="keyword">let</span> c = Cons(<span class="number">4</span>, Rc::clone(&amp;a));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每次调用<code>Rc::clone</code>，都将引用计数加1.// 这里是浅拷贝<br>b: 3-&gt;5-&gt;10-&gt;Nil<br>c: 4-&gt;5-&gt;10-&gt;Nil</p>
<p>打印引用数:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> a = Rc::new(Cons(<span class="number">5</span>, Rc::new(Cons(<span class="number">10</span>, Rc::new(Nil)))));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"count after creating a = &#123;&#125;"</span>, Rc::strong_count(&amp;a));</span><br><span class="line">    <span class="keyword">let</span> b = Cons(<span class="number">3</span>, Rc::clone(&amp;a));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"count after creating b = &#123;&#125;"</span>, Rc::strong_count(&amp;a));</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> c = Cons(<span class="number">4</span>, Rc::clone(&amp;a));</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"count after creating c = &#123;&#125;"</span>, Rc::strong_count(&amp;a));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"count after c goes out of scope = &#123;&#125;"</span>, Rc::strong_count(&amp;a));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="单一所有权、单线程、内部可变：引用计数-gt-RefCell"><a href="#单一所有权、单线程、内部可变：引用计数-gt-RefCell" class="headerlink" title="单一所有权、单线程、内部可变：引用计数=&gt;RefCell"></a>单一所有权、单线程、内部可变：引用计数=&gt;RefCell<T></h1><h2 id="借用规则"><a href="#借用规则" class="headerlink" title="借用规则"></a>借用规则</h2><ol>
<li>每时每刻，要么有一个可变引用;要么有n个不可变引用；(这两者互斥)</li>
<li>引用必须总是有效的。</li>
</ol>
<p>对于引用和<code>Box&lt;T&gt;</code>: <code>编译时</code>进行借用规则检查；(编译错误)<br>对于<code>RefCell&lt;T&gt;</code>:   <code>运行时</code>进行借用规则检查；(<code>panic</code>)</p>
<p>引用和<code>Box&lt;T&gt;</code>: 第一级指针不可变，则级联得每一级都不可变。<br><code>RefCell</code>: 第一级指针不可变，第二级可以借用可变引用，然后修改；</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[cfg(test)]</span></span><br><span class="line"><span class="keyword">mod</span> tests &#123;</span><br><span class="line">    <span class="keyword">use</span> super::*;</span><br><span class="line">    <span class="keyword">use</span> std::cell::RefCell;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">MockMessenger</span></span> &#123;</span><br><span class="line">        sent_messages: RefCell&lt;<span class="built_in">Vec</span>&lt;<span class="built_in">String</span>&gt;&gt;,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">impl</span> MockMessenger &#123;</span><br><span class="line">        <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>() -&gt; MockMessenger &#123;</span><br><span class="line">            MockMessenger &#123; sent_messages: RefCell::new(<span class="built_in">vec!</span>[]) &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">impl</span> Messenger <span class="keyword">for</span> MockMessenger &#123;</span><br><span class="line">        <span class="function"><span class="keyword">fn</span> <span class="title">send</span></span>(&amp;<span class="keyword">self</span>, message: &amp;<span class="built_in">str</span>) &#123;</span><br><span class="line">        <span class="comment">// 注意这里的borrow_mut，借出可变:</span></span><br><span class="line">            <span class="keyword">self</span>.sent_messages.borrow_mut().push(<span class="built_in">String</span>::from(message));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">it_sends_an_over_75_percent_warning_message</span></span>() &#123;</span><br><span class="line">        <span class="comment">// --snip--</span></span><br><span class="line">#         <span class="keyword">let</span> mock_messenger = MockMessenger::new();</span><br><span class="line">#         <span class="keyword">let</span> <span class="keyword">mut</span> limit_tracker = LimitTracker::new(&amp;mock_messenger, <span class="number">100</span>);</span><br><span class="line">#         limit_tracker.set_value(<span class="number">75</span>);</span><br><span class="line">        <span class="comment">// 注意这里的borrow，借出不可变:</span></span><br><span class="line">        <span class="built_in">assert_eq!</span>(mock_messenger.sent_messages.borrow().len(), <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>borrow</code> 方法返回 <code>Ref</code> 类型的智能指针；<br><code>borrow_mut</code> 方法返回 <code>RefMut</code> 类型的智能指针。</p>
<p>这两个类型都实现了 <code>Deref</code> 所以可以当作常规引用对待。<br>借用规则在运行时检查，例如同时借出两个可变引用将会panic:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> one_borrow = <span class="keyword">self</span>.sent_messages.borrow_mut();</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> two_borrow = <span class="keyword">self</span>.sent_messages.borrow_mut();</span><br></pre></td></tr></table></figure>
<p>底层原理依然是引用计数。</p>
<h2 id="结合Rc和RefCell"><a href="#结合Rc和RefCell" class="headerlink" title="结合Rc和RefCell"></a>结合Rc和RefCell</h2><p>结合Rc和RefCell的话，就可以结合多所有权和单所有权，不可变和可变:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">List</span></span> &#123;</span><br><span class="line">    Cons(Rc&lt;RefCell&lt;<span class="built_in">i32</span>&gt;&gt;, Rc&lt;List&gt;),<span class="comment">// 注意这里</span></span><br><span class="line">    Nil,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> List::&#123;Cons, Nil&#125;;</span><br><span class="line"><span class="keyword">use</span> std::rc::Rc;</span><br><span class="line"><span class="keyword">use</span> std::cell::RefCell;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> value = Rc::new(RefCell::new(<span class="number">5</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> a = Rc::new(Cons(Rc::clone(&amp;value), Rc::new(Nil)));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> b = Cons(Rc::new(RefCell::new(<span class="number">6</span>)), Rc::clone(&amp;a));</span><br><span class="line">    <span class="keyword">let</span> c = Cons(Rc::new(RefCell::new(<span class="number">10</span>)), Rc::clone(&amp;a));</span><br><span class="line"></span><br><span class="line">    *value.borrow_mut() += <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"a after = &#123;:?&#125;"</span>, a);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"b after = &#123;:?&#125;"</span>, b);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"c after = &#123;:?&#125;"</span>, c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>混合使用<code>Rc</code>和<code>RefCell</code>可以构造循环引用，造成内存泄露。<br>可以用弱引用来消除这一隐患: 将 <code>Rc&lt;T&gt;</code> 变为 <code>Weak&lt;T&gt;</code>。</p>
<h1 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h1><p><a href="https://rustlang-cn.org/office/rust/book/smart-pointers/ch15-06-reference-cycles.html" target="_blank" rel="noopener">https://rustlang-cn.org/office/rust/book/smart-pointers/ch15-06-reference-cycles.html</a></p>
<h1 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h1><h2 id="线程模型"><a href="#线程模型" class="headerlink" title="线程模型"></a>线程模型</h2><p>rust标准库提供1:1线程，有其他第三方库提供M:N的。<br>创建线程: <code>thread::spawn</code>+闭包：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"><span class="keyword">use</span> std::time::Duration;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> handle = thread::spawn(|| &#123;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span>..<span class="number">10</span> &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">"hi number &#123;&#125; from the spawned thread!"</span>, i);</span><br><span class="line">            thread::sleep(Duration::from_millis(<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span>..<span class="number">5</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"hi number &#123;&#125; from the main thread!"</span>, i);</span><br><span class="line">        thread::sleep(Duration::from_millis(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    handle.join().unwrap();<span class="comment">// 阻塞等待子线程</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>子线程中可以捕获主线程的变量，获得所有权. 使用<code>move</code>，以免主线程把它drop了：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> v = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> handle = thread::spawn(<span class="keyword">move</span> || &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"Here's a vector: &#123;:?&#125;"</span>, v);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    handle.join().unwrap();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="消息传递-channel"><a href="#消息传递-channel" class="headerlink" title="消息传递: channel"></a>消息传递: channel</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"><span class="keyword">use</span> std::sync::mpsc;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> (tx, rx) = mpsc::channel();</span><br><span class="line">    <span class="comment">// tx: 发送者</span></span><br><span class="line">    <span class="comment">// rx: 接收者</span></span><br><span class="line">    thread::spawn(<span class="keyword">move</span> || &#123;</span><br><span class="line">        <span class="keyword">let</span> val = <span class="built_in">String</span>::from(<span class="string">"hi"</span>);</span><br><span class="line">        tx.send(val).unwrap();<span class="comment">// 单所有权,发送后不能再使用val</span></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> received = rx.recv().unwrap();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Got: &#123;&#125;"</span>, received);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>mpsc： 多生产者、单消费者<br>recv： 阻塞接收<br>try_recv: 非阻塞接收，立即返回</p>
<p>这里之所以是多生产者，是因为可以把生产者无限克隆出去，然后发送消息：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> tx1 = mpsc::Sender::clone(&amp;tx);</span><br></pre></td></tr></table></figure>

<h2 id="共享状态并发"><a href="#共享状态并发" class="headerlink" title="共享状态并发"></a>共享状态并发</h2><h2 id="互斥器-mutex"><a href="#互斥器-mutex" class="headerlink" title="互斥器(mutex)"></a>互斥器(mutex)</h2><p>rust中的锁是一种特殊的智能指针，通过重载drop trait来确保离开作用域的时候释放锁。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::sync::Mutex;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> m = Mutex::new(<span class="number">5</span>);</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> num = m.lock().unwrap();</span><br><span class="line">        *num = <span class="number">6</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"m = &#123;:?&#125;"</span>, m);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于多个线程都需要访问同一个锁，因此需要多所有权的智能指针，并且能够并发使用：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Rc&lt;T&gt;: 单线程，多所有权；</span><br><span class="line">Arc&lt;T&gt;: 多线程，多所有权。</span><br></pre></td></tr></table></figure>
<p>并发访问的例子:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::sync::&#123;Mutex, Arc&#125;;</span><br><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> counter = Arc::new(Mutex::new(<span class="number">0</span>));<span class="comment">// 智能指针包装</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> handles = <span class="built_in">vec!</span>[];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="number">0</span>..<span class="number">10</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> counter = Arc::clone(&amp;counter);<span class="comment">// 克隆来增加引用计数</span></span><br><span class="line">        <span class="keyword">let</span> handle = thread::spawn(<span class="keyword">move</span> || &#123; </span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut</span> num = counter.lock().unwrap();</span><br><span class="line"></span><br><span class="line">            *num += <span class="number">1</span>; <span class="comment">// move+离开作用域,引用-1</span></span><br><span class="line">        &#125;);</span><br><span class="line">        handles.push(handle);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> handle <span class="keyword">in</span> handles &#123;</span><br><span class="line">        handle.join().unwrap();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Result: &#123;&#125;"</span>, *counter.lock().unwrap());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里可以看出Mutex具有内部可变性。同时可以用Mutex构造死锁(循环依赖)。</p>
<h2 id="Send与Sync的trait"><a href="#Send与Sync的trait" class="headerlink" title="Send与Sync的trait"></a>Send与Sync的trait</h2><p>rust中用两个trait来标记所有权在线程中的转移以及引用的多线程访问: </p>
<blockquote>
<p><code>Send trait</code>:  支持多线程<code>所有权</code>转移,所有权在线程之间转移; 除Rc<T>以外的大部分类型是Send trait;<br><code>Sync trait</code>:  支持多线程访问, 线程之间可以共享值的<code>引用</code>；<br>除Rc<T>以外的大部分类型是Sync trait;</p>
</blockquote>
<p><code>unsafe rust</code>中的裸指针也没有实现这两个trait.</p>
<p>绝大部分情况不需要手动实现send与sync的trait。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://xiaoyue26.github.io/2019/10/06/2019-10/rust%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0-2/" data-id="ck96cxpqb00k9maamb1qe6pmi" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/rust/" rel="tag">rust</a></li></ul>

    </footer>
  </div>
  
</article>
 


  


  <nav id="page-nav">
    <a class="extend prev" rel="prev" href="/page/3/">&amp;laquo; 上一页</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><a class="page-number" href="/page/6/">6</a><span class="space">&hellip;</span><a class="page-number" href="/page/23/">23</a><a class="extend next" rel="next" href="/page/5/">下一页&amp;raquo;</a>
  </nav>
</section>
           
    <aside id="sidebar">
  
    

  
    
  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title recent-posts">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/09/25/2022-09/nc%E5%91%BD%E4%BB%A4%E7%AC%94%E8%AE%B0/">nc命令笔记</a>
          </li>
        
          <li>
            <a href="/2022/09/25/2022-09/%E8%B0%83%E4%BC%98-%E8%A7%A3%E5%86%B3%E7%BA%BF%E7%A8%8B%E6%B1%A0%E9%80%A0%E6%88%90%E7%9A%84%E8%BF%9B%E7%A8%8B%E5%8D%A1%E9%A1%BF%E3%80%81cpu%E6%AF%9B%E5%88%BA%E9%97%AE%E9%A2%98/">调优-解决线程池造成的进程卡顿、cpu毛刺问题</a>
          </li>
        
          <li>
            <a href="/2022/08/30/2022-08/%E8%B0%83%E4%BC%98-cpu%E6%AF%9B%E5%88%BA%E9%97%AE%E9%A2%98/">调优-cpu毛刺问题</a>
          </li>
        
          <li>
            <a href="/2022/05/31/2022-05/w-tinylfu%E7%BC%93%E5%AD%98%E7%AE%97%E6%B3%95/">w-tinylfu缓存算法</a>
          </li>
        
          <li>
            <a href="/2022/03/25/2022-03/G1%E8%B0%83%E4%BC%98-%E5%A4%8D%E6%9D%82%E4%B8%9A%E5%8A%A1%E6%B2%BB%E7%90%86%E5%B0%8F%E8%AE%B0/">G1调优-复杂业务治理小记</a>
          </li>
        
      </ul>
    </div>
  </div>

  
    

  
</aside>

      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-left">
      &copy; 2014 - 2022 风梦七&nbsp;|&nbsp;
      主题 <a href="https://github.com/giscafer/hexo-theme-cafe/" target="_blank">Cafe</a>
    </div>
     <div id="footer-right">
      联系方式&nbsp;|&nbsp;296671657@qq.com
    </div>
  </div>
</footer>
 
<script src="/jquery/jquery.min.js"></script>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">首页</a>
  
    <a href="/archives" class="mobile-nav-link">归档</a>
  
    <a href="/about" class="mobile-nav-link">关于</a>
  
</nav>
    <img class="back-to-top-btn" src="/images/fly-to-top.png"/>
<script>
// Elevator script included on the page, already.
window.onload = function() {
  var elevator = new Elevator({
    selector:'.back-to-top-btn',
    element: document.querySelector('.back-to-top-btn'),
    duration: 1000 // milliseconds
  });
}
</script>
      

  
    <script>
      var cloudTieConfig = {
        url: document.location.href, 
        sourceId: "",
        productKey: "e2fb4051c49842688ce669e634bc983f",
        target: "cloud-tie-wrapper"
      };
    </script>
    <script src="https://img1.ws.126.net/f2e/tie/yun/sdk/loader.js"></script>
    

  







<!-- author:forvoid begin -->
<!-- author:forvoid begin -->

<!-- author:forvoid end -->

<!-- author:forvoid end -->


  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      })
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      })
    </script>
    <script type="text/javascript" src="https://cdn.rawgit.com/mathjax/MathJax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


 
<script src="/js/is.js"></script>



  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>


<script src="/js/elevator.js"></script>

  </div>
</body>
</html>