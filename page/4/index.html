<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>笔记本</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="笔记本">
<meta property="og:url" content="http://xiaoyue26.github.io/page/4/index.html">
<meta property="og:site_name" content="笔记本">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="风梦七">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="笔记本" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    
  
  
<link rel="stylesheet" href="/css/style.css">

  

<meta name="generator" content="Hexo 4.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    
    <div id="header-inner" class="inner">
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://xiaoyue26.github.io"></form>
      </div>
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">首页</a>
        
          <a class="main-nav-link" href="/archives">归档</a>
        
          <a class="main-nav-link" href="/about">关于</a>
        
      </nav>
      
    </div>
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">笔记本</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">风梦七</a>
        </h2>
      
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-2019-09/springboot包结构" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/09/08/2019-09/springboot%E5%8C%85%E7%BB%93%E6%9E%84/" class="article-date">
  <time datetime="2019-09-08T10:32:14.000Z" itemprop="datePublished">2019-09-08</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/java/">java</a>►<a class="article-category-link" href="/categories/java/spring/">spring</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/09/08/2019-09/springboot%E5%8C%85%E7%BB%93%E6%9E%84/">springboot包结构</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <h1 id="使用springboot打包插件"><a href="#使用springboot打包插件" class="headerlink" title="使用springboot打包插件"></a>使用springboot打包插件</h1><p>如果用springboot插件进行打包以后,包结构会发生变化:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mainClass</span>&gt;</span>com.tencent.xxx.Application<span class="tag">&lt;/<span class="name">mainClass</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">goal</span>&gt;</span>repackage<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>springboot打包的jar包用<code>tar -xvf</code>解压以后,大致结构如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">+-META-INF</span><br><span class="line">|  +-MANIFEST.MF</span><br><span class="line">|  +-maven</span><br><span class="line">|     +-pom.xml</span><br><span class="line">|     +-pom.properties</span><br><span class="line">+-org</span><br><span class="line">|  +-springframework</span><br><span class="line">|     +-boot</span><br><span class="line">|        +-loader</span><br><span class="line">|           +-&lt;spring boot loader classes&gt;</span><br><span class="line">+-BOOT-INF</span><br><span class="line">   +-classes</span><br><span class="line">   |  +-com</span><br><span class="line">   |     +-tencent</span><br><span class="line">   |        +-xxx.class</span><br><span class="line">   |  +-其他src&#x2F;main&#x2F;resource路径下的文件</span><br><span class="line">   +-lib</span><br><span class="line">      +-依赖的jar包</span><br></pre></td></tr></table></figure>
<p>可以看出主要分为三部分:<br><code>META-INF</code>文件夹: 元数据信息;<br><code>org</code>文件夹: springboot框架相关的class和依赖;<br><code>BOOT-INF</code>: 我们写的代码、resource以及引入的相关依赖。</p>
<p>其中比较重要的是元数据信息中的<code>MANIFEST.MF</code>:</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">Manifest-Version:</span> <span class="number">1.0</span></span><br><span class="line"><span class="attr">Archiver-Version:</span> <span class="string">Plexus</span> <span class="string">Archiver</span></span><br><span class="line"><span class="attr">Built-By:</span> <span class="string">mengqifeng</span></span><br><span class="line"><span class="attr">Start-Class:</span> <span class="string">com.tencent.xxx.Application</span></span><br><span class="line"><span class="attr">Spring-Boot-Classes:</span> <span class="string">BOOT-INF/classes/</span></span><br><span class="line"><span class="attr">Spring-Boot-Lib:</span> <span class="string">BOOT-INF/lib/</span></span><br><span class="line"><span class="attr">Spring-Boot-Version:</span> <span class="number">2.2</span><span class="number">.0</span><span class="string">.M4</span></span><br><span class="line"><span class="attr">Created-By:</span> <span class="string">Apache</span> <span class="string">Maven</span> <span class="number">3.5</span><span class="number">.3</span></span><br><span class="line"><span class="attr">Build-Jdk:</span> <span class="number">1.8</span><span class="string">.0_161</span></span><br><span class="line"><span class="attr">Main-Class:</span> <span class="string">org.springframework.boot.loader.JarLauncher</span></span><br></pre></td></tr></table></figure>
<p>这里可以看出springboot的入口类是<code>org.springframework.boot.loader.JarLauncher</code>。<br>先启动它这个类(main-class)，然后反射调用我们的类(start-class)。</p>
<p>此外由于这里看出lib文件夹的目录是<code>/BOOT-INF/class/lib</code>,我们可以手动在pom文件中修改resource文件的打包路径,对准这个目录放进去就可以作为库文件依赖了:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src\main\resources\lib<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">targetPath</span>&gt;</span>/BOOT-INF/class/lib<span class="tag">&lt;/<span class="name">targetPath</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.jar<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="默认的maven包结构"><a href="#默认的maven包结构" class="headerlink" title="默认的maven包结构"></a>默认的maven包结构</h1><p>如果把<code>xxx.jar.original</code>解压开的话,能得到springboot<code>repackage</code>以前的包结构。<br>此时只有两部分,元数据信息和我们写的代码(字节码和资源文件),没有依赖库:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+-META-INF</span><br><span class="line">|  +-MANIFEST.MF</span><br><span class="line">|  +-maven</span><br><span class="line">|     +-pom.xml</span><br><span class="line">|     +-pom.properties</span><br><span class="line">+-com(我们写的代码)以及其他src&#x2F;main&#x2F;resource路径下的文件</span><br></pre></td></tr></table></figure>

<p>元数据信息中的<code>MANIFEST.MF</code>内容也少一些:</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">Manifest-Version:</span> <span class="number">1.0</span></span><br><span class="line"><span class="attr">Archiver-Version:</span> <span class="string">Plexus</span> <span class="string">Archiver</span></span><br><span class="line"><span class="attr">Built-By:</span> <span class="string">mengqifeng</span></span><br><span class="line"><span class="attr">Created-By:</span> <span class="string">Apache</span> <span class="string">Maven</span> <span class="number">3.5</span><span class="number">.3</span></span><br><span class="line"><span class="attr">Build-Jdk:</span> <span class="number">1.8</span><span class="string">.0_161</span></span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://xiaoyue26.github.io/2019/09/08/2019-09/springboot%E5%8C%85%E7%BB%93%E6%9E%84/" data-id="ck96cxpq700jwmaaman5t7jxy" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/" rel="tag">java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/maven/" rel="tag">maven</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/spring/" rel="tag">spring</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-2019-09/JNI总结" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/09/07/2019-09/JNI%E6%80%BB%E7%BB%93/" class="article-date">
  <time datetime="2019-09-07T10:20:10.000Z" itemprop="datePublished">2019-09-07</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/java/">java</a>►<a class="article-category-link" href="/categories/java/%E6%80%A7%E8%83%BD/">性能</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/09/07/2019-09/JNI%E6%80%BB%E7%BB%93/">JNI总结</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <h1 id="what-JNI是啥"><a href="#what-JNI是啥" class="headerlink" title="what: JNI是啥"></a>what: JNI是啥</h1><p><code>JNI(Java Native Interface)</code>是java访问<code>native</code>方法的接口规范。<br>所谓<code>native</code>方法一般是c/c++代码。（也可以是汇编）<br>java实现了一个JNI框架来让java和其他语言互调，java方法可以调JNI接口声明了的native方法，native方法也可以创建、使用java对象。<br>JNI接口规范主要按照<code>c</code>语言，不像<code>c++</code>一样改写方法名。<br>因此实际编码中需要用<code>extern c</code>来维持方法名的纯净。</p>
<p>编译方法:<br>c++: <code>print(int)</code>=&gt;<code>print_int</code>;<br>c: <code>print</code>.<br>所以我们需要c这种风格的。(不支持重载)</p>
<h1 id="why-为啥要使用JNI"><a href="#why-为啥要使用JNI" class="headerlink" title="why: 为啥要使用JNI"></a>why: 为啥要使用JNI</h1><p>使用的场景包括:</p>
<ol>
<li>有些现成的代码是c/c++的，需要在java中调用; （比如一些平台相关的、SIMD操作、或其他java中没有的库）</li>
<li>c/c++版本的代码也许有巨大的性能优势。</li>
</ol>
<h1 id="HOW-JNI如何工作"><a href="#HOW-JNI如何工作" class="headerlink" title="HOW: JNI如何工作"></a>HOW: JNI如何工作</h1><h2 id="如何使用JNI"><a href="#如何使用JNI" class="headerlink" title="如何使用JNI"></a>如何使用JNI</h2><p>两种方法： 静态注册和动态加载。</p>
<h3 id="静态注册"><a href="#静态注册" class="headerlink" title="静态注册"></a>静态注册</h3><p>假设我们要在java中调用c的方法,大致分为6个步骤:</p>
<ol>
<li>在java中声明一个<code>native</code>方法,但是不实现;</li>
<li>编译java字节码,生成<code>class</code>文件;(<code>javac</code>命令)</li>
<li>用class文件生成<code>.h</code>的文件头;(<code>javah</code>命令)</li>
<li>创建<code>.c</code>文件实现<code>.h</code>文件头中声明的方法;</li>
<li>编译<code>.c</code>，<code>.h</code>文件生成动态链接库<code>.so</code>;</li>
<li>在<code>java</code>中加载<code>.so</code>文件,使用第一步中声明的方法。</li>
</ol>
<p>相关命令:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:.</span><br><span class="line">javac HelloWorld.java</span><br><span class="line">javah HelloWorld</span><br><span class="line">gcc -fPIC -I /usr/lib/jvm/jdk/include -I /usr/lib/jvm/jdk/include/linux -shared libHelloWorld.c -o libHelloWorld.so</span><br><span class="line">export LD_LIBRARY_PATH=.:$LD_LIBRARY_PATH # 为了找到so文件</span><br><span class="line">java -Djava.library.path=. HelloWorld  # 也是为了找到so文件(二选一即可)</span><br></pre></td></tr></table></figure>

<h3 id="动态加载"><a href="#动态加载" class="headerlink" title="动态加载"></a>动态加载</h3><p>利用<code>RegisterNatives</code>方法来注册Java方法与JNI函数的映射。</p>
<ol>
<li>利用结构体<code>JNINativeMethod</code>数组记录 Java 方法与 JNI 函数的对应关系</li>
<li>实现 <code>JNI_OnLoad</code> 方法，在加载动态库后，执行动态注册</li>
<li>调用 <code>FindClass</code> 方法，获取Java对象</li>
<li>调用 <code>RegisterNatives</code>方法，传入 Java 对象、<code>JNINativeMethod</code>;</li>
<li>数组及注册方法数完成注册；</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下是c++版本的,c语言版本的话很简单,只要把:</span></span><br><span class="line"><span class="comment">// env-&gt;改成(*env)-&gt;</span></span><br><span class="line"><span class="comment">// 调用的方法参数第一个参数加上env即可。</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> JNI_CLASS_PAPT <span class="meta-string">"com/xxx"</span></span></span><br><span class="line"><span class="function">JNIEXPORT jstring JNICALL <span class="title">native_test</span><span class="params">(JNIEnv *env, jobject instance)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> env-&gt;NewStringUTF(<span class="string">"hello world"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> JNINativeMethod g_methods[] = &#123;</span><br><span class="line">        <span class="comment">// Java层方法、参数类型、native方法</span></span><br><span class="line">        &#123;<span class="string">"get_hello_world"</span>, <span class="string">"()Ljava/lang/String;"</span>, (<span class="keyword">void</span>*)native_test&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 动态库加载时回调方法</span></span><br><span class="line"><span class="function">jint <span class="title">JNI_OnLoad</span><span class="params">(JavaVM *vm, <span class="keyword">void</span> *reserved)</span> </span>&#123;</span><br><span class="line">    JNIEnv *env = <span class="literal">NULL</span>;</span><br><span class="line">    vm-&gt;GetEnv((<span class="keyword">void</span>**)&amp;env, JNI_VERSION_1_8);</span><br><span class="line">    jclass clazz= env-&gt;FindClass(JNI_CLASS_PAPT);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 注册Java和natvie方法映射表</span></span><br><span class="line">    env-&gt;RegisterNatives(clazz</span><br><span class="line">    , g_methods</span><br><span class="line">    , <span class="keyword">sizeof</span>(g_methods)/<span class="keyword">sizeof</span>(g_methods[<span class="number">0</span>]));</span><br><span class="line">    <span class="keyword">return</span> JNI_VERSION_1_8;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参见<code>jni.h</code>中的<code>JNINativeMethod</code>结构体:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* name; <span class="comment">// java方法名</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* signature;<span class="comment">// java方法签名</span></span><br><span class="line">    <span class="keyword">void</span>*       fnPtr; <span class="comment">// c函数指针</span></span><br><span class="line">&#125; JNINativeMethod;</span><br></pre></td></tr></table></figure>


<h2 id="JNI原理"><a href="#JNI原理" class="headerlink" title="JNI原理"></a>JNI原理</h2><p>本质其实就是JVM使用了so动态链接库中的函数，所以关键在于函数名的映射。<br>一个典型的<code>native</code>方法的签名如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// native方法的签名由类名(含包名,点换成下划线)和方法名拼接而成:</span></span><br><span class="line">JNIEXPORT <span class="keyword">void</span> JNICALL Java_packname_classname_methodname</span><br><span class="line">  (JNIEnv *env, jobject obj)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*Implement Native Method Here*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可见，JVM调用native方法的时候，需要传递一个<code>JNIEnv</code>指针和一个<code>jobject</code>指针。</p>
<blockquote>
<p>JNIEnv: 包含访问JVM的接口，可以进行native数组和java数组转换，字符串转换，对象实例化、抛异常等等java能做的事情；</p>
</blockquote>
<blockquote>
<p>jobject: 声明native方法的java对象。</p>
</blockquote>
<p>每一个Java线程对应一个<code>JNIEnv</code>。<br><code>JNIEnv</code>指针仅在native方法当前线程中有效；如果手动保存到其他地方，然后在其他线程中想要使用，需要调用<code>AttachCurrentThread</code>来挂靠当前线程到jvm，使用完毕后调用<code>DetachCurrentThread</code>脱离jvm。<br>挂靠样例:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. </span></span><br><span class="line">JNIEnv *env;</span><br><span class="line">(*g_vm)-&gt;AttachCurrentThread (g_vm, (<span class="keyword">void</span> **) &amp;env, <span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">// 2. 脱离:</span></span><br><span class="line">(*g_vm)-&gt;DetachCurrentThread (g_vm);</span><br></pre></td></tr></table></figure>



<h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p>native和java的基本类型能自动互转，复杂类型（数组、数组、对象）则要使用<code>JNIEnv</code>显式地进行转换。</p>
<p>字符串转换(C++版本):</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span></span><br><span class="line">JNIEXPORT <span class="keyword">void</span> JNICALL Java_ClassName_MethodName</span><br><span class="line">  (JNIEnv *env, jobject obj, jstring javaString)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// java字符串=&gt;c字符串</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *nativeString = env-&gt;GetStringUTFChars(javaString, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// do something with nativeString</span></span><br><span class="line">    <span class="comment">// 释放:</span></span><br><span class="line">    env-&gt;ReleaseStringUTFChars(javaString, nativeString);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>c语言版本就是参数多了<code>env</code>参数:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">JNIEXPORT <span class="keyword">void</span> JNICALL Java_ClassName_MethodName</span><br><span class="line">  (JNIEnv *env, jobject obj, jstring javaString)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 转换:</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *nativeString = (*env)-&gt;GetStringUTFChars(env, javaString, <span class="number">0</span>);</span><br><span class="line"><span class="comment">// 释放:</span></span><br><span class="line">    (*env)-&gt;ReleaseStringUTFChars(env, javaString, nativeString);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="基本类型的映射"><a href="#基本类型的映射" class="headerlink" title="基本类型的映射"></a>基本类型的映射</h2><table>
<thead>
<tr>
<th>native类型</th>
<th>Java类型</th>
<th>描述</th>
<th>java类型签名（signature）</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>unsigned char</td>
<td>jboolean</td>
<td>unsigned 8位</td>
<td>Z</td>
<td></td>
</tr>
<tr>
<td>signed char</td>
<td>jbyte</td>
<td>signed 8位</td>
<td>B</td>
<td></td>
</tr>
<tr>
<td>unsigned short</td>
<td>jchar</td>
<td>unsigned 16位</td>
<td>C</td>
<td></td>
</tr>
<tr>
<td>short</td>
<td>jshort</td>
<td>signed 16位</td>
<td>S</td>
<td></td>
</tr>
<tr>
<td>long</td>
<td>jint</td>
<td>signed 32位</td>
<td>I</td>
<td></td>
</tr>
<tr>
<td>long long__int64</td>
<td>jlong</td>
<td>signed 64位</td>
<td>J</td>
<td></td>
</tr>
<tr>
<td>float</td>
<td>jfloat</td>
<td>32位</td>
<td>F</td>
<td></td>
</tr>
<tr>
<td>double</td>
<td>jdouble</td>
<td>64位</td>
<td>D</td>
<td></td>
</tr>
<tr>
<td>void</td>
<td>void</td>
<td></td>
<td>V</td>
<td></td>
</tr>
</tbody></table>
<p>string类的类型签名: <code>Ljava/lang/String;</code><br>整型数组的类型签名: <code>[I</code><br><code>int[][]</code>的签名: <code>[[I</code></p>
<h1 id="JNI代码中调用java对象方法"><a href="#JNI代码中调用java对象方法" class="headerlink" title="JNI代码中调用java对象方法"></a>JNI代码中调用java对象方法</h1><h2 id="1-调用实例方法"><a href="#1-调用实例方法" class="headerlink" title="1. 调用实例方法"></a>1. 调用实例方法</h2><p>首先我们有env和obj，步骤是：</p>
<blockquote>
<ol>
<li>用env、obj获取class对象cls;</li>
<li>用env、cls和方法签名反射获得方法引用mid;</li>
<li>用env、obj、mid调用方法。</li>
</ol>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">JNIEXPORT <span class="keyword">void</span> JNICALL  <span class="title">Java_InstanceMethodCall_nativeMethod</span><span class="params">(JNIEnv *env, jobject obj)</span> </span>&#123; </span><br><span class="line">     jclass cls = (*env)-&gt;GetObjectClass(env, obj);  </span><br><span class="line">     jmethodID mid =  (*env)-&gt;GetMethodID(env, cls, <span class="string">"callback"</span>, <span class="string">"()V"</span>);  </span><br><span class="line">     <span class="keyword">if</span> (mid == <span class="literal">NULL</span>) &#123; </span><br><span class="line">         <span class="keyword">return</span>; <span class="comment">/* method not found */</span> </span><br><span class="line">     &#125; </span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">"In C\n"</span>); </span><br><span class="line">     (*env)-&gt;CallVoidMethod(env, obj, mid);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-调用静态方法"><a href="#2-调用静态方法" class="headerlink" title="2. 调用静态方法"></a>2. 调用静态方法</h2><p>前两步和刚才一样,第三部把Obj换成cls即可:</p>
<ol>
<li>获取cls;</li>
<li>获取mid;</li>
<li>用env、cls、mid调用静态方法。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">JNIEXPORT <span class="keyword">void</span> JNICALL  <span class="title">Java_StaticMethodCall_nativeMethod</span><span class="params">(JNIEnv *env, jobject obj)</span> </span>&#123; </span><br><span class="line">     jclass cls = (*env)-&gt;GetObjectClass(env, obj); </span><br><span class="line">     jmethodID mid =  </span><br><span class="line">         (*env)-&gt;GetStaticMethodID(env, cls, <span class="string">"callback"</span>, <span class="string">"()V"</span>); </span><br><span class="line">     <span class="keyword">if</span> (mid == <span class="literal">NULL</span>) &#123; </span><br><span class="line">         <span class="keyword">return</span>;  <span class="comment">/* method not found */</span> </span><br><span class="line">     &#125; </span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">"In C\n"</span>); </span><br><span class="line">     (*env)-&gt;CallStaticVoidMethod(env, cls, mid);  <span class="comment">// 这里是cls</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="JNI需要注意的点"><a href="#JNI需要注意的点" class="headerlink" title="JNI需要注意的点"></a>JNI需要注意的点</h1><ol>
<li>native方法自己管理内存,jvm不gc这部分;</li>
<li>JNI调用开销较大，不宜频繁调用;（java数组、字符串都会线性拷贝）</li>
<li>JNI方法平台有关,移植性差;</li>
<li>c代码里显式释放内存;</li>
<li>字符编码问题。</li>
</ol>
<p>第四点一般是获取和释放成对使用：(多少get就有多少delete或release)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GetObjectField&#x3D;&gt;DeleteLocalRef</span><br><span class="line">GetStringUTFChars&#x3D;&gt;ReleaseStringUTFChars</span><br></pre></td></tr></table></figure>

<p>最后一个字符编码问题:<br>JNI里的这几个函数实际上用的是修改版本的<code>UTF-8</code>，并不完全等效于<code>UTF-8</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">NewStringUTF</span><br><span class="line">GetStringUTFLength</span><br><span class="line">GetStringUTFChars</span><br><span class="line">ReleaseStringUTFChars</span><br><span class="line">GetStringUTFRegion</span><br></pre></td></tr></table></figure>
<p>用户应当使用这几个函数,先创建UTF-16，然后安全地转换成标准<code>UTF-8</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">NewString</span><br><span class="line">GetStringLength</span><br><span class="line">GetStringChars</span><br><span class="line">ReleaseStringChars</span><br><span class="line">GetStringRegion</span><br><span class="line">GetStringCritical</span><br><span class="line">ReleaseStringCritical</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://xiaoyue26.github.io/2019/09/07/2019-09/JNI%E6%80%BB%E7%BB%93/" data-id="ck96cxpq400jlmaam08ly4o8b" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JNI/" rel="tag">JNI</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/" rel="tag">java</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-2019-09/静态链接库和动态链接库" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/09/04/2019-09/%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93%E5%92%8C%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93/" class="article-date">
  <time datetime="2019-09-04T02:24:06.000Z" itemprop="datePublished">2019-09-04</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/java/">java</a>►<a class="article-category-link" href="/categories/java/%E6%80%A7%E8%83%BD/">性能</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/09/04/2019-09/%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93%E5%92%8C%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93/">静态链接库和动态链接库</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <h2 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h2><p><code>JNI</code>的时候发现要使用<code>so</code>文件、动态链接库，那么究竟什么是动态链接库呢？</p>
<p>参考:<br><a href="https://www.zhihu.com/question/20484931" target="_blank" rel="noopener">https://www.zhihu.com/question/20484931</a></p>
<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>库有两种：静态库和动态库。<br>静态库: <code>.a</code>,<code>.lib</code>;<br>动态库：<code>.so</code>,<code>.dll</code>;<br><code>windows</code>:<code>.lib</code>,<code>.dll</code>;<br><code>linux</code>:<code>.a</code>,<code>.so</code>;</p>
<p>非库:<br>生成<code>.o</code>文件: <code>g++ -c hellospeak.cpp</code>;<br>// 只产生编译的代码(没有链接link)<br>生成<code>.out</code>文件: <code>g++ hellospeak.cpp speak.cpp -o hellospeak</code>;<br>// 执行完整的编译过程，并且生成一个a.out文件。</p>
<h1 id="链接过程"><a href="#链接过程" class="headerlink" title="链接过程"></a>链接过程</h1><p>源文件(<code>.h</code>,<code>.cpp</code>)<br>=&gt;预编译=&gt;编译=&gt;汇编<br>=&gt;<strong>链接</strong><br>=&gt;可执行文件</p>
<p>这里我们主要关心<strong>链接</strong>阶段。</p>
<h2 id="静态库"><a href="#静态库" class="headerlink" title="静态库"></a>静态库</h2><p>链接阶段:<br>汇编生成的<code>.o</code>+引用的库=&gt; 可执行文件;</p>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ol>
<li>静态库在内存中可能造成空间浪费。<br>如100个进程都使用了静态库A，则内存中有100份占用。</li>
<li>更新库不灵活。</li>
</ol>
<h2 id="动态库-又称共享库"><a href="#动态库-又称共享库" class="headerlink" title="动态库(又称共享库)"></a>动态库(又称共享库)</h2><p>链接阶段：<br>不加入引用的库。推迟到运行时。<br>运行时：<br>动态加载<code>.so</code>,<code>.dll</code>文件。</p>
<h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h3><p>多了运行时计算符号链接的开销，但是这个开销不大。</p>
<p>所以jni只能使用动态链接库。(linux的话就是<code>so</code>文件)</p>
<h2 id="gcc相关参数"><a href="#gcc相关参数" class="headerlink" title="gcc相关参数"></a>gcc相关参数</h2><p><a href="https://colobu.com/2018/08/28/15-Most-Frequently-Used-GCC-Compiler-Command-Line-Options/" target="_blank" rel="noopener">https://colobu.com/2018/08/28/15-Most-Frequently-Used-GCC-Compiler-Command-Line-Options/</a></p>
<p><code>-fPIC</code>: 产生位置无关的代码；<br><code>-shared</code>: 产生共享库;(动态库)<br>例子:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc -c -Wall -Werror -fPIC Cfile.c</span><br><span class="line">gcc -shared -o libCfile.so Cfile.o</span><br></pre></td></tr></table></figure>

<p><code>-static</code>: 生成静态链接的文件<br>例子:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc main.c -static -o main -lpthread</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://xiaoyue26.github.io/2019/09/04/2019-09/%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93%E5%92%8C%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93/" data-id="ck96cxpq900k4maamdzml6iii" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JNI/" rel="tag">JNI</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/" rel="tag">java</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-2019-09/CriticalNative-降低JNI开销" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/09/01/2019-09/CriticalNative-%E9%99%8D%E4%BD%8EJNI%E5%BC%80%E9%94%80/" class="article-date">
  <time datetime="2019-09-01T08:41:03.000Z" itemprop="datePublished">2019-09-01</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/java/">java</a>►<a class="article-category-link" href="/categories/java/%E6%80%A7%E8%83%BD/">性能</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/09/01/2019-09/CriticalNative-%E9%99%8D%E4%BD%8EJNI%E5%BC%80%E9%94%80/">CriticalNative:降低JNI开销</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <h1 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h1><p><code>Android</code>中有<code>@CriticalNative</code>注解:<br><a href="https://source.android.google.cn/devices/tech/dalvik/improvements" target="_blank" rel="noopener">https://source.android.google.cn/devices/tech/dalvik/improvements</a><br>里面说到:</p>
<blockquote>
<p>@FastNative 可以使原生方法的性能提升高达 2 倍，@CriticalNative 则可以提升高达4倍。 </p>
</blockquote>
<p>那么这是怎么做到的呢？</p>
<h1 id="native方法"><a href="#native方法" class="headerlink" title="native方法"></a>native方法</h1><p>调用native方法时,JVM的工作步骤:<br>(源码: <a href="http://hg.openjdk.java.net/jdk8u/jdk8u/hotspot/file/4d9931ebf861/src/cpu/x86/vm/sharedRuntime_x86_64.cpp#l1723" target="_blank" rel="noopener">http://hg.openjdk.java.net/jdk8u/jdk8u/hotspot/file/4d9931ebf861/src/cpu/x86/vm/sharedRuntime_x86_64.cpp#l1723</a>)</p>
<blockquote>
<ol>
<li>创建栈帧;</li>
<li>根据ABI移动参数到寄存器或者栈;(ABI: 应用二进制接口)</li>
<li>封装对象引用到JNI handlers;</li>
<li>获取静态方法的<code>JNIEnv*</code>和<code>jclass</code>,把他们作为额外参数传递;</li>
<li>检查是否调用<code>method_entry</code>的trace函数; </li>
<li>检查是否调用对象锁;（<code>synchronized</code>）(optinal)</li>
<li>检查native方法是否已经链接;(懒加载函数检查、链接)</li>
<li>线程状态从<code>in_java</code>转变为<code>in_native</code>;</li>
<li>调用native方法;</li>
<li>检查是否需要safepoint;</li>
<li>线程状态转回<code>in_java</code>;</li>
<li>解锁对象锁;(optional)</li>
<li>notify <code>method_exit</code>;(optional)</li>
<li>将对象结果解出，重置JNI handlers;</li>
<li>处理JNI异常;</li>
<li>移除栈帧。</li>
</ol>
</blockquote>
<p>开销比较大,主要是用于各种参数拷贝,尤其是遇到数组，需要来回拷贝、检查。</p>
<p>此时，如果是足够简单的native方法,可以用<code>Critical Natives</code>来降低开销。</p>
<h1 id="Critical-Native方法"><a href="#Critical-Native方法" class="headerlink" title="Critical Native方法"></a>Critical Native方法</h1><p><code>Critical Natives</code>方法是需要满足下列约束的<code>native</code>方法:</p>
<blockquote>
<ol>
<li>必须是static且没有synchronized; (省掉上一节的6、12步)</li>
<li>参数类型必须是基本类型或基本类型的数组;(省掉上一节中的对象相关3、14)</li>
<li>具体实现不能调用JNI函数(也就是不使用<code>JNIEnv* env</code>和<code>jclass cls</code>,既然不使用就不用传给它了),不能分配java对象或者抛出异常;(省掉上一节中的4、15)</li>
<li>不能运行太长时间.(因为它会阻塞gc)</li>
</ol>
</blockquote>
<p>基于这个原理的话, <code>critical native</code>方法比普通<code>native</code>方法快的原因其实是节省了一些调用开始和结束的开销，因此如果被调用的方法如果是时间占用的大头的话，其实这个优化幅度就很小了。<br>反之如果是频繁调用的方法，而且每次调用的数据量很小，此时调用开销和执行开销是同量级，那么累计的优化幅度就会很大。<br>（比如只是长度为16的数组计算的话，计算力提升可以达到2～3倍。）</p>
<p>满足上述约束以后,<code>Critical Natives</code>方法还需要进行下列声明:</p>
<blockquote>
<ol>
<li>方法名以<code>JavaCritical_</code>开头;</li>
<li>没有额外的<code>JNIEnv*</code>和<code>jclass</code>参数;(因为是static方法,自然也就没有jobject参数了)</li>
<li>java数组传递的时候用两个参数: 数组长度、数组引用(基本类型)。<br>// 这样不再需要调用<code>GetArrayLength</code>、<code>GetByteArrayElements</code>等函数。</li>
</ol>
</blockquote>
<p>此外critical natives方法变成临界区。<br><code>native</code>方法示例:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">JNIEXPORT jint JNICALL</span><br><span class="line">Java_com_package_MyClass_nativeMethod(JNIEnv* env, jclass klass, jbyteArray <span class="built_in">array</span>) &#123;</span><br><span class="line">    jboolean isCopy;</span><br><span class="line">    jint length = (*env)-&gt;GetArrayLength(env, <span class="built_in">array</span>);</span><br><span class="line">    jbyte* buf = (*env)-&gt;GetByteArrayElements(env, <span class="built_in">array</span>, &amp;isCopy);</span><br><span class="line">    jint result = <span class="built_in">process</span>(buf, length);</span><br><span class="line">    (*env)-&gt;ReleaseByteArrayElements(env, <span class="built_in">array</span>, buf, JNI_ABORT);</span><br><span class="line">    <span class="keyword">return</span> result;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Critical Natives</code>方法示例:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">JNIEXPORT jint JNICALL</span><br><span class="line">JavaCritical_com_package_MyClass_nativeMethod(jint length, jbyte* buf) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">process</span>(buf, length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>critical</code>版本的方法是JIT需要的(默认是调用超过1500次,可以调JIT参数<code>-XX:CompileThreshold=invocations</code>);<br>普通<code>native</code>版本的方法是解释器需要的;</p>
<p>因此实际用的时候，这俩版本的代码都要写上。比如是这样的:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;jni.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(jbyte* <span class="built_in">array</span>, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">        result += <span class="built_in">array</span>[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Class:     com_tencent_xxx_test_Natives</span></span><br><span class="line"><span class="comment"> * Method:    javaCriticalImpl</span></span><br><span class="line"><span class="comment"> * Signature: ([B)I</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">JNIEXPORT jint JNICALL Java_com_tencent_xxx_test_Natives_javaCriticalImpl</span><br><span class="line">  (JNIEnv* env, jclass cls, jbyteArray <span class="built_in">array</span>)&#123;</span><br><span class="line">  jboolean isCopy;</span><br><span class="line">  jint length = (*env)-&gt;GetArrayLength(env, <span class="built_in">array</span>);</span><br><span class="line">  jbyte* buf = (jbyte*) (*env)-&gt;GetPrimitiveArrayCritical(env, <span class="built_in">array</span>, &amp;isCopy);</span><br><span class="line">  jint result = sum(buf, length);</span><br><span class="line">  (*env)-&gt;ReleasePrimitiveArrayCritical(env, <span class="built_in">array</span>, buf, JNI_ABORT);</span><br><span class="line">  <span class="comment">// 有副作用的c函数用0; 无副作用的c函数直接用JNI_ABORT.</span></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">JNIEXPORT jint JNICALL</span><br><span class="line">JavaCritical_com_tencent_xxx_test_Natives_javaCriticalImpl(jint length, jbyte* buf) &#123;</span><br><span class="line">    <span class="keyword">return</span> sum(buf, length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>(之所以这么繁琐的原因是这个特性和Unsafe一样是jdk内部使用的,没有公开发布给普通程序员,正式发布估计要到jdk10了)</p>
<p>参考:<br><a href="http://cr.openjdk.java.net/~jrose/panama/native-call-primitive.html" target="_blank" rel="noopener">http://cr.openjdk.java.net/~jrose/panama/native-call-primitive.html</a><br><a href="http://mail.openjdk.java.net/pipermail/panama-dev/2015-December/000225.html" target="_blank" rel="noopener">http://mail.openjdk.java.net/pipermail/panama-dev/2015-December/000225.html</a><br><a href="https://stackoverflow.com/questions/36298111/is-it-possible-to-use-sun-misc-unsafe-to-call-c-functions-without-jni/36309652#36309652" target="_blank" rel="noopener">https://stackoverflow.com/questions/36298111/is-it-possible-to-use-sun-misc-unsafe-to-call-c-functions-without-jni/36309652#36309652</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://xiaoyue26.github.io/2019/09/01/2019-09/CriticalNative-%E9%99%8D%E4%BD%8EJNI%E5%BC%80%E9%94%80/" data-id="ck96cxpq200jgmaam80lnhwyz" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JNI/" rel="tag">JNI</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/" rel="tag">java</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-2019-09/程序计算加速之SIMD相关概念" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/09/01/2019-09/%E7%A8%8B%E5%BA%8F%E8%AE%A1%E7%AE%97%E5%8A%A0%E9%80%9F%E4%B9%8BSIMD%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/" class="article-date">
  <time datetime="2019-09-01T08:27:04.000Z" itemprop="datePublished">2019-09-01</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/java/">java</a>►<a class="article-category-link" href="/categories/java/%E6%80%A7%E8%83%BD/">性能</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/09/01/2019-09/%E7%A8%8B%E5%BA%8F%E8%AE%A1%E7%AE%97%E5%8A%A0%E9%80%9F%E4%B9%8BSIMD%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/">程序计算加速之SIMD相关概念</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <h1 id="What-什么是SIMD"><a href="#What-什么是SIMD" class="headerlink" title="What: 什么是SIMD"></a>What: 什么是SIMD</h1><p>SIMD全称<code>Single Instruction Multiple Data</code>，单指令多数据流，是一种采用一个控制器来控制多个处理器，同时对一组数据（又称“数据向量”）中的每一个分别执行相同的操作从而实现空间上的并行性的技术。</p>
<p>也就是说SIMD需要CPU指令集的支持，才能用一条指令就同时并行计算多个数据。当然了，这里同时计算时运用的是同一种运算，比如都是加法。</p>
<h1 id="WHY-为什么要使用SIMD"><a href="#WHY-为什么要使用SIMD" class="headerlink" title="WHY: 为什么要使用SIMD"></a>WHY: 为什么要使用SIMD</h1><p>能并行计算肯定是要比串行计算快的。<br>SIMD是cpu层面的加速，当然还有gpu层面的加速比如cuda编程。<br>如果需要大量浮点数计算、矩阵计算，比如游戏场景、机器学习场景下都是需要这些加速技术的。</p>
<h1 id="不同版本和历史"><a href="#不同版本和历史" class="headerlink" title="不同版本和历史"></a>不同版本和历史</h1><p>既然说到cpu，肯定绕不开intel和AMD。<br>最早是intel推出的，利用了多余的寄存器来加速多媒体运算，后来逐渐标准化：</p>
<h2 id="缩写"><a href="#缩写" class="headerlink" title="缩写:"></a>缩写:</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MMX(可能是MultiMedia eXtension的缩写)</span><br><span class="line">SSE(Streaming SIMD Extensions)</span><br><span class="line">AVX(Advanced Vcetor Extension) : 对SSE的后续扩展，主要分为AVX、AVX2、AVX512三种。在目前常见的机器上，大多只支持到AVX系列。</span><br></pre></td></tr></table></figure>
<h2 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">MMX: intel, Pentium;</span><br><span class="line">SSE: intel, Pentium 3;</span><br><span class="line">SSE2: intel, Pentium 4;</span><br><span class="line">SSE3: intel, Pentium 4;</span><br><span class="line">SSE4: intel, Core 2 Duo; 128位。</span><br><span class="line">SSE5: AMD;</span><br><span class="line">AVX:  intel, 因为SSE5被AMD抢先出了,intel恼羞成怒改名叫AVX了; 支持256位。</span><br><span class="line">AVX2: intel, 加入了整形支持。支持256位。</span><br><span class="line">AVX512: intel, 支持521位。</span><br></pre></td></tr></table></figure>

<h1 id="HOW：-如何使用SIMD"><a href="#HOW：-如何使用SIMD" class="headerlink" title="HOW： 如何使用SIMD"></a>HOW： 如何使用SIMD</h1><h2 id="JAVA中使用"><a href="#JAVA中使用" class="headerlink" title="JAVA中使用"></a>JAVA中使用</h2><p>jdk8的话，可以<code>jinfo -flag &lt;pid&gt;</code>一下，这三个其实是默认配置(java8):</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-XX:UseAVX&#x3D;2</span><br><span class="line">-XX:UseSSE&#x3D;5</span><br><span class="line">-XX:+UseSSE42Intrinsics</span><br></pre></td></tr></table></figure>

<p>可以受益的操作：<br>加减乘除、乘累加。<br>所以jvm是默认会对一些代码进行SIMD优化，具体方法是自己构造数组，比如本来只是要统计一个数组的总和，用一个局部变量即可，可以改成用一个长度为8的局部数组（或者16、具体长度需要benchmark才知道最优，要符合cpu的SIMD支持长度），然后在8个位置上分别求和，最后把局部数组求和得到答案，这种代码会比直接求和快1倍。</p>
<p>上述trick自然是非常间接地使用了，直接使用SIMD的库还在开发中：<br><a href="https://openjdk.java.net/jeps/338" target="_blank" rel="noopener">https://openjdk.java.net/jeps/338</a><br>估计要等到java10以后才能用上了。<br>也有一些国外的scala库(LMS)： <a href="https://astojanov.github.io/blog/2017/12/20/scala-simd.html?tdsourcetag=s_pcqq_aiomsg" target="_blank" rel="noopener">https://astojanov.github.io/blog/2017/12/20/scala-simd.html?tdsourcetag=s_pcqq_aiomsg</a><br>但不知道靠谱不靠谱。</p>
<p>直接使用的库在C语言中是有的，叫做<code>SIMD Intrinsics</code>：<br><a href="https://software.intel.com/sites/landingpage/IntrinsicsGuide/#techs=MMX,SSE,SSE2,SSE3,SSSE3,SSE4_1,SSE4_2,AVX,AVX2,FMA,AVX_512" target="_blank" rel="noopener">https://software.intel.com/sites/landingpage/IntrinsicsGuide/#techs=MMX,SSE,SSE2,SSE3,SSSE3,SSE4_1,SSE4_2,AVX,AVX2,FMA,AVX_512</a><br>比如<code>_mm_set_ps1</code>函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">???-ss后缀的操作: 4个操作数中有一个参加运算；</span><br><span class="line">???-ps后缀的操作：4个操作数都参加运算。</span><br></pre></td></tr></table></figure>
<p>因此我们可以用JNI调用来使用SIMD。<br>为了一定程度上减少JNI开销的话，可以使用<code>CriticalNative</code>。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://www.cnblogs.com/lgxZJ/p/8688430.html" target="_blank" rel="noopener">https://www.cnblogs.com/lgxZJ/p/8688430.html</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://xiaoyue26.github.io/2019/09/01/2019-09/%E7%A8%8B%E5%BA%8F%E8%AE%A1%E7%AE%97%E5%8A%A0%E9%80%9F%E4%B9%8BSIMD%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/" data-id="ck96cxpq900k1maam7l1r7igy" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/SIMD/" rel="tag">SIMD</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/" rel="tag">java</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-2019-08/clickhouse实战之jdbc接入" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/08/25/2019-08/clickhouse%E5%AE%9E%E6%88%98%E4%B9%8Bjdbc%E6%8E%A5%E5%85%A5/" class="article-date">
  <time datetime="2019-08-25T10:29:55.000Z" itemprop="datePublished">2019-08-25</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/clickhouse/">clickhouse</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/08/25/2019-08/clickhouse%E5%AE%9E%E6%88%98%E4%B9%8Bjdbc%E6%8E%A5%E5%85%A5/">clickhouse实战之jdbc接入</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><p>安装好clickhouse后有几个关键的配置需要调整。<br><code>clickhouse</code>的配置文件主要有两个:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/clickhouse-server/config.xml # 服务器配置 </span><br><span class="line">vi /etc/clickhouse-server/users.xml #  客户端连接的默认配置</span><br></pre></td></tr></table></figure>
<p><code>config.xml</code>里需要调整的主要是数据文件的目录、http端口、监听地址:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">http_port</span>&gt;</span>8080<span class="tag">&lt;/<span class="name">http_port</span>&gt;</span> <span class="comment">&lt;!-- 默认是8123--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">listen_host</span>&gt;</span>0.0.0.0<span class="tag">&lt;/<span class="name">listen_host</span>&gt;</span> <span class="comment">&lt;!-- 默认只监听本地127.0.0.1--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">path</span>&gt;</span>/var/lib/clickhouse/<span class="tag">&lt;/<span class="name">path</span>&gt;</span> <span class="comment">&lt;!-- 需要chown -R clickhouse:clickhouse这个目录 如果后续要修改，也可以停服后通过软链接移动到别的目录--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">uncompressed_cache_size</span>&gt;</span>8589934592<span class="tag">&lt;/<span class="name">uncompressed_cache_size</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mark_cache_size</span>&gt;</span>5368709120<span class="tag">&lt;/<span class="name">mark_cache_size</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>此外也能通过配置文件发现默认的tcp端口是9000,interserver_http_port是9009。</p>
<p><code>users.xml</code>里需要调整的主要是:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">max_memory_usage</span>&gt;</span>20000000000<span class="tag">&lt;/<span class="name">max_memory_usage</span>&gt;</span><span class="comment">&lt;!-- 单个查询的最大内存使用bytes--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">password</span>&gt;</span><span class="tag">&lt;/<span class="name">password</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="启动命令"><a href="#启动命令" class="headerlink" title="启动命令"></a>启动命令</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 服务端:</span></span><br><span class="line">sudo service clickhouse-server start </span><br><span class="line"><span class="meta">#</span><span class="bash"> 客户端(多行模式):</span></span><br><span class="line">clickhouse-client -m </span><br><span class="line"><span class="meta">#</span><span class="bash"> 客户端执行sql文件:</span></span><br><span class="line">clickhouse-client -mn &lt; 1.sql</span><br></pre></td></tr></table></figure>

<h1 id="jdbc"><a href="#jdbc" class="headerlink" title="jdbc"></a>jdbc</h1><p>首先是引入依赖:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/ru.yandex.clickhouse/clickhouse-jdbc --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>ru.yandex.clickhouse<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>clickhouse-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.1.54<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>*<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这里我项目里其他地方用fasterxml，有版本冲突，因此这里exclude掉了。</p>
<p>然后配置yml:</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring.clickhouse.hikari:</span></span><br><span class="line">  <span class="attr">idle-timeout:</span> <span class="number">1000</span></span><br><span class="line">  <span class="attr">jdbc-url:</span> <span class="string">jdbc:clickhouse://&lt;your_host_or_ip_address&gt;:8080/default</span></span><br><span class="line">  <span class="attr">driverClassName:</span> <span class="string">ru.yandex.clickhouse.ClickHouseDriver</span></span><br><span class="line">  <span class="attr">maximumPoolSize:</span> <span class="number">10</span></span><br><span class="line">  <span class="attr">rewriteBatchedStatements:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>最后像普通jdbc一样使用即可:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 配置：</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"spring.clickhouse.hikari"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClickhouseDSConfig</span> <span class="keyword">extends</span> <span class="title">HikariConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span>(name=<span class="string">"chds"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">dataSource</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HikariDataSource(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 存储层:</span></span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChDao</span> <span class="keyword">extends</span> <span class="title">JdbcDaoSupport</span> <span class="keyword">implements</span> <span class="title">IChDao</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ChDao</span><span class="params">(@Qualifier(<span class="string">"chds"</span>)</span> DataSource ds) </span>&#123;</span><br><span class="line">        setDataSource(ds);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title">query</span><span class="params">(String sql, Object... args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.getJdbcTemplate().queryForMap(sql, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Map&lt;String, Object&gt;&gt; queryForList(String sql, Object... args) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.getJdbcTemplate().queryForList(sql, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 使用: </span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">IChDao dao;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"begin~~~"</span>);</span><br><span class="line">    String sqlDB = <span class="string">"show databases"</span>;<span class="comment">//查询数据库</span></span><br><span class="line">    System.out.println(dao.queryForList(sqlDB));</span><br><span class="line">    System.out.println(dao.queryForList(<span class="string">"show tables;"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://xiaoyue26.github.io/2019/08/25/2019-08/clickhouse%E5%AE%9E%E6%88%98%E4%B9%8Bjdbc%E6%8E%A5%E5%85%A5/" data-id="ck96cxpq100jamaam88yifok3" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/clickhouse/" rel="tag">clickhouse</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/" rel="tag">java</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-2019-08/神秘的monad——函数式编程" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/08/23/2019-08/%E7%A5%9E%E7%A7%98%E7%9A%84monad%E2%80%94%E2%80%94%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/" class="article-date">
  <time datetime="2019-08-23T01:20:21.000Z" itemprop="datePublished">2019-08-23</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/java/">java</a>►<a class="article-category-link" href="/categories/java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/08/23/2019-08/%E7%A5%9E%E7%A7%98%E7%9A%84monad%E2%80%94%E2%80%94%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/">神秘的monad——函数式编程</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <p>monad确实比较难理解，我认真翻了一个星期资料才理解。</p>
<p>讲得比较好的参考资料：<br><a href="http://josephguan.github.io/2016/06/25/monad-in-scala/" target="_blank" rel="noopener">http://josephguan.github.io/2016/06/25/monad-in-scala/</a><br>比较形象的、有图的：<br><a href="http://blog.forec.cn/2017/03/02/translation-adit-faamip/" target="_blank" rel="noopener">http://blog.forec.cn/2017/03/02/translation-adit-faamip/</a><br>数学上讲得比较多的：(scala版代码可用)<br><a href="https://segmentfault.com/a/1190000008000905" target="_blank" rel="noopener">https://segmentfault.com/a/1190000008000905</a></p>
<p>参考资料3中的scala版代码:</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 半群:</span></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">SemiGroup</span>[<span class="type">A</span>] </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">op</span></span>(a1: <span class="type">A</span>, a2: <span class="type">A</span>): <span class="type">A</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. monoid: (还不是monad) 比半群多一个零元</span></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Monoid</span>[<span class="type">A</span>] <span class="keyword">extends</span> <span class="title">SemiGroup</span>[<span class="type">A</span>] </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">zero</span></span>: <span class="type">A</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函子: (有map函数就是Functor)</span></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Functor</span>[<span class="type">F</span>[_]] </span>&#123;</span><br><span class="line">  <span class="comment">// 输入一个A的容器F[A],输入一个A类型=&gt;B类型的变化</span></span><br><span class="line">  <span class="comment">// 输出B类型的容器F[B]</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">map</span></span>[<span class="type">A</span>, <span class="type">B</span>](a: <span class="type">F</span>[<span class="type">A</span>])(f: <span class="type">A</span> =&gt; <span class="type">B</span>): <span class="type">F</span>[<span class="type">B</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">MonadTest</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> stringMonoid = <span class="keyword">new</span> <span class="type">Monoid</span>[<span class="type">String</span>] &#123;</span><br><span class="line">      <span class="function"><span class="keyword">def</span> <span class="title">op</span></span>(a1: <span class="type">String</span>, a2: <span class="type">String</span>) = a1 + a2</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">def</span> <span class="title">zero</span> </span>= <span class="string">""</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">listMonoid</span></span>[<span class="type">A</span>] = <span class="keyword">new</span> <span class="type">Monoid</span>[<span class="type">List</span>[<span class="type">A</span>]] &#123;</span><br><span class="line">      <span class="function"><span class="keyword">def</span> <span class="title">op</span></span>(a1: <span class="type">List</span>[<span class="type">A</span>], a2: <span class="type">List</span>[<span class="type">A</span>]) = a1 ++ a2</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">def</span> <span class="title">zero</span> </span>= <span class="type">Nil</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">optionMonoid</span></span>[<span class="type">A</span>] = <span class="keyword">new</span> <span class="type">Monoid</span>[<span class="type">Option</span>[<span class="type">A</span>]] &#123;</span><br><span class="line">      <span class="function"><span class="keyword">def</span> <span class="title">op</span></span>(a1: <span class="type">Option</span>[<span class="type">A</span>], a2: <span class="type">Option</span>[<span class="type">A</span>]) = a1 orElse a2</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">def</span> <span class="title">zero</span> </span>= <span class="type">None</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">listFunctor</span> </span>= <span class="keyword">new</span> <span class="type">Functor</span>[<span class="type">List</span>] &#123;</span><br><span class="line">      <span class="function"><span class="keyword">def</span> <span class="title">map</span></span>[<span class="type">A</span>, <span class="type">B</span>](a: <span class="type">List</span>[<span class="type">A</span>])(f: (<span class="type">A</span>) =&gt; <span class="type">B</span>) = a.map(f)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*trait Monad[M[_]] &#123;</span></span><br><span class="line"><span class="comment">  def unit[A](a: A): M[A]   //identity</span></span><br><span class="line"><span class="comment">  def join[A](mma: M[M[A]]): M[A]</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"><span class="comment">// Monad: (有unit和flatmap就是monad)</span></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Monad</span>[<span class="type">M</span>[_]] </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">unit</span></span>[<span class="type">A</span>](a: <span class="type">A</span>): <span class="type">M</span>[<span class="type">A</span>]</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">flatMap</span></span>[<span class="type">A</span>, <span class="type">B</span>](fa: <span class="type">M</span>[<span class="type">A</span>])(f: <span class="type">A</span> =&gt; <span class="type">M</span>[<span class="type">B</span>]): <span class="type">M</span>[<span class="type">B</span>]</span><br><span class="line"></span><br><span class="line">  <span class="comment">// def join[A](mma: M[M[A]]): M[A] = flatMap(mma)(ma =&gt; ma)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>附抄scala版的monad(参考资料1):</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Monad</span>[+<span class="type">T</span>] </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">flatMap</span></span>[<span class="type">U</span>]( f : (<span class="type">T</span>) =&gt; <span class="type">Monad</span>[<span class="type">U</span>] ) : <span class="type">Monad</span>[<span class="type">U</span>]</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">unit</span></span>(value : <span class="type">B</span>) : <span class="type">Monad</span>[<span class="type">B</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// map可以理解为flatmap的特化:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">map</span></span>[<span class="type">U</span>](f : (<span class="type">T</span>) =&gt; <span class="type">U</span>) : <span class="type">Monad</span>[<span class="type">U</span>] = flatMap(v =&gt; unit(f(v)))</span><br><span class="line"></span><br><span class="line"><span class="comment">// Try类型monad:</span></span><br><span class="line"><span class="keyword">val</span> result:<span class="type">Try</span>[<span class="type">Int</span>] = <span class="type">Try</span>(<span class="string">"5"</span>.toInt).flatMap&#123;a =&gt;</span><br><span class="line">                      <span class="type">Try</span>(<span class="string">"6a"</span>.toInt).flatMap&#123;b =&gt;</span><br><span class="line">                      <span class="type">Try</span>(<span class="string">"9"</span>.toInt).flatMap&#123;c =&gt; <span class="type">Try</span>(a + b +c )&#125;&#125;&#125;</span><br><span class="line"><span class="comment">// for是flatmap的语法糖:</span></span><br><span class="line"><span class="keyword">val</span> result: <span class="type">Try</span>[<span class="type">Int</span>] = <span class="keyword">for</span> (</span><br><span class="line">    a &lt;- <span class="type">Try</span>(<span class="string">"5"</span>.toInt);</span><br><span class="line">    b &lt;- <span class="type">Try</span>(<span class="string">"6a"</span>.toInt);</span><br><span class="line">    c &lt;- <span class="type">Try</span>(<span class="string">"9"</span>.toInt)</span><br><span class="line">  ) <span class="keyword">yield</span>( a + b + c)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.1含幺半群G: </span></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Monad</span>[+<span class="type">T</span>]</span></span><br><span class="line"><span class="class"><span class="title">//</span> 1.2<span class="title">二元封闭、结合运算</span></span>:</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">flatMap</span></span>[<span class="type">U</span>]( f : (<span class="type">T</span>) =&gt; <span class="type">Monad</span>[<span class="type">U</span>] ) : <span class="type">Monad</span>[<span class="type">U</span>]</span><br><span class="line"><span class="comment">// 1.3幺元:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">unit</span></span>(value : <span class="type">B</span>) : <span class="type">Monad</span>[<span class="type">B</span>] </span><br><span class="line"><span class="comment">// 2.1结合律/封闭:</span></span><br><span class="line">monad.flatMap(f).flatMap(g) == monad.flatMap(v =&gt; f(v).flatMap(g)) <span class="comment">// associativity</span></span><br><span class="line"><span class="comment">// 案例:</span></span><br><span class="line"><span class="keyword">val</span> multiplier : <span class="type">Int</span> =&gt; <span class="type">Option</span>[<span class="type">Int</span>] = v =&gt; <span class="type">Some</span>(v * v)</span><br><span class="line"><span class="keyword">val</span> divider : <span class="type">Int</span> =&gt; <span class="type">Option</span>[<span class="type">Int</span>] = v =&gt; <span class="type">Some</span>(v/<span class="number">2</span>)</span><br><span class="line"><span class="keyword">val</span> original = <span class="type">Some</span>(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">original.flatMap(multiplier).flatMap(divider) ===</span><br><span class="line">original.flatMap(v =&gt; multiplier(v).flatMap(divider))</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 2.2 左幺元</span></span><br><span class="line">unit(x).flatMap(f) == f(x)</span><br><span class="line"><span class="comment">// 案例:</span></span><br><span class="line"><span class="keyword">val</span> multiplier : <span class="type">Int</span> =&gt; <span class="type">Option</span>[<span class="type">Int</span>] = v =&gt; <span class="type">Some</span>(v * v)</span><br><span class="line"><span class="keyword">val</span> item = <span class="type">Some</span>(<span class="number">10</span>).flatMap(multiplier)</span><br><span class="line">item === multiplier(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.3 右幺元</span></span><br><span class="line">monad.flatMap(unit) == monad</span><br><span class="line"><span class="comment">// 案例:</span></span><br><span class="line"><span class="keyword">val</span> value = <span class="type">Some</span>(<span class="number">50</span>).flatMap(v =&gt; <span class="type">Some</span>(v))</span><br><span class="line">value === <span class="type">Some</span>(<span class="number">50</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 范畴</span></span><br><span class="line">高阶类型（如<span class="type">List</span>[<span class="type">T</span>+]）</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 函子(Functor)</span></span><br><span class="line"><span class="comment">// 函数， Int =&gt; String</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span></span>(i:<span class="type">Int</span>): <span class="type">String</span> = i.toString</span><br><span class="line"><span class="comment">// 函子， List[T] =&gt; Set[T]</span></span><br><span class="line">scala&gt; <span class="function"><span class="keyword">def</span> <span class="title">baz</span></span>[<span class="type">T</span>](l:<span class="type">List</span>[<span class="type">T</span>]): <span class="type">Set</span>[<span class="type">T</span>] = l.toSet</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5. 自函子(Endofunctor)：</span></span><br><span class="line">把一个类型映射到自身类型，比如<span class="type">Int</span>=&gt;<span class="type">Int</span>, <span class="type">String</span>=&gt;<span class="type">String</span> </span><br><span class="line">例如flatmap:</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">flatMap</span></span>[<span class="type">U</span>]( f : (<span class="type">T</span>) =&gt; <span class="type">Monad</span>[<span class="type">U</span>] ) : <span class="type">Monad</span>[<span class="type">U</span>]</span><br></pre></td></tr></table></figure>



<blockquote>
<p>下面开始是我个人的理解</p>
</blockquote>
<h2 id="函数式语言"><a href="#函数式语言" class="headerlink" title="函数式语言"></a>函数式语言</h2><blockquote>
<p>函数是一等公民。<br>无函数副作用。</p>
</blockquote>
<p>（学校里教的）<br>函数可以像普通变量一样使用。（比c里的函数指针更进一步）</p>
<h3 id="更函数式一点"><a href="#更函数式一点" class="headerlink" title="更函数式一点"></a>更函数式一点</h3><p>尽量无状态，最好都像lambda演算一样，有很深的递归。<br>用递归代替循环。</p>
<p>Monad就是这个思想的一个具体实现。</p>
<h2 id="代码层面理解"><a href="#代码层面理解" class="headerlink" title="代码层面理解"></a>代码层面理解</h2><p>Monad在scala中就是一个有flatmap的容器，可以把函数fmap的输出收集起来打平回原来的Monad类型。<br>比较好理解的Monad类型是容器类型：List,Option. </p>
<h2 id="形象上理解"><a href="#形象上理解" class="headerlink" title="形象上理解"></a>形象上理解</h2><p>Monad形象上理解类似于有管道操作的容器，可以把函数fmap的输出适配回Monad类型，方便投入下一个函数中。</p>
<h2 id="比较严密的定义上理解："><a href="#比较严密的定义上理解：" class="headerlink" title="比较严密的定义上理解："></a>比较严密的定义上理解：</h2><p>（去掉范畴学的数学术语，简化理解）<br>Monad是一个我们定义的集合，它上面有零元（如Option中的None\List中的nil），它上面还有一种二元操作op，op(A,B)的结果依然属于Monad(封闭性)，并且运算满足结合律(可以随意加括号)。<br>所以如果有unit函数(生成零元)，flatmap函数（把二元操作打平回集合元素类型，满足封闭性），就可以成为一个Monad了。至于结合律，由于函数都满足结合律，因此可以忽略。</p>
<p>总结:<br>有map函数: Functor、函子<br>有ap函数（参数为函数的map）: Applicative、应用<br>有flatmap函数: Monad</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://xiaoyue26.github.io/2019/08/23/2019-08/%E7%A5%9E%E7%A7%98%E7%9A%84monad%E2%80%94%E2%80%94%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/" data-id="ck96cxpq200jdmaamd4kn4fpv" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/monad/" rel="tag">monad</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/scala/" rel="tag">scala</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%87%BD%E6%95%B0%E5%BC%8F/" rel="tag">函数式</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-2019-07/disruptor笔记" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/27/2019-07/disruptor%E7%AC%94%E8%AE%B0/" class="article-date">
  <time datetime="2019-07-27T07:49:48.000Z" itemprop="datePublished">2019-07-27</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/">消息队列</a>►<a class="article-category-link" href="/categories/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/disruptor/">disruptor</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/27/2019-07/disruptor%E7%AC%94%E8%AE%B0/">disruptor笔记——代替blockingQueue和java9flowAPI</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>blockingQueue缺点:</p>
<ol>
<li>竞态严重: producer\consumer;</li>
<li>cache不友好: 线程a结束后，线程b的所有缓存都污染。</li>
</ol>
<h1 id="discruptor方案"><a href="#discruptor方案" class="headerlink" title="discruptor方案"></a>discruptor方案</h1><p>理想适用场景：<br>1个producer,多个consumer.</p>
<p>循环队列：<br>producer: 存储自己的游标(cursor);<br>consumer: 存储自己的消费offset。 </p>
<ol>
<li>循环队列: 降低竞态,分离了多个游标;(当然还是有竞态，用内存屏障)</li>
<li>cursor中加入padding: 避免cursor缓存污染;（填充上7个long）</li>
<li>用CAS和忙等(busy spin)代替锁。(资源换性能)</li>
<li>预先申请了一大片内存：避免gc干扰。</li>
</ol>
<ul>
<li>优化</li>
</ul>
<ol>
<li>batch commit; // 避免竞态次数 比如消费者不是每次只读1个，它直接询问生产进度seqK，保存下来，然后一直消费到seqK之前都不用再询问cursor. （询问需要穿过consumer barrier）</li>
<li>多个producer时: CAS写入; </li>
<li>支持复杂dag优化。</li>
</ol>
<p>附:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// padding:</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileLong</span></span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">long</span> value = <span class="number">0L</span>;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">long</span> p1, p2, p3, p4, p5, p6; <span class="comment">// comment out</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="信息交流"><a href="#信息交流" class="headerlink" title="信息交流"></a>信息交流</h2><h3 id="consumer获取producer信息"><a href="#consumer获取producer信息" class="headerlink" title="consumer获取producer信息"></a>consumer获取producer信息</h3><img src="/images/2019-07/consumer_barrier.png" class="" width="400" height="600" title="consumer_barrier">
<p>通过consumer barrier从获取cursor信息： 最新生产sequence number;<br>这种策略下，消费者不需要知道其他消费者的情况(独立offset)</p>
<h2 id="producer获取信息"><a href="#producer获取信息" class="headerlink" title="producer获取信息"></a>producer获取信息</h2><img src="/images/2019-07/producer_barrier.png" class="" width="400" height="600" title="producer_barrier">
<p>通过producer barrier获取ring buffer和消费者信息。<br>等待最慢的消费者释放空间：获取最慢的消费者的offset。以便获得更多可读的节点空间。（这里也可以批处理，同时获得多个空间，同时写）</p>
<p>两阶段提交：</p>
<ol>
<li>数据写入节点;</li>
<li>commit. </li>
</ol>
<h1 id="复杂dag支持"><a href="#复杂dag支持" class="headerlink" title="复杂dag支持"></a>复杂dag支持</h1><img src="/images/2019-07/disruptor_dag.png" class="" width="400" height="600" title="disruptor_dag">
<p>如上图所示的菱形结构可能在实际业务中会出现。<br>producer进度: 22<br>c1进度: 21<br>c2进度: 18<br>c3进度: 15<br>此时producer想要继续写的时候卡住，因为15的位置还不可用。<br>也就是生产者的速度受制于叶子节点的消费者。</p>
<p>c1,c2的处理结果一般是原地写入entry的不同字段，避免冲突。<br>(entry节点的定义可以有多个值字段)</p>
<p>更多详情直接参见：<br><a href="http://wiki.jikexueyuan.com/project/disruptor-getting-started/write-ringbuffer.html" target="_blank" rel="noopener">http://wiki.jikexueyuan.com/project/disruptor-getting-started/write-ringbuffer.html</a></p>
<p>maven依赖：<br><a href="https://mvnrepository.com/artifact/com.lmax/disruptor/3.4.2" target="_blank" rel="noopener">https://mvnrepository.com/artifact/com.lmax/disruptor/3.4.2</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://xiaoyue26.github.io/2019/07/27/2019-07/disruptor%E7%AC%94%E8%AE%B0/" data-id="ck96cxppv00iqmaamalhkb5aj" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/disruptor/" rel="tag">disruptor</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/" rel="tag">java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/" rel="tag">消息队列</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-2019-07/领域驱动设计-第7-17章笔记" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/22/2019-07/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1-%E7%AC%AC7-17%E7%AB%A0%E7%AC%94%E8%AE%B0/" class="article-date">
  <time datetime="2019-07-22T02:09:04.000Z" itemprop="datePublished">2019-07-22</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/java/">java</a>►<a class="article-category-link" href="/categories/java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/22/2019-07/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1-%E7%AC%AC7-17%E7%AB%A0%E7%AC%94%E8%AE%B0/">领域驱动设计-第7~17章笔记</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <h1 id="第七章-实例：货物运输系统"><a href="#第七章-实例：货物运输系统" class="headerlink" title="第七章 实例：货物运输系统"></a>第七章 实例：货物运输系统</h1><h2 id="1-需求"><a href="#1-需求" class="headerlink" title="1. 需求"></a>1. 需求</h2><ol>
<li>跟踪货物的主要处理部署；</li>
<li>预约货物；</li>
<li>货物到达某一处理步骤时自动发送发票。</li>
</ol>
<h2 id="领域语言"><a href="#领域语言" class="headerlink" title="领域语言"></a>领域语言</h2><p>货物: cargo<br>客户: customer<br>规格: specification<br>运输动作: carrier movement</p>
<ol>
<li>一个cargo(货物)涉及到多个customer(客户)，每个customer承担不同角色。</li>
<li>cargo的运送目标已指定；</li>
<li>由一系列满足specification(规格)的carrier movement(运输动作)来完成运送目标。</li>
</ol>
<img src="/images/2019-07/chapter7_class.png" class="" width="800" height="1200" title="chapter7_class">
<p>上述类图中Customer包括托运人、收货人、快递员等角色。<br>（都是我们软件要服务的客户）<br>Handling Event可以细分为不同种类的事件（装货、卸货、提货…）</p>
<h2 id="隔离领域"><a href="#隔离领域" class="headerlink" title="隔离领域"></a>隔离领域</h2><p>要把领域层划分出来，首先识别出3个用户层的应用程序功能：</p>
<ol>
<li>跟踪查询: 访问某个cargo过去、现在的处理情况;(Delivery History)</li>
<li>预定: 注册一个cargo；</li>
<li>事件日志记录: 为1准备信息。<br>三个应用层类：<br>Tracking Query,Booking Application,Incident Logging Applicatoin。<br>这三个应用层类只是协调者，负责向领域层提问。</li>
</ol>
<h2 id="区分Entity和Value-Object"><a href="#区分Entity和Value-Object" class="headerlink" title="区分Entity和Value Object"></a>区分Entity和Value Object</h2><p>看对象是必须被跟踪的实体还是仅表示一个基本值。</p>
<p><code>Customer</code>: Entity<br><code>Cargo</code>: Entity<br><code>Handling Event</code>和<code>Carrier Movement</code>: Entity<br><code>Delivery History</code>: Entity<br><code>Delivery Specification</code>: Value Object: 可替换，货物满足的规则只要等效即可，并不一定需要是某一个id的规则。<br><code>Role</code>: Value Object.</p>
<h2 id="设计关联"><a href="#设计关联" class="headerlink" title="设计关联"></a>设计关联</h2><p>双向关联往往会产生问题，因此要研究把双向关联转换成单向关联。<br>好处：</p>
<ol>
<li>双向关联=&gt;单向关联：降低出错概率；</li>
<li>研究遍历方向过程中：让领域更加清晰。</li>
</ol>
<p>把低频需求的遍历方向交给数据库实现；<br>留下的单向遍历作为领域层的单向引用。</p>
<h2 id="Aggregate边界"><a href="#Aggregate边界" class="headerlink" title="Aggregate边界"></a>Aggregate边界</h2><p>Customer: 根<br>Location: 根<br>Carrier Movement: 根<br>Cargo: 根,它的边界可以囊括所有因它才存在的弱实体: <code>Delivery History</code>,<code>Delivery Specification</code>。<br>(分发历史、分发规则(VO)、处理事件)</p>
<p><code>Handling Event</code>： </p>
<ol>
<li>查找某个<code>Delivery History</code>中的<code>Handling Event</code>;</li>
<li>查找某次<code>Carrier Movement</code>的操作，需要<code>Handling Event</code>的id，需要<code>Handling Event</code>作为根。</li>
</ol>
<h2 id="创建Repository"><a href="#创建Repository" class="headerlink" title="创建Repository"></a>创建Repository</h2><p>作为根的Entity创建repository.<br>（其他就不创建了，精简类的数量）</p>
<img src="/images/2019-07/agg_root.png" class="" width="800" height="1200" title="agg_root">

<p>如图有7个Entity,5个根。<br>应对的需求:</p>
<ol>
<li>用户选择承担不同角色：发货方、收货人；Customer;</li>
<li>货物目的地需要Location;</li>
<li>用户需要查找装货的Carrier Movement;</li>
<li>用户需要输入系统哪个Cargo完成了装货: Cargo;</li>
<li>Handling Event的需求待定。<br>如下图是加上了repository后：<img src="/images/2019-07/repository.png" class="" width="800" height="1200" title="repository">

</li>
</ol>
<h2 id="用例"><a href="#用例" class="headerlink" title="用例"></a>用例</h2><h3 id="1-更改目的地"><a href="#1-更改目的地" class="headerlink" title="1. 更改目的地"></a>1. 更改目的地</h3><p><code>Delivery Specification</code>是个VO，可以直接创建一个新的，替换旧的即可。</p>
<h2 id="2-重复预订"><a href="#2-重复预订" class="headerlink" title="2. 重复预订"></a>2. 重复预订</h2><p>常常会需要基于旧的cargo作为原型创建新的cargo。<br>（重复下单同一种商品）</p>
<ol>
<li>Delivery History: 应创建新、空的；（其他弱实体同）</li>
<li>Customer Roles: 和原来的cargo引用同样的运输角色Customer。</li>
<li>Tracking ID: 新增。</li>
</ol>
<p>总结三类：</p>
<ol>
<li>弱实体、边界内：创建新的、空的。</li>
<li>边界外：可以引用相同的。</li>
<li>根：新增（自增id）。</li>
</ol>
<h2 id="从需求频次出发简化设计"><a href="#从需求频次出发简化设计" class="headerlink" title="从需求频次出发简化设计"></a>从需求频次出发简化设计</h2><img src="/images/2019-07/handling_event.png" class="" width="800" height="1200" title="handling_event">
<p>Handling Event相关需求的频次：<br>创建、新增：高频<br>查询： 低频</p>
<p>由于查询<code>Delivery History</code>中的<code>Handling Event</code>是低频需求，因此可以考虑不在<code>Delivery History</code>中直接存储<code>Handling Event</code>数组，这样节省了存储开销，也降低了维护一致性的成本。这里创建、新增<code>Handling Event</code>是高频的，因此如果<code>Delivery History</code>中是存储数组，要频繁维护一致性，而且是Agg边界外的改动引起Agg边界内的变动，属于不合理设计。</p>
<p>综上：可将<code>Delivery History</code>中的<code>Handling Event</code>改为即时查询接口，而不是直接存储数组。</p>
<p>优点：使Handling Event的新建变得简单，不会与Cargo Agg发生争用。</p>
<blockquote>
<p>换句话说，类似于我们平时设计表字段的时候，高频查询的字段直接放到同一个表里头（可能有时候会反三范式），低频的抽出来扔另一张表(弱实体)里。原文这里是对象级的讨论。</p>
</blockquote>
<h2 id="Module：模块化"><a href="#Module：模块化" class="headerlink" title="Module：模块化"></a>Module：模块化</h2><img src="/images/2019-07/module.png" class="" width="800" height="1200" title="module">
<p>将紧密关联的实体封装到一个模块。</p>
<h2 id="引入新特性：-配额检查"><a href="#引入新特性：-配额检查" class="headerlink" title="引入新特性： 配额检查"></a>引入新特性： 配额检查</h2><p><code>Allocation Checker</code>: 确保高利润的商品能够运输完，确保大部分商品不会因为运力不足退单毁约。</p>
<ul>
<li>输入：</li>
</ul>
<ol>
<li>某cargo: 已经预订了多少; （或这个分类已经预订了多少）</li>
<li>某cargo: 最大预订配额。（或这个分类最大配额）</li>
</ol>
<ul>
<li>输出:<br>是否能继续预订。</li>
</ul>
<h3 id="实现1"><a href="#实现1" class="headerlink" title="实现1"></a>实现1</h3><p>如小猿的做法: 配额是存储在商品信息里头的。<br>(参见warehouse)</p>
<h3 id="实现2"><a href="#实现2" class="headerlink" title="实现2:"></a>实现2:</h3><p>配额是由另一个系统提供的。<br>同一个商品可以属于不同的类别，影响不同层面的配额。<br>这样配额相关属性抽离出来变成一类弱实体。</p>
<h1 id="第三部分-通过重构来加深理解"><a href="#第三部分-通过重构来加深理解" class="headerlink" title="第三部分 通过重构来加深理解"></a>第三部分 通过重构来加深理解</h1><p>目标：巧妙的领域模型<br>手段：不断重构，加深对领域的理解</p>
<h2 id="重构"><a href="#重构" class="headerlink" title="重构"></a>重构</h2><p>重构的定义是在不改变功能的前提下重新设计它。</p>
<p>重构的层次:</p>
<ol>
<li>微重构；（累积成更深层次重构）；// 参见《重构》一书</li>
<li>源于对领域的新认知；</li>
<li>设计模式重构。</li>
</ol>
<h2 id="深层模型"><a href="#深层模型" class="headerlink" title="深层模型"></a>深层模型</h2><p>浅层模型： 在需求文档中确定名词和动词，初始建模；（不够成熟深入）（只有具体元素）<br>深层模型： 穿过领域表象，清楚表达领域专家主要关注点以及最相关知识。（恰当的抽象元素和具体元素）</p>
<h2 id="深层模型与柔性设计"><a href="#深层模型与柔性设计" class="headerlink" title="深层模型与柔性设计"></a>深层模型与柔性设计</h2><p>（柔性设计详见第10章）<br>好的深层模型能方便地支持柔性设计。</p>
<h2 id="发现过程"><a href="#发现过程" class="headerlink" title="发现过程"></a>发现过程</h2><p>（发现过程、捕捉领域核心概念详见第9章）<br>第11章: 分析模式<br>第12章: 设计模式</p>
<h1 id="第八章-突破"><a href="#第八章-突破" class="headerlink" title="第八章 突破"></a>第八章 突破</h1><img src="/images/2019-07/breakthrough.png" class="" width="800" height="1200" title="breakthrough">
<p>如上图所示，重构在某个节点的投入可能会有很大的回报。<br>（如果突然孵化了对项目的最重要理解，会给项目带来重大冲击）<br>即使是小的改进也可以防止系统退化。</p>
<h2 id="突破案例"><a href="#突破案例" class="headerlink" title="突破案例"></a>突破案例</h2><p>背景：<br>管理银团贷款的程序。<br>基本需求：<br>跟踪支持整个贷款过程。</p>
<h3 id="大致过程"><a href="#大致过程" class="headerlink" title="大致过程"></a>大致过程</h3><p>原先的设计绑定了放贷股份和信贷股份，错误的理解。<br>突然有一天明白了两者基本无关联，重新设计了模型，得到突破，快速迭代。</p>
<p>总结： 好的模型能让无技术背景的业务方也能快速理解。（而不是抱怨专业性太强看不懂）</p>
<h1 id="第九章-深层模型"><a href="#第九章-深层模型" class="headerlink" title="第九章 深层模型"></a>第九章 深层模型</h1><h2 id="倾听语言"><a href="#倾听语言" class="headerlink" title="倾听语言"></a>倾听语言</h2><p>线索：</p>
<ol>
<li>用户长期抱怨、频繁查询的场景，可能是遗漏了重要领域对象。</li>
<li>领域专家试图纠正你的术语；</li>
<li>用户感到困惑的名词。</li>
<li>始终无法形成DSL。(讨论中的术语经常超出DSL范围)</li>
</ol>
<h2 id="会计示例"><a href="#会计示例" class="headerlink" title="会计示例"></a>会计示例</h2><p>主要讲的是学了会计学以后模型更合理，深层。</p>
<h2 id="约束的提炼"><a href="#约束的提炼" class="headerlink" title="约束的提炼"></a>约束的提炼</h2><p>约束包括显式规则、隐式规则。<br>遇到如下情况时，应将隐式规则提炼到显式对象(显式规则)：</p>
<ol>
<li>计算约束所需数据从定义上不属于这个对象；</li>
<li>相关规则在多个对象出现，代码重复；</li>
<li>设计和需求围绕着这些规则，而这些约束却分散在过程代码中。</li>
</ol>
<h3 id="将规则显式提炼的案例：超订策略"><a href="#将规则显式提炼的案例：超订策略" class="headerlink" title="将规则显式提炼的案例：超订策略"></a>将规则显式提炼的案例：超订策略</h3><img src="/images/2019-07/overbook.png" class="" width="800" height="1200" title="overbook">
<p>如上图voyage表示实际座席、cargo表示售出货物。<br>同时引入overbooking policy来显式封装超订的规则约束。</p>
<p>两个矛盾的点：</p>
<ol>
<li>不希望过程变成模型的主要部分；</li>
<li>重要的过程则必须显露在模型中。<br>把握这个边界的诀窍：<br>这个过程是否经常被领域专家提起，或者仅作为程序机制的一部分。</li>
</ol>
<h2 id="模式：-Specification"><a href="#模式：-Specification" class="headerlink" title="模式： Specification"></a>模式： Specification</h2><img src="/images/2019-07/specification.png" class="" width="800" height="1200" title="specification">
<p>一般性的，可以将约束、规则提取出来，作为领域层的Value Object。<br>用途包括：</p>
<ul>
<li>选择</li>
<li>过滤</li>
<li>按规格创建/生成对象。</li>
</ul>
<h1 id="第十章-柔性设计"><a href="#第十章-柔性设计" class="headerlink" title="第十章 柔性设计"></a>第十章 柔性设计</h1><p>柔性设计是深层模型的补充。<br>当我们把隐式概念抽离显式表达出来以后，就有原料来进行柔性设计了。</p>
<p>过多抽象层、间接设计=&gt;过度设计<br>适当抽象层、间接设计=&gt;柔性设计</p>
<p>简单并不容易做到。<br>柔性设计需要揭示深层次的底层模型，把它潜在的部分明确展示出来。</p>
<p>具体方法包括如下：</p>
<h2 id="1-模式：表现意图的接口-Intention-Revealing-Interface"><a href="#1-模式：表现意图的接口-Intention-Revealing-Interface" class="headerlink" title="1. 模式：表现意图的接口(Intention-Revealing Interface)"></a>1. 模式：表现意图的接口(Intention-Revealing Interface)</h2><img src="/images/2019-07/deep_model.png" class="" width="800" height="1200" title="deep_model">
<p>Intention-Revealing Interface: 表现意图的接口<br>有了它以后能够区分出：<br>Side-Effect-Freefunction: 无副作用的函数<br>StandAloneClass: 松耦合对象<br>Conceptual Contours: 概念边界\概念轮廓<br>Closeure of Operation: 闭合操作<br>甚至能基于接口直接编写单元测试中的断言。<br>（有时候可能无法达到这么理想，需要在单元测试中写Assert来进一步注释）</p>
<p>设计人员的客户包括其他合作开发人员。<br>接口中包含更多信息时，开发人员可以更有效地使用对象。<br>（否则就必须深入研究对象的内部机制、理解细节，失去了封装的价值）</p>
<p>接口设计重点：<br>给出意图、副作用、作用；<br>但无需给出具体实现细节。</p>
<h2 id="2-模式：无副作用函数（Size-Effect-free-function）"><a href="#2-模式：无副作用函数（Size-Effect-free-function）" class="headerlink" title="2. 模式：无副作用函数（Size-Effect-free function）"></a>2. 模式：无副作用函数（Size-Effect-free function）</h2><p>通过区分有无副作用，可以进一步降低查看底层实现的开销。<br>常见的无副作用操作：查询。<br>可以通过VO对象把一些操作也转化成无副作用。</p>
<p>一些复杂操作可以进一步分解成：有副作用、无副作用的两个操作。</p>
<p>挖掘深层模型案例：<br>油漆：</p>
<img src="/images/2019-07/paint1.png" class="" width="800" height="1200" title="paint1">
<p>第一步：把接口意图明确（混合两种油漆）</p>
<img src="/images/2019-07/paint2.png" class="" width="800" height="1200" title="paint2">
<p>第二步：原来的方法只修改paint1，不改paint2；不符合常识，后继开发人员也无法理解。改成深层模型，原来的paint改为不可变（Stock Paint），单独引入被混合后的油漆(Mixed Paint)。</p>
<h2 id="3-模式：-Assertion"><a href="#3-模式：-Assertion" class="headerlink" title="3. 模式： Assertion"></a>3. 模式： Assertion</h2><p>用断言把副作用明确表示出来。</p>
<h2 id="4-概念轮廓、概念边界"><a href="#4-概念轮廓、概念边界" class="headerlink" title="4. 概念轮廓、概念边界"></a>4. 概念轮廓、概念边界</h2><p>我们应该对每个依赖关系提出质疑，直到证实它确实表示对象的基本概念。<br>尽量把模块之间的依赖重构为模块内依赖；<br>模块内依赖重构为尽量少的对象之间的依赖。</p>
<h2 id="5-低耦合的对象"><a href="#5-低耦合的对象" class="headerlink" title="5. 低耦合的对象"></a>5. 低耦合的对象</h2><h2 id="6-模式：闭合操作-Closure-of-Operation"><a href="#6-模式：闭合操作-Closure-of-Operation" class="headerlink" title="6. 模式：闭合操作 Closure of Operation"></a>6. 模式：闭合操作 Closure of Operation</h2><p>实数集合上进行加减乘除后结果仍在实数集合中，这就是闭合操作。<br>像刚才油漆的混合操作之后得到的仍然是油漆，这就极大降低了依赖。</p>
<h2 id="7-声明式设计"><a href="#7-声明式设计" class="headerlink" title="7. 声明式设计"></a>7. 声明式设计</h2><p>声明式语言常见的有sql、各种配置文件。<br>比如把nginx的配置文件nginx.conf看作一种语言，则它是声明式的。(无法限定过程细节)<br>声明式设计就是写一段DSL，然后生成一份满足声明的约束条件的代码。比如mybatis里头用工具(jar包)+xml配置生成orm相关java代码。</p>
<ul>
<li>好处: 避免开发人员去写单调乏味容易出错的代码；</li>
<li>坏处: 生成的代码不灵活,声明可能不足以表达一切。</li>
</ul>
<h2 id="8-声明式设计风格"><a href="#8-声明式设计风格" class="headerlink" title="8. 声明式设计风格"></a>8. 声明式设计风格</h2><p>将上述几个模式组合以后，可以使用声明式设计风格。</p>
<h3 id="声明式风格的Specification"><a href="#声明式风格的Specification" class="headerlink" title="声明式风格的Specification"></a>声明式风格的Specification</h3><h4 id="1-用逻辑运算组合Specification-闭包操作模式"><a href="#1-用逻辑运算组合Specification-闭包操作模式" class="headerlink" title="1.用逻辑运算组合Specification (闭包操作模式)"></a>1.用逻辑运算组合Specification (闭包操作模式)</h4><p>运算组合结果还是Specification</p>
<img src="/images/2019-07/and_spec.png" class="" width="800" height="1200" title="and_spec">
<p>如图,可以通过子类的方法实现这种设计。（开销很大）</p>
<img src="/images/2019-07/cheap_spec.png" class="" width="800" height="1200" title="cheap_spec">
<p>如图，还可以通过逻辑算法来实现这种设计，这个栈的含义是:<br><code>and ( not (armored) , not(ventilated))</code><br>这种实现的优点: 对象个数少,内存使用效率高;<br>这种实现的缺点: 需要更高级的开发人员。</p>
<h2 id="9-切入问题的角度-（如何优化设计）"><a href="#9-切入问题的角度-（如何优化设计）" class="headerlink" title="9. 切入问题的角度 （如何优化设计）"></a>9. 切入问题的角度 （如何优化设计）</h2><h3 id="1-分割子领域"><a href="#1-分割子领域" class="headerlink" title="1. 分割子领域"></a>1. 分割子领域</h3><h3 id="2-尽可能利用已有的形式"><a href="#2-尽可能利用已有的形式" class="headerlink" title="2. 尽可能利用已有的形式"></a>2. 尽可能利用已有的形式</h3><p>从头创建一个严密的概念框架不能作为一项日常工作。<br>因此我们经常需要对建立已久的概念系统加以修改和利用。</p>
<h3 id="示例：-股份数学"><a href="#示例：-股份数学" class="headerlink" title="示例： 股份数学"></a>示例： 股份数学</h3><p>还钱=&gt;钱的分配按放贷股份</p>
<p>首先第一步: 把有无副作用的函数分离；(查归查，改归改)<br>3个函数:<br>计算分配方案;<br>执行(分配方案);<br>查询余额。</p>
<h4 id="第二步：把隐式概念变成显式概念"><a href="#第二步：把隐式概念变成显式概念" class="headerlink" title="第二步：把隐式概念变成显式概念"></a>第二步：把隐式概念变成显式概念</h4><img src="/images/2019-07/share_pie.png" class="" width="800" height="1200" title="share_pie">
<p>显式引入股份份额的概念(share_pie)。<br>然后把分配方案的计算委托给share_pie，这样简化了loan对象,可以进行复杂的计算。<br>share_pie可以作为VO（因为计算是无副作用而且通用的）</p>
<h4 id="第三步-引入闭合操作-运算"><a href="#第三步-引入闭合操作-运算" class="headerlink" title="第三步: 引入闭合操作(运算)"></a>第三步: 引入闭合操作(运算)</h4><img src="/images/2019-07/share_pie_vo.png" class="" width="800" height="1200" title="share_pie_vo">
<p>股份的份额运算变成闭合操作，并且由于是VO（不可变），每次返回新的Share pie.</p>
<p>最后把上层调用代码用声明式的风格改写即可。</p>
<p>核心思想： 把复杂计算封装到无状态的VO中。看情况引入闭合逻辑运算，进一步扩充计算能力。</p>
<h1 id="第11章-分析模式的应用"><a href="#第11章-分析模式的应用" class="headerlink" title="第11章 分析模式的应用"></a>第11章 分析模式的应用</h1><h2 id="案例：-账户的利息计算"><a href="#案例：-账户的利息计算" class="headerlink" title="案例： 账户的利息计算"></a>案例： 账户的利息计算</h2><p>需求：</p>
<ol>
<li>计算利息；</li>
<li>跟踪借款、付款、手续费；<br>（两种过账）<br>初始类图:<img src="/images/2019-07/class11_1.png" class="" width="800" height="1200" title="class11_1">

</li>
</ol>
<h3 id="引入复式记账-简化平账的并发问题"><a href="#引入复式记账-简化平账的并发问题" class="headerlink" title="引入复式记账(简化平账的并发问题)"></a>引入复式记账(简化平账的并发问题)</h3><p>加入每次的交易记录(不可变条目)，类似于所有快照都记录。<br>(Transaction)</p>
<h3 id="进一步挖掘需求"><a href="#进一步挖掘需求" class="headerlink" title="进一步挖掘需求"></a>进一步挖掘需求</h3><p>区分“应计项目”(accrual)和实际过账；<br>应记项目：立即发生；<br>实际过账：可以延迟。<br>例如利息可以每天计算，但只在月末过账。（例如夜间批量过账）<br>新的类图:</p>
<img src="/images/2019-07/class11_7.png" class="" width="800" height="1200" title="class11_7">
<p>注意到图中获取利息和费用的函数都是无副作用的。</p>
<h3 id="进一步考察过账需求"><a href="#进一步考察过账需求" class="headerlink" title="进一步考察过账需求"></a>进一步考察过账需求</h3><p>过账的触发时机：</p>
<ol>
<li>立即触发: 每次新增交易(Entry被插入)都触发，进行所有更新；</li>
<li>手动触发：向Account发送命令来触发过账规则；（进行更新）</li>
<li>基于规则触发：由代理驱动。<br>实际实现中可能根据过账的类型来决定触发时机（是否实时到账）。</li>
</ol>
<h1 id="第12章-将设计模式应用于模型"><a href="#第12章-将设计模式应用于模型" class="headerlink" title="第12章 将设计模式应用于模型"></a>第12章 将设计模式应用于模型</h1><p>有些设计模式可以用作领域模式：</p>
<h2 id="Strategy-Policy-模式"><a href="#Strategy-Policy-模式" class="headerlink" title="Strategy(Policy)模式"></a>Strategy(Policy)模式</h2><img src="/images/2019-07/policy.png" class="" width="800" height="1200" title="policy">
<p>模式中有一些可以灵活更换的策略(无状态)。<br>如路径查找中，可以选择时间最短或者成本最低等等策略。</p>
<h2 id="Composite模式"><a href="#Composite模式" class="headerlink" title="Composite模式"></a>Composite模式</h2><img src="/images/2019-07/composite.png" class="" width="800" height="1200" title="composite">
<p>复杂领域建模时，会遇到多个部分组成的重要对象。(可能继续嵌套)<br>例如航线可能由多个航段组成。航段可以进一步划分。</p>
<p>原文: 其他可用的设计模式不再一一列举</p>
<h1 id="第13章-通过重构得到更深层的理解"><a href="#第13章-通过重构得到更深层的理解" class="headerlink" title="第13章 通过重构得到更深层的理解"></a>第13章 通过重构得到更深层的理解</h1><p>(1)以领域为本;<br>(2)用不同的方式看待事物；<br>(3)坚持与领域专家对话。</p>
<h2 id="开始重构"><a href="#开始重构" class="headerlink" title="开始重构"></a>开始重构</h2><p>一段复杂或笨拙的代码：<br>问题的根源在于领域模型中的概念或者关系发生了错误。</p>
<p>另一种例外就是代码很整洁，但是与领域专家的语言不一致，这可能会埋下隐患，因此依然需要重构。</p>
<p>方法：</p>
<ul>
<li>请教领域专家：寻找灵感；</li>
<li>借鉴已有的经验、案例。</li>
<li>不用完全证明修改的合理性后再修改，应该掌握一个度然后持续重构。<br>(类似于物种进化过程中的爆发变化和间断平衡)</li>
</ul>
<h1 id="第四部分：-战略设计"><a href="#第四部分：-战略设计" class="headerlink" title="第四部分： 战略设计"></a>第四部分： 战略设计</h1><p>三个主题：</p>
<ol>
<li>上下文：ContextMap,也就是模块化；(Bounded Context)</li>
<li>精炼: 重点关心项目中最有价值、特殊的方面，其他组件外包；(Core Domain)</li>
<li>大比例结构: 大分层。(4个左右)(Responsibility Layer)</li>
</ol>
<h1 id="第14章-上下文-保持模型的完整性"><a href="#第14章-上下文-保持模型的完整性" class="headerlink" title="第14章 上下文: 保持模型的完整性"></a>第14章 上下文: 保持模型的完整性</h1><p>需要保证模型的内部统一性，不要有模棱两可的意义、规则的冲突。<br>（举个案例两个团队使用同一个模型出错，最后分开成两个不同场景的模型了）</p>
<p>Bounded context: 限界上下文，定义每个模型的应用范围；<br>Context Map: 上下文图，给出项目上下文和它们之间关系的总体视图；</p>
<img src="/images/2019-07/context_map.png" class="" width="800" height="1200" title="ContextMap">
<p>Continuous Integration: 持续集成,小项目使用,模型统一;<br>Shared Kernel: 共享内核;平等团队合作；<br>Customer/Supplier Teams: 上下游合作,有共同的直接上级；<br>Conformist: 跟随者，沿用类似内核；（上游写得不错，直接拿过来增强即可）<br>Open Host Service: 支持多个客户；(与多个外部系统集成时)<br>Seperate Ways: 团队自由工作(没有共同直接上级)；或者上游写得太烂，直接抛弃重写。<br>Anticorruption Layer: 隔离层，单向转换。（与遗留系统集成时）或者上游写得太烂，一边重构一边用。</p>
<h2 id="Bounded-Context"><a href="#Bounded-Context" class="headerlink" title="Bounded Context"></a>Bounded Context</h2><p>类似于细胞膜一样，缩小模型的命名空间、覆盖范围。<br>降低成员之间沟通的成本（DSL中术语太多记不住，洪泛了）</p>
<p>一个模型只在一个上下文中使用。</p>
<p>// Bounded Context和Module还是有所区别。一个是逻辑上的，一个是物理上的。</p>
<p>识别不一致:</p>
<ol>
<li>场景发生变化后：接口不匹配了。</li>
<li>重复的概念和假同源: 使用相同的术语，但其实是不同的模型。</li>
</ol>
<h2 id="Continuous-Integration-持续集成"><a href="#Continuous-Integration-持续集成" class="headerlink" title="Continuous Integration: 持续集成"></a>Continuous Integration: 持续集成</h2><p>在一个Bounded Context中的模型应该持续集成，保持一致性。<br>（小团队、高频交流）</p>
<h2 id="Context-Map-全局视图"><a href="#Context-Map-全局视图" class="headerlink" title="Context Map: 全局视图"></a>Context Map: 全局视图</h2><p>ContextMap同时服务于项目管理和软件设计。<br>甚至要按照它来安排办公室的物理位置。</p>
<h3 id="案例：预订context和运输context"><a href="#案例：预订context和运输context" class="headerlink" title="案例：预订context和运输context"></a>案例：预订context和运输context</h3><img src="/images/2019-07/bounded_context.png" class="" width="800" height="1200" title="bounded_context">
<p>预订Context: 完成Route Specification=&gt;地点代码的转换；<br>运输Context: 完成Node标识=&gt;行程表、航程安排的转换。<br>两个上下文之间的接口非常小，可以由Side_Effect_free function构成，由于<br>同时使用两个上下文，因此可以应用有效的路线安排算法。</p>
<h3 id="其他要点"><a href="#其他要点" class="headerlink" title="其他要点"></a>其他要点</h3><ol>
<li>确定Context的边界；(每个人都知道)</li>
<li>每个上下文应当有名字，方便讨论；(加入DSL)</li>
</ol>
<p>将这两点文档化。</p>
<h3 id="Context-Map中一些常见的模式"><a href="#Context-Map中一些常见的模式" class="headerlink" title="Context Map中一些常见的模式"></a>Context Map中一些常见的模式</h3><p>持续集成模式：<br>紧密集成产品的优秀团队：大的统一的模型</p>
<p>Shared Kernel（共享内核）/Customer-supplier(客户供应商)：</p>
<ul>
<li>团队协调能力有限;</li>
<li>为不同的用户群提供服务;</li>
</ul>
<p>Separate Way(独立自主)模式:</p>
<ul>
<li>集成并不重要时;</li>
</ul>
<p>Open Host Service(开放主机服务)/Anticorruption Layer(防护层)：</p>
<ul>
<li>与遗留系统或外部系统进行一定程度集成时。</li>
</ul>
<h2 id="Shared-Kernel-共享内核"><a href="#Shared-Kernel-共享内核" class="headerlink" title="Shared Kernel (共享内核)"></a>Shared Kernel (共享内核)</h2><p>持续集成是开销最大的，开销稍微小一点的是共享内核。<br>（仅持续集成内核部分）</p>
<p>从领域模型中选出两个团队都同意共享的一个子集。<br>一个团队在没与另一个团队商量之前不应擅自更改它。</p>
<p><strong>测试</strong><br>需要自动测试套件</p>
<p>可以每周进行一次内核的合并。</p>
<p>Shared Kernel通常是Core Domain(参见精炼部分，Core Domain就是精炼出来的项目需要解决的最核心逻辑)，或者一组Generic Subdomain(通用子领域)。</p>
<h2 id="Customer-Supplier-Development-Team-客户-供应商模式"><a href="#Customer-Supplier-Development-Team-客户-供应商模式" class="headerlink" title="Customer/Supplier Development Team(客户/供应商模式)"></a>Customer/Supplier Development Team(客户/供应商模式)</h2><p>适用情况：</p>
<ol>
<li>一个子系统服务于另一个子系统；</li>
<li>下游很少向上游反馈信息，单向依赖；</li>
<li>两个子系统为完全不同的用户群服务。 </li>
</ol>
<p>上下游很自然得分割到两个Bounded Context中。</p>
<p>注意事项：</p>
<ul>
<li>上下游负责的两个团队的行政关系：最好有共同的直接上级；<br>原因：需要正式规定团队之间的关系、责任。<br>两者有工作依赖关系，相互制约，如果无法互相推动可能导致交付delay。 </li>
</ul>
<p><strong>测试</strong><br>两个团队一起开发自动验收测试，验证预期的接口。<br>降低耦合性。上游团队做出修改时不必担心对下游团队产生副作用。<br>(接力赛时前面的选手不能一直回头看，他需要相信队友能把棒准确交到他手中，否则整个团队的速度都会慢下来)</p>
<h2 id="Conformist-跟随者模式"><a href="#Conformist-跟随者模式" class="headerlink" title="Conformist(跟随者模式)"></a>Conformist(跟随者模式)</h2><p>适用情况：<br>依然是上下游关系，但没有共同直接上级。<br>(管理层次相隔很远，无法推动)</p>
<p>此时下游团队只能靠自己了，3种选择：</p>
<ol>
<li>放弃对上游的利用: Separete Way(独立自主模式)</li>
<li>Anticorruption Layer: (防护层模式)上游写得很烂，一边重构一边用；</li>
<li>Conformist: (跟随者模式)上游写得不错，拿过来进行增强即可。</li>
</ol>
<p>Conformist与Shared Kernel类似都是用了相同内核，但是Conformist中另一个团队对合作没有兴趣。</p>
<h2 id="Anticorruption-Layer-防护层模式"><a href="#Anticorruption-Layer-防护层模式" class="headerlink" title="Anticorruption Layer(防护层模式)"></a>Anticorruption Layer(防护层模式)</h2><p>适用情况：<br>遗留代码写得烂，或上游写得不行但重写代价太高时，只能一边写一边重构。</p>
<p>一般重构不要直接全盘否定，这样工作量太大不可能立即完成。</p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>Facade: 外观模式: 子系统可供替换的接口，方便切换新老实现；<br>Adapter: 适配器：把新老系统转换成相同的接口。</p>
<p>个人思考：<br>微服务级别的隔离，部分请求发给新服务（一切都要灰度测试）</p>
<h2 id="Separate-Way-独立自主模式"><a href="#Separate-Way-独立自主模式" class="headerlink" title="Separate Way(独立自主模式)"></a>Separate Way(独立自主模式)</h2><p>如果集成的收益很小，代价很高，可以考虑不集成。</p>
<h2 id="Open-Host-Service（开放主机服务）"><a href="#Open-Host-Service（开放主机服务）" class="headerlink" title="Open Host Service（开放主机服务）"></a>Open Host Service（开放主机服务）</h2><p>适用情况：<br>需要和大量其他系统集成时。</p>
<p>定义一个协议，使我们的系统可以作为一组Service供其它系统访问。<br>开放这个协议，让所有需要与我们系统集成的人都可以使用它。<br>当有新的集成需求时，增强并扩展这个协议。<br>（如果只是特殊需求，可以写个一次性的转换器，共享协议应该简单而且内聚）</p>
<h2 id="Published-Language-公共语言"><a href="#Published-Language-公共语言" class="headerlink" title="Published Language(公共语言)"></a>Published Language(公共语言)</h2><p>两个Bounded Context之间模型转换的时候，<br>交换信息时如果有共同语言(无歧义)能简化转换。<br>如Open Host Service模式中，如果能发明一种简单好理解的共享协议，别的系统就能快速接入。</p>
<p>公共语言可能是： XML,JSON…</p>
<h2 id="模型的集成统一"><a href="#模型的集成统一" class="headerlink" title="模型的集成统一"></a>模型的集成统一</h2><p>集成的过程中往往会出现互相冲突的领域模型。<br>因此要适当简化，宁可缺少喷水功能，也不要包含不正确的特性。</p>
<h2 id="Context的边界选择："><a href="#Context的边界选择：" class="headerlink" title="Context的边界选择："></a>Context的边界选择：</h2><p>大的Context适用情况:</p>
<ol>
<li>用一个统一的模型来处理时，用户任务之间流动更顺畅；</li>
<li>一个内聚模型比两个更容易理解；</li>
<li>两个模型转换很难；</li>
<li>共享语言可以使团队沟通起来更清楚。 </li>
</ol>
<p>小的Context适用情况：</p>
<ol>
<li>降低了开发之间的沟通开销；</li>
<li>降低规模后：持续集成更容易了；</li>
<li>太大的上下文需要更高级的抽象模型：相关技巧人员短缺；</li>
<li>不同模型满足一些特殊需求。</li>
</ol>
<h2 id="集成外部系统的经验"><a href="#集成外部系统的经验" class="headerlink" title="集成外部系统的经验"></a>集成外部系统的经验</h2><ol>
<li>首先考虑不集成：Seperate Way模式；</li>
<li>外部系统写得好：Conformist模式：</li>
<li>外部系统写得烂：Anticorruption Layer。</li>
</ol>
<img src="/images/2019-07/context_map2.png" class="" width="800" height="1200" title="context_map2">

<h1 id="第15章-精炼-Core-Domain"><a href="#第15章-精炼-Core-Domain" class="headerlink" title="第15章 精炼 (Core Domain)"></a>第15章 精炼 (Core Domain)</h1><p>领域驱动的核心是把领域层提取出来；<br>还可以进一步把领域层中最核心要解决的问题（项目的立项根因）提取出来：<br>Core Domain。 </p>
<p>核心思想：专注于核心问题，而不被大量次要问题所淹没。</p>
<p>精炼包括：</p>
<ol>
<li>帮助成员掌握系统的总体设计及协调；</li>
<li>找到一个适度规模的核心模型，加入到通用语言，促进沟通；</li>
<li>指导重构；</li>
<li>专注于模型中最有价值的部分；</li>
<li>指导外包、现成组件的使用以及任务委派。</li>
</ol>
<img src="/images/2019-07/refine.png" class="" width="800" height="1200" title="refine">

<h2 id="Core-Domain模式"><a href="#Core-Domain模式" class="headerlink" title="Core Domain模式"></a>Core Domain模式</h2><p>尽量压缩Core Domain，在Core Domain中努力开发深层模型和柔性设计。<br>(让最有才能的人来开发Core Domain，自主开发的软件的最大价值在于对Core Domain的完全控制。应该让最有才能的人+领域专家长期合作开发)</p>
<p>Domain Vision Statement: 领域前景说明<br>Highlighted Core : 突出的核心<br>Generic Subdomain: 通用子领域：模型中最普通不特别的部分；<br>Cohesive Mechanism: 内聚机制<br>Seperated Core: 隔离的核心：核心外的实现可替换<br>Abstract Core: 抽象内核：连核心的实现也是可替换的。</p>
<h2 id="Generic-Subdomain"><a href="#Generic-Subdomain" class="headerlink" title="Generic Subdomain"></a>Generic Subdomain</h2><p>通用子领域：与项目目标无直接联系，增加复杂性，不限于仅在本项目可以使用。（如数据库连接池这种纯技术的部分、带时区的日期和时间功能）</p>
<p>它们的解决方案：</p>
<ol>
<li>购买现成的；</li>
<li>使用开源的；</li>
<li>把实现外包出去；</li>
<li>内部实现它。</li>
</ol>
<h2 id="Domain-Vision-Statement领域前景说明-1页"><a href="#Domain-Vision-Statement领域前景说明-1页" class="headerlink" title="Domain Vision Statement领域前景说明(1页)"></a>Domain Vision Statement领域前景说明(1页)</h2><p>不涉及技术指标，但要把项目和其他项目区分开来。<br>描述支持的功能和目标。<br>（区别于某个版本的技术规格）</p>
<h2 id="Highlighted-Core-3-7页"><a href="#Highlighted-Core-3-7页" class="headerlink" title="Highlighted Core(3~7页)"></a>Highlighted Core(3~7页)</h2><p>在代码级完成Core Domain前，可以先文档级描述Core Domain。<br>描述Core Domain及内部元素的主要交互。<br>尽量精简。</p>
<h2 id="Cohesive-Mechanism-内聚机制"><a href="#Cohesive-Mechanism-内聚机制" class="headerlink" title="Cohesive Mechanism(内聚机制)"></a>Cohesive Mechanism(内聚机制)</h2><p>分离出去的代码要内聚，用Intention-revealing接口来公开功能。<br>从而留下更小的Core Domain。<br>（例如可以分离Specification对象(规格)）</p>
<p>Generic Subdomain与Cohesize Mechanism都是为Core domain减负。</p>
<h2 id="Segregated-Core-分离内核"><a href="#Segregated-Core-分离内核" class="headerlink" title="Segregated Core(分离内核)"></a>Segregated Core(分离内核)</h2><p>等到上述步骤完成，内核逐渐与其他部分分离开。<br>进一步重构，彻底去掉代码耦合，把内核分离出来。</p>
<h2 id="Abstract-Core-抽象内核"><a href="#Abstract-Core-抽象内核" class="headerlink" title="Abstract Core(抽象内核)"></a>Abstract Core(抽象内核)</h2><p>把模型中最基本的概念识别出来，分离到不同的类、抽象类、接口中。<br>详细的实现留在子领域定义的module中。</p>
<p><strong>综上</strong><br>重构时也应当优先重构Core Domain。</p>
<h1 id="第16章-大比例结构"><a href="#第16章-大比例结构" class="headerlink" title="第16章 大比例结构"></a>第16章 大比例结构</h1><p>前文：上下文（Bounded Context）,精炼(Core Domain/Generic Subdomain)<br>分离出很多Module后，要找一个类非常困难。<br>这个时候为了便于管理： 大比例结构(约4层)</p>
<img src="/images/2019-07/layer_struct.png" class="" width="800" height="1200" title="layer_struct">

<p>Evolving Order: 逐步进化演化。<br>System Metaphor: 隐喻思维；（用一些比喻、如防火墙）<br>Responsibility layer: 职责模式<br>Knowlege level: 知识级别模式；<br>Plugggable Component Framework: 解耦组件；</p>
<h2 id="System-Metaphor模式"><a href="#System-Metaphor模式" class="headerlink" title="System Metaphor模式"></a>System Metaphor模式</h2><p>隐喻模式。<br>例如核和外层的比喻，防火墙的比喻。<br>用比喻来分层。（但是宁缺毋滥）</p>
<h2 id="Responsibility-Layer职责分层模式"><a href="#Responsibility-Layer职责分层模式" class="headerlink" title="Responsibility Layer职责分层模式"></a>Responsibility Layer职责分层模式</h2><p>类似于MVC中Repository等，上层可以访问下层，下层则不能访问上层。<br>还可以根据访问频率、状态变化频率分层。</p>
<h2 id="运输系统-投资银行案例"><a href="#运输系统-投资银行案例" class="headerlink" title="运输系统/投资银行案例"></a>运输系统/投资银行案例</h2><p>作业层<br>能力层<br>决策支持层<br>潜能层<br>承诺层</p>
<img src="/images/2019-07/layer1.png" class="" width="800" height="1200" title="layer1">
<img src="/images/2019-07/layer2.png" class="" width="800" height="1200" title="layer2">
<p>（类似于Controller,logic,repository层等等）</p>
<h2 id="Knowledge-level知识级别模式"><a href="#Knowledge-level知识级别模式" class="headerlink" title="Knowledge level知识级别模式"></a>Knowledge level知识级别模式</h2><img src="/images/2019-07/knowledge_level.png" class="" width="800" height="1200" title="knowledge_level">
<p>与Reponsibily layer的区别在于两个层之间互相依赖。<br>案例用的是养老金分配的知识级别模式。<br>某些模型能根据元数据来工作，知识级别较高。</p>
<h2 id="Pluggable-Component-Framework"><a href="#Pluggable-Component-Framework" class="headerlink" title="Pluggable Component Framework"></a>Pluggable Component Framework</h2><p>一个中央hub上支持所需的协议，可以灵活替换组件。<br>这种模式一般是经过很长时间演变后产生。<br>（起码在Abstract Core之后）</p>
<h2 id="最小化"><a href="#最小化" class="headerlink" title="最小化"></a>最小化</h2><p>一开始使用最松散的System metaphor隐喻模式，逐渐深化。</p>
<h1 id="第17章-领域驱动设计的综合运用"><a href="#第17章-领域驱动设计的综合运用" class="headerlink" title="第17章 领域驱动设计的综合运用"></a>第17章 领域驱动设计的综合运用</h1><img src="/images/2019-07/domain_all.png" class="" width="800" height="1200" title="domain_all">
<p>综合使用前面的三点：<br>上下文、精炼、大比例结构。</p>
<h2 id="大比例结合上下文-bounded-context"><a href="#大比例结合上下文-bounded-context" class="headerlink" title="大比例结合上下文(bounded context)"></a>大比例结合上下文(bounded context)</h2><p>把不同bounded context放到不同层</p>
<h2 id="大比例结合精炼"><a href="#大比例结合精炼" class="headerlink" title="大比例结合精炼"></a>大比例结合精炼</h2><p>帮助理清Core Domain内部关系和Generic subdomain之间关系。<br>（放到不同层）</p>
<img src="/images/2019-07/layer_all2.png" class="" width="800" height="1200" title="layer_all2">
<p>大比例结合上下文后的图如上所示。</p>
<h2 id="战略设计决策的6个要点"><a href="#战略设计决策的6个要点" class="headerlink" title="战略设计决策的6个要点"></a>战略设计决策的6个要点</h2><ol>
<li>决策传达到整个团队；</li>
<li>决策过程收集反馈；</li>
<li>计划允许演变；</li>
<li>架构团队和开发团队都需要聪明人；</li>
<li>简约、谦逊原则；（不要对开发形成障碍）</li>
<li>对象职责专一而开发人员是多面手。</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://xiaoyue26.github.io/2019/07/22/2019-07/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1-%E7%AC%AC7-17%E7%AB%A0%E7%AC%94%E8%AE%B0/" data-id="ck96cxpq000j5maambbi918wj" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/DDD/" rel="tag">DDD</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AE%BE%E8%AE%A1/" rel="tag">设计</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-2019-07/hll算法原理" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/06/2019-07/hll%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86/" class="article-date">
  <time datetime="2019-07-06T09:19:23.000Z" itemprop="datePublished">2019-07-06</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/06/2019-07/hll%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86/">hll算法原理</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <h1 id="What-HLL-HyperLogLog是啥"><a href="#What-HLL-HyperLogLog是啥" class="headerlink" title="What: HLL/HyperLogLog是啥"></a>What: HLL/HyperLogLog是啥</h1><p>近似计算uv的算法,每一千万错误率0.5%.<br>谷歌改进后的算法为HLL++/HyperLogLog plus算法，改进了一些边界和精度问题（分类处理了稀疏和稠密的数据集情况，稀疏转化成稠密）。HLL++在边界条件下从1.5%优化到0.5%。而且不会出现突变高的错误率情况。</p>
<img src="/images/2019-07/hll_plus.png" class="" width="800" height="1200" title="hll_plus">

<p>论文:<br><a href="http://static.googleusercontent.com/media/research.google.com/en/us/pubs/archive/40671.pdf" target="_blank" rel="noopener">http://static.googleusercontent.com/media/research.google.com/en/us/pubs/archive/40671.pdf</a></p>
<h1 id="How-HLL原理"><a href="#How-HLL原理" class="headerlink" title="How: HLL原理"></a>How: HLL原理</h1><h2 id="n次伯努利"><a href="#n次伯努利" class="headerlink" title="n次伯努利"></a>n次伯努利</h2><p>进行了n次进行抛硬币实验，每次分别记录下第一次抛到正面的抛掷次数K1~Kn，那么可以用n次实验中最大的抛掷次数Kmax;<br>则可以预估实验组数量为n的预估值=2^Kmax.<br>参考:<br><a href="http://www.rainybowe.com/blog/2017/07/13/%E7%A5%9E%E5%A5%87%E7%9A%84HyperLogLog%E7%AE%97%E6%B3%95/index.html" target="_blank" rel="noopener">http://www.rainybowe.com/blog/2017/07/13/%E7%A5%9E%E5%A5%87%E7%9A%84HyperLogLog%E7%AE%97%E6%B3%95/index.html</a></p>
<h2 id="LC算法"><a href="#LC算法" class="headerlink" title="LC算法"></a>LC算法</h2><p>所有数据hash以后，从低位开始第一个1的位置K。<br>预估值为2^K.</p>
<h2 id="HLL算法"><a href="#HLL算法" class="headerlink" title="HLL算法"></a>HLL算法</h2><p>分桶后求调和平均，概率上减少异常。</p>
<h2 id="redis中的实现"><a href="#redis中的实现" class="headerlink" title="redis中的实现"></a>redis中的实现</h2><p>代码：<a href="https://github.com/antirez/redis/blob/unstable/src/hyperloglog.c" target="_blank" rel="noopener">https://github.com/antirez/redis/blob/unstable/src/hyperloglog.c</a><br>内存: 2^14个桶,每个桶6bit。(实际作为一个大数组12KB。)</p>
<ol>
<li>每个输入通过hash算法得出64bit哈希值x；</li>
<li>x的低14位,用来选择桶号(0-2^14-1号)Mi;</li>
<li>x的高50位,用来找K(也就是第一次出现1的位置，或者说0后缀的长度)，把K存入Mi。</li>
</ol>
<p>这样处理完所有用户输入后，用公式算出n的估计值:</p>
<img src="/images/2019-07/hll.png" class="" width="800" height="1200" title="hll">

<blockquote>
<p>对于第三点中的K,(也就是n次伯努利里的Kmax) (对于每个用户id的Kmax值存入桶的6位中)<br>高位剩下50位,第一个1的位置最大是50,而2^6=64，所以能够存下50这个数字(以及其他所有Kmax)。</p>
</blockquote>
<p>HLL++的话还要加入更多的边界调整。</p>
<h2 id="可视化模拟"><a href="#可视化模拟" class="headerlink" title="可视化模拟"></a>可视化模拟</h2><p><a href="http://content.research.neustar.biz/blog/hll.html" target="_blank" rel="noopener">http://content.research.neustar.biz/blog/hll.html</a><br>上述链接中是m=64个桶(4*16的方阵)，每个格子中存放一个十进制数，实际最大是2^6也就是64，如果新来了K值，则会和原来的K值做逻辑交运算。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://xiaoyue26.github.io/2019/07/06/2019-07/hll%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86/" data-id="ck96cxppy00ixmaam5scrc2mc" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hll/" rel="tag">hll</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hyperloglog/" rel="tag">hyperloglog</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li></ul>

    </footer>
  </div>
  
</article>
 


  


  <nav id="page-nav">
    <a class="extend prev" rel="prev" href="/page/3/">&amp;laquo; 上一页</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><a class="page-number" href="/page/6/">6</a><span class="space">&hellip;</span><a class="page-number" href="/page/22/">22</a><a class="extend next" rel="next" href="/page/5/">下一页&amp;raquo;</a>
  </nav>
</section>
           
    <aside id="sidebar">
  
    

  
    
  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title recent-posts">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/02/18/2022-02/%E6%8B%A5%E5%A1%9E%E7%AE%97%E6%B3%95bbr/">quic中的拥塞算法bbr</a>
          </li>
        
          <li>
            <a href="/2022/02/17/2022-02/http3-quic%E4%BC%98%E7%BC%BA%E7%82%B9%E5%8F%8A%E5%8E%9F%E5%9B%A0/">http3_quic优缺点及原因</a>
          </li>
        
          <li>
            <a href="/2022/02/16/2022-02/http-range/">http_range</a>
          </li>
        
          <li>
            <a href="/2022/01/21/2022-01/voip-rtc/">VoIP和RTC</a>
          </li>
        
          <li>
            <a href="/2021/07/26/2021-07/metaspace%E7%AC%94%E8%AE%B0/">metaspace笔记</a>
          </li>
        
      </ul>
    </div>
  </div>

  
    

  
</aside>

      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-left">
      &copy; 2014 - 2022 风梦七&nbsp;|&nbsp;
      主题 <a href="https://github.com/giscafer/hexo-theme-cafe/" target="_blank">Cafe</a>
    </div>
     <div id="footer-right">
      联系方式&nbsp;|&nbsp;296671657@qq.com
    </div>
  </div>
</footer>
 
<script src="/jquery/jquery.min.js"></script>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">首页</a>
  
    <a href="/archives" class="mobile-nav-link">归档</a>
  
    <a href="/about" class="mobile-nav-link">关于</a>
  
</nav>
    <img class="back-to-top-btn" src="/images/fly-to-top.png"/>
<script>
// Elevator script included on the page, already.
window.onload = function() {
  var elevator = new Elevator({
    selector:'.back-to-top-btn',
    element: document.querySelector('.back-to-top-btn'),
    duration: 1000 // milliseconds
  });
}
</script>
      

  
    <script>
      var cloudTieConfig = {
        url: document.location.href, 
        sourceId: "",
        productKey: "e2fb4051c49842688ce669e634bc983f",
        target: "cloud-tie-wrapper"
      };
    </script>
    <script src="https://img1.ws.126.net/f2e/tie/yun/sdk/loader.js"></script>
    

  







<!-- author:forvoid begin -->
<!-- author:forvoid begin -->

<!-- author:forvoid end -->

<!-- author:forvoid end -->


  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      })
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      })
    </script>
    <script type="text/javascript" src="https://cdn.rawgit.com/mathjax/MathJax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


 
<script src="/js/is.js"></script>



  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>


<script src="/js/elevator.js"></script>

  </div>
</body>
</html>