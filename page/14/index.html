<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>笔记本</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="笔记本">
<meta property="og:url" content="http://xiaoyue26.github.io/page/14/index.html">
<meta property="og:site_name" content="笔记本">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="风梦七">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="笔记本" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    
  
  
<link rel="stylesheet" href="/css/style.css">

  

<meta name="generator" content="Hexo 4.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    
    <div id="header-inner" class="inner">
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://xiaoyue26.github.io"></form>
      </div>
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">首页</a>
        
          <a class="main-nav-link" href="/archives">归档</a>
        
          <a class="main-nav-link" href="/about">关于</a>
        
      </nav>
      
    </div>
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">笔记本</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">风梦七</a>
        </h2>
      
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-2018-01/高性能Mysql笔记-第1章" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/01/14/2018-01/%E9%AB%98%E6%80%A7%E8%83%BDMysql%E7%AC%94%E8%AE%B0-%E7%AC%AC1%E7%AB%A0/" class="article-date">
  <time datetime="2018-01-14T10:16:46.000Z" itemprop="datePublished">2018-01-14</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/mysql/">mysql</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/01/14/2018-01/%E9%AB%98%E6%80%A7%E8%83%BDMysql%E7%AC%94%E8%AE%B0-%E7%AC%AC1%E7%AB%A0/">高性能Mysql笔记-第1章</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <h1 id="第一章-架构与历史"><a href="#第一章-架构与历史" class="headerlink" title="第一章 架构与历史"></a>第一章 架构与历史</h1><p>逻辑架构:<br>客户端<br>=&gt;连接/线程处理<br>=&gt;查询缓存/解析器<br>=&gt;优化器<br>=&gt;存储引擎. </p>
<p>其中只有innodb引擎会解析SQL中的外键定义.其他引擎不会解析SQL.<br>所有内容都应该同时关注两个层面的实现: 服务器层和存储引擎层.</p>
<h2 id="1-1-1-连接管理"><a href="#1-1-1-连接管理" class="headerlink" title="1.1.1 连接管理"></a>1.1.1 连接管理</h2><p>每个客户端连接都会在服务器进程中拥有一个线程,这个连接的查询只会在这个单独的线程中执行. 服务器会负责缓存线程,因此不需要为每个新连接创建或销毁线程.</p>
<h2 id="1-1-2-优化与执行"><a href="#1-1-2-优化与执行" class="headerlink" title="1.1.2 优化与执行"></a>1.1.2 优化与执行</h2><p>首先查询缓存中有没有,如果没有:</p>
<p>Mysql会解析查询,并创建内部数据结构(解析树),然后进行优化,包括重写查询,决定表的读取顺序以及选择合适的索引.</p>
<p>用户可以使用hint指令指导优化.</p>
<p>优化器并不关心底层存储引擎的具体实现,但会向底层存储引擎请求一些数据.</p>
<h2 id="1-2-并发控制"><a href="#1-2-并发控制" class="headerlink" title="1.2 并发控制"></a>1.2 并发控制</h2><h3 id="1-2-1-读写锁"><a href="#1-2-1-读写锁" class="headerlink" title="1.2.1 读写锁"></a>1.2.1 读写锁</h3><p>读锁: 共享锁,不干扰其他锁.<br>写锁: 排他锁,排除其他读写锁.</p>
<h3 id="1-2-2-锁粒度"><a href="#1-2-2-锁粒度" class="headerlink" title="1.2.2 锁粒度"></a>1.2.2 锁粒度</h3><ul>
<li><p>表锁<br>开销最小,但并发度低.<br>// ALTER TABLE语句都会使用表锁,不管底层引擎是什么.</p>
</li>
<li><p>行锁<br>最大程度的并发,但也有最大的锁开销. 由存储引擎各自实现.</p>
</li>
</ul>
<h2 id="1-3-事务"><a href="#1-3-事务" class="headerlink" title="1.3 事务"></a>1.3 事务</h2><p>基本流程:</p>
<ol>
<li>Start transaction;</li>
<li>执行一组SQL</li>
<li>commit. </li>
</ol>
<p>事务的4个指标(ACID):</p>
<ol>
<li>原子性: 要么全部成功,要么全部回滚.</li>
<li>一致性: 事务中间状态的修改不会保存到数据库中.(感觉和原子性有重合)</li>
<li>隔离性: 事务在最终提交之前,对其他事务是不可见的.</li>
<li>持久性: 一旦事务提交,修改就会永久保存到数据库中. </li>
</ol>
<h3 id="1-3-1-隔离级别"><a href="#1-3-1-隔离级别" class="headerlink" title="1.3.1 隔离级别"></a>1.3.1 隔离级别</h3><p>4种隔离级别(由低到高):<br><strong>1.Read uncommitted:</strong></p>
<blockquote>
<p>未提交读. 有脏读. 能读到别的事务还没commit的修改. 太弱, 基本不用.</p>
</blockquote>
<p><strong>2.Read committed</strong>  (Mysql以外的数据库默认级别)</p>
<blockquote>
<p>提交读. 一个事务的修改,提交前对其他事务不可见.<br>存在不可重复读问题.<br>比如如下流程:</p>
</blockquote>
<ol>
<li>A事务读V; </li>
<li>B事务提交V;</li>
<li>A事务读V.<br>由于B事务中间提交了一次,A事务两次读到的值不一样,也就是不可重复读.</li>
</ol>
<p><strong>3.Repeatable Read</strong> (Mysql默认级别)</p>
<blockquote>
<p>可重复读. 可以重复读单条记录. (方法,InnoDb增加多版本并发控制MVCC)<br>存在幻读问题.<br>比如如下流程:</p>
</blockquote>
<ol>
<li>A事务读范围行Vs;</li>
<li>B事务插入v到Vs中;</li>
<li>A事务读范围行Vs.<br>由于B事务中交提交了一次,A事务两次读到的范围行不一样,也就是幻读.<br>(可以用MVCC+间隙锁解决.)</li>
</ol>
<p><strong>4.Serialable</strong></p>
<blockquote>
<p>可串行化. 解决了幻读.<br>强制事务串行执行. 增加了每一行锁.</p>
</blockquote>
<p>总结问题:</p>
<blockquote>
<ol>
<li>未提交读: 脏读,不可重复读,幻读.</li>
<li>提交读:        不可重复读,幻读.</li>
<li>可重复读:                 幻读.</li>
<li>可串行:   慢.</li>
</ol>
</blockquote>
<p>mysql默认是可重复读,解决正确使用的幻读，使用MVCC+间隙锁;<br>MVCC:  解决两次快照读的幻读; (两次快照读一定一样)<br>间隙锁: 解决两次当前读的幻读; (两次当前读一定一样)</p>
<p>而，快照读和当前读的结果对于mysql的<code>可重复读</code>级别来说，可能结果不一样。<br>因此我们定义的正确使用: 程序￿员不应假设”快照读”和”当前读”的结果一样。</p>
<blockquote>
<p>快照读: select xxx<br>当前读: select xxx for update; 或者update/insert语句中隐含的读(基于当前数据库的数据状态)</p>
</blockquote>
<p>如果在最高隔离级别(串行)下，事务中的所有读都会被加上间歇锁，<br>因此保证了快照读和当前读的结果。// 也就是即使程序员不懂这方面知识、不正确使用，也能得到正确的结果。</p>
<h3 id="1-3-2-事务死锁"><a href="#1-3-2-事务死锁" class="headerlink" title="1.3.2 事务死锁"></a>1.3.2 事务死锁</h3><p>Innodb:<br>检查到死锁的循环依赖<br>=&gt;立即返回错误.</p>
<ul>
<li>处理死锁:<br>将持有最少行级写锁(排他锁)的事务进行回滚.</li>
</ul>
<h3 id="1-3-3-事务日志"><a href="#1-3-3-事务日志" class="headerlink" title="1.3.3 事务日志"></a>1.3.3 事务日志</h3><p><code>WAL(Write-Ahead Logging) 异步刷盘</code>.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. 数据追加写到日志里(顺序IO);</span><br><span class="line">2. 数据修改到原数据里. (随机IO).</span><br></pre></td></tr></table></figure>

<p>第二步如果失败崩溃,可以利用第一步的日志修复.</p>
<h3 id="1-3-4-Mysql中的事务"><a href="#1-3-4-Mysql中的事务" class="headerlink" title="1.3.4 Mysql中的事务"></a>1.3.4 Mysql中的事务</h3><p>Mysql事务型引擎: InnoDB, NDB Cluster. (MyIsam不支持事务)<br>第三方引擎: XtraDB,PBXT<br>InnoDb支持所有4个隔离级别.</p>
<p><strong>自动提交</strong><br>Mysql默认使用自动提交. 如果不显式得开始一个事务,每个查询都被当成一个独立的事务.</p>
<p>可能导致强制提交事务的命令:</p>
<ol>
<li>Alter Table</li>
<li>Lock Tables</li>
<li>其他导致大量数据更改的语句…</li>
</ol>
<p><strong>在事务中混合使用存储引擎(不推荐)</strong></p>
<ul>
<li>服务层: 不管理事务;</li>
<li>存储引擎: 具体实现事务.</li>
</ul>
<p>混合使用InnoDb,MyISAM: (事务型表+非事务型表)</p>
<blockquote>
<p>回滚时,非事务型表上的变更无法撤销, 导致数据库处于不一致状态.</p>
</blockquote>
<p><strong>隐式和显式锁定</strong><br>InnoDb采用两阶段锁定协议. </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">加锁: 事务执行过程中随时加锁;</span><br><span class="line">解锁: 仅当Commit或RollBack时.</span><br></pre></td></tr></table></figure>

<blockquote>
<p>隐式加锁: 存储引擎自动加锁<br>显式加锁: 明确指定语句: <code>Select ... Lock In Share Mode</code></p>
</blockquote>
<ul>
<li>tip<blockquote>
<p>尽量不要显式加锁,而是交给Innodb实现. 以避免无法预料的错误.<br>(除非研究得很深了.)</p>
</blockquote>
</li>
</ul>
<h2 id="1-4-多版本并发控制-MVCC"><a href="#1-4-多版本并发控制-MVCC" class="headerlink" title="1.4 多版本并发控制 MVCC"></a>1.4 多版本并发控制 MVCC</h2><p>MVCC: 行级锁的一个变种. 在很多情况下避免了加锁操作, 开销更低.<br>大多实现了非阻塞的读操作, 写操作只锁定必要的行.</p>
<ul>
<li>实现<br>每个事务开始的时候保存数据在某个时间点的快照.</li>
</ul>
<p><strong>InnoDb的MVCC</strong>(空间换时间,少加锁)</p>
<blockquote>
<p>每行记录后保存两个隐藏列: </p>
</blockquote>
<ol>
<li>行的创建系统版本号;</li>
<li>行的删除系统版本号.</li>
</ol>
<p>系统版本号反映了时间.<br>每开始一个新的事务,系统版本号都会递增.<br>事务开始时刻的系统版本号会作为事务的版本号,<br>用来和查询到的每行记录的版本号比较.</p>
<p>##Innodb的可重复读级别下<br><strong>Select</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. 创建版本号&lt;&#x3D;当前事务版本的数据;</span><br><span class="line">2. 删除版本号&gt;当前事务版本的数据 (或者没有删除).</span><br></pre></td></tr></table></figure>

<p><strong>Insert</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1. 插入新行,创建版本号&#x3D;当前事务版本号.</span><br></pre></td></tr></table></figure>

<p><strong>Delete</strong>(标记删)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. 删除的行,删除版本号&#x3D;当前事务版本号.</span><br><span class="line">(打标记,而不是真的删)</span><br></pre></td></tr></table></figure>

<p><strong>Update</strong>(标记删+插入新)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. 插入新行,创建版本号&#x3D;当前事务版本号.</span><br><span class="line">2. 原来的行,删除版本号&#x3D;当前事务版本号.</span><br></pre></td></tr></table></figure>

<h2 id="底层原理"><a href="#底层原理" class="headerlink" title="底层原理"></a>底层原理</h2><p>实际实现参见: <a href="https://liuzhengyang.github.io/2017/04/18/innodb-mvcc/" target="_blank" rel="noopener">https://liuzhengyang.github.io/2017/04/18/innodb-mvcc/</a><br>是将旧版本的行存在undo log中，如果没有依赖这部分undo log的事务结束了(提交或者回滚),<br>这部分undo log是会销毁的，因此不会造成永久的存储负担。</p>
<p>MVCC与隔离级别:</p>
<blockquote>
<ol>
<li>读未提交: 不使用MVCC;</li>
<li>读已提交: 使用MVCC; // 可能版本号条件不同</li>
<li>可重复读: 使用MVCC+当前读间隙锁; // 解决正确使用情况下的幻读 </li>
<li>可串行读: MVCC+快照读和当前读都有间隙锁. // 解决所有情况下的幻读</li>
</ol>
</blockquote>
<p>MVCC相当于乐观锁或者无锁、空间换时间；<br>间隙锁相当于悲观锁。真实地锁了索引。</p>
<h2 id="1-5-Mysql的存储引擎"><a href="#1-5-Mysql的存储引擎" class="headerlink" title="1.5 Mysql的存储引擎"></a>1.5 Mysql的存储引擎</h2><ul>
<li><p>每个数据库: 一个目录</p>
</li>
<li><p>每个数据表: </p>
</li>
</ul>
<ol>
<li><code>元数据</code>(表定义): 表同名的<code>.frm</code>文件; (服务层统一实现)</li>
<li><code>数据</code>;  (存储引擎分别实现)</li>
<li><code>索引</code>.  (存储引擎分别实现)</li>
</ol>
<h3 id="元数据-表定义具体内容"><a href="#元数据-表定义具体内容" class="headerlink" title="元数据(表定义具体内容)"></a>元数据(表定义具体内容)</h3><p>表的相关属性:</p>
<ul>
<li>Name</li>
<li>Engine</li>
<li>Row_format: </li>
</ul>
<ol>
<li>Dynamic: 行长度可变,包含Varchar或Blob的行.</li>
<li>Fixed: 只包含固定长度列.</li>
<li>Compressed: 压缩表.</li>
</ol>
<ul>
<li>Rows: 行数. Innodb:估算值. MyISAM: 精确值;</li>
<li>Index_length: 索引长度</li>
<li>Collcation: 默认字符集和字符排序规则.</li>
<li>其他信息…</li>
</ul>
<h3 id="1-5-1-InnoDB存储引擎"><a href="#1-5-1-InnoDB存储引擎" class="headerlink" title="1.5.1 InnoDB存储引擎"></a>1.5.1 InnoDB存储引擎</h3><p>设计目标: 大量短期事务.<br>Mysql主推引擎.</p>
<p><strong>存储</strong><br>数据: 表空间中,一系列数据文件组成.<br>索引: 表空间中,独立的索引文件.</p>
<p>隔离级别的实现:</p>
<ol>
<li>MVCC;</li>
<li>间隙锁: 不仅锁定查询涉及的行,还锁定索引中的间隙,防止幻读. </li>
</ol>
<p>存储格式:(跨平台)</p>
<ol>
<li>主键: 指向物理地址;</li>
<li>二级索引: 非主键索引,指向主键,所以主键应尽可能小. </li>
</ol>
<h2 id="MyISam"><a href="#MyISam" class="headerlink" title="MyISam"></a>MyISam</h2><p><strong>存储</strong></p>
<ol>
<li>数据: <code>.MYD</code></li>
<li>索引: <code>.MYI</code></li>
</ol>
<p>变长行: 默认最大数据量256TB,因为指向数据记录的指针长度是6B.<br>可以修改Max_Rows和Avg_row_length的值,来改变指针长度.<br>(两者相乘=表最大容量)</p>
<p><strong>并发</strong><br>整张表加锁.</p>
<p><strong>索引</strong><br>支持全文索引,基于分词创建的索引.</p>
<p><strong>压缩表</strong><br>不再修改的表可以进行压缩,提高查询性能,减少磁盘空间.</p>
<h3 id="1-5-3-其他引擎"><a href="#1-5-3-其他引擎" class="headerlink" title="1.5.3 其他引擎"></a>1.5.3 其他引擎</h3><p>Archive: 只支持插入和查询,不支持修改和删除.<br>BlackHole: 丢弃所有插入的数据,只记录日志. 有很多问题.<br>CSV: 存储CSV文件. (这个场景应该考虑使用Sql Server)<br>Federated: 访问其他Mysql服务器的代理,默认禁用.</p>
<ul>
<li>Memory: 磁盘只保存结构,数据在内存,重启后丢失数据.<br>使用场景: </li>
</ul>
<ol>
<li>查找或映射表;// 邮编和州名的映射表;</li>
<li>缓存周期性聚合数据;</li>
<li>保存数据分析中产生的中间数据.</li>
</ol>
<p>限制: </p>
<ol>
<li>表级锁;</li>
<li>只支持定长列, 如果指定了varchar,会转换成char. </li>
</ol>
<p>Merge引擎:<br>多个MyIsam表合并的虚拟表;<br>引入分区功能后弃用.</p>
<p>NDB引擎:<br>Mysql集群版.</p>
<h3 id="1-5-5-选择合适的引擎"><a href="#1-5-5-选择合适的引擎" class="headerlink" title="1.5.5 选择合适的引擎"></a>1.5.5 选择合适的引擎</h3><p>场景:</p>
<ol>
<li>全文索引: InnoDB + Sphinx</li>
<li>在线热备份: InnoDB</li>
<li>记录日志: MyISAM,Archive</li>
<li>10TB以下: InnoDB</li>
<li>10TB以上: InfoBright.</li>
<li>大部分情况优先考虑: Innodb</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://xiaoyue26.github.io/2018/01/14/2018-01/%E9%AB%98%E6%80%A7%E8%83%BDMysql%E7%AC%94%E8%AE%B0-%E7%AC%AC1%E7%AB%A0/" data-id="ck96cxpnv00ahmaam9sch1mtq" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/mysql/" rel="tag">mysql</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-2018-01/Netty-in-action笔记-第1-2章" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/01/13/2018-01/Netty-in-action%E7%AC%94%E8%AE%B0-%E7%AC%AC1-2%E7%AB%A0/" class="article-date">
  <time datetime="2018-01-13T14:16:24.000Z" itemprop="datePublished">2018-01-13</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/java/">java</a>►<a class="article-category-link" href="/categories/java/Netty/">Netty</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/01/13/2018-01/Netty-in-action%E7%AC%94%E8%AE%B0-%E7%AC%AC1-2%E7%AB%A0/">Netty in action笔记-第1-2章</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <p>Hadoop中用了Netty3,所以得看看这一块.<br>中文版的代码链接:<br><a href="https://github.com/ReactivePlatform/netty-in-action-cn" target="_blank" rel="noopener">https://github.com/ReactivePlatform/netty-in-action-cn</a></p>
<h1 id="第一章-Netty介绍"><a href="#第一章-Netty介绍" class="headerlink" title="第一章 Netty介绍"></a>第一章 Netty介绍</h1><p>这一章主要介绍了一下Netty.<br>Netty封装了Java NIO中的一些复杂的细节和坑.</p>
<h2 id="1-1-为什么使用Netty"><a href="#1-1-为什么使用Netty" class="headerlink" title="1.1 为什么使用Netty"></a>1.1 为什么使用Netty</h2><ol>
<li>Netty提供了高层次抽象来简化TCP/UDP服务器的编程.<br>用Netty可以实现FTP,SMTP,HTTP,WebSocket,SPDY.</li>
<li>Netty社区很活跃.</li>
</ol>
<h3 id="1-1-2-Netty框架的组成"><a href="#1-1-2-Netty框架的组成" class="headerlink" title="1.1.2 Netty框架的组成"></a>1.1.2 Netty框架的组成</h3><img src="/images/netty-chapter1.png" class="" width="400" height="600" title="Netty框架">

<h2 id="1-2-异步设计"><a href="#1-2-异步设计" class="headerlink" title="1.2 异步设计"></a>1.2 异步设计</h2><p>Netty中主要使用了回调+Future. </p>
<h3 id="1-2-1-回调"><a href="#1-2-1-回调" class="headerlink" title="1.2.1 回调"></a>1.2.1 回调</h3><p>异步处理的一种技术是回调. 就是在一些关心的事件上注册回调函数.<br>// 个人理解,回调应该是同步非阻塞.<br>// 同步: 客户端等待注册完成;<br>// 非阻塞: 服务端只是注册事件,返回得很快.</p>
<h3 id="1-2-2-Future"><a href="#1-2-2-Future" class="headerlink" title="1.2.2 Future"></a>1.2.2 Future</h3><p><code>java.util.concurrent</code>包中附带的Future接口.使用<code>Executor</code>异步执行.<br>每传递一个Runnable对象到<code>ExecutorService.submit()</code>方法就会得到一个回调的Future,能使用它检测是否执行完成.<br>// 个人理解,Future其实是异步阻塞.<br>// 异步: 客户端不等待服务端执行结束,拿到Future后,需要自己轮询结果.<br>// 阻塞: 服务端不会主动回调,只是提供一个查询接口.</p>
<h3 id="1-4-Netty相比NIO优点"><a href="#1-4-Netty相比NIO优点" class="headerlink" title="1.4 Netty相比NIO优点"></a>1.4 Netty相比NIO优点</h3><ol>
<li>兼容性和跨平台性进一步提高;</li>
<li>扩展ByteBuffer.<br><code>ByteBuffer</code>允许包装一个<code>byte[]</code>来获得一个实例,可以尽量减少内存拷贝.</li>
<li>消除NIO的内存泄漏(jdk1.7以上)<br>NIO对于缓存区的聚合和分散操作可能造成内存泄漏.</li>
</ol>
<ul>
<li><p>分散(Scatter)</p>
<blockquote>
<p>将<code>ScatteringByteBuffer</code>中的数据分散到多个<code>ByteBuffer</code>中.</p>
</blockquote>
</li>
<li><p>聚合(Gather)</p>
<blockquote>
<p>将多个<code>ByteBuffer</code>的数据聚合到<code>GatheringByteChannel</code>中.</p>
</blockquote>
</li>
</ul>
<ol start="4">
<li>解决epoll缺陷导致的100%cpu问题.</li>
</ol>
<h1 id="第二章-Netty核心概念-简单示例"><a href="#第二章-Netty核心概念-简单示例" class="headerlink" title="第二章 Netty核心概念,简单示例"></a>第二章 Netty核心概念,简单示例</h1><p>这章用的是Netty4.(但愿和Netty3同理)<br>上来先整了几段代码,而没有先说概念.<br>代码如下:<br><a href="https://github.com/xiaoyue26/netty-in-action-cn/blob/ChineseVersion/chapter2/Server/src/main/java/nia/chapter2/echoserver/EchoServer.java" target="_blank" rel="noopener">https://github.com/xiaoyue26/netty-in-action-cn/blob/ChineseVersion/chapter2/Server/src/main/java/nia/chapter2/echoserver/EchoServer.java</a></p>
<p>可以看出服务端和客户端代码很类似,大致套路是:</p>
<ol>
<li>创建一个EventLoopGroup;//类似于召集一群干活的(线程池)</li>
<li>创建一个Bootstrap(ServerBootstrap);// 类似于管家/控制面板</li>
<li>Bootstrap配置上eventGroup,channel用的类,端口地址,处理链.</li>
<li>绑定到端口开始工作. </li>
</ol>
<p>值得注意的是,所有涉及到Future的方法都是异步的,可以通过主动调用<code>sync</code>方法来进行同步等待.(当然也可以轮询)</p>
<ul>
<li>设计思想</li>
</ul>
<ol>
<li>在Bootstrap上使用Future;</li>
<li>在处理链上使用回调.</li>
</ol>
<ul>
<li>具体细节</li>
</ul>
<ol>
<li><code>ChannelInboundHandlerAdapter</code>:<br>处理完消息后需要释放资源;(<code>ByteBuf.release()</code>)</li>
<li><code>SimpleChannelInboundHandler</code>:<br>完成channelRead0后自动释放消息.</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://xiaoyue26.github.io/2018/01/13/2018-01/Netty-in-action%E7%AC%94%E8%AE%B0-%E7%AC%AC1-2%E7%AB%A0/" data-id="ck96cxpnm009cmaamc7dc0r1n" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/NIO/" rel="tag">NIO</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Netty/" rel="tag">Netty</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/" rel="tag">java</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-2018-01/java并发编程的艺术笔记-第二章" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/01/13/2018-01/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E7%AB%A0/" class="article-date">
  <time datetime="2018-01-13T13:29:19.000Z" itemprop="datePublished">2018-01-13</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/java/">java</a>►<a class="article-category-link" href="/categories/java/%E5%B9%B6%E5%8F%91/">并发</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/01/13/2018-01/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E7%AB%A0/">java并发编程的艺术笔记-第二章</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <h1 id="第二章-java并发机制的底层实现原理"><a href="#第二章-java并发机制的底层实现原理" class="headerlink" title="第二章 java并发机制的底层实现原理"></a>第二章 java并发机制的底层实现原理</h1><ul>
<li>java代码执行流程</li>
</ul>
<ol>
<li>java代码编译成class文件(字节码);</li>
<li>class被类加载器加载到JVM中;</li>
<li>JVM执行class,生成汇编码;</li>
<li>汇编码(转化成机器码/cpu指令)在cpu上执行.</li>
</ol>
<p>因此java并发机制的底层实现依赖于两个层面:</p>
<ol>
<li>class=&gt;汇编码过程中增加的指令;</li>
<li>并发相关cpu指令的具体执行过程. </li>
</ol>
<h2 id="2-1-volatile"><a href="#2-1-volatile" class="headerlink" title="2.1 volatile"></a>2.1 volatile</h2><ul>
<li><p>定义<br>可见性. 对于volatile变量,所有线程看到的值是一致的.<br>换句话说,某个线程对于volatile的修改能立即生效.</p>
</li>
<li><p>实现</p>
</li>
</ul>
<ol>
<li>class=&gt;指令: 增加Lock指令</li>
<li>Lock指令具体执行:<br>(1) 将当前cpu包含该值的缓存行写回内存;<br>(2) 在总线上通知其他cpu这个地址已发生更改,需要刷新缓存.<br>(缓存一致性协议)</li>
</ol>
<ul>
<li>相关优化<br>由于上述实现中的2(1)为:”将当前cpu包含该值的缓存行写回内存”,<br>换句话说,如果这个值跨行了,就会影响两行的数据,也就会导致两行的缓存失效,<br>其他cpu刷新缓存的数据量变成两倍.<br>因此尽量要把数据对齐到一行. (比如32位,64位)</li>
</ul>
<h2 id="2-2-synchronized"><a href="#2-2-synchronized" class="headerlink" title="2.2 synchronized"></a>2.2 synchronized</h2><p>内置锁,锁某个对象.(可以是当前实例对象或当前类对象)</p>
<ul>
<li>实现</li>
</ul>
<ol>
<li><p>class=&gt;指令:<br>增加:<br>进入同步块: monitorenter<br>离开同步块: monitorexit (正常离开或者异常)</p>
</li>
<li><p>cpu对这俩指令的执行书里没有细讲,只说了对象头里相关数据是怎么存的.</p>
</li>
</ol>
<h3 id="2-2-1-对象头中锁相关数据"><a href="#2-2-1-对象头中锁相关数据" class="headerlink" title="2.2.1 对象头中锁相关数据"></a>2.2.1 对象头中锁相关数据</h3><ul>
<li>对象头内容</li>
</ul>
<ol>
<li>Mark Word: hashCode/分代年龄/锁信息. </li>
<li>类元数据地址;</li>
<li>数组长度. // 如果是数组</li>
</ol>
<ul>
<li>不同锁标志的信息</li>
</ul>
<ol>
<li>轻量级锁: 指向栈中锁记录的指针;   // 锁标志00</li>
<li>重量级锁: 指向互斥量的指针    ;   // 锁标志10</li>
<li>GC标记  : 空;                     // 锁标志11</li>
<li>偏向锁  : 线程ID,epoch,分代年龄,1; // 锁标志01</li>
</ol>
<p>锁的4种状态: (锁只能升级,不能降级)</p>
<ol>
<li>无锁;</li>
<li>偏向锁: 一个线程使用该对象;</li>
<li>轻量级锁: 多个线程交替使用该对象;</li>
<li>重量级锁: 多个线程同时竞争该对象. </li>
</ol>
<p><strong>偏向锁</strong><br>HotSpot作者:<br>大多数情况下不存在多个线程竞争一个对象,这个时候可以优化让线程获得锁的代价更低.</p>
<ul>
<li>获取偏向锁流程</li>
</ul>
<ol>
<li>检查对象头里线程ID是不是自己或者是否无锁状态;</li>
<li>复制对象头中Mark Word到栈中;</li>
<li>在副本上写线程ID为自己ID;</li>
<li>CAS,用副本替换Mark Word,获得偏向锁. </li>
</ol>
<p>如果成功的话,下次进入同步块的时候,只要第1步能成功,就不再需要CAS操作了.<br>换句话说,这种场景下, 同一个线程可以重入同一个对象的锁,只有第一次需要CAS操作(代价比较大的操作).</p>
<ul>
<li>偏向锁的撤销(也就是对象头中存储的线程ID改掉)</li>
</ul>
<ol>
<li>别的线程也申请这个锁;</li>
<li>之前拥有锁的线程不存活=&gt; 对象头设置成无锁;</li>
<li>之前拥有锁的线程存活 =&gt; 锁升级.</li>
</ol>
<p><strong>轻量级锁</strong></p>
<ul>
<li>获取轻量级锁流程</li>
</ul>
<ol>
<li>检查</li>
<li>复制对象头中Mark word到栈中;</li>
<li>副本中写指向自己锁记录的指针;</li>
<li>CAS,用副本替换Mark word,获得偏向锁. </li>
</ol>
<p>如果第4步失败,尝试先不阻塞,使用自旋获取锁.(有可能已经拥有这个锁,试试看)<br>如果又失败,膨胀(升级)为重量级锁.</p>
<ul>
<li>轻量级锁的解锁</li>
</ul>
<ol>
<li>CAS还原复制的对象头.</li>
</ol>
<p>如果成功,就解锁;<br>如果失败,说明除了自己还有别人也改过对象头.膨胀为重量级锁.</p>
<p>对比:</p>
<ol>
<li>偏向锁: 打个自己的标记;</li>
<li>轻量级锁: 不阻塞,自旋重试;</li>
<li>重量级锁: 阻塞,等待唤醒.</li>
</ol>
<h2 id="2-3-原子操作实现原理"><a href="#2-3-原子操作实现原理" class="headerlink" title="2.3 原子操作实现原理"></a>2.3 原子操作实现原理</h2><ol>
<li>总线锁: 某个cpu用Lock指令锁总线,独占内存; // 开销大</li>
<li>缓存锁: 某个cpu修改内存地址,使其他cpu缓存无效.//开销小</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://xiaoyue26.github.io/2018/01/13/2018-01/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E7%AB%A0/" data-id="ck96cxpnt00a6maamda4y0a46" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/" rel="tag">java</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-2018-01/谷歌的一致性哈希算法" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/01/13/2018-01/%E8%B0%B7%E6%AD%8C%E7%9A%84%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95/" class="article-date">
  <time datetime="2018-01-13T03:18:36.000Z" itemprop="datePublished">2018-01-13</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/01/13/2018-01/%E8%B0%B7%E6%AD%8C%E7%9A%84%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95/">谷歌的一致性哈希算法</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <h1 id="jump-consistent-hash"><a href="#jump-consistent-hash" class="headerlink" title="jump consistent hash"></a>jump consistent hash</h1><p><code>jump consistent hash</code>是谷歌发表的一种一致性哈希算法.<br>空间复杂度: O(1);<br>时间复杂度: O(lgn).</p>
<h2 id="设计目标："><a href="#设计目标：" class="headerlink" title="设计目标："></a>设计目标：</h2><p>1.平衡性，把对象均匀地分布在所有桶中。(这个大部分哈希算法都能做到)<br>2.单调性，当桶的数量变化时，只需要把最少量的对象从旧桶移动到新桶，不需要做更多移动。比如原来是10个桶,增加了10个桶,只需要移动一半的对象就好了.<br>(更改算法的输入参数n,会有一半的对象依然映射到原来的桶里,有一半的对象映射到新的桶里.)</p>
<h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><p>记 <code>ch(key,num_buckets)</code> 为桶数量为<code>num_buckets</code>时的<code>hash</code>函数,返回分配的桶下标。</p>
<ul>
<li><p>num_buckets=1时:<br>由于只有1个桶，显而易见，对任意k，有<code>ch(k,1)==0</code>。</p>
</li>
<li><p>num_buckets=2时:<br>为了使hash的结果保持均匀，ch(k,2)的结果应该有占比1/2的结果保持为0，有1/2跳变为1。</p>
</li>
</ul>
<p>由此可以归纳，一般规律是：</p>
<blockquote>
<p><code>num_buckets</code>从<code>n</code>变化到<code>n+1</code>后，<br><code>ch(k,n+1)</code> 的结果中，应该有占比 <code>n/(n+1)</code> 的结果保持不变，<br>而有 <code>1/(n+1)</code> 跳变为 <code>n+1</code>。</p>
</blockquote>
<p>因此，我们可以用一个随机数生成器，来决定每次要不要跳变，并且让这个随机数生成器的状态仅仅依赖于<code>key</code>。所以就得到下面这个初步代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ch</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> num_buckets)</span> </span>&#123;</span><br><span class="line">    random.seed(key) ;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; num_buckets; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (random.next() &lt; <span class="number">1.0</span>/(j+<span class="number">1</span>) ) &#123;</span><br><span class="line">            b = j ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="算法正确性"><a href="#算法正确性" class="headerlink" title="算法正确性"></a>算法正确性</h2><p>(0-based)<br>n个桶,从0开始往n-2跳变(n-2次)，每次跳变的概率依次是<code>1/2</code>,<code>1/3</code>,<code>1/4</code>…<code>1/n</code>。<br>从而保证keys在每个桶分布的概率均匀。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">P(b&#x3D;0(初始值)) &#x3D;每次都不变&#x3D;1&#x2F;2*2&#x2F;3*3&#x2F;4...(n-2)&#x2F;(n-1)*(n-1)&#x2F;n&#x3D;1&#x2F;n;</span><br><span class="line">P(b&#x3D;1) &#x3D;1&#x2F;2(变)*2&#x2F;3(不变)*....&#x3D;1&#x2F;n;</span><br><span class="line">P(b&#x3D;2) &#x3D;1(变或者不变)*1&#x2F;3(变)*3&#x2F;4*...(n-1)&#x2F;n&#x3D;1&#x2F;n;</span><br><span class="line">P(b&#x3D;3) &#x3D;1(变或者不变)*1(变或者不变)*1&#x2F;4*4&#x2F;5...*(n-1)&#x2F;n&#x3D;1&#x2F;n;</span><br><span class="line">P(b&#x3D;k) &#x3D;1*1....1&#x2F;k(变)*k&#x2F;(k+1)...(n-1)&#x2F;n&#x3D;1&#x2F;n;</span><br><span class="line">P(b&#x3D;n-2) &#x3D;1&#x2F;n;</span><br><span class="line">P(b&#x3D;n-1) &#x3D;1- (上述所有的和)&#x3D;1-(n-1)&#x2F;(n-2)&#x3D;1&#x2F;n.</span><br></pre></td></tr></table></figure>

<h2 id="算法复杂度"><a href="#算法复杂度" class="headerlink" title="算法复杂度"></a>算法复杂度</h2><p>n为桶的数量的话,进行n-1次跳变判断,算法复杂度是O(n).</p>
<h1 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h1><h2 id="改进的思路"><a href="#改进的思路" class="headerlink" title="改进的思路"></a>改进的思路</h2><p>通过随机数，确定下一个跳变的j，而不是对每一个位置进行跳变判断。<br>因为跳变的概率从1/2开始一直在减少，所以依概率来说每次跳变的间隔大于1,所以计算下一个跳变值的次数少于n-1.</p>
<blockquote>
<p>定义P(b,j&gt;=i)的含义为: 当前跳变值为b时,下一个跳变值为j,j&gt;=i的概率. </p>
</blockquote>
<p>假设我们使用0-base的数组,则下标i位置不变的概率为: <code>(i+1)/(i+2)</code><br>下一个跳变值j&gt;=i时,也就是[b+1,i-2]区间内保持不变,因此有:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">P(b,j&gt;&#x3D;b)&#x3D;1 &#x2F;&#x2F;(显然下一个跳变值&gt;b)</span><br><span class="line">P(b,j&gt;&#x3D;b+1)&#x3D;1 &#x2F;&#x2F;(显然下一个跳变值&gt;&#x3D;b+1)</span><br><span class="line">P(b,j&gt;&#x3D;b+2)&#x3D;1*(b+1&#x2F;b+2)</span><br><span class="line">...</span><br><span class="line">P(b,j&gt;&#x3D;i)&#x3D; 1*(b+1&#x2F;b+2)*(b+2)&#x2F;(b+3)...(i-1)&#x2F;i &#x3D; (b+1)&#x2F;i</span><br></pre></td></tr></table></figure>

<p>假设有一个在[0,1]区间均匀分布的随机变量R,由于均匀分布的特性,R &lt; k的概率为 k.<br>(例如R&lt; 0.3的概率为0.3),P(R&lt;(b+1)/i)= (b+1)/i = P(j&gt;=i);</p>
<p>因此可以生成一个[0,1]范围的随机数r,规定r&lt;(b+1)/i的时候,就有j&gt;=i;<br>因此 i&lt;(b+1)/r. 由于对于任意的i都有j&gt;=i,因此:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">j&#x3D;floor( (b+1)&#x2F;r)，</span><br></pre></td></tr></table></figure>
<p>这样我们用一个随机数r得到了j。</p>
<p>改进后代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ch</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> num_buckets)</span> </span>&#123;</span><br><span class="line">    random.seed(key) ;</span><br><span class="line">    <span class="keyword">int</span> b = -<span class="number">1</span>; <span class="comment">//  上次跳变值</span></span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>; <span class="comment">// 这次跳变值</span></span><br><span class="line">    <span class="keyword">while</span>(j&lt;num_buckets)&#123;<span class="comment">// j不能超出范围</span></span><br><span class="line">        b=j; </span><br><span class="line">        <span class="keyword">double</span> r=random.next(); <span class="comment">//  0&lt;r&lt;1.0</span></span><br><span class="line">        j = floor( (b+<span class="number">1</span>) /r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中r为<code>[0,1]</code>区间的随机数(均匀分布)。<br>算法中使用了一个64位的线性同余随机数生成器。<br>结果分布的均匀性与输入<code>key</code>的分布无关，由伪随机数生成器的均匀性保证。<br>由于用的是伪随机数,生成器由<code>key</code>进行seed,因此能保证一致性.</p>
<h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>根据概率计算.<br>由于r平均为0.5,因此j平均来说是成倍增长的,因此改进后算法的平均时间复杂度为：<code>O(log(n))</code></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://xiaoyue26.github.io/2018/01/13/2018-01/%E8%B0%B7%E6%AD%8C%E7%9A%84%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95/" data-id="ck96cxpns00a2maam6rh0b1uq" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C/" rel="tag">一致性哈希</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-2018-01/java并发编程实战笔记-15-16章" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/01/07/2018-01/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0-15-16%E7%AB%A0/" class="article-date">
  <time datetime="2018-01-07T12:15:33.000Z" itemprop="datePublished">2018-01-07</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/java/">java</a>►<a class="article-category-link" href="/categories/java/%E5%B9%B6%E5%8F%91/">并发</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/01/07/2018-01/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0-15-16%E7%AB%A0/">java并发编程实战-15-16章</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <h1 id="第十五章-原子变量与非阻塞同步机制"><a href="#第十五章-原子变量与非阻塞同步机制" class="headerlink" title="第十五章 原子变量与非阻塞同步机制"></a>第十五章 原子变量与非阻塞同步机制</h1><p>并发包里的工具(如信号量<code>Semaphore</code>和<code>ConcurrentLinkedQueue</code>)<br>比<code>synchronized</code>性能更好,伸缩性更好.<br>原因是使用了<code>原子变量与非阻塞同步机制</code>.</p>
<p>非阻塞的底层: CAS操作. (compare and swap)<br>没有锁,<code>Lock free</code>,因此更接近完美.<br>因此没有活跃性问题.</p>
<h2 id="15-1-锁的劣势"><a href="#15-1-锁的劣势" class="headerlink" title="15.1 锁的劣势"></a>15.1 锁的劣势</h2><p>性能不行.</p>
<h2 id="15-2-硬件对并发的支持"><a href="#15-2-硬件对并发的支持" class="headerlink" title="15.2 硬件对并发的支持"></a>15.2 硬件对并发的支持</h2><p>独占锁: 基于悲观假设,不互斥的话会出事.(悲观锁)<br>乐观方法: 特殊指令: 包括, Test And Set , Fetch and Increment, CAS, 条件存储.</p>
<h2 id="15-2-CAS-比较并交换"><a href="#15-2-CAS-比较并交换" class="headerlink" title="15.2 CAS 比较并交换"></a>15.2 CAS 比较并交换</h2><p><code>CAS</code>包括三个操作数: 内存位置,旧值,新值.<br>//类似对应java中<code>map</code>的<code>replace</code>操作的三个操作数: key,旧值,新值.</p>
<p>CAS操作失败的线程不会挂,会获得失败信息.(同步非阻塞)<br>可以反复重试. (类似于<code>poll</code>的轮询)</p>
<p>CAS的缺点:<br>需要调用者自己处理竞争问题.// 重试,回退,放弃.<br>CAS实现的非阻塞算法通常比用锁写复杂一些.</p>
<h2 id="15-3-原子变量类"><a href="#15-3-原子变量类" class="headerlink" title="15.3 原子变量类"></a>15.3 原子变量类</h2><p>包括<code>AtomicInteger</code>等等.提供各种原子操作,如CAS,自增等.<br>它和一样保证写后读,但还保证内容是原子更新的.(比如两块内存看似一起更新)</p>
<ul>
<li>tip:<blockquote>
<p>原子变量类不适合作为容器的Key.<br>容器的Key一般要是Immutable对象.(如Integer,String)</p>
</blockquote>
</li>
</ul>
<h2 id="15-4-具体案例"><a href="#15-4-具体案例" class="headerlink" title="15.4 具体案例"></a>15.4 具体案例</h2><p>这一节用CAS实现了链表,栈,原子的域更新器.<br>需要看着源码学习.</p>
<h3 id="15-4-4-ABA问题"><a href="#15-4-4-ABA问题" class="headerlink" title="15.4.4 ABA问题"></a>15.4.4 ABA问题</h3><p>CAS(V,A,B)需要判断V位置是否为A,然后替换为B.<br>但如果V位置发生变化: A-&gt;B-&gt;A.<br>这样其实和我们希望的条件已经不同了,本质上是变化了,只不过值没变,版本号变了.<br>实例来说,就是链表节点引用没变,引用的值已经变了.</p>
<p>解决方案:<br>使用<code>AtomicStampedReference</code>(以及<code>AtomicMarkableReference</code>)支持在两个变量上执行原子的条件更新. </p>
<ul>
<li><p><code>AtomicStampedReference</code><br>[对象,引用]二元组,在引用上加上版本号. </p>
</li>
<li><p><code>AtomicMarkableReference</code><br>[对象引用,布尔值]二元组,可标记节点为已删除的节点.</p>
</li>
</ul>
<h1 id="第十六章-java内存模型"><a href="#第十六章-java内存模型" class="headerlink" title="第十六章 java内存模型"></a>第十六章 java内存模型</h1><h2 id="16-1-概念"><a href="#16-1-概念" class="headerlink" title="16.1 概念"></a>16.1 概念</h2><p>为了性能,会进行指令重排,预测执行等等.<br>内存模型: <code>JMM</code>.<br>内存模型规定,优化(重排)时应该遵守哪些约束.</p>
<ul>
<li>串行一致性:<br>如果约束够用,执行结果就会和串行一样.</li>
</ul>
<h2 id="16-1-1-平台的内存模型"><a href="#16-1-1-平台的内存模型" class="headerlink" title="16.1.1 平台的内存模型"></a>16.1.1 平台的内存模型</h2><p>平台给出内存模型,约束自己,向外界保证xx条件下会发生什么.<br>提供接口/指令: 如内存栅栏,提供协调存储的接口.</p>
<h2 id="16-1-3-JAVA内存模型"><a href="#16-1-3-JAVA内存模型" class="headerlink" title="16.1.3 JAVA内存模型"></a>16.1.3 JAVA内存模型</h2><ol>
<li>程序顺序: 同一个线程里按源码顺序执行;</li>
<li>监视器锁: 解锁会在加锁之前;(A线程释放了,B线程才能获得锁)</li>
<li>volatile: 写后读. (原子变量也是)</li>
<li>线程启动: Thread.start之后才会有run等其他操作发生.</li>
<li>中断规则: (1)A线程中断B线程;(2)B检测到中断. 保证(1)在(2)前面. </li>
<li>终结器:   构造函数在终结器之前执行完成.</li>
<li>传递性:   上述规则可以传递.</li>
</ol>
<p>1是针对单一线程的,2-7都是针对多个线程之间的代码顺序.<br>口诀: 程锁原线中终传. </p>
<h2 id="16-1-4-借助同步"><a href="#16-1-4-借助同步" class="headerlink" title="16.1.4 借助同步"></a>16.1.4 借助同步</h2><p>也就是借助上述7个已有的约束设计代码,达到同步效果.<br>比如我们平时用的锁,就是利用用了第二条,监视器锁规则.</p>
<p>类库中提供的约束:</p>
<ol>
<li>线程安全容器: 写后读. </li>
<li><code>CountDownLatch</code>: 倒数操作在await返回之前.</li>
<li><code>Semaphore</code>: PV操作,V释放在P获得之前. (别人释放了,你才能获得)</li>
<li><code>Future</code>: get返回之前,任务的代码会执行完.</li>
<li><code>Executor</code>: 提交任务操作,将在执行任务操作之前.</li>
<li><code>CyclicBarrier</code>: (1)线程A到达栅栏;(2)其他线程离开栅栏. (1)会在(2)前面.换句话说,大家伙会等线程A到了才离开.<br>… </li>
</ol>
<h2 id="16-2-发布"><a href="#16-2-发布" class="headerlink" title="16.2 发布"></a>16.2 发布</h2><p>错误示例:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@NotThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Resource resource;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Resource <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(resource==<span class="keyword">null</span>)&#123;<span class="comment">// 显然多个线程会在这里冲突.</span></span><br><span class="line">            resource=<span class="keyword">new</span> Resource();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> resource;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>安全但是慢:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Resource resource;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> Resource <span class="title">getInstance</span><span class="params">()</span></span>&#123;<span class="comment">// 方法级同步</span></span><br><span class="line">        <span class="keyword">if</span>(resource==<span class="keyword">null</span>)&#123;</span><br><span class="line">            resource=<span class="keyword">new</span> Resource();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> resource;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>直接静态初始化:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">C</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Resource resource=<span class="keyword">new</span> Resource();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Resource <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> resource;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>占位符技术: 延迟静态初始化:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">D</span></span>&#123; </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ResourceHolder</span></span>&#123; <span class="comment">// 懒汉,完美. </span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> Resource resource=<span class="keyword">new</span> Resource();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Resource <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ResourceHolder.resource;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>双检(DCL): 不推荐. 慢,繁琐. </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">E</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Resource resource; <span class="comment">// volatile</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Resource <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(resource==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(E<span class="class">.<span class="keyword">class</span>)</span>&#123; <span class="comment">// Class对象锁.</span></span><br><span class="line">                <span class="keyword">if</span>(resource==<span class="keyword">null</span>)&#123;</span><br><span class="line">                    resource=<span class="keyword">new</span> Resource();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> resource;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 之所以需要volatile,是为了保证resource变量的写操作立即刷新到内存,起码在读之前. (StoreLoad屏障)</span></span><br></pre></td></tr></table></figure>



<h2 id="初始化安全域"><a href="#初始化安全域" class="headerlink" title="初始化安全域:"></a>初始化安全域:</h2><p>对象的初始引用不会被重排序到构造函数之前.</p>
<ul>
<li><code>final</code>:<br><code>final</code>域能够安全发布,通过<code>final</code>域可达的变量\容器的写入操作安全发布.</li>
</ul>
<p>示例:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SafeStates</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String,String&gt;States;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SafeStates</span><span class="params">()</span></span>&#123;</span><br><span class="line">        states= <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        states.put(<span class="string">"alaska"</span>,<span class="string">"AK"</span>);</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getV</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> states.get(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>线程A创建的SafeStates对象,线程B能安全得访问getV方法.</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://xiaoyue26.github.io/2018/01/07/2018-01/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0-15-16%E7%AB%A0/" data-id="ck96cxpnp009omaam6pwnfbf3" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/" rel="tag">java</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-2018-01/java并发编程实战笔记-10-11章" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/01/04/2018-01/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0-10-11%E7%AB%A0/" class="article-date">
  <time datetime="2018-01-04T14:28:55.000Z" itemprop="datePublished">2018-01-04</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/java/">java</a>►<a class="article-category-link" href="/categories/java/%E5%B9%B6%E5%8F%91/">并发</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/01/04/2018-01/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0-10-11%E7%AB%A0/">java并发编程实战笔记-10-11章</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <p>第十章主要介绍活跃性危险,也就是安全性和活跃性的权衡.锁不多不少.<br>安全性: 就是正确性.锁要够多,不然数据并发访问就错了.<br>活跃性: 就是性能.  锁不能太多,死锁了,或者太卡了.  </p>
<h1 id="10-1-死锁"><a href="#10-1-死锁" class="headerlink" title="10.1 死锁"></a>10.1 死锁</h1><p>哲学家问题: 循环等待死锁.<br>数据库服务器如何解决事务死锁:</p>
<blockquote>
<ol>
<li>检测到等待关系有向图有环;</li>
<li>选一个牺牲者kill了. </li>
<li>应用程序自己重试被kill的事务.</li>
</ol>
</blockquote>
<h2 id="10-1-1-锁顺序死锁"><a href="#10-1-1-锁顺序死锁" class="headerlink" title="10.1.1 锁顺序死锁"></a>10.1.1 锁顺序死锁</h2><p>避免死锁的手段1:</p>
<blockquote>
<p>控制获取锁的顺序.</p>
</blockquote>
<p>如果所有线程获取锁(资源)的顺序一样,就不会死锁. </p>
<h2 id="10-1-2-动态的锁顺序死锁"><a href="#10-1-2-动态的锁顺序死锁" class="headerlink" title="10.1.2 动态的锁顺序死锁"></a>10.1.2 动态的锁顺序死锁</h2><p>锁顺序很难处理. 比如两个账户转账.<br>一种方法是使用俩账户的hash码,比较顺序.<br>当遇到hash码冲突的时候,使用加时赛:</p>
<blockquote>
<ol>
<li>定义一个新的锁;</li>
<li>冲突的线程轮流申请这个锁,然后再申请账户锁.</li>
</ol>
</blockquote>
<p>相当于冲突的线程串行执行.</p>
<p>(其实我觉得对于这个问题,账户肯定有唯一id,用id排序就好了.)</p>
<h2 id="10-1-3-协作对象之间的死锁"><a href="#10-1-3-协作对象之间的死锁" class="headerlink" title="10.1.3 协作对象之间的死锁"></a>10.1.3 协作对象之间的死锁</h2><p>如果获取多个锁的操作不在唯一的同一个方法里, 问题变得麻烦.<br>成因:<br>方法1: 持有锁时调用外部方法,而外部方法请求了另一个锁.<br>方法2: 同上.</p>
<p>方法1,方法2获取锁的顺序相反时,可能死锁.</p>
<p>解决方法:<br>收缩<code>synchronized</code>的范围从方法级缩小到块级.</p>
<h2 id="10-1-4-开放调用"><a href="#10-1-4-开放调用" class="headerlink" title="10.1.4 开放调用"></a>10.1.4 开放调用</h2><p>开放调用: 调用方法时不需要持有锁.<br>也就是方法上没有加<code>synchronized</code>,而是在里头某一个块里用了.</p>
<h2 id="10-1-5-资源死锁"><a href="#10-1-5-资源死锁" class="headerlink" title="10.1.5 资源死锁"></a>10.1.5 资源死锁</h2><p>资源不够死锁. 如线程资源\数据库连接资源.</p>
<ul>
<li>解决方案:<br>书里没写, 我觉得可以考虑前文说的”选取牺牲者”方法.</li>
</ul>
<h1 id="10-2-死锁的避免与诊断"><a href="#10-2-死锁的避免与诊断" class="headerlink" title="10.2 死锁的避免与诊断"></a>10.2 死锁的避免与诊断</h1><ol>
<li>每个线程只获取一个锁. //比较不现实,涉及原子性的实现.</li>
<li>顺序获取.</li>
<li>支持定时的锁. // 代替内置锁</li>
</ol>
<h2 id="10-2-2-死锁的诊断"><a href="#10-2-2-死锁的诊断" class="headerlink" title="10.2.2 死锁的诊断"></a>10.2.2 死锁的诊断</h2><p>通过Thread Dump信息.<br>方法: 向JVM发送SIGQUIT信号.<br>命令行:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kill -3 [id]</span><br></pre></td></tr></table></figure>
<p>jdk1.5: 有内置锁信息, 无显式锁信息;<br>jdk1.6: 有内置锁信息, 少量显式锁信息.<br>(?那岂不是意味着尽量不要使用显式锁?)</p>
<h1 id="10-3-其他活跃性危险"><a href="#10-3-其他活跃性危险" class="headerlink" title="10.3 其他活跃性危险"></a>10.3 其他活跃性危险</h1><p>活跃性危险: 太卡<br>包括: 死锁,饥饿,丢失信号,活锁.</p>
<h2 id="10-3-1-饥饿"><a href="#10-3-1-饥饿" class="headerlink" title="10.3.1 饥饿"></a>10.3.1 饥饿</h2><p>如短作业优先调度的时候,长作业就会饥饿.</p>
<h2 id="10-3-2-糟糕的响应性"><a href="#10-3-2-糟糕的响应性" class="headerlink" title="10.3.2 糟糕的响应性"></a>10.3.2 糟糕的响应性</h2><p>GUI线程优先级太低, 响应性就会差.</p>
<h2 id="10-3-3-活锁"><a href="#10-3-3-活锁" class="headerlink" title="10.3.3 活锁"></a>10.3.3 活锁</h2><p>重复的失败.<br>如线程不停得获取锁,释放锁,似乎能完成,但其实总也完成不了,无间地狱,死循环.</p>
<ul>
<li>案例1: 华龙道<br>发数据包碰撞. 重试算法一样,总是在相同的路口再碰撞.<br>解决方法:<br>增加随机性. 重试时间加一个随机参数.</li>
</ul>
<ul>
<li>案例2:<br>过度的错误恢复.<br>解决方法:<br>不过度.</li>
</ul>
<h1 id="第十一章-性能与可伸缩性"><a href="#第十一章-性能与可伸缩性" class="headerlink" title="第十一章 性能与可伸缩性"></a>第十一章 性能与可伸缩性</h1><p>线程的使用<br>目的: 提高性能.<br>缺陷: 提高复杂性.<br>场景: 多cpu系统,任务不是cpu密集的.<br>衡量手段: 看cpu使用情况图.</p>
<h2 id="11-1-1-可伸缩性"><a href="#11-1-1-可伸缩性" class="headerlink" title="11.1.1 可伸缩性"></a>11.1.1 可伸缩性</h2><p>可伸缩性: 当增加资源时(cpu,内存等等),程序吞吐量/处理能力增加比例适中.</p>
<p>可伸缩性与性能往往矛盾.<br>单线程的性能优化方法 往往导致=&gt; 可伸缩性下降. </p>
<h2 id="11-2-Amdahl定律"><a href="#11-2-Amdahl定律" class="headerlink" title="11.2 Amdahl定律"></a>11.2 Amdahl定律</h2><p>增加计算资源时,程序理论上能实现的最高加速比.</p>
<p>Speedup &lt;= 1/ ( F + (1-F)/N )<br>N: N个处理器<br>F: 必须串行的任务比例. </p>
<p>N趋近于无穷大时,加速比为 1/F.<br>(F为50%时,加速比最大为2.)</p>
<p>提高可伸缩性方法总结:</p>
<ol>
<li>缩小锁的粒度;</li>
<li>减少锁的持有时间(好像和上一条差不多);</li>
<li>尽量使用非独占锁. </li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://xiaoyue26.github.io/2018/01/04/2018-01/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0-10-11%E7%AB%A0/" data-id="ck96cxpnr009wmaam63sqf43c" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/" rel="tag">java</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-2018-01/java并发编程实战笔记-8章" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/01/01/2018-01/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0-8%E7%AB%A0/" class="article-date">
  <time datetime="2018-01-01T07:34:18.000Z" itemprop="datePublished">2018-01-01</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/java/">java</a>►<a class="article-category-link" href="/categories/java/%E5%B9%B6%E5%8F%91/">并发</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/01/01/2018-01/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0-8%E7%AB%A0/">java并发编程实战笔记-8章</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <h1 id="线程池的使用"><a href="#线程池的使用" class="headerlink" title="线程池的使用"></a>线程池的使用</h1><p>这章介绍实际应用中配置调优的一些高级选项. 以及各种坑.</p>
<h1 id="8-1-任务与执行策略的隐形耦合"><a href="#8-1-任务与执行策略的隐形耦合" class="headerlink" title="8.1  任务与执行策略的隐形耦合"></a>8.1  任务与执行策略的隐形耦合</h1><p>有些任务需要指定执行策略:</p>
<ol>
<li>依赖性任务: 就是任务之间不独立</li>
<li>线程不封闭的: 就是只能单线程跑的.</li>
<li>对响应时间敏感的: 如GUI. </li>
<li>使用ThreadLocal的: 线程池会重用线程. 因此可能有风险.</li>
</ol>
<h2 id="8-1-1-死锁"><a href="#8-1-1-死锁" class="headerlink" title="8.1.1 死锁"></a>8.1.1 死锁</h2><p>有界线程池不能无限提交. 如果里头的任务都死锁了,线程池也死锁了.</p>
<h2 id="8-1-2-响应时间"><a href="#8-1-2-响应时间" class="headerlink" title="8.1.2 响应时间"></a>8.1.2 响应时间</h2><p>如果任务都很慢,线程池的响应时间自然也慢.<br>可以限时或者增大线程池容量.</p>
<h1 id="8-2-线程池大小公式"><a href="#8-2-线程池大小公式" class="headerlink" title="8.2 线程池大小公式"></a>8.2 线程池大小公式</h1><p>N = cpu数量 = Runtime.getRuntime().availableProcessors();<br>U = 目标cpu利用率<br>W/C= 等待时间和执行时间的比率 (响应度)<br>SIZE = N*U/(1+W/C) </p>
<h1 id="8-3-配置ThreadPoolExecutor"><a href="#8-3-配置ThreadPoolExecutor" class="headerlink" title="8.3 配置ThreadPoolExecutor"></a>8.3 配置ThreadPoolExecutor</h1><p>可以通过Executors获取jdk设计好的一些线程池实现.</p>
<h2 id="8-3-1-线程的创建与取消"><a href="#8-3-1-线程的创建与取消" class="headerlink" title="8.3.1 线程的创建与取消"></a>8.3.1 线程的创建与取消</h2><p>基本大小: 没有任务时候的线程大小.<br>最大大小: 上限.<br>存活时间: 线程空闲时间达到存活时间,则被回收.</p>
<h2 id="8-3-2-管理队列任务"><a href="#8-3-2-管理队列任务" class="headerlink" title="8.3.2 管理队列任务"></a>8.3.2 管理队列任务</h2><p>线程池满了以后,提交的任务进入等待队列.<br>newFixedThreadPool: 无界等待队列 LinkedBlockingQueue<br>newSingleThreadExecutor: 无界等待队列 LinkedBlockingQueue</p>
<p>有界等待队列的话,需要饱和策略. </p>
<h2 id="8-3-3-饱和策略"><a href="#8-3-3-饱和策略" class="headerlink" title="8.3.3 饱和策略"></a>8.3.3 饱和策略</h2><ol>
<li>中止(默认): abort. 抛异常.</li>
<li>调用者运行: 让主线程自己干. 拥塞会外延到TCP层. </li>
<li>丢弃: 抛弃该任务. 不抛异常.</li>
<li>丢弃最老: 丢弃下一个将要执行的.(如果用了优先级队列,就是抛弃优先级最高的,会造成错误.)</li>
</ol>
<h1 id="8-4-扩展ThreadPoolExecutor"><a href="#8-4-扩展ThreadPoolExecutor" class="headerlink" title="8.4 扩展ThreadPoolExecutor"></a>8.4 扩展ThreadPoolExecutor</h1><p>需要实际需求和应用案例才能学会. </p>
<h1 id="8-5-递归算法的并行化"><a href="#8-5-递归算法的并行化" class="headerlink" title="8.5 递归算法的并行化"></a>8.5 递归算法的并行化</h1><p>首先循环可以并行化:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">final</span> Ele e: eles)&#123;</span><br><span class="line">    exec.execute(</span><br><span class="line">    <span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;process(e);&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>递归也一样, 遍历依然是递归的, 但把每一个节点的计算收集到线程池中,异步计算.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dfs(node,exec,results)&#123;</span><br><span class="line"> exec.execute(...);</span><br><span class="line"> dfs(node.children());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>第九章是图形界面,略过.</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://xiaoyue26.github.io/2018/01/01/2018-01/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0-8%E7%AB%A0/" data-id="ck96cxpnu00aemaam6euicert" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/" rel="tag">java</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-2017-12/hive调优之数据倾斜" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/12/26/2017-12/hive%E8%B0%83%E4%BC%98%E4%B9%8B%E6%95%B0%E6%8D%AE%E5%80%BE%E6%96%9C/" class="article-date">
  <time datetime="2017-12-26T11:35:00.000Z" itemprop="datePublished">2017-12-26</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/hadoop/">hadoop</a>►<a class="article-category-link" href="/categories/hadoop/hive/">hive</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/12/26/2017-12/hive%E8%B0%83%E4%BC%98%E4%B9%8B%E6%95%B0%E6%8D%AE%E5%80%BE%E6%96%9C/">hive调优之数据倾斜</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <p>上一篇中记录了hive调优的一些常规手段. 但对于某些数据集, 常规手段是无能为力的, 例如数据倾斜时.</p>
<p>对于hive而言,数据倾斜就是某个reducer跑得特别慢,这一点可以从日志中reducer开在99%或某个值很久看出,也可以从web ui中查看:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">运行后:</span><br><span class="line">http:&#x2F;&#x2F;xxx:19888&#x2F;jobhistory&#x2F;tasks&#x2F;job_1472710912354_3070682&#x2F;r</span><br><span class="line">运行前:</span><br><span class="line">http:&#x2F;&#x2F;xxx:8088&#x2F;proxy&#x2F;application_1472710912354_3070684&#x2F;mapreduce&#x2F;tasks&#x2F;job_1472710912354_3070684&#x2F;r</span><br></pre></td></tr></table></figure>
<p>如果具体看日志的话,会发现大部分时间在进行外排.<br>对于这种任务最重要的是消除外排,有如下几种优化手段:</p>
<h2 id="1-加内存"><a href="#1-加内存" class="headerlink" title="1. 加内存"></a>1. 加内存</h2><p>最简单粗暴就是给reduce加内存了. 让它别外排:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> mapreduce.reduce.memory.mb=<span class="number">10240</span>;</span><br></pre></td></tr></table></figure>
<p>类似的,如果mapper内存不够,可以减小每个mapper处理的数据量,增大mapper的数量:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> mapreduce.input.fileinputformat.split.maxsize=<span class="number">64000000</span>;</span><br></pre></td></tr></table></figure>

<h2 id="2-倾斜key单独处理"><a href="#2-倾斜key单独处理" class="headerlink" title="2. 倾斜key单独处理"></a>2. 倾斜key单独处理</h2><p>第二种手段也比较简单, 就是把出现倾斜的key找出来,假如很少的话,可以把它们摘出来,单独处理(或遗弃). 开启hive自动消除数据倾斜:(效果有效)</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> hive.optimize.skewjoin = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">set</span> hive.skewjoin.key=<span class="number">1000</span>;</span><br><span class="line"><span class="keyword">set</span> hive.groupby.skewindata=<span class="literal">true</span>;</span><br><span class="line"><span class="keyword">set</span> hive.groupby.mapaggr.checkinterval=<span class="number">100</span>;</span><br></pre></td></tr></table></figure>

<h2 id="3-局部聚合-1-相同value聚合"><a href="#3-局部聚合-1-相同value聚合" class="headerlink" title="3. 局部聚合(1): 相同value聚合"></a>3. 局部聚合(1): 相同value聚合</h2><p>(没有什么优化是增加一个阶段不能解决的.如果有,就再加一个阶段)<br>为了减少最后汇聚到reducer上的数据量,可以在之前增加一个阶段,对某个key的数据进行局部聚合. </p>
<p>以某次需求为例,需要求各个省市区维度下的丢包率\延迟的50,90,99分位数.数据量每天200G. 分位数计算极其耗时, 尤其是计算周统计数据时, 数据量达到TB级. </p>
<p>在使用了前一篇优化笔记手段以及上述手段后,依然耗时4小时.原来查询最耗时的部分如下:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span>  es</span><br><span class="line">       ,province</span><br><span class="line">       ,city</span><br><span class="line">       ,ipOprator</span><br><span class="line">       ,percentile(xxx,<span class="number">0.5</span>,<span class="number">0.9</span>,<span class="number">0.99</span>)</span><br><span class="line"><span class="keyword">FROM</span> ttt</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> es,province,ipOprator <span class="keyword">with</span> <span class="keyword">cube</span></span><br></pre></td></tr></table></figure>
<p>查看hive的percentile源码实现,其对于同一个key的处理逻辑大致这么几步:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(依次输入每个value)</span><br><span class="line">1. O(n)</span><br><span class="line">把所有value放进一个Map&lt;value,LongWriteable&gt;里,相同的value则增加map中的计数值;</span><br><span class="line">2. O(nlogn)</span><br><span class="line">在reduce中把map中的所有entry放入一个List中,然后对List根据value值进行全排序(&#96;Collections.sort(entriesList, new MyComparator());&#96;);</span><br><span class="line">3. O(n)</span><br><span class="line">从头开始扫一遍上一步的List, 根据计数器的值总和,分位数,定位到对应的分位数,返回.</span><br></pre></td></tr></table></figure>
<p>将其重写为可以进行局部聚合, 从而略去第一步:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span>  es</span><br><span class="line">       ,province</span><br><span class="line">       ,city</span><br><span class="line">       ,ipOprator</span><br><span class="line">      ,percent_new(c1,<span class="keyword">num</span>,<span class="number">0.5</span>,<span class="number">0.9</span>,<span class="number">0.99</span>)</span><br><span class="line"><span class="keyword">FROM</span> (<span class="keyword">select</span> es,province,ipOprator,c1,<span class="keyword">count</span>(<span class="number">1</span>) <span class="keyword">as</span> <span class="keyword">num</span></span><br><span class="line">    <span class="keyword">FROM</span> xxx</span><br><span class="line">    <span class="keyword">GROUP</span> <span class="keyword">BY</span> es,province,ipOprator,c1</span><br><span class="line">) <span class="keyword">as</span> t </span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> es,province,ipOprator <span class="keyword">with</span> <span class="keyword">cube</span></span><br></pre></td></tr></table></figure>
<p>优化后,时间缩短到30分钟.</p>
<ul>
<li>TODO:<br>优化第二步中的全排序. </li>
</ul>
<h2 id="4-局部聚合2-相同key聚合"><a href="#4-局部聚合2-相同key聚合" class="headerlink" title="4. 局部聚合2: 相同key聚合"></a>4. 局部聚合2: 相同key聚合</h2><p>由于上一案例中的聚合函数是分位数计算,聚合的粒度只能达到相同value聚合,对于其他聚合函数,如最大值,最小值等,如果语义上能对相同key先聚合,问题的规模就可以进一步缩小. 方法是先把相同key的数据分拆成不同的key,加上前缀或后缀 如:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">key -&gt; key_1</span><br><span class="line">key -&gt; key_2</span><br><span class="line">...</span><br><span class="line">key -&gt; key_10</span><br></pre></td></tr></table></figure>
<p>分拆的数量等于并行度,取决于原有的数据集, 然后先进行一阶段聚合,最后去掉前缀后缀,再进行一次聚合得到最后的结果.<br>这种方法的关键就是要求同一个key的聚合计算可以分拆.</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://xiaoyue26.github.io/2017/12/26/2017-12/hive%E8%B0%83%E4%BC%98%E4%B9%8B%E6%95%B0%E6%8D%AE%E5%80%BE%E6%96%9C/" data-id="ck96cxpnk0090maam4d5qhboj" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hive/" rel="tag">hive</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-2017-12/hive调优" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/12/25/2017-12/hive%E8%B0%83%E4%BC%98/" class="article-date">
  <time datetime="2017-12-25T08:45:15.000Z" itemprop="datePublished">2017-12-25</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/hadoop/">hadoop</a>►<a class="article-category-link" href="/categories/hadoop/hive/">hive</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/12/25/2017-12/hive%E8%B0%83%E4%BC%98/">hive sql调优</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <p>这里记录一下hive任务调优的三(n)板斧.</p>
<h1 id="map-join"><a href="#map-join" class="headerlink" title="map join"></a>map join</h1><p>对于存在join的sql,首先最简单的就是开启map join:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> hive.auto.convert.join = <span class="literal">true</span> ; <span class="comment">-- 开启自动转化成mapjoin</span></span><br><span class="line"><span class="keyword">set</span> hive.mapjoin.smalltable.filesize = <span class="number">2500000</span> ; <span class="comment">-- 设置广播小表size</span></span><br></pre></td></tr></table></figure>
<p>sql中足够小的表应该放在join操作左边. 由于小表数据会被广播到各个节点,消除了shuffle运算,提高了运算效率.<br>前提当然是存在足够小的表. 实际业务中一般是各种维度表.</p>
<h1 id="排序消除"><a href="#排序消除" class="headerlink" title="排序消除"></a>排序消除</h1><blockquote>
<p>注: 是否加速取决于数据集.</p>
</blockquote>
<p>排序属于非常耗时的操作(<code>O(nlogn)</code>),所以对于order by,sort by语句,可以从语义上寻找突破口. 例如对于每天最后一次的用户行为,原来的可能是这样写的:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line">(<span class="keyword">select</span> userid</span><br><span class="line">      ,<span class="keyword">url</span></span><br><span class="line">      ,row_number(<span class="keyword">partition</span> <span class="keyword">by</span> userid <span class="keyword">order</span> <span class="keyword">by</span> <span class="built_in">bigint</span>(<span class="built_in">timestamp</span>)<span class="keyword">DESC</span>) <span class="keyword">as</span> <span class="keyword">rank</span></span><br><span class="line"><span class="keyword">FROM</span> xxxx</span><br><span class="line">)<span class="keyword">AS</span> a </span><br><span class="line"><span class="keyword">where</span> <span class="keyword">rank</span>=<span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>可以改为先求最大时间戳,再进行<code>join</code>(<code>map join</code>):</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span></span><br><span class="line">(<span class="keyword">select</span> userid,<span class="keyword">max</span>(<span class="built_in">bigint</span>(<span class="built_in">timestamp</span>)) <span class="keyword">from</span> xxx <span class="keyword">group</span> <span class="keyword">by</span> userid) <span class="keyword">as</span> a</span><br><span class="line"><span class="keyword">join</span> xxx <span class="keyword">on</span> b </span><br><span class="line">  <span class="keyword">on</span> a.timestamp=b.timestamp</span><br></pre></td></tr></table></figure>
<p>这样更改后虽然消除了排序操作,但是引入了shuffle操作(join)(并且对于hive要laod两遍数据),因此是否加速取决于具体的数据集. 对于任务卡死(或者很慢)在reduce阶段的hive任务,可以尝试进行排序消除.<br>实际经验来看,如果数据量大到导致外排,需要消除<code>order by</code>.</p>
<h1 id="distinct消除-两阶段group-by"><a href="#distinct消除-两阶段group-by" class="headerlink" title="distinct消除(两阶段group by)"></a>distinct消除(两阶段group by)</h1><p>回字有4种写法,而distinct一般有2种.</p>
<h2 id="1-多列或1列去重"><a href="#1-多列或1列去重" class="headerlink" title="1. 多列或1列去重"></a>1. 多列或1列去重</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> a,b,udf(c1) <span class="keyword">as</span> c2 <span class="keyword">from</span> xxx</span><br></pre></td></tr></table></figure>
<p>由于hive是通过<code>group by</code>实现distinct,上述sql其实等效于:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> a,b,udf(c1) <span class="keyword">from</span> xxx <span class="keyword">group</span> <span class="keyword">by</span> a,b,udf(c1)</span><br></pre></td></tr></table></figure>
<p>可以通过explain查看两者的执行计划是完全一致的.<br>如果能确定udf是单射变换,也就是c1到c2是一对一,而没有多对一,可以等效改写为:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> a,b,udf(c1) <span class="keyword">from</span> xxx <span class="keyword">group</span> <span class="keyword">by</span> a,b,c1</span><br></pre></td></tr></table></figure>
<p>总之,对于这个场景下的distinct使用,如果没有udf,可以不进行消除.</p>
<h2 id="2-聚合函数中使用-如uv计算"><a href="#2-聚合函数中使用-如uv计算" class="headerlink" title="2. 聚合函数中使用(如uv计算)"></a>2. 聚合函数中使用(如uv计算)</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> dt,<span class="keyword">count</span>(<span class="keyword">distinct</span> userid) <span class="keyword">as</span> uv </span><br><span class="line"><span class="keyword">from</span> xxx</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> dt</span><br></pre></td></tr></table></figure>
<p>这种聚合函数中使用distinct属于比较常见的业务查询需求,hive执行时会把所有数据灌到一个reducer中,毫无并行度.<br>可以使用两阶段group by进行优化,写法:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> dt,<span class="keyword">count</span>(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">(<span class="keyword">select</span> <span class="keyword">distinct</span> dt,userid <span class="keyword">from</span> xxx) <span class="keyword">as</span> t </span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> dt</span><br></pre></td></tr></table></figure>
<p>这样去重操作在第一个阶段分担到了多个reducer上,速度提升很多.</p>
<p>实际优化的时候,主要有三种情况阻碍,无法直接改写:</p>
<h3 id="1-同一列不同条件的count-distinct"><a href="#1-同一列不同条件的count-distinct" class="headerlink" title="1. 同一列不同条件的count distinct"></a>1. 同一列不同条件的count distinct</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> dt</span><br><span class="line">,<span class="keyword">count</span>(<span class="keyword">distinct</span> userid) <span class="keyword">as</span> seven_uv</span><br><span class="line">,<span class="keyword">count</span>(<span class="keyword">distinct</span> <span class="keyword">if</span>(c1&gt;xxx,userid,<span class="literal">NULL</span>)) <span class="keyword">as</span> new_uv</span><br><span class="line">,<span class="keyword">count</span>(<span class="keyword">distinct</span> <span class="keyword">if</span>(c2&gt;xxx,userid,<span class="literal">NULL</span>)) <span class="keyword">as</span> query_uv</span><br></pre></td></tr></table></figure>
<p>可以通过增加标记列转化:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> dt</span><br><span class="line">,<span class="keyword">count</span>(userid) <span class="keyword">as</span> seven_uv</span><br><span class="line">,<span class="keyword">count</span>(<span class="keyword">if</span>(is_new=<span class="number">1</span>,userid,<span class="literal">NULL</span>)) <span class="keyword">as</span> new_uv</span><br><span class="line">,<span class="keyword">count</span>(<span class="keyword">if</span>(is_query=<span class="number">1</span>,userid,<span class="literal">NULL</span>)) <span class="keyword">as</span> query_uidnum <span class="comment">-- query_uv</span></span><br><span class="line"><span class="keyword">from</span> </span><br><span class="line">(...</span><br><span class="line">,<span class="keyword">max</span>(<span class="keyword">if</span>(c1&gt;xxx,<span class="number">1</span>,<span class="number">0</span>)) is_new</span><br><span class="line">,<span class="keyword">max</span>(<span class="keyword">if</span>(c2&gt;xxx,<span class="number">1</span>,<span class="number">0</span>)) <span class="keyword">as</span> is_query</span><br><span class="line">...) <span class="keyword">as</span> tt</span><br></pre></td></tr></table></figure>

<h3 id="2-多维聚合-group-by-with-cube"><a href="#2-多维聚合-group-by-with-cube" class="headerlink" title="2. 多维聚合(group by with cube)"></a>2. 多维聚合(group by with cube)</h3><p>可以通过一行变多行,手动维护grouping sets的组合:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">lateral view explode(array('全部',platform)) tt1 as platform_t</span><br><span class="line">lateral view explode(array('全部',version)) tt2 as version_t</span><br><span class="line">lateral view explode(array('全部',vendor)) tt3 as vendor_t</span><br><span class="line">lateral view explode(array('全部',phase)) tt4 as phase_t</span><br><span class="line">GROUP BY platform_t,version_t,vendor_t,phase_t</span><br><span class="line">     ,userid</span><br></pre></td></tr></table></figure>

<h2 id="不同列聚合"><a href="#不同列聚合" class="headerlink" title="不同列聚合."></a>不同列聚合.</h2><p>例如:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">count(distinct userid)</span><br><span class="line">count(distinct deviceid)</span><br></pre></td></tr></table></figure>
<p>这种如果确实出现了reduce卡死,可以进行分拆成两个查询分别计算(load两遍数据),最后join到一起. 代码会比较长. </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://xiaoyue26.github.io/2017/12/25/2017-12/hive%E8%B0%83%E4%BC%98/" data-id="ck96cxpnl0094maam0f7p0mtm" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hive/" rel="tag">hive</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-2017-12/hive之bug汇总" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/12/20/2017-12/hive%E4%B9%8Bbug%E6%B1%87%E6%80%BB/" class="article-date">
  <time datetime="2017-12-20T10:01:19.000Z" itemprop="datePublished">2017-12-20</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/hadoop/">hadoop</a>►<a class="article-category-link" href="/categories/hadoop/hive/">hive</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/12/20/2017-12/hive%E4%B9%8Bbug%E6%B1%87%E6%80%BB/">hive之bug汇总</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <p>这里总结一下hive的bug,或者说表现与spark sql不同的feature(bug?).<br>由于hive的distinct实际实现为group by,因此下述的group by相关bug也适用于distinct.</p>
<h1 id="1-列重命名BUG"><a href="#1-列重命名BUG" class="headerlink" title="1. 列重命名BUG"></a>1. 列重命名BUG</h1><blockquote>
<p>导致结果错误.<br>spark-sql能正常处理.</p>
</blockquote>
<p>子查询中重命名列时,如果和原有表中某列名相同,并且where条件中有那一列,取原有表的列值.<br>构造测试用例:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span></span><br><span class="line">(<span class="keyword">SELECT</span> <span class="number">123</span> <span class="keyword">as</span> paperid</span><br><span class="line"><span class="keyword">FROM</span>  temp.feng_test1</span><br><span class="line"><span class="keyword">where</span> paperid=<span class="number">70455</span></span><br><span class="line">)<span class="keyword">AS</span> a</span><br></pre></td></tr></table></figure>
<p>上述查询的结果是70455,而不是我们想象中的123.<br>而这个查询:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span></span><br><span class="line">(<span class="keyword">SELECT</span> <span class="number">123</span> <span class="keyword">as</span> paperid</span><br><span class="line"><span class="keyword">FROM</span>  temp.feng_test1</span><br><span class="line">)<span class="keyword">AS</span> a</span><br></pre></td></tr></table></figure>
<p>或这个查询:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span></span><br><span class="line">(<span class="keyword">SELECT</span> <span class="number">123</span> <span class="keyword">as</span> paperid</span><br><span class="line"><span class="keyword">FROM</span>  (<span class="keyword">select</span> <span class="number">70455</span> <span class="keyword">as</span> paperid) <span class="keyword">as</span> t </span><br><span class="line"><span class="keyword">where</span> paperid=<span class="number">70455</span></span><br><span class="line">)<span class="keyword">AS</span> a</span><br></pre></td></tr></table></figure>
<p>都能正确返回123.</p>
<h1 id="2-GROUP-BY-UDF-Serde复合bug"><a href="#2-GROUP-BY-UDF-Serde复合bug" class="headerlink" title="2. GROUP BY+UDF+Serde复合bug"></a>2. GROUP BY+UDF+Serde复合bug</h1><blockquote>
<p>导致抛异常退出.<br>spark-sql能正常处理.</p>
</blockquote>
<p>GROUP BY,自定义UDF和自定义Serde都能正常独立工作.<br>这是一个多重条件下产生的bug:<br>1.表定义为string,而自定义的serde类放入了long对象;(bug)<br>2.自定义UDF使用简便写法(继承UDF,复杂写法为继承GenericUDF);(正常行为)<br>3.运行如下语句:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> xx</span><br><span class="line"><span class="keyword">from</span> <span class="string">`1中serde的表`</span></span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> <span class="string">`2中udf`</span></span><br></pre></td></tr></table></figure>

<p>这个bug可以说是serde写得有问题导致的,严格来说hive没有太大问题.<br>原因是hive调用简单udf时,是运行时进行反射,填入方法的参数,实参与形参定义不同抛出异常.</p>
<h1 id="3-GROUP-BY-重复列-BUG"><a href="#3-GROUP-BY-重复列-BUG" class="headerlink" title="3. GROUP BY+重复列 BUG"></a>3. GROUP BY+重复列 BUG</h1><blockquote>
<p>导致结果错误.<br>spark-sql能正常处理.</p>
</blockquote>
<p>GROUP BY 时,如果有涉及引用的重复列, 如构造用例中的alist[0],由于hive在各种方面都会重用引用,会导致bug.<br>用例的输出结果为: <code>1,1,1</code>.<br>而不是我们想象中的: <code>1,1,3333</code>.</p>
<p>构造用例如下:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> aid,bid,mistake</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">      (<span class="keyword">SELECT</span> <span class="number">1</span> <span class="keyword">as</span> aid</span><br><span class="line">      )<span class="keyword">AS</span> a</span><br><span class="line"><span class="keyword">JOIN</span></span><br><span class="line">      (<span class="keyword">SELECT</span> alist[<span class="number">0</span>] <span class="keyword">as</span> bid</span><br><span class="line">            ,mistake</span><br><span class="line">      <span class="keyword">FROM</span> (<span class="keyword">SELECT</span> <span class="number">2</span> <span class="keyword">as</span> courseid) <span class="keyword">AS</span> a</span><br><span class="line">      <span class="keyword">JOIN</span> (<span class="keyword">SELECT</span> <span class="number">2</span> <span class="keyword">as</span> courseid</span><br><span class="line">                  ,<span class="string">'3333'</span> <span class="keyword">as</span> mistake</span><br><span class="line">                  ,<span class="built_in">array</span>(<span class="number">1</span>) <span class="keyword">as</span> alist</span><br><span class="line">            ) <span class="keyword">AS</span> b</span><br><span class="line">        <span class="keyword">ON</span> a.courseid=b.courseid</span><br><span class="line">      <span class="keyword">GROUP</span> <span class="keyword">BY</span> alist[<span class="number">0</span>]</span><br><span class="line">              ,alist[<span class="number">0</span>]</span><br><span class="line">              ,mistake</span><br><span class="line">      )<span class="keyword">AS</span> b</span><br><span class="line"> <span class="keyword">ON</span> aid=bid</span><br></pre></td></tr></table></figure>

<h1 id="4-row-number-数据类型溢出-bug"><a href="#4-row-number-数据类型溢出-bug" class="headerlink" title="4. row_number + 数据类型溢出 bug"></a>4. row_number + 数据类型溢出 bug</h1><blockquote>
<p>导致结果错误.<br>spark-sql能正常处理.</p>
</blockquote>
<p>假设tp是一个字符串类型,强行转换成int类型时,如果发生数据溢出,比如值是13位时间戳(1514285700375),排序行为将不可预测.既不是降序也不是升序.</p>
<p>构造错误样例如下:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> userid,phaseid,tp</span><br><span class="line">,row_number()<span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> userid <span class="keyword">order</span> <span class="keyword">by</span> <span class="built_in">int</span>(tp)) <span class="keyword">as</span> <span class="keyword">rank</span></span><br><span class="line"><span class="keyword">from</span> xxxx</span><br></pre></td></tr></table></figure>

<p>正确样例:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> userid,phaseid,tp</span><br><span class="line">,row_number()<span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> userid <span class="keyword">order</span> <span class="keyword">by</span> <span class="built_in">bigint</span>(tp)) <span class="keyword">as</span> <span class="keyword">rank</span></span><br><span class="line"><span class="keyword">from</span> xxxx</span><br></pre></td></tr></table></figure>

<h1 id="5-sort-array-BUG-Feature-函数副作用"><a href="#5-sort-array-BUG-Feature-函数副作用" class="headerlink" title="5. sort_array BUG(Feature) 函数副作用"></a>5. sort_array BUG(Feature) 函数副作用</h1><blockquote>
<p>导致结果错误.<br>spark-sql能正确处理.</p>
</blockquote>
<p>hive中对数组进行排序后,会改变原有数组.(会在原有数组基础上排序)<br>spark-sql则会返回一个深拷贝,不改变原有数组.</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> alist</span><br><span class="line">      ,sort_array(alist) <span class="keyword">as</span> alist2</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">(<span class="keyword">select</span> <span class="built_in">array</span>(<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>) <span class="keyword">as</span> alist</span><br><span class="line">)<span class="keyword">AS</span> t</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://xiaoyue26.github.io/2017/12/20/2017-12/hive%E4%B9%8Bbug%E6%B1%87%E6%80%BB/" data-id="ck96cxpnj008xmaamc8xl8r5i" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hive/" rel="tag">hive</a></li></ul>

    </footer>
  </div>
  
</article>
 


  


  <nav id="page-nav">
    <a class="extend prev" rel="prev" href="/page/13/">&amp;laquo; 上一页</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/12/">12</a><a class="page-number" href="/page/13/">13</a><span class="page-number current">14</span><a class="page-number" href="/page/15/">15</a><a class="page-number" href="/page/16/">16</a><span class="space">&hellip;</span><a class="page-number" href="/page/22/">22</a><a class="extend next" rel="next" href="/page/15/">下一页&amp;raquo;</a>
  </nav>
</section>
           
    <aside id="sidebar">
  
    

  
    
  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title recent-posts">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/02/16/2022-02/http-range/">http_range</a>
          </li>
        
          <li>
            <a href="/2022/01/21/2022-01/voip-rtc/">VoIP和RTC</a>
          </li>
        
          <li>
            <a href="/2021/07/26/2021-07/metaspace%E7%AC%94%E8%AE%B0/">metaspace笔记</a>
          </li>
        
          <li>
            <a href="/2021/06/01/2021-06/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E7%AC%94%E8%AE%B0-1/">网络安全笔记-1</a>
          </li>
        
          <li>
            <a href="/2021/02/22/2021-02/%E5%A4%9A%E9%A1%B9%E7%9B%AE%E5%85%B1%E4%BA%AB%E4%BB%A3%E7%A0%81%E4%B9%8B%E2%80%94%E2%80%94git-subtree/">多项目共享代码之——git subtree</a>
          </li>
        
      </ul>
    </div>
  </div>

  
    

  
</aside>

      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-left">
      &copy; 2014 - 2022 风梦七&nbsp;|&nbsp;
      主题 <a href="https://github.com/giscafer/hexo-theme-cafe/" target="_blank">Cafe</a>
    </div>
     <div id="footer-right">
      联系方式&nbsp;|&nbsp;296671657@qq.com
    </div>
  </div>
</footer>
 
<script src="/jquery/jquery.min.js"></script>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">首页</a>
  
    <a href="/archives" class="mobile-nav-link">归档</a>
  
    <a href="/about" class="mobile-nav-link">关于</a>
  
</nav>
    <img class="back-to-top-btn" src="/images/fly-to-top.png"/>
<script>
// Elevator script included on the page, already.
window.onload = function() {
  var elevator = new Elevator({
    selector:'.back-to-top-btn',
    element: document.querySelector('.back-to-top-btn'),
    duration: 1000 // milliseconds
  });
}
</script>
      

  
    <script>
      var cloudTieConfig = {
        url: document.location.href, 
        sourceId: "",
        productKey: "e2fb4051c49842688ce669e634bc983f",
        target: "cloud-tie-wrapper"
      };
    </script>
    <script src="https://img1.ws.126.net/f2e/tie/yun/sdk/loader.js"></script>
    

  







<!-- author:forvoid begin -->
<!-- author:forvoid begin -->

<!-- author:forvoid end -->

<!-- author:forvoid end -->


  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      })
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      })
    </script>
    <script type="text/javascript" src="https://cdn.rawgit.com/mathjax/MathJax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


 
<script src="/js/is.js"></script>



  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>


<script src="/js/elevator.js"></script>

  </div>
</body>
</html>