<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>笔记本</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="笔记本">
<meta property="og:url" content="http://xiaoyue26.github.io/page/8/index.html">
<meta property="og:site_name" content="笔记本">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="风梦七">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="笔记本" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    
  
  
<link rel="stylesheet" href="/css/style.css">

  

<meta name="generator" content="Hexo 4.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    
    <div id="header-inner" class="inner">
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://xiaoyue26.github.io"></form>
      </div>
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">首页</a>
        
          <a class="main-nav-link" href="/archives">归档</a>
        
          <a class="main-nav-link" href="/about">关于</a>
        
      </nav>
      
    </div>
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">笔记本</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">风梦七</a>
        </h2>
      
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-2019-02/高性能mysql第12-16章-笔记" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/02/13/2019-02/%E9%AB%98%E6%80%A7%E8%83%BDmysql%E7%AC%AC12-16%E7%AB%A0-%E7%AC%94%E8%AE%B0/" class="article-date">
  <time datetime="2019-02-13T01:34:54.000Z" itemprop="datePublished">2019-02-13</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/mysql/">mysql</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/02/13/2019-02/%E9%AB%98%E6%80%A7%E8%83%BDmysql%E7%AC%AC12-16%E7%AB%A0-%E7%AC%94%E8%AE%B0/">高性能mysql第12-16章-笔记</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <p>这一章主要讲了一些概念和一些Mysql Cluster变种，略。</p>
<h2 id="高可用概念"><a href="#高可用概念" class="headerlink" title="高可用概念"></a>高可用概念</h2><p>5个9: 99.999%，每年允许5分钟宕机时间。</p>
<h2 id="宕机原因"><a href="#宕机原因" class="headerlink" title="宕机原因"></a>宕机原因</h2><ol>
<li>运行环境: 磁盘耗尽；</li>
<li>性能问题：糟糕sql，schema索引设计;</li>
<li>复制问题：主备不一致；</li>
<li>数据丢失：如误操作。</li>
</ol>
<h3 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h3><ol>
<li>禁用查询缓存</li>
<li>禁用复制过滤器、触发器。</li>
</ol>
<h1 id="高性能mysql第13章-笔记-云端mysql"><a href="#高性能mysql第13章-笔记-云端mysql" class="headerlink" title="高性能mysql第13章-笔记-云端mysql"></a>高性能mysql第13章-笔记-云端mysql</h1><p>IaaS:基础设施虚拟化；<br>DaaS:数据库虚拟化。</p>
<h2 id="Iaas"><a href="#Iaas" class="headerlink" title="Iaas:"></a>Iaas:</h2><p>mysql需要的4种资源:</p>
<ol>
<li>cpu: 云cpu一般较慢；</li>
<li>内存: 最好能到512GB~1TB；</li>
<li>IO： ms级，虚拟化后一般慢100倍； </li>
<li>网络： 一般不成为瓶颈。</li>
</ol>
<h2 id="Daas："><a href="#Daas：" class="headerlink" title="Daas："></a>Daas：</h2><p>稍微讲了一下亚马逊RDS，略过。</p>
<h1 id="高性能mysql第14章-笔记-应用层优化"><a href="#高性能mysql第14章-笔记-应用层优化" class="headerlink" title="高性能mysql第14章-笔记-应用层优化"></a>高性能mysql第14章-笔记-应用层优化</h1><h2 id="思考的角度"><a href="#思考的角度" class="headerlink" title="思考的角度"></a>思考的角度</h2><ol>
<li>应用和数据库正确分工；</li>
<li>ORM的循环SQL和嵌套查询的性能优劣；</li>
<li>缓存(redis)；</li>
<li>连接池。</li>
</ol>
<h2 id="web服务器问题"><a href="#web服务器问题" class="headerlink" title="web服务器问题"></a>web服务器问题</h2><p>静态资源： 用nginx代替apache<br>移除无用的apache模块</p>
<h2 id="缓存问题"><a href="#缓存问题" class="headerlink" title="缓存问题"></a>缓存问题</h2><p>不同等级层次的缓存:</p>
<ol>
<li>进程缓存;</li>
<li>本地共享内存缓存;</li>
<li>分布式内存缓存;(memcached)</li>
<li>磁盘缓存。</li>
</ol>
<h3 id="缓存失效策略"><a href="#缓存失效策略" class="headerlink" title="缓存失效策略"></a>缓存失效策略</h3><ol>
<li>TTL;</li>
<li>显式失效:更新数据时候更新缓存或者标记缓存为脏数据;</li>
<li>读时失效:读的时候再判断缓存是否已经过期； （加快写，减慢了读）</li>
</ol>
<h1 id="高性能mysql第15章-笔记-备份与恢复"><a href="#高性能mysql第15章-笔记-备份与恢复" class="headerlink" title="高性能mysql第15章-笔记-备份与恢复"></a>高性能mysql第15章-笔记-备份与恢复</h1><p>备份建议：</p>
<ol>
<li>使用Percona XtraBackup、Mysql Enterprise Backup；</li>
<li>生产服务器和备份服务器分开，以免同时挂掉。</li>
<li>定期进行恢复测试。</li>
</ol>
<h2 id="逻辑备份"><a href="#逻辑备份" class="headerlink" title="逻辑备份"></a>逻辑备份</h2><p>(SQL,mysqldump)<br>缺点: </p>
<ol>
<li>恢复起来慢</li>
</ol>
<h2 id="物理备份"><a href="#物理备份" class="headerlink" title="物理备份"></a>物理备份</h2><p>(文件)<br>缺点：</p>
<ol>
<li>受版本、兼容性影响，bug概率高。</li>
<li>文件很大。</li>
</ol>
<p>建议：<br>0. 全局使用<code>utf-8</code>;</p>
<ol>
<li>逻辑：使用<code>mysqldump</code>备份结构；</li>
<li>物理: 使用<code>select into outfile</code>导出数据为分隔符文件。</li>
<li>恢复结构：执行1中的sql;</li>
<li>恢复数据：<code>load data infile</code>。<br>其中2，4两步对字符集有要求。（不能单独设置某列字符集）</li>
</ol>
<h2 id="增量备份和全量备份"><a href="#增量备份和全量备份" class="headerlink" title="增量备份和全量备份"></a>增量备份和全量备份</h2><p>尽量做全备，增量bug多；</p>
<h2 id="数据一致性"><a href="#数据一致性" class="headerlink" title="数据一致性"></a>数据一致性</h2><p><code>mysqldump --single-transaction</code><br>可能会导致非常长的事务，从而失败。</p>
<h2 id="binlog清理"><a href="#binlog清理" class="headerlink" title="binlog清理"></a>binlog清理</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">purge</span> <span class="keyword">master</span> <span class="keyword">logs</span> <span class="keyword">before</span> <span class="keyword">current_date</span> - <span class="built_in">Interval</span> N <span class="keyword">day</span></span><br></pre></td></tr></table></figure>
<p>或者设置<code>expire_logs_days</code>。</p>
<h2 id="innodb损坏恢复"><a href="#innodb损坏恢复" class="headerlink" title="innodb损坏恢复"></a>innodb损坏恢复</h2><h3 id="1-二级索引损坏"><a href="#1-二级索引损坏" class="headerlink" title="1. 二级索引损坏"></a>1. 二级索引损坏</h3><p>3种办法：</p>
<ol>
<li><code>optimize table</code>语句;</li>
<li>删除重建表;</li>
<li>表引擎改为<code>myisam</code>，再改回来。</li>
</ol>
<h3 id="2-聚簇索引损坏"><a href="#2-聚簇索引损坏" class="headerlink" title="2. 聚簇索引损坏"></a>2. 聚簇索引损坏</h3><p><strong>优先使用备份还原</strong><br>否则：<br>(大概率只能修复未受损坏影响的行。)<br>通过<code>innodb_force_recover</code>选项导出表，如果导出过程崩溃，需要跳过受损行。</p>
<h3 id="3-损坏系统结构"><a href="#3-损坏系统结构" class="headerlink" title="3. 损坏系统结构"></a>3. 损坏系统结构</h3><p>损坏： innodb事务日志(redo log),表空间撤销日志(undo log),数据字典。</p>
<p><strong>优先使用备份还原</strong><br>否则：<br>可能需要做整个数据库的导出和还原。<br>innodb内部绝大部分工作可能受影响。</p>
<p>上述2，3两种损坏最好从备份还原数据。</p>
<h1 id="高性能mysql第16章-笔记-用户工具"><a href="#高性能mysql第16章-笔记-用户工具" class="headerlink" title="高性能mysql第16章-笔记-用户工具"></a>高性能mysql第16章-笔记-用户工具</h1><p>这章主要介绍一些工具：</p>
<h3 id="UI工具"><a href="#UI工具" class="headerlink" title="UI工具:"></a>UI工具:</h3><ol>
<li>MysqlWorkbench;</li>
<li>SQLyog: 同workbench,windows专用；</li>
</ol>
<h3 id="命令行工具"><a href="#命令行工具" class="headerlink" title="命令行工具:"></a>命令行工具:</h3><ol>
<li>Percona Toolkit: 管理员必备；</li>
<li>The openark kit：一些管理任务的python脚本。</li>
</ol>
<h3 id="监控工具"><a href="#监控工具" class="headerlink" title="监控工具"></a>监控工具</h3><ol>
<li>Nagios;<br>2-6等其余很多略过。</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://xiaoyue26.github.io/2019/02/13/2019-02/%E9%AB%98%E6%80%A7%E8%83%BDmysql%E7%AC%AC12-16%E7%AB%A0-%E7%AC%94%E8%AE%B0/" data-id="ck96cxppe00gzmaam67zeat24" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/mysql/" rel="tag">mysql</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-2019-02/高性能mysql-第十一章-笔记-可扩展" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/02/12/2019-02/%E9%AB%98%E6%80%A7%E8%83%BDmysql-%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0-%E7%AC%94%E8%AE%B0-%E5%8F%AF%E6%89%A9%E5%B1%95/" class="article-date">
  <time datetime="2019-02-12T03:03:52.000Z" itemprop="datePublished">2019-02-12</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/mysql/">mysql</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/02/12/2019-02/%E9%AB%98%E6%80%A7%E8%83%BDmysql-%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0-%E7%AC%94%E8%AE%B0-%E5%8F%AF%E6%89%A9%E5%B1%95/">高性能mysql-第十一章-笔记-可扩展</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <h2 id="可扩展"><a href="#可扩展" class="headerlink" title="可扩展"></a>可扩展</h2><ol>
<li>数据量；</li>
<li>用户量: 并发量。</li>
<li>负载。</li>
</ol>
<h2 id="可扩展性的描述"><a href="#可扩展性的描述" class="headerlink" title="可扩展性的描述"></a>可扩展性的描述</h2><img src="/images/2019-02/usl_ext.png" class="" width="400" height="600" title="usl_ext">
<ul>
<li><p>线性扩展: 加1倍资源=&gt;加1倍性能。(理想最优情况，一般达不到)</p>
</li>
<li><p>Amdahl定律: </p>
</li>
</ul>
<ol>
<li>存在无法并发的工作;</li>
<li>存在需要交互的工作;<br>因此吞吐量达不到线性增长，会趋于平缓。</li>
</ol>
<ul>
<li>USL扩展:(通用可扩展定律)</li>
</ul>
<ol>
<li>存在无法并发的工作;</li>
<li>存在需要交互的工作;</li>
<li>存在内部系统通信开销。</li>
</ol>
<p>从3种扩展性的描述看，我们的目标是趋近于线性扩展，因此应该尽量削减USL扩展中的三个方面: 减少串行、减少交互、减少内部通信。</p>
<h2 id="垂直扩展-纵向扩展、向上扩展"><a href="#垂直扩展-纵向扩展、向上扩展" class="headerlink" title="垂直扩展(纵向扩展、向上扩展)"></a>垂直扩展(纵向扩展、向上扩展)</h2><p>升级硬件。价格更高，性能比低。<br>mysql利用极限:<br>CPU: 24<br>内存: 128<br>更多的时候提升趋于平缓。</p>
<h2 id="向内扩展"><a href="#向内扩展" class="headerlink" title="向内扩展"></a>向内扩展</h2><p>优化查询、索引，压缩数据。</p>
<h2 id="水平扩展-横向扩展，向外扩展"><a href="#水平扩展-横向扩展，向外扩展" class="headerlink" title="水平扩展(横向扩展，向外扩展)"></a>水平扩展(横向扩展，向外扩展)</h2><ol>
<li>复制</li>
<li>拆分</li>
<li>分片(sharding)</li>
</ol>
<p>拆分: 按功能拆分（微服务），划分的表之间不会进行关联操作</p>
<h3 id="数据分片-sharding"><a href="#数据分片-sharding" class="headerlink" title="数据分片(sharding)"></a>数据分片(sharding)</h3><p>用userid分片。<br>id+hash。</p>
<img src="/images/2019-02/star_model.png" class="" width="400" height="600" title="star_model">
<p>星形/雪花模型: 容易分片。<br>网状模型:      难以分片。 </p>
<p>因此早期设计应该避免网状模型。</p>
<p>分片方式:</p>
<ol>
<li>固定分配，硬编码; 缺点: 无法处理热点。优点: 简单。</li>
<li>动态分配：缺点：实现复杂。</li>
</ol>
<p>热点解决方案：随机数+哈希；<br>扩展性： 预分配32个分片，用DNS单点，把4个库放在一个实例(IP)上。</p>
<p>小猿(CP): 库名_32.表名; DNS作为单点。<br>网易(CP): 类似codis，引入中间件单点。</p>
<h3 id="全局唯一ID"><a href="#全局唯一ID" class="headerlink" title="全局唯一ID"></a>全局唯一ID</h3><ol>
<li>autoinc: 利用自增幅度和初始偏移;</li>
<li>创建一个全局表，进行autoinc id分配;</li>
<li>使用memcached/redis，生成全局自增id;(没有持久性)</li>
</ol>
<p>其中2，3可以批量生成一批，减少调用次数。</p>
<h3 id="冷热数据分表"><a href="#冷热数据分表" class="headerlink" title="冷热数据分表"></a>冷热数据分表</h3><p>归档、冷数据分离到另一张表、或者将冷数据分离到较差的节点。</p>
<h3 id="负载均衡的目的"><a href="#负载均衡的目的" class="headerlink" title="负载均衡的目的"></a>负载均衡的目的</h3><img src="/images/2019-02/balance.png" class="" width="400" height="600" title="balance">
<ol>
<li>可扩展性；（读写分离）</li>
<li>高效性；</li>
<li>可用性；</li>
<li>透明性；</li>
<li>一致性。</li>
</ol>
<h3 id="负载均衡算法"><a href="#负载均衡算法" class="headerlink" title="负载均衡算法"></a>负载均衡算法</h3><ol>
<li>随机</li>
<li>轮询</li>
<li>最少连接数: 有缺点，新加入的机器还没有预热缓存，却立即分配了最多的连接；</li>
<li>最快响应；</li>
<li>哈希：通过源IP进行哈希（会话局部性）；</li>
<li>权重：结合上述算法，根据底层机器的性能差异进行权重。</li>
</ol>
<p>具体采用哪个算法，取决于工作负载类型。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://xiaoyue26.github.io/2019/02/12/2019-02/%E9%AB%98%E6%80%A7%E8%83%BDmysql-%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0-%E7%AC%94%E8%AE%B0-%E5%8F%AF%E6%89%A9%E5%B1%95/" data-id="ck96cxppd00gvmaamfl3ydges" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/mysql/" rel="tag">mysql</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-2019-02/高性能mysql第九-十章-笔记-选硬件-主备复制" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/02/11/2019-02/%E9%AB%98%E6%80%A7%E8%83%BDmysql%E7%AC%AC%E4%B9%9D-%E5%8D%81%E7%AB%A0-%E7%AC%94%E8%AE%B0-%E9%80%89%E7%A1%AC%E4%BB%B6-%E4%B8%BB%E5%A4%87%E5%A4%8D%E5%88%B6/" class="article-date">
  <time datetime="2019-02-11T14:41:01.000Z" itemprop="datePublished">2019-02-11</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/mysql/">mysql</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/02/11/2019-02/%E9%AB%98%E6%80%A7%E8%83%BDmysql%E7%AC%AC%E4%B9%9D-%E5%8D%81%E7%AB%A0-%E7%AC%94%E8%AE%B0-%E9%80%89%E7%A1%AC%E4%BB%B6-%E4%B8%BB%E5%A4%87%E5%A4%8D%E5%88%B6/">高性能mysql第九/十章-笔记-选硬件/主备复制</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <p>这章主要讲怎么挑mysql的硬件。</p>
<h1 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h1><p>多核的</p>
<h1 id="磁盘"><a href="#磁盘" class="headerlink" title="磁盘"></a>磁盘</h1><p>raid卡，带电，防断电的</p>
<h2 id="iostat和vmstat用法"><a href="#iostat和vmstat用法" class="headerlink" title="iostat和vmstat用法"></a>iostat和vmstat用法</h2><p>略</p>
<h1 id="高性能mysql第十章-笔记-复制"><a href="#高性能mysql第十章-笔记-复制" class="headerlink" title="高性能mysql第十章-笔记-复制"></a>高性能mysql第十章-笔记-复制</h1><p>使用场景：</p>
<ol>
<li>数据分布；</li>
<li>负载均衡（从库可以读）；</li>
<li>备份；</li>
<li>高可用/故障切换；</li>
<li>升级测试。 <img src="/images/2019-02/relay_log.png" class="" width="800" height="1200" title="relay_log">
主库备库同步流程：</li>
<li>主库: 生成binlog;(binlog dump线程)</li>
<li>备库: 读取binlong放入中继日志relay log;（通过TCP/IP协议,IO线程）</li>
<li>备库: 重放relay log。(单线程,SQL线程)</li>
</ol>
<h2 id="配置复制"><a href="#配置复制" class="headerlink" title="配置复制"></a>配置复制</h2><ol>
<li>每台服务器上创建账号;</li>
<li>配置主库和备库；</li>
<li>通知备库连接到主库，并从主库复制数据。</li>
</ol>
<h3 id="第一步创建账号"><a href="#第一步创建账号" class="headerlink" title="第一步创建账号"></a>第一步创建账号</h3><p>主库、备库：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">grant</span> <span class="keyword">replication</span> <span class="keyword">slave</span>, <span class="keyword">replication</span> <span class="keyword">client</span> <span class="keyword">on</span> *.*</span><br><span class="line"><span class="keyword">to</span> repl@<span class="string">'192.168.0.%'</span> indentified <span class="keyword">by</span> <span class="string">'p4ssword'</span>,;</span><br></pre></td></tr></table></figure>

<h3 id="第二步设置主库和备库"><a href="#第二步设置主库和备库" class="headerlink" title="第二步设置主库和备库"></a>第二步设置主库和备库</h3><p>主库:<br><code>[my.conf]</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">log_bin &#x3D; mysql-bin</span><br><span class="line">server_id &#x3D; 10</span><br></pre></td></tr></table></figure>
<p>重启主库。<br>检查主库完成配置:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">master</span> <span class="keyword">status</span>;</span><br><span class="line"></span><br><span class="line">+<span class="comment">------------------+-----------+--------------+------------------+-------------------+</span></span><br><span class="line">| File             | Position  | Binlog_Do_DB | Binlog_Ignore_DB | Executed_Gtid_Set |</span><br><span class="line">+<span class="comment">------------------+-----------+--------------+------------------+-------------------+</span></span><br><span class="line">| mysql-bin.000611 | 618598987 |              |                  |                   |</span><br><span class="line">+<span class="comment">------------------+-----------+--------------+------------------+-------------------+</span></span><br></pre></td></tr></table></figure>


<p>备库配置：<br><code>[my.conf]</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">log_bin &#x3D; mysql-bin</span><br><span class="line">server_id &#x3D; 2 </span><br><span class="line">relay_log &#x3D; &#x2F;var&#x2F;lib&#x2F;mysql&#x2F;mysql-relay-bin</span><br><span class="line">log_slave_updates &#x3D; 1 # 备库自身的重放事件也记录到binlog中</span><br><span class="line">read_only &#x3D; 1</span><br></pre></td></tr></table></figure>

<h3 id="第三步：启动复制"><a href="#第三步：启动复制" class="headerlink" title="第三步：启动复制"></a>第三步：启动复制</h3><p>备库执行sql:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">change</span> <span class="keyword">master</span> <span class="keyword">to</span> MASTER_HOST= <span class="string">'server1'</span></span><br><span class="line">,MASTER_USER=<span class="string">'reply'</span></span><br><span class="line">,MASTER_PASSWORD=<span class="string">'p4ssword'</span></span><br><span class="line">,MASTER_LOG_FILE=<span class="string">'mysql-bin.000001'</span></span><br><span class="line">,MASTER_LOG_POS=<span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>检查备库配置:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">slave</span> <span class="keyword">status</span> \G</span><br></pre></td></tr></table></figure>

<p>让备库开始复制:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">start</span> <span class="keyword">slave</span>;</span><br></pre></td></tr></table></figure>



<h2 id="binlog配置"><a href="#binlog配置" class="headerlink" title="binlog配置"></a>binlog配置</h2><h3 id="主库配置"><a href="#主库配置" class="headerlink" title="主库配置"></a>主库配置</h3><p><code>sync_binlog</code>=1: 事务提交前把binlog存到磁盘上。</p>
<h2 id="复制的原理"><a href="#复制的原理" class="headerlink" title="复制的原理"></a>复制的原理</h2><p><code>binlog_format</code>:</p>
<ol>
<li>基于语句的复制(逻辑): 出错机率大,开销小;</li>
<li>基于行的复制(物理): 几乎不出错,开销一般更大。(5.1以后开始有)</li>
</ol>
<p>基于语句的复制的<strong>缺点</strong>:</p>
<ol>
<li>不支持触发器或者存储过程：有bug;</li>
<li>只能串行重放。</li>
</ol>
<p>基于行的<strong>缺点</strong>:</p>
<ol>
<li>可读性差，无法直接知道执行了什么SQL。<br>解决方案: <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 1:</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">master</span> <span class="keyword">logs</span>;</span><br><span class="line"><span class="comment">-- 2:</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">binlog</span> <span class="keyword">events</span> <span class="keyword">in</span> <span class="string">'mysql-bin.000643'</span> <span class="keyword">from</span> <span class="number">1073742091</span>;</span><br></pre></td></tr></table></figure>


</li>
</ol>
<h2 id="复制的过滤器"><a href="#复制的过滤器" class="headerlink" title="复制的过滤器"></a>复制的过滤器</h2><p>不建议使用。</p>
<h2 id="复制的拓扑"><a href="#复制的拓扑" class="headerlink" title="复制的拓扑"></a>复制的拓扑</h2><h3 id="1-一主多备-星形模型"><a href="#1-一主多备-星形模型" class="headerlink" title="1. 一主多备(星形模型)"></a>1. 一主多备(星形模型)</h3><h3 id="2-双主"><a href="#2-双主" class="headerlink" title="2. 双主"></a>2. 双主</h3><p>不建议使用,两个主库都可写会有很多问题</p>
<h3 id="3-HA模式-类似于双主-但只有一个可写"><a href="#3-HA模式-类似于双主-但只有一个可写" class="headerlink" title="3. HA模式(类似于双主,但只有一个可写)"></a>3. HA模式(类似于双主,但只有一个可写)</h3><img src="/images/2019-02/HA.png" class="" width="800" height="1200" title="HA">
<p>两个库的配置基本相同，只是其中一个库是只读的。<br>如果有Alter table等耗时操作，可以在备库上执行，然后互换两个库。<br>优点：<br>故障恢复很简单。</p>
<p>具体设置情况:</p>
<ol>
<li>两个库数据相同;</li>
<li>创建复制账号，选择不同serverid；</li>
<li>两者启用binlog,互相跟踪;</li>
<li>备库设置成只读，主库设置成可写。</li>
</ol>
<p>由于serverid，主库不会重复消费自己的变更。（忽略自己的日志）</p>
<h3 id="确定备库追上了主库"><a href="#确定备库追上了主库" class="headerlink" title="确定备库追上了主库"></a>确定备库追上了主库</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 主库:</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">master</span> <span class="keyword">status</span>;<span class="comment">-- 记录一下文件名和偏移量</span></span><br><span class="line"><span class="comment">-- 备库:</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">master_pos_wait</span>(<span class="keyword">file</span>, pos[, <span class="keyword">timeout</span>])</span><br></pre></td></tr></table></figure>

<h3 id="4-环形-gt-3的库成环"><a href="#4-环形-gt-3的库成环" class="headerlink" title="4. 环形(&gt;=3的库成环)"></a>4. 环形(&gt;=3的库成环)</h3><p>不建议使用，太脆弱容易死循环。</p>
<h3 id="5-分发主库"><a href="#5-分发主库" class="headerlink" title="5. 分发主库"></a>5. 分发主库</h3><img src="/images/2019-02/fenfa_mysql.png" class="" width="800" height="1200" title="fenfa_mysql">
<p>一主多备对于备的数量有上限，可以用分发主库来进行扩展。<br>为了避免在分发主库上执行查询，可以将它的表修改为blackhole引擎。<br>（storage_engine=blackhole）</p>
<h3 id="6-模拟多主库"><a href="#6-模拟多主库" class="headerlink" title="6. 模拟多主库"></a>6. 模拟多主库</h3><img src="/images/2019-02/moni_multi.png" class="" width="800" height="1200" title="moni_multi">
<p>备库可以轮流读两个主库，俩主库带blackhole即可。</p>
<h2 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">insert ...</span><br><span class="line">select ...</span><br><span class="line">-- 转换成:</span><br><span class="line">select into outfile .. </span><br><span class="line">load data infile  ...</span><br></pre></td></tr></table></figure>
<p>这样更快(不需要加锁)</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://xiaoyue26.github.io/2019/02/11/2019-02/%E9%AB%98%E6%80%A7%E8%83%BDmysql%E7%AC%AC%E4%B9%9D-%E5%8D%81%E7%AB%A0-%E7%AC%94%E8%AE%B0-%E9%80%89%E7%A1%AC%E4%BB%B6-%E4%B8%BB%E5%A4%87%E5%A4%8D%E5%88%B6/" data-id="ck96cxppg00h7maam081s1f7j" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/mysql/" rel="tag">mysql</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-2019-02/高性能mysql第八章-笔记-优化服务器配置" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/02/11/2019-02/%E9%AB%98%E6%80%A7%E8%83%BDmysql%E7%AC%AC%E5%85%AB%E7%AB%A0-%E7%AC%94%E8%AE%B0-%E4%BC%98%E5%8C%96%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE/" class="article-date">
  <time datetime="2019-02-11T14:37:32.000Z" itemprop="datePublished">2019-02-11</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/mysql/">mysql</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/02/11/2019-02/%E9%AB%98%E6%80%A7%E8%83%BDmysql%E7%AC%AC%E5%85%AB%E7%AB%A0-%E7%AC%94%E8%AE%B0-%E4%BC%98%E5%8C%96%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE/">高性能mysql第八章-笔记-优化服务器配置</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <blockquote>
<p>错误配置不如维持默认配置。</p>
</blockquote>
<h1 id="优化服务器配置"><a href="#优化服务器配置" class="headerlink" title="优化服务器配置"></a>优化服务器配置</h1><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><p>服务端读取<code>mysqld</code>分段<br>客户端可能会读取客户端分段。</p>
<h2 id="配置级别"><a href="#配置级别" class="headerlink" title="配置级别"></a>配置级别</h2><p>全局、连接级、会话级<br><code>sort_buffer_size</code>: 每个线程都可以设置<br><code>join_buffer_size</code>: 可以为每个关联都设置一个关联缓冲。</p>
<h2 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h2><p>用git管理配置文件</p>
<h2 id="最优配置"><a href="#最优配置" class="headerlink" title="最优配置"></a>最优配置</h2><p>书上也不知道怎么配出最优配置。</p>
<ol>
<li>用benchmark：穷举配置成本太高；</li>
<li>用比较低的值慢慢试探，较低的内存配置对性能影响不大（百分之几），但较高的内存配置会造成较大的性能抖动，因此尽量以较低的配置。</li>
</ol>
<h2 id="Buffer-pool（Innodb）"><a href="#Buffer-pool（Innodb）" class="headerlink" title="Buffer pool（Innodb）"></a>Buffer pool（Innodb）</h2><p>缓存内容:</p>
<ol>
<li>缓存索引;</li>
<li>缓存行数据；</li>
<li>缓存自适应哈希索引；</li>
<li>插入缓冲；（延迟合并写入）</li>
<li>锁。</li>
</ol>
<h2 id="Key-caches-MyIsam"><a href="#Key-caches-MyIsam" class="headerlink" title="Key caches(MyIsam)"></a>Key caches(MyIsam)</h2><p>键缓冲(键缓存)。<br>MyIsam只缓存索引，不缓存数据。</p>
<p>查看MyIsam的索引总大小:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">sum</span>(index_length) </span><br><span class="line"><span class="keyword">from</span> information_schema.tables</span><br><span class="line"><span class="keyword">where</span> <span class="keyword">engine</span>=<span class="string">'MYISAM'</span>;</span><br><span class="line"><span class="comment">-- 也可以看看分布:</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">engine</span>,<span class="keyword">sum</span>(index_length) </span><br><span class="line"><span class="keyword">from</span> information_schema.tables</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="keyword">engine</span>;</span><br><span class="line"></span><br><span class="line">+<span class="comment">--------------------+-------------------+</span></span><br><span class="line">| engine             | sum(index_length) |</span><br><span class="line">+<span class="comment">--------------------+-------------------+</span></span><br><span class="line">| CSV                |                 0 |</span><br><span class="line">| InnoDB             |       68176035840 |</span><br><span class="line">| MEMORY             |                 0 |</span><br><span class="line">| MyISAM             |            124928 |</span><br><span class="line">| PERFORMANCE_SCHEMA |                 0 |</span><br><span class="line">+<span class="comment">--------------------+-------------------+</span></span><br></pre></td></tr></table></figure>
<p>key cache的大小不要超过MYISAM索引总大小。</p>
<h2 id="线程缓存"><a href="#线程缓存" class="headerlink" title="线程缓存"></a>线程缓存</h2><p><code>thread_cache_size</code>:  缓存线程数量。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">'%thread_cache_size%'</span>;</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">'%thread%'</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">+<span class="comment">-----------------------------------------+---------------------------+</span></span><br><span class="line">| Variable_name                           | Value                     |</span><br><span class="line">+<span class="comment">-----------------------------------------+---------------------------+</span></span><br><span class="line">| innodb_purge_threads                    | 1                         |</span><br><span class="line">| innodb_read_io_threads                  | 12                        |</span><br><span class="line">| innodb_thread_concurrency               | 0                         |</span><br><span class="line">| innodb_thread_sleep_delay               | 10000                     |</span><br><span class="line">| innodb_write_io_threads                 | 12                        |</span><br><span class="line">| max_delayed_threads                     | 20                        |</span><br><span class="line">| max_insert_delayed_threads              | 20                        |</span><br><span class="line">| myisam_repair_threads                   | 1                         |</span><br><span class="line">| performance_schema_max_thread_classes   | 50                        |</span><br><span class="line">| performance_schema_max_thread_instances | -1                        |</span><br><span class="line">| pseudo_thread_id                        | 4804578                   |</span><br><span class="line">| thread_cache_size                       | 512                       |</span><br><span class="line">| thread_concurrency                      | 4                         |</span><br><span class="line">| thread_handling                         | one-thread-per-connection |</span><br><span class="line">| thread_stack                            | 524288                    |</span><br><span class="line">+<span class="comment">-----------------------------------------+---------------------------+</span></span><br></pre></td></tr></table></figure>

<h2 id="表缓存"><a href="#表缓存" class="headerlink" title="表缓存"></a>表缓存</h2><p>对myisam有用，innodb用处不大。<br>算是一个已经过时的配置。</p>
<h2 id="Buffer-Pool相关架构"><a href="#Buffer-Pool相关架构" class="headerlink" title="Buffer Pool相关架构"></a>Buffer Pool相关架构</h2><img src="/images/2019-02/buffer_pool.png" class="" width="800" height="1200" title="buffer_pool">
<p>图中的undo日志是方便事务回滚的。<br>(redo日志是类似WAL，防断电的，利用顺序IO优化性能)</p>
<p>事务日志(redo log)使用类似环形数组的数据结构，可以环形写入到flush过的头部，节省存储空间。</p>
<h3 id="Log-Buffer（Redo-log-事务日志）"><a href="#Log-Buffer（Redo-log-事务日志）" class="headerlink" title="Log Buffer（Redo log/事务日志）"></a>Log Buffer（Redo log/事务日志）</h3><p>每次变更: 记录到Log Buffer(Buffer Pool =&gt; Log Buffer)</p>
<p>Log Buffer刷盘到磁盘日志文件的时机(或者说触发事件):</p>
<ol>
<li>每一秒钟(定时器tick事件);</li>
<li>或事务提交事件;</li>
<li>或缓冲区满。</li>
</ol>
<p>以上是默认的三个事件，调节参数为<code>innodb_flush_log_at_trx_commit</code>,3种取值:<br>0: 事务提交:不触发;<br>1: 事务提交:刷盘到磁盘;(默认值，3种事件皆触发刷盘)<br>2: 事务提交:刷新到操作系统缓存。（能扛mysql进程挂掉，不能扛断电，断电的话会丢一秒数据。）</p>
<p>如果缓冲区满的太频繁(1s满了很多次)，可以考虑增大缓冲区大小来减少IO次数。<br>参数:<br><code>innodb_log_buffer_size</code>: 默认1M，推荐1~8M。</p>
<p>调节这个参数需要命令:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">engine</span> <span class="keyword">innodb</span> <span class="keyword">status</span></span><br></pre></td></tr></table></figure>

<h2 id="Innodb读写日志、数据文件配置"><a href="#Innodb读写日志、数据文件配置" class="headerlink" title="Innodb读写日志、数据文件配置"></a>Innodb读写日志、数据文件配置</h2><p>这是一个风险很高的选项，认真学习以后有必要再修改。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">global</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">'%flush_method%'</span>;</span><br><span class="line"></span><br><span class="line">+<span class="comment">---------------------+----------+</span></span><br><span class="line">| Variable_name       | Value    |</span><br><span class="line">+<span class="comment">---------------------+----------+</span></span><br><span class="line">| innodb_flush_method | O_DIRECT |</span><br><span class="line">+<span class="comment">---------------------+----------+</span></span><br></pre></td></tr></table></figure>
<p>windows用的选项:<br>async_unbuffered,unbuffered,normal.</p>
<p>linux：</p>
<ul>
<li><p><code>fdatasync</code>: 默认值。用<code>fsync()</code>刷新数据和日志文件。<br><code>fdatasync()</code>函数只刷新文件的数据；<br><code>fsync()</code>函数刷新数据和日志文件。<br>配置为<code>fdatasync</code>时其实会调用<code>fsync()</code>函数。默认会合并多个文件的fsync()操作，合并IO操作。可以通过<code>innodb_file_per_table</code>选项为每个文件独立fsync()，但也会增多IO操作。</p>
</li>
<li><p><code>O_DIRECT</code>: 数据文件: 用<code>O_DIRECT</code>标记或<code>directio()</code>函数。<br>（不影响日志文件）<br>区别: 使用fsync()函数刷盘，但会通知操作系统不要缓存数据，也不要预读。<br>相当于关闭了操作系统缓存（读写）。<br>特例： 不影响raid卡的预读、写缓存。</p>
</li>
<li><p><code>ALL_O_DIRECT</code>: 影响数据和日志文件。</p>
</li>
<li><p><code>O_DSYNC</code>: 日志文件: 用<code>O_SYNC</code>标记，写同步（日志写到磁盘才返回）<br>（不影响数据文件）<br>区别：不禁用操作系统的缓存。</p>
</li>
</ul>
<table>
<thead>
<tr>
<th align="center">配置值</th>
<th align="center">实际调用函数</th>
<th align="center">概述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">fdatasync</td>
<td align="center">fsync(含义相反)</td>
<td align="center">刷新数据和日志，有操作系统缓存</td>
</tr>
<tr>
<td align="center">O_DIRECT</td>
<td align="center"></td>
<td align="center">刷新数据，关闭缓存</td>
</tr>
<tr>
<td align="center">ALL_O_DIRECT</td>
<td align="center"></td>
<td align="center">刷新数据和日志，关闭缓存</td>
</tr>
<tr>
<td align="center">O_DSYNC</td>
<td align="center">O_SYNC</td>
<td align="center">刷新日志，有操作系统缓存</td>
</tr>
</tbody></table>
<p>O_DSYNC和fdatasync的区别:<br>（实际是O_SYNC和fsync的区别）fsync允许写操作累积在缓存，然后一次性刷新。<br>O_SYNC是每次都是同步IO，每次都刷盘。</p>
<h3 id="tips-1"><a href="#tips-1" class="headerlink" title="tips"></a>tips</h3><p>如果使用raid卡带电: O_DIRECT;<br>否则: O_DIRECT或fdatasync都有可能，看业务需求。</p>
<h2 id="Innodb表空间"><a href="#Innodb表空间" class="headerlink" title="Innodb表空间"></a>Innodb表空间</h2><p>位于<code>innodb_data_home_dir</code>目录:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">表、索引、回滚日志(undo log)、插入缓冲(Insert Buffer)、双写缓冲(DoubleWrite Buffer)。</span><br></pre></td></tr></table></figure>

<p>目录下可以挂载多个设备，但不会自动做负载均衡，只有写满第一个才会写第二个，因此需要底层用raid自己做负载均衡。<br>挂载多个目录:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">innodb_data_file_path &#x3D; &#x2F;disk1&#x2F;ibdata1:1G;&#x2F;disk2&#x2F;ibdata2:1G;&#x2F;disk3&#x2F;ibdata3:1G:autoextended:max:2G</span><br></pre></td></tr></table></figure>

<p>建议使用<code>innodb_file_per_table</code>选项，每个表的表空间一个文件。<br>缺点：DROP Table慢。<br>原因: </p>
<ol>
<li>删除文件慢；</li>
<li>移除表空间需要Innodb锁定和扫描缓冲区，查找属于这个表空间的页。</li>
</ol>
<h4 id="运行时间长的事务"><a href="#运行时间长的事务" class="headerlink" title="运行时间长的事务"></a>运行时间长的事务</h4><p>缺点: undo log增长到打爆表空间、磁盘。</p>
<h3 id="双写缓冲-Doublewrite-Buffer"><a href="#双写缓冲-Doublewrite-Buffer" class="headerlink" title="双写缓冲(Doublewrite Buffer)"></a>双写缓冲(Doublewrite Buffer)</h3><p>功能: 避免页没写完整导致的数据损坏。<br>buffer pool =&gt; Doublewrite Buffer =&gt; 磁盘</p>
<p>写两次，但由于有<code>fsync()</code>，而且这个过程时间顺序上比较紧密，可以一次性刷到磁盘，写两次的性能损耗也就多了百分之记。</p>
<h3 id="binlog-IO配置"><a href="#binlog-IO配置" class="headerlink" title="binlog IO配置"></a>binlog IO配置</h3><p><code>sync_binlog</code>: binlog配置。<br>N=0(默认值): 不干预，让操作系统自己决定。<br>N&gt;0: N次写以后，刷新到磁盘。（一般不会大于1)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show global variables like &#39;%log%&#39;;</span><br></pre></td></tr></table></figure>

<p>innodb的6种日志:</p>
<ol>
<li>redo log(物理/WAL): 事务开始后写入缓冲区innodb_log_buffer;（存储引擎层）</li>
<li>undo log(逻辑/版本): 事务开始后为了事务回滚准备的日志，从buffer pool=&gt;表空间;</li>
<li>bin log(逻辑/SQL): 主从复制。或者基于时间点的还原。(类似于存了sql)。（事务提交前产生，数据库层）</li>
<li>slow query log: 慢查询;</li>
<li>general log: 一般日志;</li>
<li>relay log: 中继日志。</li>
</ol>
<p>undo log（在表空间）: 修改前的值/版本号;<br>undo log可以配置从表空间中分离出来。</p>
<p>redo log（在log buffer）: 类似于WAL，记录buffer pool和disk的不同。</p>
<h3 id="回滚事务的crash恢复"><a href="#回滚事务的crash恢复" class="headerlink" title="回滚事务的crash恢复"></a>回滚事务的crash恢复</h3><ul>
<li>redo log: 只追加写，提交到磁盘以后标记为可以被新日志覆盖。</li>
<li>基于这个特性，即使事务已经回滚了，它的redo log依然是存在的。</li>
<li>再基于以上这点，db crash以后，可以恢复已经回滚的事务。</li>
</ul>
<p>回滚事务的crash恢复,有两种策略:</p>
<ol>
<li>读redo log,挑已经提交的事务进行恢复;</li>
<li>读redo log,恢复所有事务，再用undo log解决回滚的事务。</li>
</ol>
<p><code>innodb</code>使用的是策略2，也就是先redo,再undo。</p>
<p>使用策略2的难点:</p>
<ul>
<li><p>需要redo log相应的undo log是健全的，否则就漏回滚了。<br>(1)解决方案1:确保undo log落盘早于redo log；（很麻烦，不用）<br>(2)解决方案2:将undo log也视为数据，记录到redo log中。（innodb采用）</p>
</li>
<li><p>总结</p>
<blockquote>
<p>crash恢复: 先读取执行redo log，再执行undo log，这样可以恢复未提交事务和回滚事务。<br>undo log和redo log的数据一致性: 把undo log也视为数据，写入redo log。</p>
</blockquote>
</li>
</ul>
<h3 id="日志与事务提交速度"><a href="#日志与事务提交速度" class="headerlink" title="日志与事务提交速度:"></a>日志与事务提交速度:</h3><p>redo log: 不影响事务提交速度。因为是事务进行中就产生、而且每秒刷盘了；<br>binlog: 影响事务提交速度。因为事务提交前才产生binlog、刷盘，因此如果开启了binlog，长时间的事务提交很慢。</p>
<p>三种重要日志的写顺序:</p>
<ol>
<li>undo log;</li>
<li>redo log;</li>
<li>binlog.</li>
</ol>
<h2 id="MYISAM的IO配置"><a href="#MYISAM的IO配置" class="headerlink" title="MYISAM的IO配置"></a>MYISAM的IO配置</h2><p><code>delay_key_write</code>:<br>OFF: 不延迟。每次写操作后刷新键缓存;<br>ON: 延迟。对使用该选项创建的表生效;<br>ALL: 延迟。对所有表生效。<br>该选项对性能提升不大,缺点:</p>
<ol>
<li>索引可能损坏;</li>
<li>关闭表时间变长;</li>
<li>占用空间变大。</li>
</ol>
<p><code>myisam_use_mmap</code>: 使用内存映射，减少系统调用开销。</p>
<h2 id="Innodb并发"><a href="#Innodb并发" class="headerlink" title="Innodb并发"></a>Innodb并发</h2><p><code>innodb_thread_concurrency</code>:<br>N=0: 不限制有多少线程进入内核;<br>N&gt;0: 同时可以有N个线程进入内核。<br>N的推荐值&lt; 2<em>cpu数</em>disk数</p>
<p><code>innodb_commit_concurrency</code>:<br>同时可以有多少个线程提交。</p>
<h2 id="Myisam并发"><a href="#Myisam并发" class="headerlink" title="Myisam并发"></a>Myisam并发</h2><p><code>concurrent_insert</code>:<br>0: 不允许并发插入;<br>1: 默认值。只要表中没有空洞，就允许并发插入。<br>2: 强制并发插入到Myisam表末尾，即使有空洞。（碎片会更多）</p>
<h2 id="基于工作负载的配置"><a href="#基于工作负载的配置" class="headerlink" title="基于工作负载的配置"></a>基于工作负载的配置</h2><ol>
<li>blob,text的表，临时表都会变成磁盘表。<br>解决方案: 使用substr。</li>
</ol>
<p><code>tmp_table_size</code>,<code>max_heap_table_size</code>: 临时表大小上限。<br><code>max_connections</code>: 最大连接数。<br><code>thread_cache_size</code>: 缓存线程数。</p>
<p> 查看配置和状态:<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">show variables like &#39;%thread%&#39;;</span><br><span class="line">show status like &#39;%thread%&#39;;</span><br></pre></td></tr></table></figure></p>
<p> <code>innodb_autoinc_lock_mode</code><br> 0: 每次都锁；<br> 1: 确定需要分配多少自增值的话，可以立即释放锁；<br> 2: 每次都不锁，空洞很多。</p>
<h2 id="两个最重要的配置"><a href="#两个最重要的配置" class="headerlink" title="两个最重要的配置"></a>两个最重要的配置</h2><p> <code>innodb_log_file_size</code>: redo log的缓冲区，如果调大了<code>innodb_buffer_pool_size</code>就要相应调大它。<br>(一种可能的值是512<em>1024</em>1024,512M,搭配2G的<code>innodb_buffer_pool_size</code>)<br>可以通过<code>show engine innodb status\G select sleep(60); show engine innodb status\G</code>,查看<code>Log sequence number</code>差，计算1个小时的redo日志写入量，大致可以设置为这个缓冲区的大小。</p>
<p><code>innodb_buffer_pool_size</code>的大小设置就比较简单了，按服务器可用内存75%设定即可。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://xiaoyue26.github.io/2019/02/11/2019-02/%E9%AB%98%E6%80%A7%E8%83%BDmysql%E7%AC%AC%E5%85%AB%E7%AB%A0-%E7%AC%94%E8%AE%B0-%E4%BC%98%E5%8C%96%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE/" data-id="ck96cxppf00h3maamgo769a0c" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/mysql/" rel="tag">mysql</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-2019-02/高性能mysql第七章-笔记-高级特性" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/02/11/2019-02/%E9%AB%98%E6%80%A7%E8%83%BDmysql%E7%AC%AC%E4%B8%83%E7%AB%A0-%E7%AC%94%E8%AE%B0-%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/" class="article-date">
  <time datetime="2019-02-11T14:31:10.000Z" itemprop="datePublished">2019-02-11</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/mysql/">mysql</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/02/11/2019-02/%E9%AB%98%E6%80%A7%E8%83%BDmysql%E7%AC%AC%E4%B8%83%E7%AB%A0-%E7%AC%94%E8%AE%B0-%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/">高性能mysql第七章-笔记-高级特性</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <h1 id="高级特性"><a href="#高级特性" class="headerlink" title="高级特性"></a>高级特性</h1><p>略过: 分区表,合并表,全文索引</p>
<h2 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h2><p>视图会影响优化器</p>
<h2 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h2><p>在线系统: 不推荐使用;<br>离线系统: 如果代码很简单，为了批量性能可以考虑。</p>
<h2 id="游标"><a href="#游标" class="headerlink" title="游标"></a>游标</h2><p>游标使用临时表实现。</p>
<p>因此：</p>
<ol>
<li>逐行只读;</li>
<li>会执行整个查询。</li>
</ol>
<p>基于2，如果只读一小部分结果，请使用limit。<br>(也就是不要使用游标来实现limit的效果，直接使用limit语句即可)</p>
<h2 id="prepareStatement"><a href="#prepareStatement" class="headerlink" title="prepareStatement"></a>prepareStatement</h2><h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><ol>
<li>客户端=&gt;服务端: SQL原型</li>
<li>服务端: SQL原型=&gt;部分执行计划A;</li>
<li>服务端=&gt;客户端: A的句柄;</li>
<li>客户端=&gt;服务端: 变量、A的句柄.</li>
</ol>
<p>优点:</p>
<ol>
<li>服务端: SQL解析只需解析/优化一次;</li>
<li>通信: 只发送参数+句柄，通信成本降低;</li>
<li>缓存: 参数可以被缓存;</li>
<li>安全: 无须转义、由于执行计划定了，不会被SQL注入。</li>
</ol>
<p><code>prepareStatement</code>的三类优化:<br>(和传入参数无关的)</p>
<ol>
<li>准备阶段: 根据已知条件,where条件优化;</li>
<li>第一次执行: 简化嵌套关联,将外关联转化成内关联;</li>
<li>每次SQL执行:<br>(1) 过滤分区;<br>(2) 尽量移除count,min,max;<br>(3) 移除常量表达式;<br>(4) 检测常量表;<br>(5) 做必要的等值传播;<br>(6) 分析和优化ref,range和索引优化等访问数据的方法;<br>(7) 优化关联顺序。</li>
</ol>
<h2 id="绑定变量"><a href="#绑定变量" class="headerlink" title="绑定变量"></a>绑定变量</h2><p><code>set @xxx:= 123</code><br>绑定变量是会话级的。</p>
<h2 id="字符集和校对"><a href="#字符集和校对" class="headerlink" title="字符集和校对"></a>字符集和校对</h2><p>字符集(<code>encode</code>)： 二进制&lt;=&gt;某类编码字符<br>校对(<code>collation</code>)：某字符集的排序规则。</p>
<p>校对集都是针对某一个字符集的。(类似于弱实体)</p>
<p>相关设置分为两类:</p>
<ol>
<li>创建对象时候的默认值</li>
<li>服务器和客户端通信的设置</li>
</ol>
<h3 id="1-创建对象时候的默认值"><a href="#1-创建对象时候的默认值" class="headerlink" title="1. 创建对象时候的默认值"></a>1. 创建对象时候的默认值</h3><p>(1)<code>character_set_server</code>: 服务器创建数据库默认值;<br>(2)表字符集;<br>(3)列字符集.<br>越小范围的优先级越高。</p>
<h3 id="2-服务器和客户端通信的设置"><a href="#2-服务器和客户端通信的设置" class="headerlink" title="2. 服务器和客户端通信的设置"></a>2. 服务器和客户端通信的设置</h3><h4 id="服务端"><a href="#服务端" class="headerlink" title="服务端:"></a>服务端:</h4><img src="/images/2019-02/mysql_char.png" class="" width="800" height="1200" title="mysql_char">
<p>(1)<code>character_set_client</code>: 服务端总是假设客户端按照<code>character_set_client</code>设置的字符集来传输数据和sql语句;<br>(2)<code>character_set_connection</code>: 服务器收到客户端sql后,转换成<code>character_set_connection</code>类型;<br>(3)<code>character_result</code>:服务端返回数据时,转换成<code>character_result</code>类型。</p>
<h4 id="客户端"><a href="#客户端" class="headerlink" title="客户端:"></a>客户端:</h4><p>客户端: <code>jdbc:mysql://localhost:3306/exceltest1?useUnicode=true&amp;characterEncoding=UTF-8</code></p>
<p>客户端可以使用<code>set names utf-8</code>语句来告诉服务端自己将使用<code>utf-8</code>传输数据。</p>
<h4 id="特殊情况"><a href="#特殊情况" class="headerlink" title="特殊情况"></a>特殊情况</h4><p>诡异的<code>character_set_database</code>: 某个数据库的默认字符集。当数据库改变的时候，它也会改变。当没有指定数据库的时候，会按照<code>character_set_server</code>。</p>
<p><code>Load Data Infile</code>:<br>数据库总是将文件中的字符按照字符集<code>character_set_database</code>来解析。<br>mysql加载数据的时候，总是以同一个字符集处理所有数据，不管表中的列是否有不同的字符集设定。</p>
<p><code>Select Into OutFile</code>:<br>输出文件时不会自动做转码，也不能指定。唯一的方法是手动调用函数<code>convert</code>。</p>
<h4 id="查看字符集设置"><a href="#查看字符集设置" class="headerlink" title="查看字符集设置"></a>查看字符集设置</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">VARIABLES</span> <span class="keyword">LIKE</span> <span class="string">'character%'</span>;</span><br></pre></td></tr></table></figure>

<p>查看mysql支持的校对集: <code>show collation</code></p>
<p>一般校对集是字符集加上三种后缀:<br><code>_bin</code>: 二进制比较;<br><code>_ci</code>: 忽略大小写(ignore);<br><code>_cs</code>: 大小写敏感(sensitive)</p>
<p>大小写敏感比二进制比较更加复杂，会有更多规则。</p>
<h3 id="mysql如何选择字符集"><a href="#mysql如何选择字符集" class="headerlink" title="mysql如何选择字符集"></a>mysql如何选择字符集</h3><p>每个字符集有对应的默认校对集；<br>每个校对集有对应的默认字符集。（一般来说，校对集依赖于字符集）</p>
<ol>
<li>如果用户设置了: 那肯定按用户设置的来;</li>
<li>如果设置了一部分: 根据用户设置找默认的。</li>
<li>什么都没设置: 根据默认配置设置。</li>
</ol>
<h1 id="分布式（XA）事务"><a href="#分布式（XA）事务" class="headerlink" title="分布式（XA）事务"></a>分布式（XA）事务</h1><p>两阶段提交。<br>协调者+参与者。</p>
<ol>
<li>所有参与者完成准备工作；</li>
<li>协调者收到所有参与者的回复，提交事务。</li>
</ol>
<p>两种XA: 内部XA,外部XA。</p>
<h2 id="内部XA"><a href="#内部XA" class="headerlink" title="内部XA"></a>内部XA</h2><p>mysql是插件式的，因此每个存储引擎是互相独立，不知道彼此存在的。<br>他们之间协调需要分布式事务。(内部XA)</p>
<ul>
<li>跨存储引擎的事务需要内部XA。</li>
</ul>
<p>如果开启了二进制日志，日志也可以看作一种特别的存储引擎，因此也需要内部XA。</p>
<h2 id="外部XA"><a href="#外部XA" class="headerlink" title="外部XA"></a>外部XA</h2><p>mysql对xa协议支持不完整，无法在一个XA中关联多个连接。<br>外部XA网络开销大，建议引入<code>MQ</code>解决，而不使用外部XA。</p>
<h1 id="查询缓存"><a href="#查询缓存" class="headerlink" title="查询缓存"></a>查询缓存</h1><ol>
<li>检查sql是不是<code>select</code>开头,如果数据源表没有更改,hash查找缓存,返回结果;</li>
<li>如果有确定性结果,存储查询语句的结果和hash值到缓存。</li>
</ol>
<p>由于2(确定性结果)，所以使用<code>current_date</code>这样的函数时，sql结果不会被缓存。</p>
<p>查询缓存的注意事项:</p>
<ol>
<li>不能有长时间的事务;(会引入全局锁)</li>
<li>不要占用太大内存(过度依赖缓存)，可以直接使用redis。</li>
</ol>
<p>过度依赖缓存的话，缓存清理以后系统会假死很久。</p>
<h2 id="查询缓存的配置参数"><a href="#查询缓存的配置参数" class="headerlink" title="查询缓存的配置参数"></a>查询缓存的配置参数</h2><p><code>show variables like &#39;%query_cache%&#39;</code></p>
<h3 id="query-cache-type"><a href="#query-cache-type" class="headerlink" title="query_cache_type"></a>query_cache_type</h3><p>三种取值:</p>
<ol>
<li>OFF(0): 关闭,默认值。</li>
<li>ON(1):  打开</li>
<li>DEMAND(2): sql里写明<code>sql_cache</code>hint的语句才放入缓存。</li>
</ol>
<p><code>query_cache_size</code>: 查询缓存占的空间;<br><code>query_cache_limit</code>: 缓存结果集最大条数;</p>
<p>清空缓存: <code>reset query cache</code><br>整理缓存碎片: <code>flush query cache</code>(服务僵死一段时间)</p>
<img src="/images/2019-02/query_cache_opt.png" class="" width="800" height="1200" title="query_cache_opt">
      
    </div>
    <footer class="article-footer">
      <a data-url="http://xiaoyue26.github.io/2019/02/11/2019-02/%E9%AB%98%E6%80%A7%E8%83%BDmysql%E7%AC%AC%E4%B8%83%E7%AB%A0-%E7%AC%94%E8%AE%B0-%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/" data-id="ck96cxppg00hamaamd748dsy9" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/mysql/" rel="tag">mysql</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-2019-02/半小时真正理解记住paxos协议" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/02/01/2019-02/%E5%8D%8A%E5%B0%8F%E6%97%B6%E7%9C%9F%E6%AD%A3%E7%90%86%E8%A7%A3%E8%AE%B0%E4%BD%8Fpaxos%E5%8D%8F%E8%AE%AE/" class="article-date">
  <time datetime="2019-02-01T01:45:14.000Z" itemprop="datePublished">2019-02-01</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/">分布式</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/02/01/2019-02/%E5%8D%8A%E5%B0%8F%E6%97%B6%E7%9C%9F%E6%AD%A3%E7%90%86%E8%A7%A3%E8%AE%B0%E4%BD%8Fpaxos%E5%8D%8F%E8%AE%AE/">半小时真正理解记住paxos协议</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <p>摘要:</p>
<blockquote>
<p>简单浏览一遍流程，然后看半小时视频: <a href="https://www.bilibili.com/video/av36134550" target="_blank" rel="noopener">https://www.bilibili.com/video/av36134550</a><br>就OK了。</p>
</blockquote>
<p>paxos是分布式一致性协议，对于CAP的取舍是完全的C，较好的A，较好的P。<br>（关于CAP: <a href="http://xiaoyue26.github.io/2019/02/01/2019-02/简单解释CAP原理">http://xiaoyue26.github.io/2019/02/01/2019-02/简单解释CAP原理</a> ）</p>
<h1 id="paxos协商流程"><a href="#paxos协商流程" class="headerlink" title="paxos协商流程"></a>paxos协商流程</h1><h2 id="两个角色"><a href="#两个角色" class="headerlink" title="两个角色"></a>两个角色</h2><p>Proposer<br>Acceptor</p>
<h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><p>首先大致扫一遍下叙流程，第一遍大概率是完全懵逼看不懂的，花1分钟在脑中留下一点点印象即可:</p>
<h3 id="准备阶段（prepare）Proposer申请epoch"><a href="#准备阶段（prepare）Proposer申请epoch" class="headerlink" title="准备阶段（prepare）Proposer申请epoch"></a>准备阶段（prepare）Proposer申请epoch</h3><p>第一阶段A：Proposer选择一个提议编号n，向所有的Acceptor广播Prepare（n）请求。</p>
<p>第一阶段B：若Acceptor接收到Prepare（n）请求，两个选择:<br>    (1)n&gt;接受过的n_old: 接受请求,返回<code>(n_old,value_old)</code>。<br>    (2)n&lt;接受过的n_old: 拒绝请求。</p>
<h3 id="接受阶段（提交阶段）"><a href="#接受阶段（提交阶段）" class="headerlink" title="接受阶段（提交阶段）"></a>接受阶段（提交阶段）</h3><p>第二阶段A：Proposer得到了Acceptor响应:<br>1.如果未超过半数accpetor响应，直接转为提议失败；</p>
<p>2.如果超过多数Acceptor的承诺，又分为不同情况：<br>(1)如果所有Acceptor返回的value都是<code>null</code>，那么向所有的Acceptor发送<code>(n,value_n)</code>;<br>(2)如果存在Acceptor返回的value不为<code>null</code>，那么从所有接受过的值中选择对应的n_old最大的作为提议的值value_old，提议编号仍然为n。但此时Proposer就不能提议自己的值，只能信任Acceptor通过的值，维护一但获得确定性取值就不能更改原则: 向所有Acceptor发送<code>(n,value_old of max n_old)</code>。</p>
<p>第二阶段B：Acceptor接收到提议<code>(n,value)</code>后：<br>(1)n!=本地保存的last_n，拒绝。<br>(2)n=本地保存的last_n，写入本地值。</p>
<h2 id="看教学视频"><a href="#看教学视频" class="headerlink" title="看教学视频:"></a>看教学视频:</h2><p><a href="https://www.bilibili.com/video/av36134550" target="_blank" rel="noopener">https://www.bilibili.com/video/av36134550</a></p>
<p>由于之前花1分钟浏览了流程，视频看到15分钟的时候心里就会已经有数了。<br>看完30分钟就理解记住了。</p>
<h2 id="温习要点"><a href="#温习要点" class="headerlink" title="温习要点"></a>温习要点</h2><ol>
<li>类似于CAS，仅当，当前值为null时，才能提议值为value。</li>
<li>类似于jdk里的hashmap扩容，当发现有人捷足先登的时候，放下陈见开始辅助n_old完成value_old的扩散。发送(n,value_old)，以自己的名义，但是以别人的值，帮助一致性尽快达成。</li>
<li>Acceptor对于epoch: 喜新厌旧,总是接受最大的epoch，防止Proposor单点故障死等。</li>
<li>Proposor对于value: 喜旧厌新,总是接受更旧的value，尽快达成一致性。</li>
</ol>
<p>以上就是Basic Paxos。其实依然会有活锁，需要引进leader缓解。leader挂了的时候退化到Basic Paxos，出现活锁几率提升。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://xiaoyue26.github.io/2019/02/01/2019-02/%E5%8D%8A%E5%B0%8F%E6%97%B6%E7%9C%9F%E6%AD%A3%E7%90%86%E8%A7%A3%E8%AE%B0%E4%BD%8Fpaxos%E5%8D%8F%E8%AE%AE/" data-id="ck96cxppb00gnmaamhyerfdxe" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/paxos/" rel="tag">paxos</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F/" rel="tag">分布式</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-2019-02/简单解释CAP原理" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/02/01/2019-02/%E7%AE%80%E5%8D%95%E8%A7%A3%E9%87%8ACAP%E5%8E%9F%E7%90%86/" class="article-date">
  <time datetime="2019-02-01T01:33:53.000Z" itemprop="datePublished">2019-02-01</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/">分布式</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/02/01/2019-02/%E7%AE%80%E5%8D%95%E8%A7%A3%E9%87%8ACAP%E5%8E%9F%E7%90%86/">简单解释CAP原理</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <p>关于CAP原理的术语描述很多,其实给理解带来了障碍。(以下是维基百科:)</p>
<blockquote>
<p>一致性（Consistency）： （等同于所有节点访问同一份最新的数据副本）<br>可用性（Availability）：（每次请求都能获取到非错的响应——但是不保证获取的数据为最新数据）<br>分区容错性（Partition tolerance）：（以实际效果而言，分区相当于对通信的时限要求。系统如果不能在时限内达成数据一致性，就意味着发生了分区的情况，必须就当前操作在C和A之间做出选择。）</p>
</blockquote>
<img src="/images/2019-02/cap.png" class="" width="800" height="1200" title="cap">
<p>如图所示,CAP最多只能取两者。（如果每项要彻底达标，只能取2个，但也可以三者都不完全实现）</p>
<p>改成自然语言，通俗解释一下，就容易理解多了:</p>
<blockquote>
<p>C: 一致性。达成一致的速度足够快、或者每次更新是整个集群原子性的操作。如果有一个中控节点(单点瓶颈)，很容易让值变更是原子性的。(但也牺牲了A)<br>A: 可用性。 没有单点瓶颈，挂1，2个节点也能正常工作。<br>P: 可分性。 把集群切两半，让它们失联，让两半都能正常工作。</p>
</blockquote>
<h2 id="具体案例的CAP取舍"><a href="#具体案例的CAP取舍" class="headerlink" title="具体案例的CAP取舍"></a>具体案例的CAP取舍</h2><p>大部分的分布式系统(或者说集群)都是先取P，然后取舍A或者C（引入单点，或者使用P2P的协议）。</p>
<p><code>lease机制</code>: CP。例如hdfs中pipeline写入,client先申请租约lease，然后写入3备份后才返回。一致性由client单点控制完成,P由3副本完成，牺牲了A（有单点）。<br><code>Quorum机制</code>:C+0.5A+0.5P。N个副本，更新W个，读R个。<br><code>2PC/两阶段提交</code>: C+0.1A+0.1P。<br><code>Paxos</code>: C+0.8C+0.8P。</p>
<p><code>redis-cluster</code>: AP。key的分布:用gossip协议(类似于p2p)达成一致性,因此C比较慢。<br><code>redis-sentile</code>: CP。key的分布:各节点完全独立,数据存在哪里完全由客户端单点维护。因此没有A。<br><code>codis</code>：CP。由代理单点维护key的分布，因此也没有A。</p>
<p>一个实际的系统可能涉及到很多分布式协议，因此每个部分对于CAP的取舍可能会有不同。<br>HDFS系统: CP。大部分看起来是有单点。<br>ceph系统: AP。大部分看起来是p2p的，</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://xiaoyue26.github.io/2019/02/01/2019-02/%E7%AE%80%E5%8D%95%E8%A7%A3%E9%87%8ACAP%E5%8E%9F%E7%90%86/" data-id="ck96cxppa00gkmaam2ka94wve" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F/" rel="tag">分布式</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-2019-01/redis的quicklist" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/01/19/2019-01/redis%E7%9A%84quicklist/" class="article-date">
  <time datetime="2019-01-19T12:29:18.000Z" itemprop="datePublished">2019-01-19</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/redis/">redis</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/01/19/2019-01/redis%E7%9A%84quicklist/">redis的quicklist</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <p>列表对象: <code>REDIS_LIST</code></p>
<p>列表对象以前有两种编码: <code>linkedlist</code>和<code>zipList</code>：<br><code>linkedList</code>: 双向链表,灵活扩展,存取效率低。<br><code>zipList</code>: 连续存储,存取效率高，对缓存友好，扩展性差，修改插入需要级联移动.甚至可以粗略看做数组。<br>小数据量的时候会使用<code>zipList</code>,大数据量的时候会使用<code>linkedList</code>。<br>但它们其实是两个极端，各有优缺点。因此之后的版本就把它们混血了一下，出了一个<code>quickList</code>，平衡优缺点。</p>
<h2 id="quickList设计"><a href="#quickList设计" class="headerlink" title="quickList设计"></a>quickList设计</h2><p>粗略地看，把双向链表的每一个节点变成<code>zipList</code>，就是<code>quickList</code>了。<br>在原来的两个数据结构之间做一个折中，量化折中的参数:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 负数表示存储容量等级,每个节点上的ziplist大小不能超过8Kb（也就是2^3KB，以此类推）</span><br><span class="line">list-max-ziplist-size -2</span><br><span class="line"># 正数表示存储个数，每个节点上的zipList内元素不能超过5个:</span><br><span class="line">list-max-ziplist-size 5</span><br></pre></td></tr></table></figure>

<p>还有一个压缩参数:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 不进行压缩:</span><br><span class="line">list-compress-depth 0 </span><br><span class="line"># 除了首尾1个，中间的压缩:</span><br><span class="line">list-compress-depth 1</span><br></pre></td></tr></table></figure>
<p>由于双向链表一般用<code>LPush</code>,<code>Rpush</code>，两端的数据访问比较频繁，</p>
<h2 id="quickList源码"><a href="#quickList源码" class="headerlink" title="quickList源码"></a>quickList源码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">quicklist</span> &#123;</span></span><br><span class="line">    quicklistNode *head;    <span class="comment">// 头结点</span></span><br><span class="line">    quicklistNode *tail;    <span class="comment">// 尾节点</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> count;    <span class="comment">// 所有数据的数量</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> len;       <span class="comment">// quicklist节点数量</span></span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">fill</span>:<span class="number">16</span>;          <span class="comment">// 单个ziplist的大小限制</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> compress:<span class="number">16</span>;   <span class="comment">// 压缩深度</span></span><br><span class="line">&#125; quicklist;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">quicklistNode</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">quicklistNode</span> *<span class="title">prev</span>;</span> <span class="comment">// 前一个节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">quicklistNode</span> *<span class="title">next</span>;</span> <span class="comment">// 后一个节点</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *zl;  <span class="comment">// ziplist</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> sz;             <span class="comment">// ziplist的内存大小</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> count:<span class="number">16</span>;     <span class="comment">// zpilist中数据项的个数</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> encoding:<span class="number">2</span>;   <span class="comment">// 1为ziplist 2是LZF压缩存储方式</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> container:<span class="number">2</span>;  </span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> recompress:<span class="number">1</span>;   <span class="comment">// 压缩标志, 为1 是压缩</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> attempted_compress:<span class="number">1</span>; <span class="comment">// 节点是否能够被压缩,只用在测试</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> extra:<span class="number">10</span>; <span class="comment">/* more bits to steal for future usage */</span></span><br><span class="line">&#125; quicklistNode;</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://xiaoyue26.github.io/2019/01/19/2019-01/redis%E7%9A%84quicklist/" data-id="ck96cxpp400fqmaam3ugwg3le" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/redis/" rel="tag">redis</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-2019-01/redis的embstr为什么是39B" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/01/19/2019-01/redis%E7%9A%84embstr%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF39B/" class="article-date">
  <time datetime="2019-01-19T02:47:50.000Z" itemprop="datePublished">2019-01-19</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/redis/">redis</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/01/19/2019-01/redis%E7%9A%84embstr%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF39B/">redis的embstr为什么是39B</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <p>回顾字符串的三种实现:</p>
<ul>
<li><code>int</code>: long能存下的数会用数字编码;</li>
<li><code>embstr</code>: &lt;=39B的字符串，或者浮点数，会用<code>embstr</code>编码;</li>
<li><code>raw</code>: &gt;39B的字符串，会用<code>raw</code>编码,也就是简单动态字符串(<code>SDS</code>)。<img src="/images/2019-01/raw.png" class="" width="800" height="1200" title="raw">
<img src="/images/2019-01/embstr.png" class="" width="800" height="1200" title="embstr">

</li>
</ul>
<p><code>embstr</code>顾名思义就是嵌入式字符串，把元数据和实际数据存放在一起，好处是这样可以对缓存友好，可以减少一次寻址。坏处是只能支持短字符串。<br>这里为啥是39B作为切换条件呢?(而且没有看到参数进行调节)，这其实是存储结构决定的。</p>
<blockquote>
<p>embstr本质上是利用了元数据存储空间里的剩余空间存储字符串。</p>
</blockquote>
<p>所以当元数据剩了40B，<code>embstr</code>就最多只能存39B了(还要留1B存<code>\0</code>)。<br>回顾元数据结构：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LRU_BITS 24</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span> &#123;</span>    <span class="comment">// redis对象</span></span><br><span class="line">    <span class="keyword">unsigned</span> type:<span class="number">4</span>;    <span class="comment">// 类型,4bit</span></span><br><span class="line">    <span class="keyword">unsigned</span> encoding:<span class="number">4</span>;    <span class="comment">// 编码,4bit</span></span><br><span class="line">    <span class="keyword">unsigned</span> lru:LRU_BITS; <span class="comment">/* lru time (relative to server.lruclock) */</span> <span class="comment">// 24bit</span></span><br><span class="line">    <span class="keyword">int</span> refcount;   <span class="comment">// 引用计数</span></span><br><span class="line">    <span class="keyword">void</span> *ptr;  <span class="comment">// 指向各种基础类型的指针</span></span><br><span class="line">&#125; robj;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> len;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="built_in">free</span>;</span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;sds;</span><br></pre></td></tr></table></figure>
<img src="/images/2019-01/sizeof0.png" class="" width="800" height="1200" title="sizeof0">
<img src="/images/2019-01/sizeof1.png" class="" width="800" height="1200" title="sizeof0">

<h2 id="redisObject占16B"><a href="#redisObject占16B" class="headerlink" title="redisObject占16B"></a>redisObject占16B</h2><p><code>16B=(4bit+4bit+24bit)+4B+8B= (32/8)B+12B</code></p>
<h2 id="sdshdr占8B"><a href="#sdshdr占8B" class="headerlink" title="sdshdr占8B"></a>sdshdr占8B</h2><p><code>8=4+4+0</code><br>注意这里的<code>char buf[]</code>不占空间，当里面存放字符串的时候才占空间，而且末尾需要1B存放<code>\0</code>。</p>
<p>按最小分配64B来算，剩余空间就是64B-16B-8B-1B=39B。</p>
<p>但是，如果仔细看看这里<code>sdshdr</code>里的，两个4B的长度：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> len;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="built_in">free</span>;</span><br></pre></td></tr></table></figure>
<p>想一下，这里最大长度也才39,根本不需要这么大的数据结构来存长度，因此其实还是有压榨空间的。</p>
<h1 id="从39B到44B"><a href="#从39B到44B" class="headerlink" title="从39B到44B"></a>从39B到44B</h1><p>新版本的<code>embstr</code>已经不是39B了，改成了44B。本质上是元数据的剩余空间再次发生了变化。<br>新版本的元数据(从<code>SDS_TYPE_5</code>到<code>SDS_TYPE_64</code>5个)：<br>(<a href="https://github.com/antirez/redis/blob/unstable/src/sds.h" target="_blank" rel="noopener">https://github.com/antirez/redis/blob/unstable/src/sds.h</a>)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Note: sdshdr5 is never used, we just access the flags byte directly.</span></span><br><span class="line"><span class="comment"> * However is here to document the layout of type 5 SDS strings. */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr5</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags; <span class="comment">/* 3 lsb of type, and 5 msb of string length */</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr8</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint8_t</span> len; <span class="comment">/* used */</span></span><br><span class="line">    <span class="keyword">uint8_t</span> alloc; <span class="comment">/* excluding the header and null terminator */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr16</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint16_t</span> len; <span class="comment">/* used */</span></span><br><span class="line">    <span class="keyword">uint16_t</span> alloc; <span class="comment">/* excluding the header and null terminator */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr32</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> len; <span class="comment">/* used */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> alloc; <span class="comment">/* excluding the header and null terminator */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr64</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint64_t</span> len; <span class="comment">/* used */</span></span><br><span class="line">    <span class="keyword">uint64_t</span> alloc; <span class="comment">/* excluding the header and null terminator */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中<code>sdshdr5</code>其实没有用，用的是<code>sdshdr8</code>，因此这里的元数据结构从8B下降到3B，<code>embstr</code>可用空间也就从39B上升到44B了。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://xiaoyue26.github.io/2019/01/19/2019-01/redis%E7%9A%84embstr%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF39B/" data-id="ck96cxpp300fnmaama6uv3u8r" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/redis/" rel="tag">redis</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-2019-01/redis4的LFU" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/01/12/2019-01/redis4%E7%9A%84LFU/" class="article-date">
  <time datetime="2019-01-12T12:03:16.000Z" itemprop="datePublished">2019-01-12</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/redis/">redis</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/01/12/2019-01/redis4%E7%9A%84LFU/">redis4的LFU</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <p>LRU实现太复杂，一般用LFU近似。<br>LFU的关键是统计访问频次。<br>可以看参考资料: <a href="https://redis.io/topics/lru-cache" target="_blank" rel="noopener">https://redis.io/topics/lru-cache</a></p>
<p>里面提到为了节省空间，用8位来统计1000次访问或更多。<br>直接存肯定不行，因为8位=&gt;256，最多存256次。<br>所以8位肯定只能存分级，256个等级。<br>比如1000次hit才增加一次等级。<br>那么怎么知道有1000次hit了呢？<br>可以用概率算法，rand()一个数，如果小于1/1000，则加1。</p>
<p>类似的概率算法还有:<code>count min sketch</code>算法，用一大堆布隆过滤器记录每个key的访问频次，<br>由于肯定会有碰撞，因此这个估计值是虚高的。<br>取的时候，从这些布隆里取一个最小的频次作为估计值即可。<br>主要思想如此，类似的还有<code>HyperLogLog</code>，但是实际代码有很多边界修正。<br>比如谷歌的HLL++算法，保证平均、最坏情况下的精度损失不会太大。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://xiaoyue26.github.io/2019/01/12/2019-01/redis4%E7%9A%84LFU/" data-id="ck96cxpp200fjmaam3d1c6jwy" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/redis/" rel="tag">redis</a></li></ul>

    </footer>
  </div>
  
</article>
 


  


  <nav id="page-nav">
    <a class="extend prev" rel="prev" href="/page/7/">&amp;laquo; 上一页</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="page-number" href="/page/7/">7</a><span class="page-number current">8</span><a class="page-number" href="/page/9/">9</a><a class="page-number" href="/page/10/">10</a><span class="space">&hellip;</span><a class="page-number" href="/page/23/">23</a><a class="extend next" rel="next" href="/page/9/">下一页&amp;raquo;</a>
  </nav>
</section>
           
    <aside id="sidebar">
  
    

  
    
  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title recent-posts">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/03/14/2022-03/%E4%B8%AD%E6%96%AD%E6%A2%B3%E7%90%86/">java方法是否可中断梳理</a>
          </li>
        
          <li>
            <a href="/2022/03/13/2022-03/mp4%E6%A0%BC%E5%BC%8F/">mp4格式</a>
          </li>
        
          <li>
            <a href="/2022/03/13/2022-03/ss%E5%91%BD%E4%BB%A4/">ss命令</a>
          </li>
        
          <li>
            <a href="/2022/03/13/2022-03/UDP%E6%89%B9%E5%A4%84%E7%90%86%E4%BC%98%E5%8C%96-GSO-GRO/">UDP批处理优化-GSO/GRO</a>
          </li>
        
          <li>
            <a href="/2022/02/24/2022-02/%E4%B8%BA%E4%BB%80%E4%B9%88%E5%85%88hash%E5%90%8E%E5%8A%A0%E5%AF%86%E7%9A%84%E6%96%B9%E6%B3%95%E5%AE%B9%E6%98%93%E9%81%AD%E9%81%87padding%E6%94%BB%E5%87%BB/">为什么先hash后加密的方法容易遭遇padding攻击</a>
          </li>
        
      </ul>
    </div>
  </div>

  
    

  
</aside>

      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-left">
      &copy; 2014 - 2022 风梦七&nbsp;|&nbsp;
      主题 <a href="https://github.com/giscafer/hexo-theme-cafe/" target="_blank">Cafe</a>
    </div>
     <div id="footer-right">
      联系方式&nbsp;|&nbsp;296671657@qq.com
    </div>
  </div>
</footer>
 
<script src="/jquery/jquery.min.js"></script>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">首页</a>
  
    <a href="/archives" class="mobile-nav-link">归档</a>
  
    <a href="/about" class="mobile-nav-link">关于</a>
  
</nav>
    <img class="back-to-top-btn" src="/images/fly-to-top.png"/>
<script>
// Elevator script included on the page, already.
window.onload = function() {
  var elevator = new Elevator({
    selector:'.back-to-top-btn',
    element: document.querySelector('.back-to-top-btn'),
    duration: 1000 // milliseconds
  });
}
</script>
      

  
    <script>
      var cloudTieConfig = {
        url: document.location.href, 
        sourceId: "",
        productKey: "e2fb4051c49842688ce669e634bc983f",
        target: "cloud-tie-wrapper"
      };
    </script>
    <script src="https://img1.ws.126.net/f2e/tie/yun/sdk/loader.js"></script>
    

  







<!-- author:forvoid begin -->
<!-- author:forvoid begin -->

<!-- author:forvoid end -->

<!-- author:forvoid end -->


  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      })
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      })
    </script>
    <script type="text/javascript" src="https://cdn.rawgit.com/mathjax/MathJax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


 
<script src="/js/is.js"></script>



  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>


<script src="/js/elevator.js"></script>

  </div>
</body>
</html>