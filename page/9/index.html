<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>笔记本</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="笔记本">
<meta property="og:url" content="http://xiaoyue26.github.io/page/9/index.html">
<meta property="og:site_name" content="笔记本">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="风梦七">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="笔记本" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    
  
  
<link rel="stylesheet" href="/css/style.css">

  

<meta name="generator" content="Hexo 4.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    
    <div id="header-inner" class="inner">
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://xiaoyue26.github.io"></form>
      </div>
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">首页</a>
        
          <a class="main-nav-link" href="/archives">归档</a>
        
          <a class="main-nav-link" href="/about">关于</a>
        
      </nav>
      
    </div>
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">笔记本</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">风梦七</a>
        </h2>
      
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-2018-11/jvm运行参数配置含义" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/11/25/2018-11/jvm%E8%BF%90%E8%A1%8C%E5%8F%82%E6%95%B0%E9%85%8D%E7%BD%AE%E5%90%AB%E4%B9%89/" class="article-date">
  <time datetime="2018-11-25T12:33:33.000Z" itemprop="datePublished">2018-11-25</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/java/">java</a>►<a class="article-category-link" href="/categories/java/jvm/">jvm</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/11/25/2018-11/jvm%E8%BF%90%E8%A1%8C%E5%8F%82%E6%95%B0%E9%85%8D%E7%BD%AE%E5%90%AB%E4%B9%89/">jvm运行参数配置含义</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <h1 id="示例1-sparkstreaming的driver配置"><a href="#示例1-sparkstreaming的driver配置" class="headerlink" title="示例1:sparkstreaming的driver配置"></a>示例1:sparkstreaming的driver配置</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">-Djava.library.path&#x3D;$JAVA_LIBRARY_PATH:&#x2F;data&#x2F;gaiaadmin&#x2F;gaiaenv&#x2F;tdwgaia&#x2F;lib&#x2F;native</span><br><span class="line">-verbose:gc</span><br><span class="line">-XX:-PrintGCDetails </span><br><span class="line">-XX:+PrintGCDateStamps</span><br><span class="line">-Xloggc:&lt;LOG_DIR&gt;&#x2F;gc.log</span><br><span class="line">-XX:MaxPermSize&#x3D;256m </span><br><span class="line">-XX:SurvivorRatio&#x3D;4 </span><br><span class="line">-XX:+UseMembar </span><br><span class="line">-XX:+UseConcMarkSweepGC</span><br><span class="line">-XX:+CMSParallelRemarkEnabled </span><br><span class="line">-XX:+CMSScavengeBeforeRemark </span><br><span class="line">-XX:ParallelCMSThreads&#x3D;4 </span><br><span class="line">-XX:+UseCMSCompactAtFullCollection </span><br><span class="line">-XX:+CMSClassUnloadingEnabled </span><br><span class="line">-XX:CMSInitiatingOccupancyFraction&#x3D;50 </span><br><span class="line">-XX:+UseCompressedOops</span><br></pre></td></tr></table></figure>
<p>含义:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">-verbose:gc是官方推荐配置,等效于-XX:+PrintGC,表示打印gc日志;</span><br><span class="line">-XX:-PrintGCDetails 减号,关闭详细gc日志;</span><br><span class="line">-XX:+PrintGCDateStamps  加号,打开gc日志日期;</span><br><span class="line">-Xloggc:&lt;LOG_DIR&gt;&#x2F;gc.log 指定gc日志路径;</span><br><span class="line">-XX:MaxPermSize&#x3D;256m  最大永生代大小;</span><br><span class="line">-XX:SurvivorRatio&#x3D;4  两个survivor:新生代的比例;</span><br><span class="line">8的话: 2:8,每个survivor占1&#x2F;10;</span><br><span class="line">4的话: 2:4,每个survivor占1&#x2F;6;</span><br><span class="line">-XX:+UseMembar 使用真内存屏障</span><br><span class="line">-XX:+UseConcMarkSweepGC 使用ParNew &amp; CMS（serial old为替补）搜集器</span><br><span class="line">-XX:+CMSParallelRemarkEnabled CMS第二次标记,使用并发标记</span><br><span class="line">-XX:+CMSScavengeBeforeRemark 第二次标记前进行一次minorGC</span><br><span class="line">-XX:ParallelCMSThreads&#x3D;4 回收线程数</span><br><span class="line">-XX:+UseCMSCompactAtFullCollection 防止堆碎片引起full gc,开启CMS阶段进行合并碎片选项</span><br><span class="line">-XX:+CMSClassUnloadingEnabled 开启回收Perm永生代</span><br><span class="line">-XX:CMSInitiatingOccupancyFraction&#x3D;50 在老生代占满50%的时候开始回收</span><br><span class="line">-XX:+UseCompressedOops 压缩指针(64位有效)</span><br></pre></td></tr></table></figure>

<h1 id="示例2-某spring-boot进程jvm非默认配置"><a href="#示例2-某spring-boot进程jvm非默认配置" class="headerlink" title="示例2:某spring boot进程jvm非默认配置"></a>示例2:某spring boot进程jvm非默认配置</h1><p><code>jinfo -flags PID</code>结果:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Non-default VM flags: </span><br><span class="line">-XX:CICompilerCount&#x3D;15 </span><br><span class="line">-XX:InitialHeapSize&#x3D;2107637760 </span><br><span class="line">-XX:MaxHeapSize&#x3D;32210157568 </span><br><span class="line">-XX:MaxNewSize&#x3D;10736369664 </span><br><span class="line">-XX:MinHeapDeltaBytes&#x3D;524288 </span><br><span class="line">-XX:NewSize&#x3D;702545920 </span><br><span class="line">-XX:OldSize&#x3D;1405091840 </span><br><span class="line">-XX:+UseCompressedClassPointers </span><br><span class="line">-XX:+UseCompressedOops </span><br><span class="line">-XX:+UseParallelGC</span><br></pre></td></tr></table></figure>
<p>含义:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">-XX:CICompilerCount&#x3D;15 JIT的编译线程数</span><br><span class="line">-XX:InitialHeapSize&#x3D;2107637760  初始堆大小</span><br><span class="line">-XX:MaxHeapSize&#x3D;32210157568     最大堆大小</span><br><span class="line">-XX:NewSize&#x3D;702545920        新生代初始大小</span><br><span class="line">-XX:MaxNewSize&#x3D;10736369664   新生代最大大小</span><br><span class="line">-XX:MinHeapDeltaBytes&#x3D;524288 每次扩展堆的时候最小增长</span><br><span class="line">-XX:OldSize&#x3D;1405091840       老生代初始大小</span><br><span class="line">-XX:+UseCompressedClassPointers 压缩指针</span><br><span class="line">-XX:+UseCompressedOops          压缩优化</span><br><span class="line">-XX:+UseParallelGC           Parallel Scavenge + Serial Old 吞吐率优先</span><br></pre></td></tr></table></figure>

<h1 id="jvm配置"><a href="#jvm配置" class="headerlink" title="jvm配置"></a>jvm配置</h1><p>参考<a href="https://www.cnblogs.com/z-sm/p/6253335.html" target="_blank" rel="noopener">https://www.cnblogs.com/z-sm/p/6253335.html</a></p>
<h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><p><code>-X</code>: 稳定选项;<br><code>-XX</code>: 非标准选项;</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://xiaoyue26.github.io/2018/11/25/2018-11/jvm%E8%BF%90%E8%A1%8C%E5%8F%82%E6%95%B0%E9%85%8D%E7%BD%AE%E5%90%AB%E4%B9%89/" data-id="ck96cxpou00eqmaamfu76coni" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/" rel="tag">java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/jvm/" rel="tag">jvm</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-2018-11/jinfo-运行时查看JVM配置及更改" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/11/25/2018-11/jinfo-%E8%BF%90%E8%A1%8C%E6%97%B6%E6%9F%A5%E7%9C%8BJVM%E9%85%8D%E7%BD%AE%E5%8F%8A%E6%9B%B4%E6%94%B9/" class="article-date">
  <time datetime="2018-11-25T12:12:57.000Z" itemprop="datePublished">2018-11-25</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/java/">java</a>►<a class="article-category-link" href="/categories/java/jvm/">jvm</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/11/25/2018-11/jinfo-%E8%BF%90%E8%A1%8C%E6%97%B6%E6%9F%A5%E7%9C%8BJVM%E9%85%8D%E7%BD%AE%E5%8F%8A%E6%9B%B4%E6%94%B9/">jinfo-运行时查看JVM配置及更改</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <h1 id="查看运行的java程序的启动命令"><a href="#查看运行的java程序的启动命令" class="headerlink" title="查看运行的java程序的启动命令"></a>查看运行的java程序的启动命令</h1><p><code>jps -lvm</code></p>
<h1 id="运行时查看JVM配置"><a href="#运行时查看JVM配置" class="headerlink" title="运行时查看JVM配置"></a>运行时查看JVM配置</h1><p>语法如下:<br><code>jinfo -flag &lt;name&gt; PID</code><br>如:<br><code>jinfo -flag CMSAbortablePrecleanWaitMillis 11715</code></p>
<p>查看全部非默认配置:<br><code>jinfo -flags PID</code><br>或者:<br><code>jcmd PID VM.flags</code></p>
<h1 id="运行时修改JVM配置"><a href="#运行时修改JVM配置" class="headerlink" title="运行时修改JVM配置"></a>运行时修改JVM配置</h1><p>首先并不是所有JVM配置都能在运行时动态修改的,需要查看哪些配置是可以运行时动态修改的:</p>
<h2 id="列出可运行时调整的JVM配置-linux"><a href="#列出可运行时调整的JVM配置-linux" class="headerlink" title="列出可运行时调整的JVM配置(linux)"></a>列出可运行时调整的JVM配置(linux)</h2><p><code>java -XX:+PrintFlagsInitial | grep manageable</code><br>结果如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">intx CMSAbortablePrecleanWaitMillis &#x3D; 100 &#123;manageable&#125;</span><br><span class="line">intx CMSTriggerInterval  &#x3D; -1 &#123;manageable&#125;</span><br><span class="line">intx CMSWaitDuration &#x3D; 2000 &#123;manageable&#125;</span><br><span class="line">bool HeapDumpAfterFullGC &#x3D; false &#123;manageable&#125;</span><br><span class="line">bool HeapDumpBeforeFullGC   &#x3D; false &#123;manageable&#125;</span><br><span class="line">bool HeapDumpOnOutOfMemoryError  &#x3D; false &#123;manageable&#125;</span><br><span class="line">ccstr HeapDumpPath &#x3D; &#123;manageable&#125;</span><br><span class="line">uintx MaxHeapFreeRatio &#x3D; 70 &#123;manageable&#125;</span><br><span class="line">uintx MinHeapFreeRatio &#x3D; 40 &#123;manageable&#125;</span><br><span class="line">bool PrintClassHistogram &#x3D; false &#123;manageable&#125;</span><br><span class="line">bool PrintClassHistogramAfterFullGC &#x3D; false &#123;manageable&#125;</span><br><span class="line">bool PrintClassHistogramBeforeFullGC  &#x3D; false &#123;manageable&#125;</span><br><span class="line">bool PrintConcurrentLocks   &#x3D; false &#123;manageable&#125;</span><br><span class="line">bool PrintGC  &#x3D; false &#123;manageable&#125;</span><br><span class="line">bool PrintGCDateStamps   &#x3D; false &#123;manageable&#125;</span><br><span class="line">bool PrintGCDetails   &#x3D; false &#123;manageable&#125;</span><br><span class="line">bool PrintGCID &#x3D; false &#123;manageable&#125;</span><br><span class="line">bool PrintGCTimeStamps   &#x3D; false &#123;manageable&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到参数的类型主要分为<code>bool</code>和非<code>bool</code>(<code>intx</code>,<code>uintx</code>,<code>ccstr</code>)。</p>
<h2 id="运行时修改bool型配置"><a href="#运行时修改bool型配置" class="headerlink" title="运行时修改bool型配置"></a>运行时修改bool型配置</h2><p>用加减(+/-)表示开关:<br><code>jinfo -flag [+|-]&lt;name&gt; PID</code></p>
<h2 id="运行时修改intx-ccstr-uintx型配置"><a href="#运行时修改intx-ccstr-uintx型配置" class="headerlink" title="运行时修改intx/ccstr/uintx型配置"></a>运行时修改intx/ccstr/uintx型配置</h2><p><code>jinfo -flag &lt;name&gt;=&lt;value&gt; PID</code></p>
<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><p>比如我们有一个java进程11715,我们突然想查看它的gc情况,但是之前又没有打开gc日志,只重定向了控制台日志,这个时候可以动态打开:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">jinfo -flag +PrintGC 11715</span><br><span class="line">jinfo -flag +PrintGCDateStamps 11715</span><br><span class="line">jinfo -flag +PrintGCDetails 11715</span><br></pre></td></tr></table></figure>
<p>拿到日志:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2018-11-25T20:21:41.772+0800: [GC (Allocation Failure) [PSYoungGen: 45952K-&gt;1856K(48128K)] 248269K-&gt;204197K(309248K), 0.0423007 secs] [Times: user&#x3D;0.88 sys&#x3D;0.02, real&#x3D;0.06 secs]</span><br></pre></td></tr></table></figure>

<p>调试完后再关掉即可:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">jinfo -flag -PrintGC 11715</span><br><span class="line">jinfo -flag -PrintGCDateStamps 11715</span><br><span class="line">jinfo -flag -PrintGCDetails 11715</span><br></pre></td></tr></table></figure>




      
    </div>
    <footer class="article-footer">
      <a data-url="http://xiaoyue26.github.io/2018/11/25/2018-11/jinfo-%E8%BF%90%E8%A1%8C%E6%97%B6%E6%9F%A5%E7%9C%8BJVM%E9%85%8D%E7%BD%AE%E5%8F%8A%E6%9B%B4%E6%94%B9/" data-id="ck96cxpor00eemaamf6do3biz" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/" rel="tag">java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/jvm/" rel="tag">jvm</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-2018-11/gc日志的含义" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/11/24/2018-11/gc%E6%97%A5%E5%BF%97%E7%9A%84%E5%90%AB%E4%B9%89/" class="article-date">
  <time datetime="2018-11-24T14:40:42.000Z" itemprop="datePublished">2018-11-24</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/java/">java</a>►<a class="article-category-link" href="/categories/java/jvm/">jvm</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/11/24/2018-11/gc%E6%97%A5%E5%BF%97%E7%9A%84%E5%90%AB%E4%B9%89/">gc日志的含义</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <h1 id="gc日志示例"><a href="#gc日志示例" class="headerlink" title="gc日志示例"></a>gc日志示例</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">2018-11-11T17:53:47.765+0800: 6.223: [GC (CMS Initial Mark)  1208720K(9946240K), 0.0293534 secs]</span><br><span class="line">2018-11-11T17:53:48.622+0800: 7.080: [GC (Allocation Failure)  2158400K-&gt;38812K(9946240K), 0.0383138 secs]</span><br><span class="line">2018-11-11T17:53:51.479+0800: 9.937: [GC (CMS Final Remark) 2018-11-11T17:53:51.480+0800: 9.937: [GC (CMS Final Remark)  1167518K-&gt;22899K(9946240K), 0.0147020 secs]</span><br><span class="line"> 22899K(9946240K), 0.0299512 secs]</span><br><span class="line">2018-11-11T17:53:55.022+0800: 13.480: [GC (Allocation Failure)  2176846K-&gt;89359K(9946240K), 0.0181967 secs]</span><br><span class="line">2018-11-11T17:54:08.938+0800: 27.396: [GC (Allocation Failure)  2247759K-&gt;301630K(9946240K), 0.1307113 secs]</span><br><span class="line">2018-11-11T17:54:12.721+0800: 31.179: [GC (Allocation Failure)  2460030K-&gt;337872K(9946240K), 0.6716872 secs]</span><br><span class="line">2018-11-11T17:54:14.953+0800: 33.411: [GC (Allocation Failure)  2496272K-&gt;338204K(9946240K), 0.1792878 secs]</span><br><span class="line">2018-11-11T17:54:15.133+0800: 33.591: [GC (GCLocker Initiated GC)  362412K-&gt;368987K(9946240K), 0.0447314 secs]</span><br><span class="line">2018-11-11T17:54:48.328+0800: 66.786: [GC (Allocation Failure)  2527387K-&gt;347750K(9946240K), 0.0532146 secs]</span><br></pre></td></tr></table></figure>

<h1 id="gc日志的组成"><a href="#gc日志的组成" class="headerlink" title="gc日志的组成"></a>gc日志的组成</h1><img src="/images/2018-11/gc_format.png" class="" width="400" height="600" title="gc_format">
<ol>
<li>日期时间: <code>2018-11-11T17:53:47.765+0800:</code>;</li>
<li>jvm启动依赖的时间(秒):  <code>6.223:</code>;</li>
<li>GC停顿类型: <code>[GC (CMS Initial Mark)</code>;</li>
<li>(不一定有)GC发生区域: <code>[DefNew”、“[Tenured”、“[Perm</code>;</li>
<li>(不一定有,针对4中的区域)GC前后该容量变化:<br>GC前该内存区域已使用容量-＞GC后该内存区域已使用容量（该内存区域总容量）<br><code>2496272K-&gt;338204K(9946240K)</code>;</li>
<li>GC前后java堆容量变化:<br>GC前Java堆已使用容量-＞GC后Java堆已使用容量（Java堆总容量）<br><code>3324K-＞152K（11904K）</code>;</li>
<li>GC耗时: <code>0.0383138 secs</code>.</li>
</ol>
<h1 id="GC区域"><a href="#GC区域" class="headerlink" title="GC区域"></a>GC区域</h1><ol>
<li><code>New</code>: 新生代、年轻代;</li>
<li><code>Tenured</code>: 老生代、老年代;</li>
<li><code>Perm</code>: 永久代.</li>
</ol>
<p>收集器的类型+区域: <code>DefNew</code>: Default Serial收集器的新生代区域。</p>
<h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><p>消除全部<code>FullGC</code>,普通gc时间占用少于5%。<br>网上说少于3秒一次的频率,由于我们是离线应用,目前还没有什么思路能达到这种性能。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://xiaoyue26.github.io/2018/11/24/2018-11/gc%E6%97%A5%E5%BF%97%E7%9A%84%E5%90%AB%E4%B9%89/" data-id="ck96cxpor00ebmaam2r59f90e" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/gc/" rel="tag">gc</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/" rel="tag">java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/jvm/" rel="tag">jvm</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-2018-10/HashedWheelTimer-大量定时器解决方案-Netty与kafka" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/10/27/2018-10/HashedWheelTimer-%E5%A4%A7%E9%87%8F%E5%AE%9A%E6%97%B6%E5%99%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88-Netty%E4%B8%8Ekafka/" class="article-date">
  <time datetime="2018-10-27T12:16:33.000Z" itemprop="datePublished">2018-10-27</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/java/">java</a>►<a class="article-category-link" href="/categories/java/Netty/">Netty</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/10/27/2018-10/HashedWheelTimer-%E5%A4%A7%E9%87%8F%E5%AE%9A%E6%97%B6%E5%99%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88-Netty%E4%B8%8Ekafka/">HashedWheelTimer-大量定时器解决方案(Netty与kafka)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <h1 id="需求"><a href="#需求" class="headerlink" title="需求:"></a>需求:</h1><p>有大量定时任务需要执行，精度要求不高，可以允许延迟执行。<br>可能的场景: 每个连接的超时事件、每个请求的超时事件。</p>
<h1 id="方案1"><a href="#方案1" class="headerlink" title="方案1:"></a>方案1:</h1><p>每个定时任务设置一个定时器、或一个<code>Scheduled</code>,<code>DelayedQueue</code>和实现<code>Delayed</code>接口的线程。<br>缺点: 开销太大;<br>优点: 少量任务时精度较高。</p>
<h1 id="方案2-超时集"><a href="#方案2-超时集" class="headerlink" title="方案2: 超时集"></a>方案2: 超时集</h1><p>将相同时间间隔的任务组织成一个集合。每个集合分配一个计时器（thread）。<br>缺点: 相同时间间隔难以满足，性能不够。</p>
<h1 id="方案3-HashedWheelTimer：-时间轮算法-Netty4工具类"><a href="#方案3-HashedWheelTimer：-时间轮算法-Netty4工具类" class="headerlink" title="方案3: HashedWheelTimer： 时间轮算法(Netty4工具类)"></a>方案3: HashedWheelTimer： 时间轮算法(Netty4工具类)</h1><p>设计一个虚拟的哈希表组织定时任务。<br>优点: 默认只用一个thread,开销小;<br>缺点:</p>
<ol>
<li>精度降低到<code>tickDuration</code>粒度;</li>
<li>定时任务不能太耗时;(解决方案: 可以在定时任务里异步处理)。</li>
</ol>
<h2 id="基本架构"><a href="#基本架构" class="headerlink" title="基本架构"></a>基本架构</h2><img src="/images/2018-10/timewheel.jpg" class="" width="400" height="600" title="timewheel">
<p>如上图所示即为时间轮。<br>引入术语:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tick: 时间轮里每一格;</span><br><span class="line">tickDuration: 每一格的时长;</span><br><span class="line">ticksPerWheel: 时间轮总共有多少格.</span><br><span class="line">newTimeout: 定时任务分配到时间轮</span><br></pre></td></tr></table></figure>

<h3 id="定时任务分配到时间轮"><a href="#定时任务分配到时间轮" class="headerlink" title="定时任务分配到时间轮"></a>定时任务分配到时间轮</h3><p>分配流程:</p>
<ol>
<li>计算定时任务deadline = <code>System.nanoTime() + unit.toNanos(delay) - startTime</code>;</li>
<li>计算定时任务放入第几格: <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> calculated = deadline / tickDuration; <span class="comment">// 需要计算几次</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">long</span> <span class="title">ticks</span><span class="params">(还需要走几格)</span> </span>= Math.max(calculated, 当前tick次数); <span class="comment">// 一般就等于calculated，这里只是为了确保不在以前走过的格子里（这样的话这个任务永远不会执行而且移除不掉了）</span></span><br><span class="line">stopIndex = (<span class="keyword">int</span>) (ticks &amp; mask); <span class="comment">// 相当于% wheel.length，因为长度是2的幂。</span></span><br></pre></td></tr></table></figure></li>
<li>计算定时任务第几轮被调用: <code>remainingRounds = (calculated - tick) / wheel.length;</code></li>
<li>放入时间轮stopIndex位置中任务链表: (remainingRounds,task)：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HashedWheelBucket bucket = wheel[stopIndex];</span><br><span class="line">bucket.addTimeout(timeout); <span class="comment">// 加入链表尾部。</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>当这个时间轮开始运行的时候（也就是开始计时，执行定时任务了），每次跳转一个tick,都会检查这个tick里的定时任务,如果定时任务轮次应当执行，则执行对应任务。</p>
<p>使用的示例代码: </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * tickDuration: 每 tick 一次的时间间隔, 每 tick 一次就会到达下一个槽位</span></span><br><span class="line"><span class="comment"> * ticksPerWheel: 轮中的 slot 数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testHashedWheelTimer</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"><span class="comment">// 1000ms一格,一轮16格（一般是2的N次幂，这样可以把hash转换为&amp;0xFFFF）</span></span><br><span class="line">    HashedWheelTimer hashedWheelTimer = <span class="keyword">new</span> HashedWheelTimer(<span class="number">1000</span>,TimeUnit.MILLISECONDS, <span class="number">16</span> );</span><br><span class="line">    System.out.println(LocalTime.now()+<span class="string">" submitted"</span>);</span><br><span class="line">    Timeout timeout = hashedWheelTimer.newTimeout((t) -&gt; &#123;</span><br><span class="line">        <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="keyword">new</span> Date() + <span class="string">" executed"</span>);</span><br><span class="line">                System.out.println(hashedWheelTimer);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">100</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="keyword">new</span> Date() + <span class="string">" FINISH"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">    &#125;, <span class="number">5</span>, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">    hashedWheelTimer.newTimeout((t) -&gt; &#123;</span><br><span class="line">        <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="keyword">new</span> Date() + <span class="string">" TASK2 executed"</span>);</span><br><span class="line">                System.out.println(hashedWheelTimer);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">10</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="keyword">new</span> Date() + <span class="string">" TASK2 FINISH"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">    &#125;, <span class="number">15</span>, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">    TimeUnit.SECONDS.sleep(<span class="number">500</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><code>HashedWheelTimer</code>源码:<br><a href="https://github.com/netty/netty/blob/4.1/common/src/main/java/io/netty/util/HashedWheelTimer.java" target="_blank" rel="noopener">https://github.com/netty/netty/blob/4.1/common/src/main/java/io/netty/util/HashedWheelTimer.java</a></p>
<p>理论基础:(操作系统内核的定时器)<br><a href="http://www.cs.columbia.edu/~nahum/w6998/papers/sosp87-timing-wheels.pdf" target="_blank" rel="noopener">http://www.cs.columbia.edu/~nahum/w6998/papers/sosp87-timing-wheels.pdf</a></p>
<h1 id="方案4：-层级时间轮-Kafka使用"><a href="#方案4：-层级时间轮-Kafka使用" class="headerlink" title="方案4： 层级时间轮(Kafka使用)"></a>方案4： 层级时间轮(Kafka使用)</h1><p>上述简单时间轮的算法存在的<strong>缺点</strong>:<br>对于延迟很长时间的任务,该方案存在较多的cpu空转。一种可能的方案是增大<code>tickduration</code>,但是很难兼顾精度和性能。</p>
<p>一种解决方案: 层级时间轮。<br>思路是模拟现实中的钟表,现实中的钟表有时针、分针、秒针,相当于不同<code>tickDuration</code>的时间轮。<br>架构图如下:</p>
<img src="/images/2018-10/timewheel2.jpg" class="" width="400" height="600" title="timewheel2">

<p>不同于<code>Netty4</code>中每个任务存放自己应到执行的轮次,层级时间轮把高轮次的定时任务分配到高层的时间轮中:层数越高=&gt;<code>tickDuration</code>越大。</p>
<p>假如定义最低层的时间轮的层号为0,高一层的为1,依次类推,只有n-1层的定时任务到期后,才会取出n层时间轮的定时任务处理（要么直接执行,要么降级,要么放回时间轮）。</p>
<p>(如果让层级时间轮每层的<code>tickDuratino</code>相同，则退化为方案3的普通时间轮。)</p>
<p>同时为了辅助推进时间轮的指针,使用<code>DelayQueue</code>存放最近到期的定时任务</p>
<h2 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h2><p>时间中每一个格中使用的数据结构为双向链表。<br>好处是只要持有其中某个节点，就可以在<code>O(1)</code>时间内进行插入或者删除操作。</p>
<h2 id="到期操作"><a href="#到期操作" class="headerlink" title="到期操作"></a>到期操作</h2><p>由<code>DelayQueue</code>辅助推进指针: </p>
<ol>
<li><code>DelayQueue</code>中优先级队列的队首最近到期的定时任务。处理结束后,由<code>leader</code>线程等待下一个定时任务的时间。因此推进步长由定时任务的间隔决定,没有cpu空转的现象。</li>
<li>推进所有时间轮的指针,对于遇到的定时任务,要么插入低层时间轮,要么删除(执行)。</li>
</ol>
<h2 id="插入操作-删除类似"><a href="#插入操作-删除类似" class="headerlink" title="插入操作(删除类似)"></a>插入操作(删除类似)</h2><p>插入新的定时任务:</p>
<ol>
<li>插入时间轮: 根据到期时间,可以算出具体应该放在哪一层时间轮的哪一格,得到对应的双向链表引用。如果这一格还是空的,需要新建一个,然后插入到<code>DelayQueue</code>中(<code>O(logN)</code>时间复杂度)。(参见<code>DelayQueue</code>原理,如果时间低于<code>DelayQueue</code>的最小延时任务,会提前唤醒里面的<code>leader</code>线程)</li>
<li>插入<code>DelayQueue</code>: 根据上一步中得到的双向链表引用,往里面插入新的定时任务（<code>O(1)</code>）。</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>层级时间轮通过不同<code>tickDuration</code>的时间轮,以较小的空间映射到一个很大的时间范围,兼顾了精度和性能。<br><strong>插入删除的时间复杂度:</strong><br>时间复杂度其实取决于有效格子的数量,因为<code>DelayQueue</code>存放的是有任务的格子,也就是双向链表的数量。低层用的是优先级队列(最小堆),假如有效格子的数量是<code>m</code>，则复杂度为<code>O(log(m))</code>。<br>实际中m一般远小于n，因此性能有很大的提高。<br><strong>理想情况</strong>:定时任务的时间间隔分布能尽量让它们位于相同格子中。 (<code>O(1)</code>)<br><strong>最坏情况</strong>:所有双向链表都只有一个任务(均匀地分布在不同格子中)。(<code>O(logN)</code>)</p>
<p>实际业务中,定时任务一般都服从对数正态分布,因此每次插入删除时间复杂度是接近<code>O(1)</code>的。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://xiaoyue26.github.io/2018/10/27/2018-10/HashedWheelTimer-%E5%A4%A7%E9%87%8F%E5%AE%9A%E6%97%B6%E5%99%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88-Netty%E4%B8%8Ekafka/" data-id="ck96cxpon00dqmaamcxajhzfw" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Netty/" rel="tag">Netty</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/" rel="tag">java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/kafka/" rel="tag">kafka</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/" rel="tag">定时任务</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-2018-10/Java并发编程的艺术-第6章3-DelayQueue" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/10/27/2018-10/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF-%E7%AC%AC6%E7%AB%A03-DelayQueue/" class="article-date">
  <time datetime="2018-10-27T04:06:10.000Z" itemprop="datePublished">2018-10-27</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/java/">java</a>►<a class="article-category-link" href="/categories/java/%E5%B9%B6%E5%8F%91/">并发</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/10/27/2018-10/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF-%E7%AC%AC6%E7%AB%A03-DelayQueue/">Java并发编程的艺术-第6章3-DelayQueue</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <p><code>DelayQueue</code>: JDK提供的延迟获取元素的无界阻塞队列。<br><strong>应用场景</strong>:</p>
<ol>
<li>缓存有效期: 能取到的时候过期.</li>
<li>定时任务: 能取到的时候执行。</li>
</ol>
<p><code>DelayQueue</code>的两个特性:<br><strong>无界</strong>: 说明底层至少使用了链表。<br><strong>阻塞</strong>: 为底层实现时，利用访问线程干活埋下伏笔(<code>leader</code>)。 </p>
<h2 id="底层实现机制"><a href="#底层实现机制" class="headerlink" title="底层实现机制"></a>底层实现机制</h2><p>底层用一个优先级队列存储<code>delay</code>元素(比如定时任务),排序依据是延迟的时长。<br>可以看出，这里用的是一个支持无界阻塞的优先级队列实现(例如<code>PriorityBlockingQueue</code>)。</p>
<p><strong>时间复杂度</strong>: <code>O(logN)</code>。由于使用的是优先级队列(最小堆),插入新元素(任务)的时间复杂度是<code>O(logN)</code>。</p>
<p><code>take</code>流程: </p>
<ol>
<li><code>lock.lockInterruptibly()</code>;</li>
<li>delay =  队首元素延时;</li>
<li>delay&lt;=0: 取出该元素;</li>
<li>delay&gt;0: 尝试设置自己线程为<code>leader</code>，然后等待delay时间。</li>
<li><code>finnally: lock.unlock()</code>;</li>
</ol>
<p>这里<code>leader</code>的职责是等待<code>delay</code>时间，以及唤醒其他等待线程。<br>注意第四步里, 由于<code>leader</code>只能有一个,所以如果尝试成为<code>leader</code>失败，就直接<code>await</code>就好,会被<code>leader</code>叫醒的。</p>
<p><code>offer</code>: offer就是简单地把元素插入堆中。如果正好是延迟最小，则此时之前的<code>leader</code>等待时间太长了，因此需要叫醒所有等待线程。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>DelayQueue</code><br><strong>优点</strong>:<br>资源开销小: 本质上只需一个线程负责等待;每次等待间隔都是delay时间,cpu空转少。<br><strong>缺点</strong><br>插入删除延时元素时间复杂度为<strong>O(logN)</strong>，对于成千上万的延时任务时间开销大,有待优化。</p>
<p>优化思路:<br>如果要比<code>O(logN)</code>更好,很自然的思路就是使用哈希表<code>O(1)</code>，空间换时间。</p>
<h2 id="优化方案"><a href="#优化方案" class="headerlink" title="优化方案"></a>优化方案</h2><p>需求: 降低插入删除延时元素的时间复杂度。<br>方案:</p>
<ol>
<li>保留优先级队列,但里面的元素改成链表引用(比如从<code>Task</code>到<code>List&lt;Task&gt;</code>);</li>
<li>引入辅助哈希表,保存的也是链表引用(<code>List&lt;Task&gt;</code>)，hash函数的输入为延时时长。</li>
</ol>
<p>这里即使<code>List&lt;Task&gt;</code>长期只有1个元素也没有关系,这里只是为了起到C++中指针的效果，方便从哈希表里直接修改(插入删除)优先级队里的数据。</p>
<p><strong><code>take</code>/<code>offer</code>流程</strong>: 与之前相似,唯一不同就是取到<code>List&lt;Task&gt;</code>后，遍历其中所有<code>Task</code>。</p>
<p><strong>插入延时元素(任务)</strong>：（删除也类似）</p>
<ol>
<li>根据延时,通过哈希函数找到哈希表中的槽位;</li>
<li>如果以前有过相同延时: 直接插入List;</li>
<li>如果以前没有相同延时: 新建List，并且插入优先级队列。</li>
</ol>
<p>可以看出这里优化的重要条件是能合并多个Task到List。<br>为了达到这个条件，可以使用进一步的优化方案: 时间轮。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://xiaoyue26.github.io/2018/10/27/2018-10/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF-%E7%AC%AC6%E7%AB%A03-DelayQueue/" data-id="ck96cxpon00dumaam35pv69ma" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/" rel="tag">java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%B9%B6%E5%8F%91/" rel="tag">并发</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-2018-10/flask多线程下，连接泄露的bug" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/10/23/2018-10/flask%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8B%EF%BC%8C%E8%BF%9E%E6%8E%A5%E6%B3%84%E9%9C%B2%E7%9A%84bug/" class="article-date">
  <time datetime="2018-10-23T08:35:52.000Z" itemprop="datePublished">2018-10-23</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/mysql/">mysql</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/10/23/2018-10/flask%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8B%EF%BC%8C%E8%BF%9E%E6%8E%A5%E6%B3%84%E9%9C%B2%E7%9A%84bug/">flask多线程下，连接泄露的bug</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <h1 id="架构图"><a href="#架构图" class="headerlink" title="架构图"></a>架构图</h1><img src="/images/2018-10/flask.png" class="" width="400" height="600" title="flask">

<p>如图所示，底层使用mysql，web服务使用<code>flask-SqlAlchemy</code>的连接池（复用连接，减少创建销毁开销），逻辑层代码使用线程池（异步IO操作，如果要异步cpu操作，可以很方便改成进程池）。</p>
<h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><ol>
<li>使用<code>db.engine.execute(sql)</code>: 从连接池获取一个连接,执行完sql后自动<code>commit</code>;(<code>commit</code>操作的回调是: 归还连接到池里); </li>
<li>使用<code>session</code>的<code>orm</code>(<code>xxxModel.query等</code>): 默认配置及推荐配置是<code>autocommit=false</code>，执行完增删查改后，处于事务未提交的状态，也就是没有归还连接。如果要归还连接，可以使用语句:<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">db.session.commit()</span><br><span class="line">db.session.rollback()</span><br><span class="line">db.session.close()</span><br><span class="line">db.session.remove(): 底层会调用db.session.close()</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>小结:</p>
<blockquote>
<p>db.engine.execute(sql) =&gt; 自动commit =&gt; 自动归还<br>session(orm) =&gt; 手动commit =&gt; 手动归还<br>因此db.engine.execute(sql)是绝对安全的;<br>orm是有条件的。接着往下看orm的安全条件。</p>
</blockquote>
<h2 id="线程与session"><a href="#线程与session" class="headerlink" title="线程与session"></a>线程与session</h2><p>使用flask的SqlAlchemy插件<code>flask-SqlAlchemy</code>时，每个线程可以直接用<code>db.session</code>获得session，即使不显式获得，使用orm的model时，其实也隐式得获得了<code>session</code>。</p>
<h3 id="线程与session的关系"><a href="#线程与session的关系" class="headerlink" title="线程与session的关系:"></a>线程与session的关系:</h3><p>每个线程有自己的<code>threadlocal</code>的<code>session</code>对象，并且随着线程销毁，会自动释放<code>session</code>,也就是会隐式调用<code>session.remove</code>，也就是会隐式释放<code>session</code>的连接。</p>
<p>多线程两种使用:</p>
<ol>
<li><code>t1=threading.Thread(...)</code>;</li>
<li>线程池: <code>future= pool.submit(...)</code>.<br>方法1的线程使用完以后自动销毁=&gt;session自动销毁=&gt;连接自动释放;<br>方法2的线程使用完以后归还线程池=&gt;session手动销毁=&gt;连接释放。</li>
</ol>
<p>小结:<br>不使用线程池=&gt;连接自动释放;<br>使用线程池=&gt;连接手动释放.<br>手动释放的方法:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.session.remove()</span><br></pre></td></tr></table></figure>

<h1 id="空闲连接超时与连接释放bug"><a href="#空闲连接超时与连接释放bug" class="headerlink" title="空闲连接超时与连接释放bug"></a>空闲连接超时与连接释放bug</h1><p>前面说到使用线程池时，连接没有自动释放，一直维护在线程的threadlocal存储中(tls)。那么这样似乎也没有什么关系，只要线程池大小&lt;连接池大小,这样连接池有空闲连接，每个线程也有自己的连接可以用，一切似乎也相安无事。</p>
<p>然而，这里有一个之前没有提到的机制：空闲连接超时回收。</p>
<h3 id="空闲连接超时回收"><a href="#空闲连接超时回收" class="headerlink" title="空闲连接超时回收"></a>空闲连接超时回收</h3><h4 id="mysql服务端"><a href="#mysql服务端" class="headerlink" title="mysql服务端:"></a>mysql服务端:</h4><p>定期检查现存连接的空闲时间，把超出<code>wait_timeout</code>的连接删除，此时客户端保存的长连接引用就失效了; 这个时间的设定:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">global</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">'wait_timeout'</span>;</span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> wait_timeout=<span class="number">10</span>*<span class="number">60</span>; <span class="comment">-- seconds</span></span><br></pre></td></tr></table></figure>

<h4 id="web服务"><a href="#web服务" class="headerlink" title="web服务:"></a>web服务:</h4><p>flask会定期检查连接池里的连接，把空闲连接删除，重新向mysql服务端申请新的连接，这样就不会访问到失效的连接引用了。其中定期的时间是: <code>app.config[&#39;SQLALCHEMY_POOL_RECYCLE&#39;] =xxx</code>(秒，应当设置为小于<code>wait_timeout</code>)。这就是为什么最好连接用完及时归还，否则可能就没法被flask刷新成新连接。</p>
<h4 id="空闲连接超时与连接释放bug-1"><a href="#空闲连接超时与连接释放bug-1" class="headerlink" title="空闲连接超时与连接释放bug"></a>空闲连接超时与连接释放bug</h4><p>bug发生的流程</p>
<ol>
<li>mysql服务端清除了空闲时间过长的连接;</li>
<li>线程池中线程一直不销毁，因此持有了活了很久的session;</li>
<li>活了很久的session持有了空闲很久的连接, 这个连接其实已经被服务端销毁了，因此已经不可用了，但是由于其一直没有归还到连接池中，因此一直没有得到更新。</li>
<li>此时web服务收到数据请求，使用该线程中的该session中的连接，就会抛异常了，因为连接已经不可用了。</li>
</ol>
<p>一般来说，空闲时间很长以后，线程池里所有线程的所有session的所有连接都会失效，因此就会完全无法通过orm访问数据库了。</p>
<p>相关异常信息:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MySQL server has gone away</span><br><span class="line">Can&#39;t reconnect until invalid transaction is rolled back</span><br></pre></td></tr></table></figure>
<p>这里之所以说<code>invalid transaction is rolled back</code>，是因为老session收到数据请求后，准备要用连接了。<br>而连接上的事务没有自动提交，也没有rollback，因此不能直接用。<br>因此尝试把连接上，上一次请求的事务提交，但由于连接已经失效，所以失败了。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://xiaoyue26.github.io/2018/10/23/2018-10/flask%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8B%EF%BC%8C%E8%BF%9E%E6%8E%A5%E6%B3%84%E9%9C%B2%E7%9A%84bug/" data-id="ck96cxpop00e4maamerbl1rgc" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/flask/" rel="tag">flask</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/mysql/" rel="tag">mysql</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/python/" rel="tag">python</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-2018-10/mysql优化实战-范围查询转点查询" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/10/22/2018-10/mysql%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98-%E8%8C%83%E5%9B%B4%E6%9F%A5%E8%AF%A2%E8%BD%AC%E7%82%B9%E6%9F%A5%E8%AF%A2/" class="article-date">
  <time datetime="2018-10-22T02:28:25.000Z" itemprop="datePublished">2018-10-22</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/mysql/">mysql</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/10/22/2018-10/mysql%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98-%E8%8C%83%E5%9B%B4%E6%9F%A5%E8%AF%A2%E8%BD%AC%E7%82%B9%E6%9F%A5%E8%AF%A2/">mysql优化实战-范围查询转点查询</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <h1 id="反直觉优化"><a href="#反直觉优化" class="headerlink" title="反直觉优化"></a>反直觉优化</h1><h2 id="慢查询"><a href="#慢查询" class="headerlink" title="慢查询:"></a>慢查询:</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> *</span><br><span class="line">    <span class="keyword">from</span> layer_data.layers_push b</span><br><span class="line">    <span class="keyword">where</span> group_key=<span class="string">'nopushtest'</span></span><br><span class="line">    <span class="keyword">AND</span> utype=<span class="string">'10w1'</span></span><br><span class="line">    <span class="keyword">AND</span> dt&gt;=<span class="number">20180620</span> <span class="keyword">AND</span> dt&lt;=<span class="number">20181020</span></span><br><span class="line">    <span class="keyword">AND</span> bucket_id=<span class="number">60</span></span><br></pre></td></tr></table></figure>
<p>上述SQL执行时间约在2.10秒,通过查看执行计划,可以发现有一个异常的指标,预估扫描的行数(<code>rows</code>)为96W，而实际结果行数应该在几十条。(查询涉及到的列合起来是联合主键)<br>此外<code>type</code>为<code>range</code>，执行的是范围扫描。<br>查询计划:(<code>explain exntended select ...</code>)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+----+-------------+-------------+-------+---------------+---------+---------+------+--------+-------------+</span><br><span class="line">| id | select_type | table       | type  | possible_keys | key     | key_len | ref  | rows   | Extra       |</span><br><span class="line">+----+-------------+-------------+-------+---------------+---------+---------+------+--------+-------------+</span><br><span class="line">|  1 | SIMPLE      | layers_push | range | PRIMARY       | PRIMARY | 216     | NULL | 989236 | Using where |</span><br><span class="line">+----+-------------+-------------+-------+---------------+---------+---------+------+--------+-------------+</span><br></pre></td></tr></table></figure>


<h2 id="快查询-（反直觉优化）"><a href="#快查询-（反直觉优化）" class="headerlink" title="快查询:（反直觉优化）"></a>快查询:（反直觉优化）</h2><p>基于上面观察到预估行数异常，一个自然的思路就是引入一个很小的辅助表来帮助优化器减少扫描的行数。辅助表的主键与原表分布相同: </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> b.*</span><br><span class="line"><span class="keyword">from</span> layer_data.layers__nopushtest a</span><br><span class="line"><span class="keyword">join</span> layer_data.layers_push b</span><br><span class="line"> <span class="keyword">ON</span> a.dt=b.dt</span><br><span class="line"><span class="keyword">AND</span> a.bucket_id=b.bucket_id</span><br><span class="line"><span class="keyword">AND</span> b.group_key=<span class="string">'nopushtest'</span></span><br><span class="line"><span class="keyword">AND</span> b.dt <span class="keyword">between</span> <span class="number">20180620</span> <span class="keyword">AND</span> <span class="number">20181020</span></span><br><span class="line"><span class="keyword">AND</span> b.utype=<span class="string">'10w1'</span></span><br><span class="line">    <span class="keyword">where</span> a.dt&gt;=<span class="number">20180620</span> <span class="keyword">and</span> a.dt&lt;=<span class="number">20181020</span></span><br><span class="line">    <span class="keyword">and</span> a.utype=<span class="string">'w1'</span></span><br><span class="line">    <span class="keyword">and</span> a.bucket_id=<span class="number">60</span></span><br></pre></td></tr></table></figure>
<p>优化后,执行时间大约在0.05秒,快了40多倍。<br>优化后的执行计划:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+----+-------------+-------+--------+---------------+---------+---------+-----------------------------------+-------+--------------------------+</span><br><span class="line">| id | select_type | table | type   | possible_keys | key     | key_len | ref                               | rows  | Extra                    |</span><br><span class="line">+----+-------------+-------+--------+---------------+---------+---------+-----------------------------------+-------+--------------------------+</span><br><span class="line">|  1 | SIMPLE      | a     | range  | PRIMARY       | PRIMARY | 38      | NULL                              | 23925 | Using where; Using index |</span><br><span class="line">|  1 | SIMPLE      | b     | eq_ref | PRIMARY       | PRIMARY | 216     | layer_data.a.dt,const,const,const |     1 | Using where              |</span><br><span class="line">+----+-------------+-------+--------+---------------+---------+---------+-----------------------------------+-------+--------------------------+</span><br></pre></td></tr></table></figure>
<p>执行流程:<br>第一步:范围扫描表a,得到连接键的所有可能取值;<br>第二步: 表b的type是eq_ref(等值连接,而且是唯一键),ref是<code>layer_data.a.dt,const,const,const</code>，预估扫描的行数变成只有1。</p>
<h1 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h1><h2 id="慢查询的执行计划"><a href="#慢查询的执行计划" class="headerlink" title="慢查询的执行计划:"></a>慢查询的执行计划:</h2><p>预估的行数有96w，执行计划是从dt为20180620的数据页顺序扫描到dt为20181020的数据页。</p>
<h3 id="范围查询的扫描行数预估："><a href="#范围查询的扫描行数预估：" class="headerlink" title="范围查询的扫描行数预估："></a>范围查询的扫描行数预估：</h3><p>这里由于使用的mysql版本是5.6(可以通过<code>select version();</code>语句查看)，预估的流程:</p>
<ol>
<li>取符合where条件的最左边的数据页及后续的8个页，再加上符合where条件的最右边的数据页,共计10个页进行采样;</li>
<li>根据上述采样结果，以及与总数据的采样比，估算出需要扫描的行数。</li>
</ol>
<h2 id="快查询的执行计划"><a href="#快查询的执行计划" class="headerlink" title="快查询的执行计划:"></a>快查询的执行计划:</h2><p>因为有辅助的小表帮忙，扫描的行数减少。执行计划是先范围扫描小表，得到所有连接键的取值后，用表b的索引挨个儿进行点查询（<code>type</code>是<code>eq_ref</code>，而不是<code>range</code>）,扫描的数据页大大减少。</p>
<p><code>range</code>类型查询:</p>
<blockquote>
<p>以下操作符会导致查询计划为range:<br>=, &lt;&gt;, &gt;, &gt;=, &lt;, &lt;=, IS NULL, &lt;=&gt;, BETWEEN, IN (…)</p>
</blockquote>
<h1 id="符合直觉的优化"><a href="#符合直觉的优化" class="headerlink" title="符合直觉的优化"></a>符合直觉的优化</h1><p>由于mysql对in有特殊的优化: 把范围查询转换为多次点查询。<br>此时虽然查询计划是<code>range</code>，但实际执行时候不会进行范围扫描，而会进行点查询。<br>因此也可以把查询改写成:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span>   *</span><br><span class="line">    <span class="keyword">from</span> layer_data.layers_push b</span><br><span class="line">    <span class="keyword">where</span> group_key=<span class="string">'nopushtest'</span></span><br><span class="line">    <span class="keyword">AND</span> utype=<span class="string">'10w1'</span></span><br><span class="line">    <span class="keyword">AND</span> dt  <span class="keyword">in</span>  (<span class="number">20180805</span>,<span class="number">20180806</span>,<span class="number">20180807</span>,<span class="number">20180808</span>,<span class="number">20180809</span>,<span class="number">20180810</span>,<span class="number">20180811</span>,<span class="number">20180812</span>,<span class="number">20180813</span>,<span class="number">20180814</span>,<span class="number">20180815</span>,<span class="number">20180816</span>,<span class="number">20180817</span>,<span class="number">20180818</span>,<span class="number">20180819</span>,<span class="number">20180820</span>,<span class="number">20180821</span>,<span class="number">20180822</span>,<span class="number">20180823</span>,<span class="number">20180824</span>,<span class="number">20180825</span>,<span class="number">20180826</span>,<span class="number">20180827</span>,<span class="number">20180828</span>,<span class="number">20180829</span>,<span class="number">20180830</span>,<span class="number">20180831</span></span><br><span class="line">,<span class="number">20180901</span>,<span class="number">20180902</span>,<span class="number">20180903</span>,<span class="number">20180904</span>,<span class="number">20180905</span>,<span class="number">20180906</span>,<span class="number">20180907</span>,<span class="number">20180908</span>,<span class="number">20180909</span>,<span class="number">20180910</span>,<span class="number">20180911</span>,<span class="number">20180912</span>,<span class="number">20180913</span>,<span class="number">20180914</span>,<span class="number">20180915</span>,<span class="number">20180916</span>,<span class="number">20180917</span>,<span class="number">20180918</span>,<span class="number">20180919</span>,<span class="number">20180920</span>,<span class="number">20180921</span>,<span class="number">20180922</span>,<span class="number">20180923</span>,<span class="number">20180924</span>,<span class="number">20180925</span>,<span class="number">20180926</span>,<span class="number">20180927</span>,<span class="number">20180928</span>,<span class="number">20180929</span>,<span class="number">20180930</span></span><br><span class="line">,<span class="number">20181001</span>,<span class="number">20181002</span>,<span class="number">20181003</span>,<span class="number">20181004</span>,<span class="number">20181005</span>,<span class="number">20181006</span>,<span class="number">20181007</span>,<span class="number">20181008</span>,<span class="number">20181009</span>,<span class="number">20181010</span>,<span class="number">20181011</span>,<span class="number">20181012</span>,<span class="number">20181013</span>,<span class="number">20181014</span>,<span class="number">20181015</span>,<span class="number">20181016</span>,<span class="number">20181017</span>,<span class="number">20181018</span>,<span class="number">20181019</span>,<span class="number">20181020</span>,<span class="number">20181021</span>,<span class="number">20181022</span>,<span class="number">20181023</span>,<span class="number">20181024</span>,<span class="number">20181025</span>,<span class="number">20181026</span>,<span class="number">20181027</span>)</span><br><span class="line">    <span class="keyword">AND</span> bucket_id=<span class="number">60</span></span><br></pre></td></tr></table></figure>
<p>优点:<br>直观,速度最快。<br>缺点:<br>啰嗦，改写起来比较麻烦，只适用于能使用代码预处理sql的地方，而且有最大长度限制。</p>
<h3 id="in查询的扫描行数预估"><a href="#in查询的扫描行数预估" class="headerlink" title="in查询的扫描行数预估"></a>in查询的扫描行数预估</h3><p>有两种方式:</p>
<ol>
<li>精确计算(<code>index_dive</code>): 直接查询对应的行;</li>
<li>采样预估(<code>index statistics</code>): 采样10个数据页,通过索引的选择性统计数据，预估总行数。</li>
</ol>
<p>具体采取哪种方式，由<code>eq_range_index_dive_limit</code>参数控制(默认是10)。<br>小于<code>eq_range_index_dive_limit</code>的时候，采用方法1，精确计算；<br>大于等于<code>eq_range_index_dive_limit</code>的时候，采用方法2, 采样预估。</p>
<h1 id="执行计划耗时"><a href="#执行计划耗时" class="headerlink" title="执行计划耗时"></a>执行计划耗时</h1><p>可以通过命令查看某个查询的具体耗时及具体发生了哪些操作:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> profiling=<span class="number">1</span>;</span><br><span class="line"><span class="comment">-- select * from xxx ;</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">profiles</span>;</span><br><span class="line"><span class="keyword">show</span> profile <span class="keyword">for</span> <span class="keyword">query</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">show</span> profile <span class="keyword">all</span> <span class="keyword">for</span> <span class="keyword">query</span> <span class="number">1</span>; <span class="comment">-- cpu,io等详细信息</span></span><br></pre></td></tr></table></figure>
<p>这里可以看到之前的慢查询发生了51w个block io input。</p>
<h1 id="优化器查询计划选择"><a href="#优化器查询计划选择" class="headerlink" title="优化器查询计划选择"></a>优化器查询计划选择</h1><p>可以通过命令查看某个查询生成执行计划时，考虑过哪些方案，以及对于where条件的等价变换，最终选择了哪个方案(<code>chosen:true</code>)。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> optimizer_trace=<span class="string">"enabled=on"</span>;</span><br><span class="line"><span class="keyword">SET</span> optimizer_trace_max_mem_size=<span class="number">1000000</span>;</span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> xxx</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> information_schema.OPTIMIZER_TRACE\G</span><br></pre></td></tr></table></figure>
<p>可以看到对于之前慢查询的查询条件只用到了dt条件，其他where条件是在服务器层进行过滤的。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://xiaoyue26.github.io/2018/10/22/2018-10/mysql%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98-%E8%8C%83%E5%9B%B4%E6%9F%A5%E8%AF%A2%E8%BD%AC%E7%82%B9%E6%9F%A5%E8%AF%A2/" data-id="ck96cxpoq00e7maam5h9zcfq9" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/mysql/" rel="tag">mysql</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-2018-10/Netty-in-action第14-15章案例研究-笔记" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/10/14/2018-10/Netty-in-action%E7%AC%AC14-15%E7%AB%A0%E6%A1%88%E4%BE%8B%E7%A0%94%E7%A9%B6-%E7%AC%94%E8%AE%B0/" class="article-date">
  <time datetime="2018-10-14T04:00:00.000Z" itemprop="datePublished">2018-10-14</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/java/">java</a>►<a class="article-category-link" href="/categories/java/Netty/">Netty</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/10/14/2018-10/Netty-in-action%E7%AC%AC14-15%E7%AB%A0%E6%A1%88%E4%BE%8B%E7%A0%94%E7%A9%B6-%E7%AC%94%E8%AE%B0/">Netty-in-action第14-15章案例研究-笔记</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <h1 id="文件上传案例-Droplr"><a href="#文件上传案例-Droplr" class="headerlink" title="文件上传案例: Droplr"></a>文件上传案例: Droplr</h1><h2 id="需求"><a href="#需求" class="headerlink" title="需求:"></a>需求:</h2><p>上传文件到S3,返回一个下载url。</p>
<p>数据流: 客户端=&gt;服务端=&gt;S3</p>
<h2 id="原始方案"><a href="#原始方案" class="headerlink" title="原始方案:"></a>原始方案:</h2><ol>
<li>服务器接受上传,存成文件;</li>
<li>服务器上传到S3;</li>
<li>服务器回复url给客户端。</li>
</ol>
<p>缺点: </p>
<ol>
<li>每个上传开销大占用大量内存,导致并发低;</li>
<li>上传完整个文件才开始上传S3,而瓶颈恰恰在于S3。</li>
<li>有磁盘IO。</li>
</ol>
<h2 id="改进方案"><a href="#改进方案" class="headerlink" title="改进方案"></a>改进方案</h2><p>流式上传,只在内存,不过磁盘。</p>
<ol>
<li>服务器接受上传，每块数据实时传输到S3;</li>
<li>接受和上传做速度适配，保持低内存消耗，高并发；</li>
<li>最后返回url给客户端。</li>
</ol>
<p>并发达到10K。</p>
<h3 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h3><ol>
<li><code>IdelStateHandler</code>关闭不活跃的连接,回滚历史进度(速度控制失败时);</li>
<li>并发达到上限时,返回503;</li>
<li>需要保证<code>HttpChunk</code>的顺序(线程池)。<br>(注: 503: 服务不可用（服务器资源耗尽，拒绝服务）)</li>
</ol>
<p>http-client库:<br><a href="https://github.com/akka/akka-http" target="_blank" rel="noopener">https://github.com/akka/akka-http</a><br><a href="https://github.com/AsyncHttpClient/async-http-client" target="_blank" rel="noopener">https://github.com/AsyncHttpClient/async-http-client</a></p>
<h1 id="实时数据同步：FireBase（被谷歌收购）"><a href="#实时数据同步：FireBase（被谷歌收购）" class="headerlink" title="实时数据同步：FireBase（被谷歌收购）"></a>实时数据同步：FireBase（被谷歌收购）</h1><h2 id="需求1"><a href="#需求1" class="headerlink" title="需求1:"></a>需求1:</h2><p>在各个用户和设备之间实时同步数据。<br>(服务器同步到各个客户端)</p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>长轮询+WebSocket.<br>先使用长轮询连接，当WebSocket可用时切换到WebSocket。</p>
<p>难点在于长轮询。</p>
<h2 id="具体细节"><a href="#具体细节" class="headerlink" title="具体细节"></a>具体细节</h2><p>轮询 : 客户端每隔N秒轮询一次;实时性不强,开销大（空转）;<br>长轮询 : 客户端询问一次服务器,然后等待服务器响应,收到响应以后才继续轮询。<br>在服务端没有回复客户端的期间,如果客户端此时想发送数据给服务端,它会先阻塞。<br><code>此时，客户端手头的数据会堆积在缓冲区。</code><br>换言之，限制是: <code>未完成请求数&lt;=1</code>。(同一个客户端)</p>
<h3 id="长轮询"><a href="#长轮询" class="headerlink" title="长轮询"></a>长轮询</h3><p>优点: 没有新数据时,服务器可以不回应客户端,这样客户端就不会接着轮询,减少空转;<br>缺点: 客户端发送数据可能被阻塞。 </p>
<h4 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h4><p>客户端: 限制改成<code>未完成请求数&lt;=2</code>。(从1上调到2)<br>服务端: 如果当前有1个未完成请求<code>A</code>，此时又收到了同一个客户端的第二个请求<code>B</code>(一般第二个是发送数据的请求),会先对<code>A</code>进行空响应,然后处理请求<code>B</code>。</p>
<p>引入新问题: <strong>消息的有序性;</strong><br>解决方案: 元数据加入消息序列号。</p>
<p>引入新问题: <strong>连接断开检测</strong><br>解决方案:<br>客户端: 超时重试(以区分于慢速网络)。<br>服务端: 超时判断为连接断开。</p>
<p>要点: Netty支持一个端口多个协议(HTTP,Websocket,长轮询,TCP)</p>
<h2 id="需求2"><a href="#需求2" class="headerlink" title="需求2:"></a>需求2:</h2><p>加密环境(<code>SSLHandler</code>)下，基于带宽计费。</p>
<h3 id="方案"><a href="#方案" class="headerlink" title="方案:"></a>方案:</h3><ol>
<li>解密前统计字节数;</li>
<li>解密后得到账户名,计入该账户的账单。</li>
</ol>
<p>要点: 统计字节数提前到解密前，提高性能。</p>
<h1 id="app推送通知-Urban-Airship案例"><a href="#app推送通知-Urban-Airship案例" class="headerlink" title="app推送通知: Urban Airship案例"></a>app推送通知: Urban Airship案例</h1><h2 id="需求-1"><a href="#需求-1" class="headerlink" title="需求"></a>需求</h2><p>实时推送通知</p>
<h2 id="方案-1"><a href="#方案-1" class="headerlink" title="方案"></a>方案</h2><ol>
<li>app维护一条到后端服务的连接;</li>
<li>借助第三方推送服务中转,服务器把消息传输给第三方平台，然后转交给app。</li>
</ol>
<p>其中苹果的APNS推送服务的使用流程:</p>
<ol>
<li>生产者: 通过TCP+SSLv3连接到APNS服务器,使用X.509证书进行身份认证;</li>
<li>生产者: 按APNS规定的格式，发送消息(二进制);</li>
<li>生产者: 读取(消息id,错误码)或成功。(因为有消息id,这里可以异步)</li>
</ol>
<p>其中消息格式是大端字节序，可以如下显式指定:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ByteBuf buf = Unpooled.buffer(size).order(ByteOrder.BIG_ENDIAN);</span><br></pre></td></tr></table></figure>

<p>初始化,设置允许重新协商密钥:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> ChannelPipeline pipeline = channel.pipeline();</span><br><span class="line"> <span class="keyword">final</span> SslHandler handler = <span class="keyword">new</span> SslHandler(clientEngine);</span><br><span class="line"> handler.setEnableRenegotiation(<span class="keyword">true</span>);<span class="comment">// 重新协商</span></span><br><span class="line"> pipeline.addLast(<span class="string">"ssl"</span>, handler);</span><br><span class="line"> pipeline.addLast(<span class="string">"decoder"</span>, <span class="keyword">new</span> ApnsResponseDecoder());</span><br></pre></td></tr></table></figure>

<h2 id="需要注意的经验"><a href="#需要注意的经验" class="headerlink" title="需要注意的经验"></a>需要注意的经验</h2><ol>
<li>运营商可能不允许TCP的keep-alive特性,会积极剔除空闲的TCP会话;</li>
<li>移动运营商可能禁止UDP.</li>
</ol>
<h1 id="第15章-案例研究，第二部分"><a href="#第15章-案例研究，第二部分" class="headerlink" title="第15章 案例研究，第二部分"></a>第15章 案例研究，第二部分</h1><h1 id="服务通信案例-Nifty和Swift-Facebook"><a href="#服务通信案例-Nifty和Swift-Facebook" class="headerlink" title="服务通信案例: Nifty和Swift(Facebook)"></a>服务通信案例: Nifty和Swift(Facebook)</h1><p><code>Thrift</code>: facebook开发的跨语言rpc远程调用、服务通信的框架。<br>组件:</p>
<ol>
<li>IDL: 定义通信的格式;</li>
<li>协议；</li>
<li>传输接口;</li>
<li>编译器: 从IDL生成服务端和客户端的存根代码(不同语言);</li>
<li>客户端和服务端实现。</li>
</ol>
<h2 id="场景"><a href="#场景" class="headerlink" title="场景:"></a>场景:</h2><p>由于<code>Thrift</code>是跨语言的远程调用。<br>其中C++版本基于<code>libevent</code>\ <code>Folly</code>开发，性能很高;<br>Java版本(<code>Nifty</code>)基于<code>Netty</code>开发，性能与C++版本不相上下。</p>
<p><strong>Nifty</strong>：</p>
<blockquote>
<p>基于<code>Netty</code>的<code>Thrift</code>java实现。</p>
</blockquote>
<h3 id="需求1：-按顺序响应"><a href="#需求1：-按顺序响应" class="headerlink" title="需求1： 按顺序响应"></a>需求1： 按顺序响应</h3><p>客户端可能会要求:<br>服务器端并行处理请求，但是返回响应必须是顺序的。</p>
<p>解决方案: 服务器端并行处理请求, 返回前排序响应。(缓冲处理好的请求结果)<br>开销: 缓冲响应的内存。（所以如果客户端不要求顺序响应，可以免除这部分开销）</p>
<p>Netty4的实现支持: <code>EventExecutor</code><br>Netty3的实现支持: <code>OrderedMemoryAwareThreadPoolExcecutor</code></p>
<p><strong>Swift</strong></p>
<blockquote>
<p>用注解来定义模型，无效IDL文件和存根。<br>底层使用Nifty作为I/O引擎。<br><a href="https://github.com/facebookarchive/swift" target="_blank" rel="noopener">https://github.com/facebookarchive/swift</a><br>已经不再维护。<br>还在维护的类似开源项目是:<br><a href="https://github.com/airlift/drift" target="_blank" rel="noopener">https://github.com/airlift/drift</a></p>
</blockquote>
<h2 id="超时处理"><a href="#超时处理" class="headerlink" title="超时处理"></a>超时处理</h2><p>问题: 每个请求维护一个超时事件的话，代价很昂贵。</p>
<p>方案1: 超时集。<br>每个客户端维护一个计时器，或者每组相同超时间隔的请求，维护一个计时器。<br>每次超时结束以后，进行下一个超时计时器。<br>优点: 开销小;<br>缺点: 要求超时间隔长度一致。</p>
<p>方案2: 使用<code>Netty</code>的<code>HashedWheelTimer</code>工具类。（空间换时间）<br>算法来自:<br><a href="http://www.cs.columbia.edu/~nahum/w6998/papers/sosp87-timing-wheels.pdf" target="_blank" rel="noopener">http://www.cs.columbia.edu/~nahum/w6998/papers/sosp87-timing-wheels.pdf</a><br>示例代码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">HashedWheelTimer timer = <span class="keyword">new</span> HashedWheelTimer(<span class="number">100</span>, TimeUnit.MILLISECONDS, <span class="number">16</span>);</span><br><span class="line">System.out.println(LocalTime.now());</span><br><span class="line">timer.newTimeout((timeout) -&gt; &#123;</span><br><span class="line">    System.out.println(LocalTime.now());</span><br><span class="line">    System.out.println(timeout);</span><br><span class="line">&#125;, <span class="number">5</span>, TimeUnit.SECONDS);</span><br><span class="line"><span class="comment">//阻塞main线程</span></span><br><span class="line">System.in.read();</span><br></pre></td></tr></table></figure>


<h1 id="RPC框架案例-Finagle-Twitter"><a href="#RPC框架案例-Finagle-Twitter" class="headerlink" title="RPC框架案例: Finagle(Twitter)"></a>RPC框架案例: Finagle(Twitter)</h1><p>前端api端点&lt;=&gt;<code>Finagle</code>&lt;=&gt;后端服务们(提供:用户信息、twitter、时间线)<br>(大部分是scala开发。原先是ruby on rails)</p>
<img src="/images/2018-10/15.6.png" class="" width="400" height="600" title="Finagle">
<p>主要功能包括: SSL、打日志(统计)、负载均衡</p>
<h3 id="负载均衡（故障管理）"><a href="#负载均衡（故障管理）" class="headerlink" title="负载均衡（故障管理）"></a>负载均衡（故障管理）</h3><p>客户端统计所有服务器的延迟、未完成请求数（负载），<br>每次选择最低负载的主机派发请求。</p>
<p>失败请求=&gt;从列表中移除对应服务器=&gt;后台不断尝试重连。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://xiaoyue26.github.io/2018/10/14/2018-10/Netty-in-action%E7%AC%AC14-15%E7%AB%A0%E6%A1%88%E4%BE%8B%E7%A0%94%E7%A9%B6-%E7%AC%94%E8%AE%B0/" data-id="ck96cxpoo00dxmaamfjyfcdyu" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Netty/" rel="tag">Netty</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/" rel="tag">java</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-2018-10/Netty-in-action-第十一章-SSL等预置实现-笔记" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/10/10/2018-10/Netty-in-action-%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0-SSL%E7%AD%89%E9%A2%84%E7%BD%AE%E5%AE%9E%E7%8E%B0-%E7%AC%94%E8%AE%B0/" class="article-date">
  <time datetime="2018-10-10T10:38:46.000Z" itemprop="datePublished">2018-10-10</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/java/">java</a>►<a class="article-category-link" href="/categories/java/Netty/">Netty</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/10/10/2018-10/Netty-in-action-%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0-SSL%E7%AD%89%E9%A2%84%E7%BD%AE%E5%AE%9E%E7%8E%B0-%E7%AC%94%E8%AE%B0/">Netty-in-action-第十一章-SSL等预置实现-笔记</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <p>这章主要讲内容:</p>
<ol>
<li>SSL/TLS;</li>
<li>HTTP/HTTPS;</li>
<li>空闲的连接和超时;</li>
<li>基于分隔符和长度的协议（处理粘包，半包）;</li>
<li>写大型数据。</li>
<li>序列化</li>
</ol>
<h1 id="SSL-TLS"><a href="#SSL-TLS" class="headerlink" title="SSL/TLS"></a>SSL/TLS</h1><p>安全协议：<code>SSL</code>/<code>TLS</code><br>用例： <code>HTTPS</code>, <code>SMTPS</code><br>实现： jdk实现(<code>javax.net.ssl</code>), <code>openssl</code>(性能更好)<br>Netty中的支持:<br><code>SslHandler</code></p>
<img src="/images/2018-10/11.1.png" class="" width="400" height="600" title="sslhandler">
<p><code>SslHandler</code>的声明:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-- SslHandler:</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SslHandler</span> <span class="keyword">extends</span> <span class="title">ByteToMessageDecoder</span> <span class="keyword">implements</span> <span class="title">ChannelOutboundHandler</span> </span></span><br><span class="line">-- 其中的ByteToMessageDecoder:</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ByteToMessageDecoder</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span></span></span><br></pre></td></tr></table></figure>
<p>由声明看出，它是一个编解码器（入站事件和出站事件都处理）。<br>入站: 字节=&gt;消息（解密）<br>出站: 消息=&gt;字节（加密）<br>具体使用则和以前的编解码器都不同：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SslChannelInitializer</span> <span class="keyword">extends</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">Channel</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SslContext context;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> startTls;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SslChannelInitializer</span><span class="params">(SslContext context,<span class="keyword">boolean</span> startTls)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.context = context;</span><br><span class="line">        <span class="keyword">this</span>.startTls = startTls;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(Channel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        SSLEngine engine = context.newEngine(ch.alloc());</span><br><span class="line">        ch.pipeline().addFirst(<span class="string">"ssl"</span></span><br><span class="line">            , <span class="keyword">new</span> SslHandler(engine, startTls));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结:<br>需要借用: SslContext</p>
<p>两个要注意的点:</p>
<ol>
<li>对于每个 <code>SslHandler</code> 实例，都使用 <code>Channel</code> 的 <code>ByteBufAllocator</code> 从 <code>SslContext</code> 获取一个新的 <code>SSLEngine</code>(<code>ch.alloc()</code>);</li>
<li><code>startTls</code>: 如果设置为 true，第一个写入的消息将不会被加密;（客户端应该设置为 true）</li>
<li><a href="https://github.com/devsunny/netty-ssl-example/blob/master/src/main/java/com/asksunny/ssl/StreamReader.java" target="_blank" rel="noopener">https://github.com/devsunny/netty-ssl-example/blob/master/src/main/java/com/asksunny/ssl/StreamReader.java</a></li>
</ol>
<h1 id="HTTP相关的handler"><a href="#HTTP相关的handler" class="headerlink" title="HTTP相关的handler"></a>HTTP相关的handler</h1><p>4个解码器、编码器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpPipelineInitializer</span> <span class="keyword">extends</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">Channel</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> client;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HttpPipelineInitializer</span><span class="params">(<span class="keyword">boolean</span> client)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.client = client;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(Channel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">        <span class="keyword">if</span> (client) &#123;</span><br><span class="line">            pipeline.addLast(<span class="string">"decoder"</span>, <span class="keyword">new</span> HttpResponseDecoder());  <span class="comment">//1</span></span><br><span class="line">            pipeline.addLast(<span class="string">"encoder"</span>, <span class="keyword">new</span> HttpRequestEncoder());  <span class="comment">//2</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            pipeline.addLast(<span class="string">"decoder"</span>, <span class="keyword">new</span> HttpRequestDecoder());  <span class="comment">//3</span></span><br><span class="line">            pipeline.addLast(<span class="string">"encoder"</span>, <span class="keyword">new</span> HttpResponseEncoder());  <span class="comment">//4</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="消息聚合"><a href="#消息聚合" class="headerlink" title="消息聚合:"></a>消息聚合:</h2><p>这回是编解码器<code>Codec</code>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpAggregatorInitializer</span> <span class="keyword">extends</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">Channel</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> client;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HttpAggregatorInitializer</span><span class="params">(<span class="keyword">boolean</span> client)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.client = client;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(Channel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">        <span class="keyword">if</span> (client) &#123;</span><br><span class="line">            pipeline.addLast(<span class="string">"codec"</span>, <span class="keyword">new</span> HttpClientCodec());  <span class="comment">//1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            pipeline.addLast(<span class="string">"codec"</span>, <span class="keyword">new</span> HttpServerCodec());  <span class="comment">//2</span></span><br><span class="line">        &#125;</span><br><span class="line">        pipeline.addLast(<span class="string">"aggegator"</span>, <span class="keyword">new</span> HttpObjectAggregator(<span class="number">512</span> * <span class="number">1024</span>));  <span class="comment">//3 512kb</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="HTTP-压缩"><a href="#HTTP-压缩" class="headerlink" title="HTTP 压缩"></a>HTTP 压缩</h2><p>客户端加解压器，服务端加压缩器:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpAggregatorInitializer</span> <span class="keyword">extends</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">Channel</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> isClient;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HttpAggregatorInitializer</span><span class="params">(<span class="keyword">boolean</span> isClient)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.isClient = isClient;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(Channel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">        <span class="keyword">if</span> (isClient) &#123;</span><br><span class="line">            pipeline.addLast(<span class="string">"codec"</span>, <span class="keyword">new</span> HttpClientCodec()); <span class="comment">//1</span></span><br><span class="line">            pipeline.addLast(<span class="string">"decompressor"</span>,<span class="keyword">new</span> HttpContentDecompressor()); <span class="comment">//2</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            pipeline.addLast(<span class="string">"codec"</span>, <span class="keyword">new</span> HttpServerCodec()); <span class="comment">//3</span></span><br><span class="line">            pipeline.addLast(<span class="string">"compressor"</span>,<span class="keyword">new</span> HttpContentCompressor()); <span class="comment">//4</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h2><p><code>http</code>部分加上<code>sslHandler</code>就是<code>https</code>。不过本质上还是需要<code>SslContext</code>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpsCodecInitializer</span> <span class="keyword">extends</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">Channel</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SslContext context;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> client;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HttpsCodecInitializer</span><span class="params">(SslContext context, <span class="keyword">boolean</span> client)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.context = context;</span><br><span class="line">        <span class="keyword">this</span>.client = client;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(Channel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">        SSLEngine engine = context.newEngine(ch.alloc());</span><br><span class="line">        pipeline.addFirst(<span class="string">"ssl"</span>, <span class="keyword">new</span> SslHandler(engine));  <span class="comment">//1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (client) &#123;</span><br><span class="line">            pipeline.addLast(<span class="string">"codec"</span>, <span class="keyword">new</span> HttpClientCodec());  <span class="comment">//2</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            pipeline.addLast(<span class="string">"codec"</span>, <span class="keyword">new</span> HttpServerCodec());  <span class="comment">//3</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h1><p><code>http</code>仅让客户端向服务端请求数据，服务端无法主动推数据给客户端。一种解决方案是让客户端轮询，另一种解决方案是<code>WebSocket</code>。<br>用<code>WebSocket</code>的话，底层是tcp双向连接，服务端可以主动发消息给客户端。</p>
<h2 id="WebSocket帧类型"><a href="#WebSocket帧类型" class="headerlink" title="WebSocket帧类型"></a>WebSocket帧类型</h2><p>三种数据帧:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BinaryWebSocketFrame: 二进制;</span><br><span class="line">TextWebSocketFrame: 文本;</span><br><span class="line">ContunuationWebSocketFrame: 后续数据;</span><br></pre></td></tr></table></figure>
<p>三种控制帧:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PingWebSocketFrame: ping，对方会回pong;</span><br><span class="line">PongWebSocketFrame: pong;</span><br><span class="line">CloseWebSocketFrame: 关闭。</span><br></pre></td></tr></table></figure>

<p>服务端示例:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebSocketServerInitializer</span> <span class="keyword">extends</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">Channel</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(Channel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ch.pipeline().addLast(</span><br><span class="line">            <span class="keyword">new</span> HttpServerCodec(),</span><br><span class="line">            <span class="comment">//为握手提供聚合的 HttpRequest</span></span><br><span class="line">            <span class="keyword">new</span> HttpObjectAggregator(<span class="number">65536</span>),</span><br><span class="line">            <span class="comment">//如果被请求的端点是"/websocket"，则处理该升级握手</span></span><br><span class="line">            <span class="keyword">new</span> WebSocketServerProtocolHandler(<span class="string">"/websocket"</span>),</span><br><span class="line">            <span class="comment">//TextFrameHandler 处理 TextWebSocketFrame</span></span><br><span class="line">            <span class="keyword">new</span> TextFrameHandler(),</span><br><span class="line">            <span class="comment">//BinaryFrameHandler 处理 BinaryWebSocketFrame</span></span><br><span class="line">            <span class="keyword">new</span> BinaryFrameHandler(),</span><br><span class="line">            <span class="comment">//ContinuationFrameHandler 处理 ContinuationWebSocketFrame</span></span><br><span class="line">            <span class="keyword">new</span> ContinuationFrameHandler());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TextFrameHandler</span> <span class="keyword">extends</span></span></span><br><span class="line"><span class="class">        <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">TextWebSocketFrame</span>&gt; </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx,</span></span></span><br><span class="line"><span class="function"><span class="params">            TextWebSocketFrame msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="comment">// Handle text frame</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">BinaryFrameHandler</span> <span class="keyword">extends</span></span></span><br><span class="line"><span class="class">        <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">BinaryWebSocketFrame</span>&gt; </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx,</span></span></span><br><span class="line"><span class="function"><span class="params">            BinaryWebSocketFrame msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="comment">// Handle binary frame</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ContinuationFrameHandler</span> <span class="keyword">extends</span></span></span><br><span class="line"><span class="class">        <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">ContinuationWebSocketFrame</span>&gt; </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx,</span></span></span><br><span class="line"><span class="function"><span class="params">            ContinuationWebSocketFrame msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="comment">// Handle continuation frame</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="空闲事件、超时事件"><a href="#空闲事件、超时事件" class="headerlink" title="空闲事件、超时事件"></a>空闲事件、超时事件</h1><p><code>WebSocket</code>协议中多了几种事件: </p>
<table>
<thead>
<tr>
<th align="center">触发时机</th>
<th align="left">事件</th>
<th align="center">处理方法</th>
<th align="center">预置handler</th>
</tr>
</thead>
<tbody><tr>
<td align="center">空闲时间超过配置</td>
<td align="left">IdleStateEvent</td>
<td align="center">userEventTriggered()</td>
<td align="center">IdleStateHandler</td>
</tr>
<tr>
<td align="center">指定时间间隔内没有收到入站数据</td>
<td align="left">ReadTimeoutException</td>
<td align="center">exceptionCaught()</td>
<td align="center">ReadTimeoutHandler</td>
</tr>
<tr>
<td align="center">指定时间间隔内没有出站数据</td>
<td align="left">WriteTimeoutException</td>
<td align="center">exceptionCaught()</td>
<td align="center">WriteTimeoutHandler</td>
</tr>
</tbody></table>
<p>具体使用方法:</p>
<ol>
<li>注册预置的handler,截获对应的事件;(<code>IdleStateHandler</code>,<code>ReadTimeoutHandler</code>,<code>WriteTimeoutHandler</code>)</li>
<li>实现一个自定义handler注册到pipeline,处理对应的事件。 </li>
</ol>
<p>空闲事件示例:</p>
<ol>
<li>注册<code>IdleStateHandler</code>，负责截获空闲事件，它会调用<code>fireUserEventTriggered</code>方法,触发<code>userEvent</code>事件;</li>
<li>实现自定义<code>handler</code>,处理<code>userEvent</code>:一种可能的处理逻辑是进行心跳检测，检测到是空闲事件就发送心跳,发送失败就关闭连接; 如果不是空闲事件,则抛出去,让下一级处理。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IdleStateHandlerInitializer</span> <span class="keyword">extends</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">Channel</span>&gt;</span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(Channel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">        pipeline.addLast(</span><br><span class="line"><span class="comment">//(1)IdleStateHandler 将在被触发时发送一个IdleStateEvent事件:</span></span><br><span class="line">                <span class="keyword">new</span> IdleStateHandler(<span class="number">0</span>, <span class="number">0</span>, <span class="number">60</span>, TimeUnit.SECONDS));</span><br><span class="line"><span class="comment">//(2)将一个HeartbeatHandler添加到ChannelPipeline中:</span></span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> HeartbeatHandler());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//(3)实现userEventTriggered()方法以发送心跳消息:</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HeartbeatHandler</span></span></span><br><span class="line"><span class="class">        <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line">        <span class="comment">//发送到远程节点的心跳消息</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ByteBuf HEARTBEAT_SEQUENCE =</span><br><span class="line">                Unpooled.unreleasableBuffer(Unpooled.copiedBuffer(</span><br><span class="line">                <span class="string">"HEARTBEAT"</span>, CharsetUtil.ISO_8859_1));</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">userEventTriggered</span><span class="params">(ChannelHandlerContext ctx,</span></span></span><br><span class="line"><span class="function"><span class="params">            Object evt)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="comment">//(4)发送心跳消息，并在发送失败时关闭该连接</span></span><br><span class="line">            <span class="keyword">if</span> (evt <span class="keyword">instanceof</span> IdleStateEvent) &#123;</span><br><span class="line">                ctx.writeAndFlush(HEARTBEAT_SEQUENCE.duplicate())</span><br><span class="line">                     .addListener(</span><br><span class="line">                         ChannelFutureListener.CLOSE_ON_FAILURE);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//若不是IdleStateEvent事件，所以将它传递给下一个ChannelInboundHandler</span></span><br><span class="line">                <span class="keyword">super</span>.userEventTriggered(ctx, evt);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h1 id="工具：解决粘包和半包-数据帧的划分问题"><a href="#工具：解决粘包和半包-数据帧的划分问题" class="headerlink" title="工具：解决粘包和半包(数据帧的划分问题)"></a>工具：解决粘包和半包(数据帧的划分问题)</h1><p><code>netty</code>主要是字节流层传输，并不关心应用层对数据的划分（并不关心帧是如何划分的）。<br>但是<code>netty</code>提供了很多帮助分隔帧的工具类，来解决粘包和半包的问题。<br>数据帧的划分问题一般有三种解决方案:</p>
<ol>
<li>定长帧;</li>
<li>指定分隔符;</li>
<li>head-body结构，header中规定body长度。(<code>HTTP</code>)比较灵活，比较常见。</li>
</ol>
<h2 id="指定分隔符"><a href="#指定分隔符" class="headerlink" title="指定分隔符"></a>指定分隔符</h2><p>相关工具类: <code>DelimitedBasedFrameDecoder</code>,<code>LineBasedFrameDecoder</code></p>
<h2 id="定长帧"><a href="#定长帧" class="headerlink" title="定长帧"></a>定长帧</h2><p>相关工具类: <code>FixedLengthFrameDecoder</code></p>
<h2 id="head-body结构"><a href="#head-body结构" class="headerlink" title="head-body结构"></a>head-body结构</h2><p>相关工具类: <code>LengthFieldBasedFrameDecoder</code></p>
<h1 id="高级特性-写大文件-或大数据"><a href="#高级特性-写大文件-或大数据" class="headerlink" title="高级特性: 写大文件(或大数据)"></a>高级特性: 写大文件(或大数据)</h1><p>两种实现:</p>
<ol>
<li>直接写文件: <code>FileRegion</code>;</li>
<li>借助预置实现:<code>ChunkedWriteHandler</code>。</li>
</ol>
<h2 id="FileReion"><a href="#FileReion" class="headerlink" title="FileReion"></a>FileReion</h2><p>直接在<code>channel</code>中写入<code>FileRegion</code>即可:(还可以用<code>ChannelProgressivePromise</code>来获取传输进度)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">FileInputStream in = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line"><span class="comment">//以该文件的完整长度创建一个新的 DefaultFileRegion</span></span><br><span class="line">FileRegion region = <span class="keyword">new</span> DefaultFileRegion(</span><br><span class="line">        in.getChannel(), <span class="number">0</span>, file.length());</span><br><span class="line"><span class="comment">//发送该 DefaultFileRegion，并注册一个 ChannelFutureListener</span></span><br><span class="line">channel.writeAndFlush(region).addListener(</span><br><span class="line">    <span class="keyword">new</span> ChannelFutureListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(ChannelFuture future)</span></span></span><br><span class="line"><span class="function">       <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (!future.isSuccess()) &#123;</span><br><span class="line">           <span class="comment">//处理失败</span></span><br><span class="line">           Throwable cause = future.cause();</span><br><span class="line">           <span class="comment">// Do something</span></span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="ChunkedWriterHandler"><a href="#ChunkedWriterHandler" class="headerlink" title="ChunkedWriterHandler"></a>ChunkedWriterHandler</h2><p>数据流是:<br>数据源=&gt;<code>ChunkedInput</code>=&gt;自定义的StreamHandler=&gt;<code>ChunkedWriteHandler</code>=&gt;出站</p>
<p>其中<code>ChunkedInput</code>有4种实现:</p>
<table>
<thead>
<tr>
<th align="center">实现名称</th>
<th align="left">数据源</th>
<th align="center">备注</th>
</tr>
</thead>
<tbody><tr>
<td align="center">ChunkedFile</td>
<td align="left">文件</td>
<td align="center">当平台不支持零拷贝，或需要转换数据时使用</td>
</tr>
<tr>
<td align="center">ChunkedNioFile</td>
<td align="left">文件</td>
<td align="center">使用FileChannel</td>
</tr>
<tr>
<td align="center">ChunkedStream</td>
<td align="left">InputStream</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">ChunkedNioStream</td>
<td align="left">ReadableByteChannel</td>
<td align="center"></td>
</tr>
</tbody></table>
<p>示例代码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(Channel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">    <span class="comment">//将 SslHandler 添加到 ChannelPipeline 中</span></span><br><span class="line">    pipeline.addLast(<span class="keyword">new</span> SslHandler(sslCtx.newEngine(ch.alloc())));</span><br><span class="line">    <span class="comment">//添加 ChunkedWriteHandler 以处理作为 ChunkedInput 传入的数据</span></span><br><span class="line">    pipeline.addLast(<span class="keyword">new</span> ChunkedWriteHandler());</span><br><span class="line">    <span class="comment">//一旦连接建立，WriteStreamHandler 就开始写文件数据</span></span><br><span class="line">    pipeline.addLast(<span class="keyword">new</span> WriteStreamHandler());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">WriteStreamHandler</span></span></span><br><span class="line"><span class="class"><span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="comment">//当连接建立时，channelActive() 方法将使用 ChunkedInput 写文件数据</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.channelActive(ctx);</span><br><span class="line">        ctx.writeAndFlush(</span><br><span class="line">        <span class="keyword">new</span> ChunkedStream(<span class="keyword">new</span> FileInputStream(file))); <span class="comment">// ChunkedStream =&gt; ChunkedInput</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="序列化数据"><a href="#序列化数据" class="headerlink" title="序列化数据"></a>序列化数据</h1><p>这里介绍3种方法:</p>
<ol>
<li>JDK的<code>ObjectOutputStream</code>;</li>
<li>JBoss marshalling;</li>
<li>Protocol buffers.<h2 id="JDK序列化"><a href="#JDK序列化" class="headerlink" title="JDK序列化"></a>JDK序列化</h2>只要实现了<code>Serializable</code>接口的对象，就可以使用<code>ObjectOutputStream</code>。<br>示例代码:<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"t.tmp"</span>);</span><br><span class="line">ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(fos);</span><br><span class="line">oos.writeObject(<span class="keyword">new</span> Date());</span><br><span class="line">oos.close();</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>Netty提供的速度优化:<br><code>ObjectInputStream</code> =&gt;<code>ObjectDecoder</code><br><code>ObjectOutputStream</code>=&gt;<code>ObjectEncoder</code></p>
<h2 id="JBoss-Marshalling序列化"><a href="#JBoss-Marshalling序列化" class="headerlink" title="JBoss Marshalling序列化"></a>JBoss Marshalling序列化</h2><p>比JDK序列化快3倍。<br><code>MarshallingDecoder</code><br><code>MarshallingEncoder</code></p>
<p>示例代码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MarshallingInitializer</span> <span class="keyword">extends</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">Channel</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MarshallerProvider marshallerProvider;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> UnmarshallerProvider unmarshallerProvider;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MarshallingInitializer</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            UnmarshallerProvider unmarshallerProvider,</span></span></span><br><span class="line"><span class="function"><span class="params">            MarshallerProvider marshallerProvider)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.marshallerProvider = marshallerProvider;</span><br><span class="line">        <span class="keyword">this</span>.unmarshallerProvider = unmarshallerProvider;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(Channel channel)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ChannelPipeline pipeline = channel.pipeline();</span><br><span class="line">        <span class="comment">//添加 MarshallingDecoder 以将 ByteBuf 转换为 POJO</span></span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> MarshallingDecoder(unmarshallerProvider));</span><br><span class="line">        <span class="comment">//添加 MarshallingEncoder 以将POJO 转换为 ByteBuf</span></span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> MarshallingEncoder(marshallerProvider));</span><br><span class="line">        <span class="comment">//添加 ObjectHandler，以处理普通的实现了Serializable 接口的 POJO</span></span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> ObjectHandler());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjectHandler</span></span></span><br><span class="line"><span class="class">        <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">Serializable</span>&gt; </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            ChannelHandlerContext channelHandlerContext,</span></span></span><br><span class="line"><span class="function"><span class="params">            Serializable serializable)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="comment">// Do something</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中provider的创建代码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> MarshallingDecoder <span class="title">buildMarshallingDecoder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="comment">//首先通过Marshalling工具类的getProvidedMarshallerFactory静态方法获取MarshallerFactory实例</span></span><br><span class="line">       <span class="comment">//参数“serial”表示创建的是Java序列化工厂对象，它由jboss-marshalling-serial-1.3.0.CR9.jar提供。</span></span><br><span class="line">       <span class="keyword">final</span> MarshallerFactory marshallerFactory = Marshalling.getProvidedMarshallerFactory(<span class="string">"serial"</span>);</span><br><span class="line">       <span class="comment">//创建了MarshallingConfiguration对象</span></span><br><span class="line">       <span class="keyword">final</span> MarshallingConfiguration configuration = <span class="keyword">new</span> MarshallingConfiguration();</span><br><span class="line">       <span class="comment">//将它的版本号设置为5</span></span><br><span class="line">       configuration.setVersion(<span class="number">5</span>);</span><br><span class="line">       <span class="comment">//然后根据MarshallerFactory和MarshallingConfiguration创建UnmarshallerProvider实例</span></span><br><span class="line">       UnmarshallerProvider provider = <span class="keyword">new</span> DefaultUnmarshallerProvider(marshallerFactory, configuration);</span><br><span class="line">       <span class="comment">//最后通过构造函数创建Netty的MarshallingDecoder对象</span></span><br><span class="line">       <span class="comment">//它有两个参数，分别是UnmarshallerProvider和单个消息序列化后的最大长度。</span></span><br><span class="line">       MarshallingDecoder decoder = <span class="keyword">new</span> MarshallingDecoder(provider, <span class="number">1024</span>);</span><br><span class="line">       <span class="keyword">return</span> decoder;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>


<h2 id="Protocol-Buffer序列化"><a href="#Protocol-Buffer序列化" class="headerlink" title="Protocol Buffer序列化"></a>Protocol Buffer序列化</h2><p>google的序列化方案。<br>主要是4个类:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 解码:</span></span><br><span class="line">ProtobufVarint32FrameDecoder: bytes=&gt;msg; 解析出头部的长度字段,以正确划分帧;</span><br><span class="line">ProtobufDecoder: msg=&gt;msg;</span><br><span class="line"><span class="comment">// 编码:</span></span><br><span class="line">ProtobufVarint32LengthFieldPrepender: msg=&gt;bytes; 头部添加长度字段.</span><br><span class="line">ProtobufEncoder: msg=&gt;msg.</span><br></pre></td></tr></table></figure>


<p>示例代码:<br>服务端:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">.childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ch.pipeline()</span><br><span class="line">                .addLast(<span class="keyword">new</span> ProtobufVarint32FrameDecoder())</span><br><span class="line">                .addLast(<span class="keyword">new</span> ProtobufDecoder(</span><br><span class="line">                        ProtoObject.Req.getDefaultInstance()))</span><br><span class="line">                .addLast(<span class="keyword">new</span> ProtobufVarint32LengthFieldPrepender())</span><br><span class="line">                .addLast(<span class="keyword">new</span> ProtobufEncoder())</span><br><span class="line">                .addLast(<span class="keyword">new</span> ServerHandler());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>客户端:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">.childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ch.pipeline()</span><br><span class="line">                .addLast(<span class="keyword">new</span> ProtobufVarint32FrameDecoder())</span><br><span class="line">                .addLast(<span class="keyword">new</span> ProtobufDecoder(</span><br><span class="line">                        ProtoObject.Resp.getDefaultInstance()))</span><br><span class="line">                .addLast(<span class="keyword">new</span> ProtobufVarint32LengthFieldPrepender())</span><br><span class="line">                .addLast(<span class="keyword">new</span> ProtobufEncoder())</span><br><span class="line">                .addLast(<span class="keyword">new</span> ClientHandler());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><code>ProtobufDecoder</code>实际上可以接受<code>MessageLite</code>或者<code>Builder</code>。<br><code>Message</code>是<code>MessageLite</code>的子接口，因此可以用<code>Message</code>代替<code>MessageLite</code>。(基类指针存放子类对象)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Message</span> <span class="keyword">extends</span> <span class="title">MessageLite</span>, <span class="title">MessageOrBuilder</span> </span>&#123;...&#125;</span><br></pre></td></tr></table></figure>



      
    </div>
    <footer class="article-footer">
      <a data-url="http://xiaoyue26.github.io/2018/10/10/2018-10/Netty-in-action-%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0-SSL%E7%AD%89%E9%A2%84%E7%BD%AE%E5%AE%9E%E7%8E%B0-%E7%AC%94%E8%AE%B0/" data-id="ck96cxpop00e0maambxtf4rc5" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Netty/" rel="tag">Netty</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/" rel="tag">java</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-2018-09/通俗理解SSL-TLS协议区别与原理" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/09/26/2018-09/%E9%80%9A%E4%BF%97%E7%90%86%E8%A7%A3SSL-TLS%E5%8D%8F%E8%AE%AE%E5%8C%BA%E5%88%AB%E4%B8%8E%E5%8E%9F%E7%90%86/" class="article-date">
  <time datetime="2018-09-26T12:07:37.000Z" itemprop="datePublished">2018-09-26</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/java/">java</a>►<a class="article-category-link" href="/categories/java/Netty/">Netty</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/09/26/2018-09/%E9%80%9A%E4%BF%97%E7%90%86%E8%A7%A3SSL-TLS%E5%8D%8F%E8%AE%AE%E5%8C%BA%E5%88%AB%E4%B8%8E%E5%8E%9F%E7%90%86/">通俗理解SSL/TLS协议区别与原理</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <h1 id="区别-历史"><a href="#区别-历史" class="headerlink" title="区别(历史)"></a>区别(历史)</h1><p><code>TLS 1.0</code>又被叫做<code>SSL 3.1</code>。<br>换算关系:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">TLS 1.0 &#x3D; SSL 3.1</span><br><span class="line">TLS 1.1 &#x3D; SSL 3.2</span><br><span class="line">TLS 1.2 &#x3D; SSL 3.3</span><br></pre></td></tr></table></figure>
<p>综上，简单说，它们的区别只是版本更迭而已。<br>展开说的话，历史: </p>
<blockquote>
</blockquote>
<p>1994年，NetScape公司设计了SSL协议（Secure Sockets Layer）的1.0版，但是未发布。</p>
<blockquote>
</blockquote>
<p>1995年，NetScape公司发布SSL 2.0版，很快发现有严重漏洞。</p>
<blockquote>
</blockquote>
<p>1996年，SSL 3.0版问世，得到大规模应用。</p>
<blockquote>
</blockquote>
<p>1999年，互联网标准化组织ISOC接替NetScape公司，发布了SSL的升级版TLS 1.0版。</p>
<blockquote>
</blockquote>
<p>2006年和2008年，TLS 1.1版和TLS 1.2版发布。（TLS1.2已经获得主流浏览器支持）</p>
<blockquote>
</blockquote>
<p>2008年8月，TLS 1.3版发布，性能好。移除了很多东西，速度快了很多，少了一次握手。</p>
<p>综上，可以先用<code>TLS 1.2</code>。</p>
<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>和以前莉姐课上说的<code>PGP</code>协议差不多，都是三板斧：摘要、非对称加密、对称加密。</p>
<h2 id="要解决的问题"><a href="#要解决的问题" class="headerlink" title="要解决的问题"></a>要解决的问题</h2><pre><code>1. 窃听。解决方案：加密
2. 篡改。解决方案：摘要 （解决数据完整性）
3. 冒充。解决方案：数字签名 （解决中间人攻击）</code></pre><h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><p>ISO七层协议:<br><code>TCP</code> :  传输层<br><code>TLS</code> :  会话层<br>    <em>表示层略</em><br><code>HTTP</code>:  应用层<br>（<code>TLS</code>+<code>HTTP</code>=&gt;<code>HTTPS</code>）</p>
<p>所以是先进行<code>3</code>次握手建立<code>TCP</code>,然后<code>4</code>次握手建立<code>TLS</code>,然后进行<code>HTTP</code>数据传输。</p>
<p>如果在<code>TCP</code>层抓包的话，里头是<code>TLS</code>加密过的数据。（中间人无法知道内容）<br>如果在<code>HTTP</code>层（应用层）收取数据的话，是已经解密过的明文。(但是中间人不太可能在应用层，除非已经嵌入到业务层代码了。)</p>
<h2 id="简化版加密通信"><a href="#简化版加密通信" class="headerlink" title="简化版加密通信"></a>简化版加密通信</h2><p>假设用三个算法做一下加密通信，可以怎么实现呢？<br>定义如下：<br><code>RSA</code>: 一种非对称加密算法<br><code>AES</code>: 一种对称加密算法<br><code>SHA1</code>: 一种摘要算法</p>
<h3 id="方案1：AES-K-data"><a href="#方案1：AES-K-data" class="headerlink" title="方案1：AES(K,data)"></a>方案1：AES(K,data)</h3><p>假如客户端是<code>C</code>，服务端是<code>S</code>，<code>C</code>和<code>S</code>要传输的数据<code>data</code>。<br>直接传明文肯定是不行，可以加密一下。用一个密钥<code>K</code>，加密成<code>AES(K,data)</code>。<br>这里为啥用AES呢，不用RSA呢，因为非对称加密(RSA)太慢了。</p>
<img src="/images/2018-09/tls1.png" class="" width="400" height="600" title="加密">

<ul>
<li>问题：<br>虽然别人不知道你俩传输了啥，但是可能悄悄得在中间篡改了数据，双方察觉不到。</li>
<li>解决方案：<br>加上摘要算法。</li>
</ul>
<h3 id="方案2：AES-K-data-SHA1-data"><a href="#方案2：AES-K-data-SHA1-data" class="headerlink" title="方案2：AES(K,data+SHA1(data))"></a>方案2：AES(K,data+SHA1(data))</h3><p>可以在数据后面加上数据的摘要，然后再加密，这样中间人一旦乱改东西马上就会被检测出来，类似于校验位。</p>
<img src="/images/2018-09/tls2.png" class="" width="400" height="600" title="摘要">

<ul>
<li>问题：<br>上述方案都有一个前提，就是通信双方使用同一个K进行加解密。<br>那么一开始的时候怎么约定、协商这个密钥K呢？</li>
<li>解决方案:<br>先用RSA协商出一个对称密钥K。</li>
</ul>
<h3 id="协商密钥"><a href="#协商密钥" class="headerlink" title="协商密钥"></a>协商密钥</h3><p>最安全的方法当然是线下见面，约定一个密钥K。但是这个通信效率太低了，并发也不高。<br>为了避免中间人攻击，这个问题的关键点在于确认对方的身份。对于CS架构来说，最关键的是客户端确认服务端的身份。因此一个很自然的思路是让每个服务端有自己的身份证。</p>
<p>计算机领域的话，身份证就是数字证书，颁发身份证的机构就是CA。<br>具体原理就是非对称加密:<br>服务端通过数字签名向客户端证明自己的身份，客户端定义一个对称密钥K，然后用服务端的公钥加密一下发给服务端，因为只有服务端能用私钥解开，因此协商密钥的过程是安全的。（即使别人截获到也没关系）</p>
<h4 id="相关原理"><a href="#相关原理" class="headerlink" title="相关原理:"></a>相关原理:</h4><p>对称加密: </p>
<blockquote>
<p>加密时候用密钥K，解密时候也用密钥K，是对称的，因此叫对称加密。</p>
</blockquote>
<p>非对称加密: </p>
<blockquote>
<p>加密时候用公钥K1,解密时候用私钥K2,不是同一个密钥，不对称，因此叫非对称加密。<br>msg = RSA(K1,data);<br>data = RSA(K2,msg)</p>
</blockquote>
<p>也就是说，把数据用K1加密一下，可以且仅可以用K2解开；反之用K2加密消息，也可以且仅可以用K1解开，这个特性就很厉害了，正好可以用于身份认证的需求。</p>
<p>回到刚才的需求，需要有一种数字证书的机制。<br>简单实现就是服务端先去CA申请一对密钥(K1,K2)，他选K1作为公钥，另一个K2作为私钥。<br>当他需要向别人证明自己的身份的时候，他用私钥加密一下消息发给客户端（<code>RSA(K2,data)</code>，数字签名）。客户端可以用公钥K1解开消息，确认他的身份。客户端可以用公钥K1加密一份数据发出去，这份数据也就服务端能解开，因为只有服务端有私钥K2。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结:"></a>总结:</h4><pre><code>数字签名: RSA(私钥K2,data)
加密一份只有指定人能解开的数据: RSA(公钥K1,data)。</code></pre><p>这个过程中客户端如何得到公钥K1呢?<br>可以由服务端发给客户端数字证书，证书由CA签名证明服务端的公钥确实是K1。</p>
<p>客户端是因为信任CA,所以信任CA作保的服务端公钥K1，所以才可以用K1验证服务端的数字签名。（信任传递）<br>也就是说即使是网络世界，也还是需要签发证书的机构的。类似于一种官方机构。如果没有这种信任的基础，匿名的网络世界是很难建立起互信机制的。</p>
<h2 id="TLS运行流程"><a href="#TLS运行流程" class="headerlink" title="TLS运行流程"></a>TLS运行流程</h2><p>简单地说就是2个步骤：先协商一个密钥，之后的通信就用这个密钥加密数据。<br><code>TLS 1.2</code>:<br>协商: 4次握手，协商出一个对称加密的密钥K；<br>通信：双方用K加密数据以后通信。</p>
<img src="/images/2018-09/tls3.png" class="" width="400" height="600" title="tls3.png">
<p>如上图所示，这4次握手就是想要协商出一个对称加密的密钥KEY,以及摘要算法的密钥。<br>图中的变量定义:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">r1: 随机数1;</span><br><span class="line">r2: 随机数2;</span><br><span class="line">r3: 随机数3;</span><br><span class="line">AES(KEY,data): 密钥是KEY，对称加密data；</span><br><span class="line">RSA(K1,data): 密钥是K1, 非对称加密data；</span><br><span class="line">finish: finish信息</span><br><span class="line">HMAC(data): 用HMAC算法对data做摘要（key省略了）。</span><br></pre></td></tr></table></figure>
<p>其中对称加密的KEY是根据3个随机数r1,r2,r3生成出来的。之所以需要这么多随机数，是为了保证这个KEY的随机性。</p>
<p>具体展开来说的话4次握手：<br>1.客户端=&gt;服务端: </p>
<blockquote>
<p>(1)随机数r1;<br>(2)客户端支持的协议版本、算法版本；</p>
</blockquote>
<p>2.服务端=&gt;客户端: </p>
<blockquote>
<p>(1)随机数r2;<br>(2)确定用的协议、算法版本;<br>(3)CA签名的证书(里面有服务器公钥K1);<br>(4)服务端数字签名。</p>
</blockquote>
<p>3.客户端=&gt;服务端: 先确认服务端的身份、生成r3, 生成对称加密的key，然后发送数据:</p>
<blockquote>
<p>(1)用服务器公钥K1非对称加密后的随机数r3;<br>(2)对称加密过的finish信息以及摘要。<br>(此时客户端已经有了r1,r2,r3,可以生成对称加密密钥key)</p>
</blockquote>
<p>4.服务端=&gt;客户端: 先解开非对称加密的数据，得到r3,然后生成对称加密的key，然后解开finish信息，发现确实能用，也就是客户端进行的对称加密是符合预期的，然后发送:</p>
<blockquote>
<p>(1)对称加密过的server finish信息以及摘要。</p>
</blockquote>
<p>如果客户端和服务端都能对Finish信息进行正常加解密且消息正确的被验证，则说明握手通道已经建立成功，接下来，双方可以进行对称加密的数据传输了。</p>
<h3 id="几个小细节"><a href="#几个小细节" class="headerlink" title="几个小细节"></a>几个小细节</h3><ol>
<li>上面的HMAC摘要算法也是有key的，而且也是由r1,r2,r3算出来的;</li>
<li>大部分时候只需要认证服务端身份(http)，有时候也需要认证客户端身份，这个时候就需要客户端也有CA证书。</li>
<li>实际代码实现中，三个随机数都是有名字的: <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">r1: 随机数1; &#x3D;&gt; random_C(random number)</span><br><span class="line">r2: 随机数2; &#x3D;&gt; random_S(random number)</span><br><span class="line">r3: 随机数3; &#x3D;&gt; pre-master key(random number)</span><br></pre></td></tr></table></figure>
r3是关键的加密保护的随机数，r1,r2,r3一起生成key。<br>r1,r2的主要用途是为了避免中间人攻击、重放攻击。（用摘要确保r1,r2无篡改，然后又是随机数的话，就不会因为是重复的key被碰撞到相同的r3，从而生成相同的key）<br>此外其他术语也略有不同：<img src="/images/2018-09/real3.png" class="" width="400" height="600" title="实际握手">

</li>
</ol>
<h2 id="可能的优化"><a href="#可能的优化" class="headerlink" title="可能的优化"></a>可能的优化</h2><p>TLS1.2的4次握手可以优化成近似3次握手。<br>因此协商过程中唯一不会被中间人破译的是客户端第三次握手发送的随机数r3，只要确保这一性质即可。这个r3之所以不会被破译，是因为是用服务端公钥加密的，只有服务端私钥能解开。<br>因此如果客户端事先知道服务端的公钥，可以在第一次握手的时候，就发送由服务端公钥加密的r3。（对于以前曾经通信过的服务端，这一前提是可行的）</p>
<p>因此整个流程就是：<br>1.客户端=&gt;服务端:<br>(1)r1; //防重放<br>(2)RSA(K1,r3+hash(r3)); //可以把自己支持的所有协议的随机数都算好，加密好。<br>(3)支持的协议、算法;<br>2.服务端=&gt;客户端:<br>(1)RSA(对r1的回应),顺便签名证明自己的身份,也消除了重放攻击;<br>(2)r2; 明文即可<br>(3)确定的协议、算法;<br>(4)AES(Key,finish信息+HMAC(finish信息)); // 客户端知道上述两个信息，就能算出对称加密的key了。</p>
<p>3.客户端=&gt;服务端: AES(Key,finish信息+HMAC(finish信息))</p>
<p>参考链接:<br><a href="https://www.cnblogs.com/lovesong/p/5186200.html" target="_blank" rel="noopener">https://www.cnblogs.com/lovesong/p/5186200.html</a><br><a href="https://blog.soaer.com/1/3eac1f9d9045410fb249dbc81cff6b22.html" target="_blank" rel="noopener">https://blog.soaer.com/1/3eac1f9d9045410fb249dbc81cff6b22.html</a><br><a href="http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://xiaoyue26.github.io/2018/09/26/2018-09/%E9%80%9A%E4%BF%97%E7%90%86%E8%A7%A3SSL-TLS%E5%8D%8F%E8%AE%AE%E5%8C%BA%E5%88%AB%E4%B8%8E%E5%8E%9F%E7%90%86/" data-id="ck96cxpom00dnmaam2tyrfqth" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/AES/" rel="tag">AES</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/HMAC/" rel="tag">HMAC</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/HTTP/" rel="tag">HTTP</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Netty/" rel="tag">Netty</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/RSA/" rel="tag">RSA</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/SSL/" rel="tag">SSL</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/TLS/" rel="tag">TLS</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/" rel="tag">java</a></li></ul>

    </footer>
  </div>
  
</article>
 


  


  <nav id="page-nav">
    <a class="extend prev" rel="prev" href="/page/8/">&amp;laquo; 上一页</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="page-number" href="/page/8/">8</a><span class="page-number current">9</span><a class="page-number" href="/page/10/">10</a><a class="page-number" href="/page/11/">11</a><span class="space">&hellip;</span><a class="page-number" href="/page/22/">22</a><a class="extend next" rel="next" href="/page/10/">下一页&amp;raquo;</a>
  </nav>
</section>
           
    <aside id="sidebar">
  
    

  
    
  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title recent-posts">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/01/21/2022-01/voip-rtc/">VoIP和RTC</a>
          </li>
        
          <li>
            <a href="/2021/07/26/2021-07/metaspace%E7%AC%94%E8%AE%B0/">metaspace笔记</a>
          </li>
        
          <li>
            <a href="/2021/06/01/2021-06/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E7%AC%94%E8%AE%B0-1/">网络安全笔记-1</a>
          </li>
        
          <li>
            <a href="/2021/02/22/2021-02/%E5%A4%9A%E9%A1%B9%E7%9B%AE%E5%85%B1%E4%BA%AB%E4%BB%A3%E7%A0%81%E4%B9%8B%E2%80%94%E2%80%94git-subtree/">多项目共享代码之——git subtree</a>
          </li>
        
          <li>
            <a href="/2020/12/27/2020-12/%E8%B7%A8%E5%9F%9F%E7%9B%B8%E5%85%B3/">跨域相关</a>
          </li>
        
      </ul>
    </div>
  </div>

  
    

  
</aside>

      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-left">
      &copy; 2014 - 2022 风梦七&nbsp;|&nbsp;
      主题 <a href="https://github.com/giscafer/hexo-theme-cafe/" target="_blank">Cafe</a>
    </div>
     <div id="footer-right">
      联系方式&nbsp;|&nbsp;296671657@qq.com
    </div>
  </div>
</footer>
 
<script src="/jquery/jquery.min.js"></script>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">首页</a>
  
    <a href="/archives" class="mobile-nav-link">归档</a>
  
    <a href="/about" class="mobile-nav-link">关于</a>
  
</nav>
    <img class="back-to-top-btn" src="/images/fly-to-top.png"/>
<script>
// Elevator script included on the page, already.
window.onload = function() {
  var elevator = new Elevator({
    selector:'.back-to-top-btn',
    element: document.querySelector('.back-to-top-btn'),
    duration: 1000 // milliseconds
  });
}
</script>
      

  
    <script>
      var cloudTieConfig = {
        url: document.location.href, 
        sourceId: "",
        productKey: "e2fb4051c49842688ce669e634bc983f",
        target: "cloud-tie-wrapper"
      };
    </script>
    <script src="https://img1.ws.126.net/f2e/tie/yun/sdk/loader.js"></script>
    

  







<!-- author:forvoid begin -->
<!-- author:forvoid begin -->

<!-- author:forvoid end -->

<!-- author:forvoid end -->


  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      })
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      })
    </script>
    <script type="text/javascript" src="https://cdn.rawgit.com/mathjax/MathJax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


 
<script src="/js/is.js"></script>



  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>


<script src="/js/elevator.js"></script>

  </div>
</body>
</html>