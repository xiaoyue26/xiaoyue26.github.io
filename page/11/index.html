<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>笔记本</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="笔记本">
<meta property="og:url" content="http://xiaoyue26.github.io/page/11/index.html">
<meta property="og:site_name" content="笔记本">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="风梦七">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="笔记本" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    
  
  
<link rel="stylesheet" href="/css/style.css">

  

<meta name="generator" content="Hexo 4.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    
    <div id="header-inner" class="inner">
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://xiaoyue26.github.io"></form>
      </div>
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">首页</a>
        
          <a class="main-nav-link" href="/archives">归档</a>
        
          <a class="main-nav-link" href="/about">关于</a>
        
      </nav>
      
    </div>
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">笔记本</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">风梦七</a>
        </h2>
      
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-2018-10/HashedWheelTimer-大量定时器解决方案-Netty与kafka" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/10/27/2018-10/HashedWheelTimer-%E5%A4%A7%E9%87%8F%E5%AE%9A%E6%97%B6%E5%99%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88-Netty%E4%B8%8Ekafka/" class="article-date">
  <time datetime="2018-10-27T12:16:33.000Z" itemprop="datePublished">2018-10-27</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/java/">java</a>►<a class="article-category-link" href="/categories/java/Netty/">Netty</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/10/27/2018-10/HashedWheelTimer-%E5%A4%A7%E9%87%8F%E5%AE%9A%E6%97%B6%E5%99%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88-Netty%E4%B8%8Ekafka/">HashedWheelTimer-大量定时器解决方案(Netty与kafka)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <h1 id="需求"><a href="#需求" class="headerlink" title="需求:"></a>需求:</h1><p>有大量定时任务需要执行，精度要求不高，可以允许延迟执行。<br>可能的场景: 每个连接的超时事件、每个请求的超时事件。</p>
<h1 id="方案1"><a href="#方案1" class="headerlink" title="方案1:"></a>方案1:</h1><p>每个定时任务设置一个定时器、或一个<code>Scheduled</code>,<code>DelayedQueue</code>和实现<code>Delayed</code>接口的线程。<br>缺点: 开销太大;<br>优点: 少量任务时精度较高。</p>
<h1 id="方案2-超时集"><a href="#方案2-超时集" class="headerlink" title="方案2: 超时集"></a>方案2: 超时集</h1><p>将相同时间间隔的任务组织成一个集合。每个集合分配一个计时器（thread）。<br>缺点: 相同时间间隔难以满足，性能不够。</p>
<h1 id="方案3-HashedWheelTimer：-时间轮算法-Netty4工具类"><a href="#方案3-HashedWheelTimer：-时间轮算法-Netty4工具类" class="headerlink" title="方案3: HashedWheelTimer： 时间轮算法(Netty4工具类)"></a>方案3: HashedWheelTimer： 时间轮算法(Netty4工具类)</h1><p>设计一个虚拟的哈希表组织定时任务。<br>优点: 默认只用一个thread,开销小;<br>缺点:</p>
<ol>
<li>精度降低到<code>tickDuration</code>粒度;</li>
<li>定时任务不能太耗时;(解决方案: 可以在定时任务里异步处理)。</li>
</ol>
<h2 id="基本架构"><a href="#基本架构" class="headerlink" title="基本架构"></a>基本架构</h2><img src="/images/2018-10/timewheel.jpg" class="" width="400" height="600" title="timewheel">
<p>如上图所示即为时间轮。<br>引入术语:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tick: 时间轮里每一格;</span><br><span class="line">tickDuration: 每一格的时长;</span><br><span class="line">ticksPerWheel: 时间轮总共有多少格.</span><br><span class="line">newTimeout: 定时任务分配到时间轮</span><br></pre></td></tr></table></figure>

<h3 id="定时任务分配到时间轮"><a href="#定时任务分配到时间轮" class="headerlink" title="定时任务分配到时间轮"></a>定时任务分配到时间轮</h3><p>分配流程:</p>
<ol>
<li>计算定时任务deadline = <code>System.nanoTime() + unit.toNanos(delay) - startTime</code>;</li>
<li>计算定时任务放入第几格: <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> calculated = deadline / tickDuration; <span class="comment">// 需要计算几次</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">long</span> <span class="title">ticks</span><span class="params">(还需要走几格)</span> </span>= Math.max(calculated, 当前tick次数); <span class="comment">// 一般就等于calculated，这里只是为了确保不在以前走过的格子里（这样的话这个任务永远不会执行而且移除不掉了）</span></span><br><span class="line">stopIndex = (<span class="keyword">int</span>) (ticks &amp; mask); <span class="comment">// 相当于% wheel.length，因为长度是2的幂。</span></span><br></pre></td></tr></table></figure></li>
<li>计算定时任务第几轮被调用: <code>remainingRounds = (calculated - tick) / wheel.length;</code></li>
<li>放入时间轮stopIndex位置中任务链表: (remainingRounds,task)：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HashedWheelBucket bucket = wheel[stopIndex];</span><br><span class="line">bucket.addTimeout(timeout); <span class="comment">// 加入链表尾部。</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>当这个时间轮开始运行的时候（也就是开始计时，执行定时任务了），每次跳转一个tick,都会检查这个tick里的定时任务,如果定时任务轮次应当执行，则执行对应任务。</p>
<p>使用的示例代码: </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * tickDuration: 每 tick 一次的时间间隔, 每 tick 一次就会到达下一个槽位</span></span><br><span class="line"><span class="comment"> * ticksPerWheel: 轮中的 slot 数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testHashedWheelTimer</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"><span class="comment">// 1000ms一格,一轮16格（一般是2的N次幂，这样可以把hash转换为&amp;0xFFFF）</span></span><br><span class="line">    HashedWheelTimer hashedWheelTimer = <span class="keyword">new</span> HashedWheelTimer(<span class="number">1000</span>,TimeUnit.MILLISECONDS, <span class="number">16</span> );</span><br><span class="line">    System.out.println(LocalTime.now()+<span class="string">" submitted"</span>);</span><br><span class="line">    Timeout timeout = hashedWheelTimer.newTimeout((t) -&gt; &#123;</span><br><span class="line">        <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="keyword">new</span> Date() + <span class="string">" executed"</span>);</span><br><span class="line">                System.out.println(hashedWheelTimer);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">100</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="keyword">new</span> Date() + <span class="string">" FINISH"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">    &#125;, <span class="number">5</span>, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">    hashedWheelTimer.newTimeout((t) -&gt; &#123;</span><br><span class="line">        <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="keyword">new</span> Date() + <span class="string">" TASK2 executed"</span>);</span><br><span class="line">                System.out.println(hashedWheelTimer);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">10</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="keyword">new</span> Date() + <span class="string">" TASK2 FINISH"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">    &#125;, <span class="number">15</span>, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">    TimeUnit.SECONDS.sleep(<span class="number">500</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><code>HashedWheelTimer</code>源码:<br><a href="https://github.com/netty/netty/blob/4.1/common/src/main/java/io/netty/util/HashedWheelTimer.java" target="_blank" rel="noopener">https://github.com/netty/netty/blob/4.1/common/src/main/java/io/netty/util/HashedWheelTimer.java</a></p>
<p>理论基础:(操作系统内核的定时器)<br><a href="http://www.cs.columbia.edu/~nahum/w6998/papers/sosp87-timing-wheels.pdf" target="_blank" rel="noopener">http://www.cs.columbia.edu/~nahum/w6998/papers/sosp87-timing-wheels.pdf</a></p>
<h1 id="方案4：-层级时间轮-Kafka使用"><a href="#方案4：-层级时间轮-Kafka使用" class="headerlink" title="方案4： 层级时间轮(Kafka使用)"></a>方案4： 层级时间轮(Kafka使用)</h1><p>上述简单时间轮的算法存在的<strong>缺点</strong>:<br>对于延迟很长时间的任务,该方案存在较多的cpu空转。一种可能的方案是增大<code>tickduration</code>,但是很难兼顾精度和性能。</p>
<p>一种解决方案: 层级时间轮。<br>思路是模拟现实中的钟表,现实中的钟表有时针、分针、秒针,相当于不同<code>tickDuration</code>的时间轮。<br>架构图如下:</p>
<img src="/images/2018-10/timewheel2.jpg" class="" width="400" height="600" title="timewheel2">

<p>不同于<code>Netty4</code>中每个任务存放自己应到执行的轮次,层级时间轮把高轮次的定时任务分配到高层的时间轮中:层数越高=&gt;<code>tickDuration</code>越大。</p>
<p>假如定义最低层的时间轮的层号为0,高一层的为1,依次类推,只有n-1层的定时任务到期后,才会取出n层时间轮的定时任务处理（要么直接执行,要么降级,要么放回时间轮）。</p>
<p>(如果让层级时间轮每层的<code>tickDuratino</code>相同，则退化为方案3的普通时间轮。)</p>
<p>同时为了辅助推进时间轮的指针,使用<code>DelayQueue</code>存放最近到期的定时任务</p>
<h2 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h2><p>时间中每一个格中使用的数据结构为双向链表。<br>好处是只要持有其中某个节点，就可以在<code>O(1)</code>时间内进行插入或者删除操作。</p>
<h2 id="到期操作"><a href="#到期操作" class="headerlink" title="到期操作"></a>到期操作</h2><p>由<code>DelayQueue</code>辅助推进指针: </p>
<ol>
<li><code>DelayQueue</code>中优先级队列的队首最近到期的定时任务。处理结束后,由<code>leader</code>线程等待下一个定时任务的时间。因此推进步长由定时任务的间隔决定,没有cpu空转的现象。</li>
<li>推进所有时间轮的指针,对于遇到的定时任务,要么插入低层时间轮,要么删除(执行)。</li>
</ol>
<h2 id="插入操作-删除类似"><a href="#插入操作-删除类似" class="headerlink" title="插入操作(删除类似)"></a>插入操作(删除类似)</h2><p>插入新的定时任务:</p>
<ol>
<li>插入时间轮: 根据到期时间,可以算出具体应该放在哪一层时间轮的哪一格,得到对应的双向链表引用。如果这一格还是空的,需要新建一个,然后插入到<code>DelayQueue</code>中(<code>O(logN)</code>时间复杂度)。(参见<code>DelayQueue</code>原理,如果时间低于<code>DelayQueue</code>的最小延时任务,会提前唤醒里面的<code>leader</code>线程)</li>
<li>插入<code>DelayQueue</code>: 根据上一步中得到的双向链表引用,往里面插入新的定时任务（<code>O(1)</code>）。</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>层级时间轮通过不同<code>tickDuration</code>的时间轮,以较小的空间映射到一个很大的时间范围,兼顾了精度和性能。<br><strong>插入删除的时间复杂度:</strong><br>时间复杂度其实取决于有效格子的数量,因为<code>DelayQueue</code>存放的是有任务的格子,也就是双向链表的数量。低层用的是优先级队列(最小堆),假如有效格子的数量是<code>m</code>，则复杂度为<code>O(log(m))</code>。<br>实际中m一般远小于n，因此性能有很大的提高。<br><strong>理想情况</strong>:定时任务的时间间隔分布能尽量让它们位于相同格子中。 (<code>O(1)</code>)<br><strong>最坏情况</strong>:所有双向链表都只有一个任务(均匀地分布在不同格子中)。(<code>O(logN)</code>)</p>
<p>实际业务中,定时任务一般都服从对数正态分布,因此每次插入删除时间复杂度是接近<code>O(1)</code>的。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://xiaoyue26.github.io/2018/10/27/2018-10/HashedWheelTimer-%E5%A4%A7%E9%87%8F%E5%AE%9A%E6%97%B6%E5%99%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88-Netty%E4%B8%8Ekafka/" data-id="ck96cxpon00dqmaamcxajhzfw" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Netty/" rel="tag">Netty</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/" rel="tag">java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/kafka/" rel="tag">kafka</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/" rel="tag">定时任务</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-2018-10/Java并发编程的艺术-第6章3-DelayQueue" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/10/27/2018-10/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF-%E7%AC%AC6%E7%AB%A03-DelayQueue/" class="article-date">
  <time datetime="2018-10-27T04:06:10.000Z" itemprop="datePublished">2018-10-27</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/java/">java</a>►<a class="article-category-link" href="/categories/java/%E5%B9%B6%E5%8F%91/">并发</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/10/27/2018-10/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF-%E7%AC%AC6%E7%AB%A03-DelayQueue/">Java并发编程的艺术-第6章3-DelayQueue</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <p><code>DelayQueue</code>: JDK提供的延迟获取元素的无界阻塞队列。<br><strong>应用场景</strong>:</p>
<ol>
<li>缓存有效期: 能取到的时候过期.</li>
<li>定时任务: 能取到的时候执行。</li>
</ol>
<p><code>DelayQueue</code>的两个特性:<br><strong>无界</strong>: 说明底层至少使用了链表。<br><strong>阻塞</strong>: 为底层实现时，利用访问线程干活埋下伏笔(<code>leader</code>)。 </p>
<h2 id="底层实现机制"><a href="#底层实现机制" class="headerlink" title="底层实现机制"></a>底层实现机制</h2><p>底层用一个优先级队列存储<code>delay</code>元素(比如定时任务),排序依据是延迟的时长。<br>可以看出，这里用的是一个支持无界阻塞的优先级队列实现(例如<code>PriorityBlockingQueue</code>)。</p>
<p><strong>时间复杂度</strong>: <code>O(logN)</code>。由于使用的是优先级队列(最小堆),插入新元素(任务)的时间复杂度是<code>O(logN)</code>。</p>
<p><code>take</code>流程: </p>
<ol>
<li><code>lock.lockInterruptibly()</code>;</li>
<li>delay =  队首元素延时;</li>
<li>delay&lt;=0: 取出该元素;</li>
<li>delay&gt;0: 尝试设置自己线程为<code>leader</code>，然后等待delay时间。</li>
<li><code>finnally: lock.unlock()</code>;</li>
</ol>
<p>这里<code>leader</code>的职责是等待<code>delay</code>时间，以及唤醒其他等待线程。<br>注意第四步里, 由于<code>leader</code>只能有一个,所以如果尝试成为<code>leader</code>失败，就直接<code>await</code>就好,会被<code>leader</code>叫醒的。</p>
<p><code>offer</code>: offer就是简单地把元素插入堆中。如果正好是延迟最小，则此时之前的<code>leader</code>等待时间太长了，因此需要叫醒所有等待线程。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>DelayQueue</code><br><strong>优点</strong>:<br>资源开销小: 本质上只需一个线程负责等待;每次等待间隔都是delay时间,cpu空转少。<br><strong>缺点</strong><br>插入删除延时元素时间复杂度为<strong>O(logN)</strong>，对于成千上万的延时任务时间开销大,有待优化。</p>
<p>优化思路:<br>如果要比<code>O(logN)</code>更好,很自然的思路就是使用哈希表<code>O(1)</code>，空间换时间。</p>
<h2 id="优化方案"><a href="#优化方案" class="headerlink" title="优化方案"></a>优化方案</h2><p>需求: 降低插入删除延时元素的时间复杂度。<br>方案:</p>
<ol>
<li>保留优先级队列,但里面的元素改成链表引用(比如从<code>Task</code>到<code>List&lt;Task&gt;</code>);</li>
<li>引入辅助哈希表,保存的也是链表引用(<code>List&lt;Task&gt;</code>)，hash函数的输入为延时时长。</li>
</ol>
<p>这里即使<code>List&lt;Task&gt;</code>长期只有1个元素也没有关系,这里只是为了起到C++中指针的效果，方便从哈希表里直接修改(插入删除)优先级队里的数据。</p>
<p><strong><code>take</code>/<code>offer</code>流程</strong>: 与之前相似,唯一不同就是取到<code>List&lt;Task&gt;</code>后，遍历其中所有<code>Task</code>。</p>
<p><strong>插入延时元素(任务)</strong>：（删除也类似）</p>
<ol>
<li>根据延时,通过哈希函数找到哈希表中的槽位;</li>
<li>如果以前有过相同延时: 直接插入List;</li>
<li>如果以前没有相同延时: 新建List，并且插入优先级队列。</li>
</ol>
<p>可以看出这里优化的重要条件是能合并多个Task到List。<br>为了达到这个条件，可以使用进一步的优化方案: 时间轮。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://xiaoyue26.github.io/2018/10/27/2018-10/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF-%E7%AC%AC6%E7%AB%A03-DelayQueue/" data-id="ck96cxpon00dumaam35pv69ma" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/" rel="tag">java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%B9%B6%E5%8F%91/" rel="tag">并发</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-2018-10/flask多线程下，连接泄露的bug" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/10/23/2018-10/flask%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8B%EF%BC%8C%E8%BF%9E%E6%8E%A5%E6%B3%84%E9%9C%B2%E7%9A%84bug/" class="article-date">
  <time datetime="2018-10-23T08:35:52.000Z" itemprop="datePublished">2018-10-23</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/mysql/">mysql</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/10/23/2018-10/flask%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8B%EF%BC%8C%E8%BF%9E%E6%8E%A5%E6%B3%84%E9%9C%B2%E7%9A%84bug/">flask多线程下，连接泄露的bug</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <h1 id="架构图"><a href="#架构图" class="headerlink" title="架构图"></a>架构图</h1><img src="/images/2018-10/flask.png" class="" width="400" height="600" title="flask">

<p>如图所示，底层使用mysql，web服务使用<code>flask-SqlAlchemy</code>的连接池（复用连接，减少创建销毁开销），逻辑层代码使用线程池（异步IO操作，如果要异步cpu操作，可以很方便改成进程池）。</p>
<h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><ol>
<li>使用<code>db.engine.execute(sql)</code>: 从连接池获取一个连接,执行完sql后自动<code>commit</code>;(<code>commit</code>操作的回调是: 归还连接到池里); </li>
<li>使用<code>session</code>的<code>orm</code>(<code>xxxModel.query等</code>): 默认配置及推荐配置是<code>autocommit=false</code>，执行完增删查改后，处于事务未提交的状态，也就是没有归还连接。如果要归还连接，可以使用语句:<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">db.session.commit()</span><br><span class="line">db.session.rollback()</span><br><span class="line">db.session.close()</span><br><span class="line">db.session.remove(): 底层会调用db.session.close()</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>小结:</p>
<blockquote>
<p>db.engine.execute(sql) =&gt; 自动commit =&gt; 自动归还<br>session(orm) =&gt; 手动commit =&gt; 手动归还<br>因此db.engine.execute(sql)是绝对安全的;<br>orm是有条件的。接着往下看orm的安全条件。</p>
</blockquote>
<h2 id="线程与session"><a href="#线程与session" class="headerlink" title="线程与session"></a>线程与session</h2><p>使用flask的SqlAlchemy插件<code>flask-SqlAlchemy</code>时，每个线程可以直接用<code>db.session</code>获得session，即使不显式获得，使用orm的model时，其实也隐式得获得了<code>session</code>。</p>
<h3 id="线程与session的关系"><a href="#线程与session的关系" class="headerlink" title="线程与session的关系:"></a>线程与session的关系:</h3><p>每个线程有自己的<code>threadlocal</code>的<code>session</code>对象，并且随着线程销毁，会自动释放<code>session</code>,也就是会隐式调用<code>session.remove</code>，也就是会隐式释放<code>session</code>的连接。</p>
<p>多线程两种使用:</p>
<ol>
<li><code>t1=threading.Thread(...)</code>;</li>
<li>线程池: <code>future= pool.submit(...)</code>.<br>方法1的线程使用完以后自动销毁=&gt;session自动销毁=&gt;连接自动释放;<br>方法2的线程使用完以后归还线程池=&gt;session手动销毁=&gt;连接释放。</li>
</ol>
<p>小结:<br>不使用线程池=&gt;连接自动释放;<br>使用线程池=&gt;连接手动释放.<br>手动释放的方法:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.session.remove()</span><br></pre></td></tr></table></figure>

<h1 id="空闲连接超时与连接释放bug"><a href="#空闲连接超时与连接释放bug" class="headerlink" title="空闲连接超时与连接释放bug"></a>空闲连接超时与连接释放bug</h1><p>前面说到使用线程池时，连接没有自动释放，一直维护在线程的threadlocal存储中(tls)。那么这样似乎也没有什么关系，只要线程池大小&lt;连接池大小,这样连接池有空闲连接，每个线程也有自己的连接可以用，一切似乎也相安无事。</p>
<p>然而，这里有一个之前没有提到的机制：空闲连接超时回收。</p>
<h3 id="空闲连接超时回收"><a href="#空闲连接超时回收" class="headerlink" title="空闲连接超时回收"></a>空闲连接超时回收</h3><h4 id="mysql服务端"><a href="#mysql服务端" class="headerlink" title="mysql服务端:"></a>mysql服务端:</h4><p>定期检查现存连接的空闲时间，把超出<code>wait_timeout</code>的连接删除，此时客户端保存的长连接引用就失效了; 这个时间的设定:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">global</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">'wait_timeout'</span>;</span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> wait_timeout=<span class="number">10</span>*<span class="number">60</span>; <span class="comment">-- seconds</span></span><br></pre></td></tr></table></figure>

<h4 id="web服务"><a href="#web服务" class="headerlink" title="web服务:"></a>web服务:</h4><p>flask会定期检查连接池里的连接，把空闲连接删除，重新向mysql服务端申请新的连接，这样就不会访问到失效的连接引用了。其中定期的时间是: <code>app.config[&#39;SQLALCHEMY_POOL_RECYCLE&#39;] =xxx</code>(秒，应当设置为小于<code>wait_timeout</code>)。这就是为什么最好连接用完及时归还，否则可能就没法被flask刷新成新连接。</p>
<h4 id="空闲连接超时与连接释放bug-1"><a href="#空闲连接超时与连接释放bug-1" class="headerlink" title="空闲连接超时与连接释放bug"></a>空闲连接超时与连接释放bug</h4><p>bug发生的流程</p>
<ol>
<li>mysql服务端清除了空闲时间过长的连接;</li>
<li>线程池中线程一直不销毁，因此持有了活了很久的session;</li>
<li>活了很久的session持有了空闲很久的连接, 这个连接其实已经被服务端销毁了，因此已经不可用了，但是由于其一直没有归还到连接池中，因此一直没有得到更新。</li>
<li>此时web服务收到数据请求，使用该线程中的该session中的连接，就会抛异常了，因为连接已经不可用了。</li>
</ol>
<p>一般来说，空闲时间很长以后，线程池里所有线程的所有session的所有连接都会失效，因此就会完全无法通过orm访问数据库了。</p>
<p>相关异常信息:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MySQL server has gone away</span><br><span class="line">Can&#39;t reconnect until invalid transaction is rolled back</span><br></pre></td></tr></table></figure>
<p>这里之所以说<code>invalid transaction is rolled back</code>，是因为老session收到数据请求后，准备要用连接了。<br>而连接上的事务没有自动提交，也没有rollback，因此不能直接用。<br>因此尝试把连接上，上一次请求的事务提交，但由于连接已经失效，所以失败了。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://xiaoyue26.github.io/2018/10/23/2018-10/flask%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8B%EF%BC%8C%E8%BF%9E%E6%8E%A5%E6%B3%84%E9%9C%B2%E7%9A%84bug/" data-id="ck96cxpop00e4maamerbl1rgc" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/flask/" rel="tag">flask</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/mysql/" rel="tag">mysql</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/python/" rel="tag">python</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-2018-10/mysql优化实战-范围查询转点查询" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/10/22/2018-10/mysql%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98-%E8%8C%83%E5%9B%B4%E6%9F%A5%E8%AF%A2%E8%BD%AC%E7%82%B9%E6%9F%A5%E8%AF%A2/" class="article-date">
  <time datetime="2018-10-22T02:28:25.000Z" itemprop="datePublished">2018-10-22</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/mysql/">mysql</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/10/22/2018-10/mysql%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98-%E8%8C%83%E5%9B%B4%E6%9F%A5%E8%AF%A2%E8%BD%AC%E7%82%B9%E6%9F%A5%E8%AF%A2/">mysql优化实战-范围查询转点查询</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <h1 id="反直觉优化"><a href="#反直觉优化" class="headerlink" title="反直觉优化"></a>反直觉优化</h1><h2 id="慢查询"><a href="#慢查询" class="headerlink" title="慢查询:"></a>慢查询:</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> *</span><br><span class="line">    <span class="keyword">from</span> layer_data.layers_push b</span><br><span class="line">    <span class="keyword">where</span> group_key=<span class="string">'nopushtest'</span></span><br><span class="line">    <span class="keyword">AND</span> utype=<span class="string">'10w1'</span></span><br><span class="line">    <span class="keyword">AND</span> dt&gt;=<span class="number">20180620</span> <span class="keyword">AND</span> dt&lt;=<span class="number">20181020</span></span><br><span class="line">    <span class="keyword">AND</span> bucket_id=<span class="number">60</span></span><br></pre></td></tr></table></figure>
<p>上述SQL执行时间约在2.10秒,通过查看执行计划,可以发现有一个异常的指标,预估扫描的行数(<code>rows</code>)为96W，而实际结果行数应该在几十条。(查询涉及到的列合起来是联合主键)<br>此外<code>type</code>为<code>range</code>，执行的是范围扫描。<br>查询计划:(<code>explain exntended select ...</code>)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+----+-------------+-------------+-------+---------------+---------+---------+------+--------+-------------+</span><br><span class="line">| id | select_type | table       | type  | possible_keys | key     | key_len | ref  | rows   | Extra       |</span><br><span class="line">+----+-------------+-------------+-------+---------------+---------+---------+------+--------+-------------+</span><br><span class="line">|  1 | SIMPLE      | layers_push | range | PRIMARY       | PRIMARY | 216     | NULL | 989236 | Using where |</span><br><span class="line">+----+-------------+-------------+-------+---------------+---------+---------+------+--------+-------------+</span><br></pre></td></tr></table></figure>


<h2 id="快查询-（反直觉优化）"><a href="#快查询-（反直觉优化）" class="headerlink" title="快查询:（反直觉优化）"></a>快查询:（反直觉优化）</h2><p>基于上面观察到预估行数异常，一个自然的思路就是引入一个很小的辅助表来帮助优化器减少扫描的行数。辅助表的主键与原表分布相同: </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> b.*</span><br><span class="line"><span class="keyword">from</span> layer_data.layers__nopushtest a</span><br><span class="line"><span class="keyword">join</span> layer_data.layers_push b</span><br><span class="line"> <span class="keyword">ON</span> a.dt=b.dt</span><br><span class="line"><span class="keyword">AND</span> a.bucket_id=b.bucket_id</span><br><span class="line"><span class="keyword">AND</span> b.group_key=<span class="string">'nopushtest'</span></span><br><span class="line"><span class="keyword">AND</span> b.dt <span class="keyword">between</span> <span class="number">20180620</span> <span class="keyword">AND</span> <span class="number">20181020</span></span><br><span class="line"><span class="keyword">AND</span> b.utype=<span class="string">'10w1'</span></span><br><span class="line">    <span class="keyword">where</span> a.dt&gt;=<span class="number">20180620</span> <span class="keyword">and</span> a.dt&lt;=<span class="number">20181020</span></span><br><span class="line">    <span class="keyword">and</span> a.utype=<span class="string">'w1'</span></span><br><span class="line">    <span class="keyword">and</span> a.bucket_id=<span class="number">60</span></span><br></pre></td></tr></table></figure>
<p>优化后,执行时间大约在0.05秒,快了40多倍。<br>优化后的执行计划:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+----+-------------+-------+--------+---------------+---------+---------+-----------------------------------+-------+--------------------------+</span><br><span class="line">| id | select_type | table | type   | possible_keys | key     | key_len | ref                               | rows  | Extra                    |</span><br><span class="line">+----+-------------+-------+--------+---------------+---------+---------+-----------------------------------+-------+--------------------------+</span><br><span class="line">|  1 | SIMPLE      | a     | range  | PRIMARY       | PRIMARY | 38      | NULL                              | 23925 | Using where; Using index |</span><br><span class="line">|  1 | SIMPLE      | b     | eq_ref | PRIMARY       | PRIMARY | 216     | layer_data.a.dt,const,const,const |     1 | Using where              |</span><br><span class="line">+----+-------------+-------+--------+---------------+---------+---------+-----------------------------------+-------+--------------------------+</span><br></pre></td></tr></table></figure>
<p>执行流程:<br>第一步:范围扫描表a,得到连接键的所有可能取值;<br>第二步: 表b的type是eq_ref(等值连接,而且是唯一键),ref是<code>layer_data.a.dt,const,const,const</code>，预估扫描的行数变成只有1。</p>
<h1 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h1><h2 id="慢查询的执行计划"><a href="#慢查询的执行计划" class="headerlink" title="慢查询的执行计划:"></a>慢查询的执行计划:</h2><p>预估的行数有96w，执行计划是从dt为20180620的数据页顺序扫描到dt为20181020的数据页。</p>
<h3 id="范围查询的扫描行数预估："><a href="#范围查询的扫描行数预估：" class="headerlink" title="范围查询的扫描行数预估："></a>范围查询的扫描行数预估：</h3><p>这里由于使用的mysql版本是5.6(可以通过<code>select version();</code>语句查看)，预估的流程:</p>
<ol>
<li>取符合where条件的最左边的数据页及后续的8个页，再加上符合where条件的最右边的数据页,共计10个页进行采样;</li>
<li>根据上述采样结果，以及与总数据的采样比，估算出需要扫描的行数。</li>
</ol>
<h2 id="快查询的执行计划"><a href="#快查询的执行计划" class="headerlink" title="快查询的执行计划:"></a>快查询的执行计划:</h2><p>因为有辅助的小表帮忙，扫描的行数减少。执行计划是先范围扫描小表，得到所有连接键的取值后，用表b的索引挨个儿进行点查询（<code>type</code>是<code>eq_ref</code>，而不是<code>range</code>）,扫描的数据页大大减少。</p>
<p><code>range</code>类型查询:</p>
<blockquote>
<p>以下操作符会导致查询计划为range:<br>=, &lt;&gt;, &gt;, &gt;=, &lt;, &lt;=, IS NULL, &lt;=&gt;, BETWEEN, IN (…)</p>
</blockquote>
<h1 id="符合直觉的优化"><a href="#符合直觉的优化" class="headerlink" title="符合直觉的优化"></a>符合直觉的优化</h1><p>由于mysql对in有特殊的优化: 把范围查询转换为多次点查询。<br>此时虽然查询计划是<code>range</code>，但实际执行时候不会进行范围扫描，而会进行点查询。<br>因此也可以把查询改写成:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span>   *</span><br><span class="line">    <span class="keyword">from</span> layer_data.layers_push b</span><br><span class="line">    <span class="keyword">where</span> group_key=<span class="string">'nopushtest'</span></span><br><span class="line">    <span class="keyword">AND</span> utype=<span class="string">'10w1'</span></span><br><span class="line">    <span class="keyword">AND</span> dt  <span class="keyword">in</span>  (<span class="number">20180805</span>,<span class="number">20180806</span>,<span class="number">20180807</span>,<span class="number">20180808</span>,<span class="number">20180809</span>,<span class="number">20180810</span>,<span class="number">20180811</span>,<span class="number">20180812</span>,<span class="number">20180813</span>,<span class="number">20180814</span>,<span class="number">20180815</span>,<span class="number">20180816</span>,<span class="number">20180817</span>,<span class="number">20180818</span>,<span class="number">20180819</span>,<span class="number">20180820</span>,<span class="number">20180821</span>,<span class="number">20180822</span>,<span class="number">20180823</span>,<span class="number">20180824</span>,<span class="number">20180825</span>,<span class="number">20180826</span>,<span class="number">20180827</span>,<span class="number">20180828</span>,<span class="number">20180829</span>,<span class="number">20180830</span>,<span class="number">20180831</span></span><br><span class="line">,<span class="number">20180901</span>,<span class="number">20180902</span>,<span class="number">20180903</span>,<span class="number">20180904</span>,<span class="number">20180905</span>,<span class="number">20180906</span>,<span class="number">20180907</span>,<span class="number">20180908</span>,<span class="number">20180909</span>,<span class="number">20180910</span>,<span class="number">20180911</span>,<span class="number">20180912</span>,<span class="number">20180913</span>,<span class="number">20180914</span>,<span class="number">20180915</span>,<span class="number">20180916</span>,<span class="number">20180917</span>,<span class="number">20180918</span>,<span class="number">20180919</span>,<span class="number">20180920</span>,<span class="number">20180921</span>,<span class="number">20180922</span>,<span class="number">20180923</span>,<span class="number">20180924</span>,<span class="number">20180925</span>,<span class="number">20180926</span>,<span class="number">20180927</span>,<span class="number">20180928</span>,<span class="number">20180929</span>,<span class="number">20180930</span></span><br><span class="line">,<span class="number">20181001</span>,<span class="number">20181002</span>,<span class="number">20181003</span>,<span class="number">20181004</span>,<span class="number">20181005</span>,<span class="number">20181006</span>,<span class="number">20181007</span>,<span class="number">20181008</span>,<span class="number">20181009</span>,<span class="number">20181010</span>,<span class="number">20181011</span>,<span class="number">20181012</span>,<span class="number">20181013</span>,<span class="number">20181014</span>,<span class="number">20181015</span>,<span class="number">20181016</span>,<span class="number">20181017</span>,<span class="number">20181018</span>,<span class="number">20181019</span>,<span class="number">20181020</span>,<span class="number">20181021</span>,<span class="number">20181022</span>,<span class="number">20181023</span>,<span class="number">20181024</span>,<span class="number">20181025</span>,<span class="number">20181026</span>,<span class="number">20181027</span>)</span><br><span class="line">    <span class="keyword">AND</span> bucket_id=<span class="number">60</span></span><br></pre></td></tr></table></figure>
<p>优点:<br>直观,速度最快。<br>缺点:<br>啰嗦，改写起来比较麻烦，只适用于能使用代码预处理sql的地方，而且有最大长度限制。</p>
<h3 id="in查询的扫描行数预估"><a href="#in查询的扫描行数预估" class="headerlink" title="in查询的扫描行数预估"></a>in查询的扫描行数预估</h3><p>有两种方式:</p>
<ol>
<li>精确计算(<code>index_dive</code>): 直接查询对应的行;</li>
<li>采样预估(<code>index statistics</code>): 采样10个数据页,通过索引的选择性统计数据，预估总行数。</li>
</ol>
<p>具体采取哪种方式，由<code>eq_range_index_dive_limit</code>参数控制(默认是10)。<br>小于<code>eq_range_index_dive_limit</code>的时候，采用方法1，精确计算；<br>大于等于<code>eq_range_index_dive_limit</code>的时候，采用方法2, 采样预估。</p>
<h1 id="执行计划耗时"><a href="#执行计划耗时" class="headerlink" title="执行计划耗时"></a>执行计划耗时</h1><p>可以通过命令查看某个查询的具体耗时及具体发生了哪些操作:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> profiling=<span class="number">1</span>;</span><br><span class="line"><span class="comment">-- select * from xxx ;</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">profiles</span>;</span><br><span class="line"><span class="keyword">show</span> profile <span class="keyword">for</span> <span class="keyword">query</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">show</span> profile <span class="keyword">all</span> <span class="keyword">for</span> <span class="keyword">query</span> <span class="number">1</span>; <span class="comment">-- cpu,io等详细信息</span></span><br></pre></td></tr></table></figure>
<p>这里可以看到之前的慢查询发生了51w个block io input。</p>
<h1 id="优化器查询计划选择"><a href="#优化器查询计划选择" class="headerlink" title="优化器查询计划选择"></a>优化器查询计划选择</h1><p>可以通过命令查看某个查询生成执行计划时，考虑过哪些方案，以及对于where条件的等价变换，最终选择了哪个方案(<code>chosen:true</code>)。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> optimizer_trace=<span class="string">"enabled=on"</span>;</span><br><span class="line"><span class="keyword">SET</span> optimizer_trace_max_mem_size=<span class="number">1000000</span>;</span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> xxx</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> information_schema.OPTIMIZER_TRACE\G</span><br></pre></td></tr></table></figure>
<p>可以看到对于之前慢查询的查询条件只用到了dt条件，其他where条件是在服务器层进行过滤的。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://xiaoyue26.github.io/2018/10/22/2018-10/mysql%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98-%E8%8C%83%E5%9B%B4%E6%9F%A5%E8%AF%A2%E8%BD%AC%E7%82%B9%E6%9F%A5%E8%AF%A2/" data-id="ck96cxpoq00e7maam5h9zcfq9" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/mysql/" rel="tag">mysql</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-2018-10/Netty-in-action第14-15章案例研究-笔记" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/10/14/2018-10/Netty-in-action%E7%AC%AC14-15%E7%AB%A0%E6%A1%88%E4%BE%8B%E7%A0%94%E7%A9%B6-%E7%AC%94%E8%AE%B0/" class="article-date">
  <time datetime="2018-10-14T04:00:00.000Z" itemprop="datePublished">2018-10-14</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/java/">java</a>►<a class="article-category-link" href="/categories/java/Netty/">Netty</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/10/14/2018-10/Netty-in-action%E7%AC%AC14-15%E7%AB%A0%E6%A1%88%E4%BE%8B%E7%A0%94%E7%A9%B6-%E7%AC%94%E8%AE%B0/">Netty-in-action第14-15章案例研究-笔记</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <h1 id="文件上传案例-Droplr"><a href="#文件上传案例-Droplr" class="headerlink" title="文件上传案例: Droplr"></a>文件上传案例: Droplr</h1><h2 id="需求"><a href="#需求" class="headerlink" title="需求:"></a>需求:</h2><p>上传文件到S3,返回一个下载url。</p>
<p>数据流: 客户端=&gt;服务端=&gt;S3</p>
<h2 id="原始方案"><a href="#原始方案" class="headerlink" title="原始方案:"></a>原始方案:</h2><ol>
<li>服务器接受上传,存成文件;</li>
<li>服务器上传到S3;</li>
<li>服务器回复url给客户端。</li>
</ol>
<p>缺点: </p>
<ol>
<li>每个上传开销大占用大量内存,导致并发低;</li>
<li>上传完整个文件才开始上传S3,而瓶颈恰恰在于S3。</li>
<li>有磁盘IO。</li>
</ol>
<h2 id="改进方案"><a href="#改进方案" class="headerlink" title="改进方案"></a>改进方案</h2><p>流式上传,只在内存,不过磁盘。</p>
<ol>
<li>服务器接受上传，每块数据实时传输到S3;</li>
<li>接受和上传做速度适配，保持低内存消耗，高并发；</li>
<li>最后返回url给客户端。</li>
</ol>
<p>并发达到10K。</p>
<h3 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h3><ol>
<li><code>IdelStateHandler</code>关闭不活跃的连接,回滚历史进度(速度控制失败时);</li>
<li>并发达到上限时,返回503;</li>
<li>需要保证<code>HttpChunk</code>的顺序(线程池)。<br>(注: 503: 服务不可用（服务器资源耗尽，拒绝服务）)</li>
</ol>
<p>http-client库:<br><a href="https://github.com/akka/akka-http" target="_blank" rel="noopener">https://github.com/akka/akka-http</a><br><a href="https://github.com/AsyncHttpClient/async-http-client" target="_blank" rel="noopener">https://github.com/AsyncHttpClient/async-http-client</a></p>
<h1 id="实时数据同步：FireBase（被谷歌收购）"><a href="#实时数据同步：FireBase（被谷歌收购）" class="headerlink" title="实时数据同步：FireBase（被谷歌收购）"></a>实时数据同步：FireBase（被谷歌收购）</h1><h2 id="需求1"><a href="#需求1" class="headerlink" title="需求1:"></a>需求1:</h2><p>在各个用户和设备之间实时同步数据。<br>(服务器同步到各个客户端)</p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>长轮询+WebSocket.<br>先使用长轮询连接，当WebSocket可用时切换到WebSocket。</p>
<p>难点在于长轮询。</p>
<h2 id="具体细节"><a href="#具体细节" class="headerlink" title="具体细节"></a>具体细节</h2><p>轮询 : 客户端每隔N秒轮询一次;实时性不强,开销大（空转）;<br>长轮询 : 客户端询问一次服务器,然后等待服务器响应,收到响应以后才继续轮询。<br>在服务端没有回复客户端的期间,如果客户端此时想发送数据给服务端,它会先阻塞。<br><code>此时，客户端手头的数据会堆积在缓冲区。</code><br>换言之，限制是: <code>未完成请求数&lt;=1</code>。(同一个客户端)</p>
<h3 id="长轮询"><a href="#长轮询" class="headerlink" title="长轮询"></a>长轮询</h3><p>优点: 没有新数据时,服务器可以不回应客户端,这样客户端就不会接着轮询,减少空转;<br>缺点: 客户端发送数据可能被阻塞。 </p>
<h4 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h4><p>客户端: 限制改成<code>未完成请求数&lt;=2</code>。(从1上调到2)<br>服务端: 如果当前有1个未完成请求<code>A</code>，此时又收到了同一个客户端的第二个请求<code>B</code>(一般第二个是发送数据的请求),会先对<code>A</code>进行空响应,然后处理请求<code>B</code>。</p>
<p>引入新问题: <strong>消息的有序性;</strong><br>解决方案: 元数据加入消息序列号。</p>
<p>引入新问题: <strong>连接断开检测</strong><br>解决方案:<br>客户端: 超时重试(以区分于慢速网络)。<br>服务端: 超时判断为连接断开。</p>
<p>要点: Netty支持一个端口多个协议(HTTP,Websocket,长轮询,TCP)</p>
<h2 id="需求2"><a href="#需求2" class="headerlink" title="需求2:"></a>需求2:</h2><p>加密环境(<code>SSLHandler</code>)下，基于带宽计费。</p>
<h3 id="方案"><a href="#方案" class="headerlink" title="方案:"></a>方案:</h3><ol>
<li>解密前统计字节数;</li>
<li>解密后得到账户名,计入该账户的账单。</li>
</ol>
<p>要点: 统计字节数提前到解密前，提高性能。</p>
<h1 id="app推送通知-Urban-Airship案例"><a href="#app推送通知-Urban-Airship案例" class="headerlink" title="app推送通知: Urban Airship案例"></a>app推送通知: Urban Airship案例</h1><h2 id="需求-1"><a href="#需求-1" class="headerlink" title="需求"></a>需求</h2><p>实时推送通知</p>
<h2 id="方案-1"><a href="#方案-1" class="headerlink" title="方案"></a>方案</h2><ol>
<li>app维护一条到后端服务的连接;</li>
<li>借助第三方推送服务中转,服务器把消息传输给第三方平台，然后转交给app。</li>
</ol>
<p>其中苹果的APNS推送服务的使用流程:</p>
<ol>
<li>生产者: 通过TCP+SSLv3连接到APNS服务器,使用X.509证书进行身份认证;</li>
<li>生产者: 按APNS规定的格式，发送消息(二进制);</li>
<li>生产者: 读取(消息id,错误码)或成功。(因为有消息id,这里可以异步)</li>
</ol>
<p>其中消息格式是大端字节序，可以如下显式指定:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ByteBuf buf = Unpooled.buffer(size).order(ByteOrder.BIG_ENDIAN);</span><br></pre></td></tr></table></figure>

<p>初始化,设置允许重新协商密钥:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> ChannelPipeline pipeline = channel.pipeline();</span><br><span class="line"> <span class="keyword">final</span> SslHandler handler = <span class="keyword">new</span> SslHandler(clientEngine);</span><br><span class="line"> handler.setEnableRenegotiation(<span class="keyword">true</span>);<span class="comment">// 重新协商</span></span><br><span class="line"> pipeline.addLast(<span class="string">"ssl"</span>, handler);</span><br><span class="line"> pipeline.addLast(<span class="string">"decoder"</span>, <span class="keyword">new</span> ApnsResponseDecoder());</span><br></pre></td></tr></table></figure>

<h2 id="需要注意的经验"><a href="#需要注意的经验" class="headerlink" title="需要注意的经验"></a>需要注意的经验</h2><ol>
<li>运营商可能不允许TCP的keep-alive特性,会积极剔除空闲的TCP会话;</li>
<li>移动运营商可能禁止UDP.</li>
</ol>
<h1 id="第15章-案例研究，第二部分"><a href="#第15章-案例研究，第二部分" class="headerlink" title="第15章 案例研究，第二部分"></a>第15章 案例研究，第二部分</h1><h1 id="服务通信案例-Nifty和Swift-Facebook"><a href="#服务通信案例-Nifty和Swift-Facebook" class="headerlink" title="服务通信案例: Nifty和Swift(Facebook)"></a>服务通信案例: Nifty和Swift(Facebook)</h1><p><code>Thrift</code>: facebook开发的跨语言rpc远程调用、服务通信的框架。<br>组件:</p>
<ol>
<li>IDL: 定义通信的格式;</li>
<li>协议；</li>
<li>传输接口;</li>
<li>编译器: 从IDL生成服务端和客户端的存根代码(不同语言);</li>
<li>客户端和服务端实现。</li>
</ol>
<h2 id="场景"><a href="#场景" class="headerlink" title="场景:"></a>场景:</h2><p>由于<code>Thrift</code>是跨语言的远程调用。<br>其中C++版本基于<code>libevent</code>\ <code>Folly</code>开发，性能很高;<br>Java版本(<code>Nifty</code>)基于<code>Netty</code>开发，性能与C++版本不相上下。</p>
<p><strong>Nifty</strong>：</p>
<blockquote>
<p>基于<code>Netty</code>的<code>Thrift</code>java实现。</p>
</blockquote>
<h3 id="需求1：-按顺序响应"><a href="#需求1：-按顺序响应" class="headerlink" title="需求1： 按顺序响应"></a>需求1： 按顺序响应</h3><p>客户端可能会要求:<br>服务器端并行处理请求，但是返回响应必须是顺序的。</p>
<p>解决方案: 服务器端并行处理请求, 返回前排序响应。(缓冲处理好的请求结果)<br>开销: 缓冲响应的内存。（所以如果客户端不要求顺序响应，可以免除这部分开销）</p>
<p>Netty4的实现支持: <code>EventExecutor</code><br>Netty3的实现支持: <code>OrderedMemoryAwareThreadPoolExcecutor</code></p>
<p><strong>Swift</strong></p>
<blockquote>
<p>用注解来定义模型，无效IDL文件和存根。<br>底层使用Nifty作为I/O引擎。<br><a href="https://github.com/facebookarchive/swift" target="_blank" rel="noopener">https://github.com/facebookarchive/swift</a><br>已经不再维护。<br>还在维护的类似开源项目是:<br><a href="https://github.com/airlift/drift" target="_blank" rel="noopener">https://github.com/airlift/drift</a></p>
</blockquote>
<h2 id="超时处理"><a href="#超时处理" class="headerlink" title="超时处理"></a>超时处理</h2><p>问题: 每个请求维护一个超时事件的话，代价很昂贵。</p>
<p>方案1: 超时集。<br>每个客户端维护一个计时器，或者每组相同超时间隔的请求，维护一个计时器。<br>每次超时结束以后，进行下一个超时计时器。<br>优点: 开销小;<br>缺点: 要求超时间隔长度一致。</p>
<p>方案2: 使用<code>Netty</code>的<code>HashedWheelTimer</code>工具类。（空间换时间）<br>算法来自:<br><a href="http://www.cs.columbia.edu/~nahum/w6998/papers/sosp87-timing-wheels.pdf" target="_blank" rel="noopener">http://www.cs.columbia.edu/~nahum/w6998/papers/sosp87-timing-wheels.pdf</a><br>示例代码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">HashedWheelTimer timer = <span class="keyword">new</span> HashedWheelTimer(<span class="number">100</span>, TimeUnit.MILLISECONDS, <span class="number">16</span>);</span><br><span class="line">System.out.println(LocalTime.now());</span><br><span class="line">timer.newTimeout((timeout) -&gt; &#123;</span><br><span class="line">    System.out.println(LocalTime.now());</span><br><span class="line">    System.out.println(timeout);</span><br><span class="line">&#125;, <span class="number">5</span>, TimeUnit.SECONDS);</span><br><span class="line"><span class="comment">//阻塞main线程</span></span><br><span class="line">System.in.read();</span><br></pre></td></tr></table></figure>


<h1 id="RPC框架案例-Finagle-Twitter"><a href="#RPC框架案例-Finagle-Twitter" class="headerlink" title="RPC框架案例: Finagle(Twitter)"></a>RPC框架案例: Finagle(Twitter)</h1><p>前端api端点&lt;=&gt;<code>Finagle</code>&lt;=&gt;后端服务们(提供:用户信息、twitter、时间线)<br>(大部分是scala开发。原先是ruby on rails)</p>
<img src="/images/2018-10/15.6.png" class="" width="400" height="600" title="Finagle">
<p>主要功能包括: SSL、打日志(统计)、负载均衡</p>
<h3 id="负载均衡（故障管理）"><a href="#负载均衡（故障管理）" class="headerlink" title="负载均衡（故障管理）"></a>负载均衡（故障管理）</h3><p>客户端统计所有服务器的延迟、未完成请求数（负载），<br>每次选择最低负载的主机派发请求。</p>
<p>失败请求=&gt;从列表中移除对应服务器=&gt;后台不断尝试重连。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://xiaoyue26.github.io/2018/10/14/2018-10/Netty-in-action%E7%AC%AC14-15%E7%AB%A0%E6%A1%88%E4%BE%8B%E7%A0%94%E7%A9%B6-%E7%AC%94%E8%AE%B0/" data-id="ck96cxpoo00dxmaamfjyfcdyu" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Netty/" rel="tag">Netty</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/" rel="tag">java</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-2018-10/Netty-in-action-第十一章-SSL等预置实现-笔记" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/10/10/2018-10/Netty-in-action-%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0-SSL%E7%AD%89%E9%A2%84%E7%BD%AE%E5%AE%9E%E7%8E%B0-%E7%AC%94%E8%AE%B0/" class="article-date">
  <time datetime="2018-10-10T10:38:46.000Z" itemprop="datePublished">2018-10-10</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/java/">java</a>►<a class="article-category-link" href="/categories/java/Netty/">Netty</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/10/10/2018-10/Netty-in-action-%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0-SSL%E7%AD%89%E9%A2%84%E7%BD%AE%E5%AE%9E%E7%8E%B0-%E7%AC%94%E8%AE%B0/">Netty-in-action-第十一章-SSL等预置实现-笔记</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <p>这章主要讲内容:</p>
<ol>
<li>SSL/TLS;</li>
<li>HTTP/HTTPS;</li>
<li>空闲的连接和超时;</li>
<li>基于分隔符和长度的协议（处理粘包，半包）;</li>
<li>写大型数据。</li>
<li>序列化</li>
</ol>
<h1 id="SSL-TLS"><a href="#SSL-TLS" class="headerlink" title="SSL/TLS"></a>SSL/TLS</h1><p>安全协议：<code>SSL</code>/<code>TLS</code><br>用例： <code>HTTPS</code>, <code>SMTPS</code><br>实现： jdk实现(<code>javax.net.ssl</code>), <code>openssl</code>(性能更好)<br>Netty中的支持:<br><code>SslHandler</code></p>
<img src="/images/2018-10/11.1.png" class="" width="400" height="600" title="sslhandler">
<p><code>SslHandler</code>的声明:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-- SslHandler:</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SslHandler</span> <span class="keyword">extends</span> <span class="title">ByteToMessageDecoder</span> <span class="keyword">implements</span> <span class="title">ChannelOutboundHandler</span> </span></span><br><span class="line">-- 其中的ByteToMessageDecoder:</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ByteToMessageDecoder</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span></span></span><br></pre></td></tr></table></figure>
<p>由声明看出，它是一个编解码器（入站事件和出站事件都处理）。<br>入站: 字节=&gt;消息（解密）<br>出站: 消息=&gt;字节（加密）<br>具体使用则和以前的编解码器都不同：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SslChannelInitializer</span> <span class="keyword">extends</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">Channel</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SslContext context;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> startTls;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SslChannelInitializer</span><span class="params">(SslContext context,<span class="keyword">boolean</span> startTls)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.context = context;</span><br><span class="line">        <span class="keyword">this</span>.startTls = startTls;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(Channel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        SSLEngine engine = context.newEngine(ch.alloc());</span><br><span class="line">        ch.pipeline().addFirst(<span class="string">"ssl"</span></span><br><span class="line">            , <span class="keyword">new</span> SslHandler(engine, startTls));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结:<br>需要借用: SslContext</p>
<p>两个要注意的点:</p>
<ol>
<li>对于每个 <code>SslHandler</code> 实例，都使用 <code>Channel</code> 的 <code>ByteBufAllocator</code> 从 <code>SslContext</code> 获取一个新的 <code>SSLEngine</code>(<code>ch.alloc()</code>);</li>
<li><code>startTls</code>: 如果设置为 true，第一个写入的消息将不会被加密;（客户端应该设置为 true）</li>
<li><a href="https://github.com/devsunny/netty-ssl-example/blob/master/src/main/java/com/asksunny/ssl/StreamReader.java" target="_blank" rel="noopener">https://github.com/devsunny/netty-ssl-example/blob/master/src/main/java/com/asksunny/ssl/StreamReader.java</a></li>
</ol>
<h1 id="HTTP相关的handler"><a href="#HTTP相关的handler" class="headerlink" title="HTTP相关的handler"></a>HTTP相关的handler</h1><p>4个解码器、编码器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpPipelineInitializer</span> <span class="keyword">extends</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">Channel</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> client;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HttpPipelineInitializer</span><span class="params">(<span class="keyword">boolean</span> client)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.client = client;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(Channel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">        <span class="keyword">if</span> (client) &#123;</span><br><span class="line">            pipeline.addLast(<span class="string">"decoder"</span>, <span class="keyword">new</span> HttpResponseDecoder());  <span class="comment">//1</span></span><br><span class="line">            pipeline.addLast(<span class="string">"encoder"</span>, <span class="keyword">new</span> HttpRequestEncoder());  <span class="comment">//2</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            pipeline.addLast(<span class="string">"decoder"</span>, <span class="keyword">new</span> HttpRequestDecoder());  <span class="comment">//3</span></span><br><span class="line">            pipeline.addLast(<span class="string">"encoder"</span>, <span class="keyword">new</span> HttpResponseEncoder());  <span class="comment">//4</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="消息聚合"><a href="#消息聚合" class="headerlink" title="消息聚合:"></a>消息聚合:</h2><p>这回是编解码器<code>Codec</code>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpAggregatorInitializer</span> <span class="keyword">extends</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">Channel</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> client;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HttpAggregatorInitializer</span><span class="params">(<span class="keyword">boolean</span> client)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.client = client;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(Channel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">        <span class="keyword">if</span> (client) &#123;</span><br><span class="line">            pipeline.addLast(<span class="string">"codec"</span>, <span class="keyword">new</span> HttpClientCodec());  <span class="comment">//1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            pipeline.addLast(<span class="string">"codec"</span>, <span class="keyword">new</span> HttpServerCodec());  <span class="comment">//2</span></span><br><span class="line">        &#125;</span><br><span class="line">        pipeline.addLast(<span class="string">"aggegator"</span>, <span class="keyword">new</span> HttpObjectAggregator(<span class="number">512</span> * <span class="number">1024</span>));  <span class="comment">//3 512kb</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="HTTP-压缩"><a href="#HTTP-压缩" class="headerlink" title="HTTP 压缩"></a>HTTP 压缩</h2><p>客户端加解压器，服务端加压缩器:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpAggregatorInitializer</span> <span class="keyword">extends</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">Channel</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> isClient;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HttpAggregatorInitializer</span><span class="params">(<span class="keyword">boolean</span> isClient)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.isClient = isClient;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(Channel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">        <span class="keyword">if</span> (isClient) &#123;</span><br><span class="line">            pipeline.addLast(<span class="string">"codec"</span>, <span class="keyword">new</span> HttpClientCodec()); <span class="comment">//1</span></span><br><span class="line">            pipeline.addLast(<span class="string">"decompressor"</span>,<span class="keyword">new</span> HttpContentDecompressor()); <span class="comment">//2</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            pipeline.addLast(<span class="string">"codec"</span>, <span class="keyword">new</span> HttpServerCodec()); <span class="comment">//3</span></span><br><span class="line">            pipeline.addLast(<span class="string">"compressor"</span>,<span class="keyword">new</span> HttpContentCompressor()); <span class="comment">//4</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h2><p><code>http</code>部分加上<code>sslHandler</code>就是<code>https</code>。不过本质上还是需要<code>SslContext</code>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpsCodecInitializer</span> <span class="keyword">extends</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">Channel</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SslContext context;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> client;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HttpsCodecInitializer</span><span class="params">(SslContext context, <span class="keyword">boolean</span> client)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.context = context;</span><br><span class="line">        <span class="keyword">this</span>.client = client;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(Channel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">        SSLEngine engine = context.newEngine(ch.alloc());</span><br><span class="line">        pipeline.addFirst(<span class="string">"ssl"</span>, <span class="keyword">new</span> SslHandler(engine));  <span class="comment">//1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (client) &#123;</span><br><span class="line">            pipeline.addLast(<span class="string">"codec"</span>, <span class="keyword">new</span> HttpClientCodec());  <span class="comment">//2</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            pipeline.addLast(<span class="string">"codec"</span>, <span class="keyword">new</span> HttpServerCodec());  <span class="comment">//3</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h1><p><code>http</code>仅让客户端向服务端请求数据，服务端无法主动推数据给客户端。一种解决方案是让客户端轮询，另一种解决方案是<code>WebSocket</code>。<br>用<code>WebSocket</code>的话，底层是tcp双向连接，服务端可以主动发消息给客户端。</p>
<h2 id="WebSocket帧类型"><a href="#WebSocket帧类型" class="headerlink" title="WebSocket帧类型"></a>WebSocket帧类型</h2><p>三种数据帧:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BinaryWebSocketFrame: 二进制;</span><br><span class="line">TextWebSocketFrame: 文本;</span><br><span class="line">ContunuationWebSocketFrame: 后续数据;</span><br></pre></td></tr></table></figure>
<p>三种控制帧:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PingWebSocketFrame: ping，对方会回pong;</span><br><span class="line">PongWebSocketFrame: pong;</span><br><span class="line">CloseWebSocketFrame: 关闭。</span><br></pre></td></tr></table></figure>

<p>服务端示例:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebSocketServerInitializer</span> <span class="keyword">extends</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">Channel</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(Channel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ch.pipeline().addLast(</span><br><span class="line">            <span class="keyword">new</span> HttpServerCodec(),</span><br><span class="line">            <span class="comment">//为握手提供聚合的 HttpRequest</span></span><br><span class="line">            <span class="keyword">new</span> HttpObjectAggregator(<span class="number">65536</span>),</span><br><span class="line">            <span class="comment">//如果被请求的端点是"/websocket"，则处理该升级握手</span></span><br><span class="line">            <span class="keyword">new</span> WebSocketServerProtocolHandler(<span class="string">"/websocket"</span>),</span><br><span class="line">            <span class="comment">//TextFrameHandler 处理 TextWebSocketFrame</span></span><br><span class="line">            <span class="keyword">new</span> TextFrameHandler(),</span><br><span class="line">            <span class="comment">//BinaryFrameHandler 处理 BinaryWebSocketFrame</span></span><br><span class="line">            <span class="keyword">new</span> BinaryFrameHandler(),</span><br><span class="line">            <span class="comment">//ContinuationFrameHandler 处理 ContinuationWebSocketFrame</span></span><br><span class="line">            <span class="keyword">new</span> ContinuationFrameHandler());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TextFrameHandler</span> <span class="keyword">extends</span></span></span><br><span class="line"><span class="class">        <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">TextWebSocketFrame</span>&gt; </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx,</span></span></span><br><span class="line"><span class="function"><span class="params">            TextWebSocketFrame msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="comment">// Handle text frame</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">BinaryFrameHandler</span> <span class="keyword">extends</span></span></span><br><span class="line"><span class="class">        <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">BinaryWebSocketFrame</span>&gt; </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx,</span></span></span><br><span class="line"><span class="function"><span class="params">            BinaryWebSocketFrame msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="comment">// Handle binary frame</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ContinuationFrameHandler</span> <span class="keyword">extends</span></span></span><br><span class="line"><span class="class">        <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">ContinuationWebSocketFrame</span>&gt; </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx,</span></span></span><br><span class="line"><span class="function"><span class="params">            ContinuationWebSocketFrame msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="comment">// Handle continuation frame</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="空闲事件、超时事件"><a href="#空闲事件、超时事件" class="headerlink" title="空闲事件、超时事件"></a>空闲事件、超时事件</h1><p><code>WebSocket</code>协议中多了几种事件: </p>
<table>
<thead>
<tr>
<th align="center">触发时机</th>
<th align="left">事件</th>
<th align="center">处理方法</th>
<th align="center">预置handler</th>
</tr>
</thead>
<tbody><tr>
<td align="center">空闲时间超过配置</td>
<td align="left">IdleStateEvent</td>
<td align="center">userEventTriggered()</td>
<td align="center">IdleStateHandler</td>
</tr>
<tr>
<td align="center">指定时间间隔内没有收到入站数据</td>
<td align="left">ReadTimeoutException</td>
<td align="center">exceptionCaught()</td>
<td align="center">ReadTimeoutHandler</td>
</tr>
<tr>
<td align="center">指定时间间隔内没有出站数据</td>
<td align="left">WriteTimeoutException</td>
<td align="center">exceptionCaught()</td>
<td align="center">WriteTimeoutHandler</td>
</tr>
</tbody></table>
<p>具体使用方法:</p>
<ol>
<li>注册预置的handler,截获对应的事件;(<code>IdleStateHandler</code>,<code>ReadTimeoutHandler</code>,<code>WriteTimeoutHandler</code>)</li>
<li>实现一个自定义handler注册到pipeline,处理对应的事件。 </li>
</ol>
<p>空闲事件示例:</p>
<ol>
<li>注册<code>IdleStateHandler</code>，负责截获空闲事件，它会调用<code>fireUserEventTriggered</code>方法,触发<code>userEvent</code>事件;</li>
<li>实现自定义<code>handler</code>,处理<code>userEvent</code>:一种可能的处理逻辑是进行心跳检测，检测到是空闲事件就发送心跳,发送失败就关闭连接; 如果不是空闲事件,则抛出去,让下一级处理。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IdleStateHandlerInitializer</span> <span class="keyword">extends</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">Channel</span>&gt;</span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(Channel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">        pipeline.addLast(</span><br><span class="line"><span class="comment">//(1)IdleStateHandler 将在被触发时发送一个IdleStateEvent事件:</span></span><br><span class="line">                <span class="keyword">new</span> IdleStateHandler(<span class="number">0</span>, <span class="number">0</span>, <span class="number">60</span>, TimeUnit.SECONDS));</span><br><span class="line"><span class="comment">//(2)将一个HeartbeatHandler添加到ChannelPipeline中:</span></span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> HeartbeatHandler());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//(3)实现userEventTriggered()方法以发送心跳消息:</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HeartbeatHandler</span></span></span><br><span class="line"><span class="class">        <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line">        <span class="comment">//发送到远程节点的心跳消息</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ByteBuf HEARTBEAT_SEQUENCE =</span><br><span class="line">                Unpooled.unreleasableBuffer(Unpooled.copiedBuffer(</span><br><span class="line">                <span class="string">"HEARTBEAT"</span>, CharsetUtil.ISO_8859_1));</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">userEventTriggered</span><span class="params">(ChannelHandlerContext ctx,</span></span></span><br><span class="line"><span class="function"><span class="params">            Object evt)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="comment">//(4)发送心跳消息，并在发送失败时关闭该连接</span></span><br><span class="line">            <span class="keyword">if</span> (evt <span class="keyword">instanceof</span> IdleStateEvent) &#123;</span><br><span class="line">                ctx.writeAndFlush(HEARTBEAT_SEQUENCE.duplicate())</span><br><span class="line">                     .addListener(</span><br><span class="line">                         ChannelFutureListener.CLOSE_ON_FAILURE);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//若不是IdleStateEvent事件，所以将它传递给下一个ChannelInboundHandler</span></span><br><span class="line">                <span class="keyword">super</span>.userEventTriggered(ctx, evt);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h1 id="工具：解决粘包和半包-数据帧的划分问题"><a href="#工具：解决粘包和半包-数据帧的划分问题" class="headerlink" title="工具：解决粘包和半包(数据帧的划分问题)"></a>工具：解决粘包和半包(数据帧的划分问题)</h1><p><code>netty</code>主要是字节流层传输，并不关心应用层对数据的划分（并不关心帧是如何划分的）。<br>但是<code>netty</code>提供了很多帮助分隔帧的工具类，来解决粘包和半包的问题。<br>数据帧的划分问题一般有三种解决方案:</p>
<ol>
<li>定长帧;</li>
<li>指定分隔符;</li>
<li>head-body结构，header中规定body长度。(<code>HTTP</code>)比较灵活，比较常见。</li>
</ol>
<h2 id="指定分隔符"><a href="#指定分隔符" class="headerlink" title="指定分隔符"></a>指定分隔符</h2><p>相关工具类: <code>DelimitedBasedFrameDecoder</code>,<code>LineBasedFrameDecoder</code></p>
<h2 id="定长帧"><a href="#定长帧" class="headerlink" title="定长帧"></a>定长帧</h2><p>相关工具类: <code>FixedLengthFrameDecoder</code></p>
<h2 id="head-body结构"><a href="#head-body结构" class="headerlink" title="head-body结构"></a>head-body结构</h2><p>相关工具类: <code>LengthFieldBasedFrameDecoder</code></p>
<h1 id="高级特性-写大文件-或大数据"><a href="#高级特性-写大文件-或大数据" class="headerlink" title="高级特性: 写大文件(或大数据)"></a>高级特性: 写大文件(或大数据)</h1><p>两种实现:</p>
<ol>
<li>直接写文件: <code>FileRegion</code>;</li>
<li>借助预置实现:<code>ChunkedWriteHandler</code>。</li>
</ol>
<h2 id="FileReion"><a href="#FileReion" class="headerlink" title="FileReion"></a>FileReion</h2><p>直接在<code>channel</code>中写入<code>FileRegion</code>即可:(还可以用<code>ChannelProgressivePromise</code>来获取传输进度)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">FileInputStream in = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line"><span class="comment">//以该文件的完整长度创建一个新的 DefaultFileRegion</span></span><br><span class="line">FileRegion region = <span class="keyword">new</span> DefaultFileRegion(</span><br><span class="line">        in.getChannel(), <span class="number">0</span>, file.length());</span><br><span class="line"><span class="comment">//发送该 DefaultFileRegion，并注册一个 ChannelFutureListener</span></span><br><span class="line">channel.writeAndFlush(region).addListener(</span><br><span class="line">    <span class="keyword">new</span> ChannelFutureListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(ChannelFuture future)</span></span></span><br><span class="line"><span class="function">       <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (!future.isSuccess()) &#123;</span><br><span class="line">           <span class="comment">//处理失败</span></span><br><span class="line">           Throwable cause = future.cause();</span><br><span class="line">           <span class="comment">// Do something</span></span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="ChunkedWriterHandler"><a href="#ChunkedWriterHandler" class="headerlink" title="ChunkedWriterHandler"></a>ChunkedWriterHandler</h2><p>数据流是:<br>数据源=&gt;<code>ChunkedInput</code>=&gt;自定义的StreamHandler=&gt;<code>ChunkedWriteHandler</code>=&gt;出站</p>
<p>其中<code>ChunkedInput</code>有4种实现:</p>
<table>
<thead>
<tr>
<th align="center">实现名称</th>
<th align="left">数据源</th>
<th align="center">备注</th>
</tr>
</thead>
<tbody><tr>
<td align="center">ChunkedFile</td>
<td align="left">文件</td>
<td align="center">当平台不支持零拷贝，或需要转换数据时使用</td>
</tr>
<tr>
<td align="center">ChunkedNioFile</td>
<td align="left">文件</td>
<td align="center">使用FileChannel</td>
</tr>
<tr>
<td align="center">ChunkedStream</td>
<td align="left">InputStream</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">ChunkedNioStream</td>
<td align="left">ReadableByteChannel</td>
<td align="center"></td>
</tr>
</tbody></table>
<p>示例代码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(Channel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">    <span class="comment">//将 SslHandler 添加到 ChannelPipeline 中</span></span><br><span class="line">    pipeline.addLast(<span class="keyword">new</span> SslHandler(sslCtx.newEngine(ch.alloc())));</span><br><span class="line">    <span class="comment">//添加 ChunkedWriteHandler 以处理作为 ChunkedInput 传入的数据</span></span><br><span class="line">    pipeline.addLast(<span class="keyword">new</span> ChunkedWriteHandler());</span><br><span class="line">    <span class="comment">//一旦连接建立，WriteStreamHandler 就开始写文件数据</span></span><br><span class="line">    pipeline.addLast(<span class="keyword">new</span> WriteStreamHandler());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">WriteStreamHandler</span></span></span><br><span class="line"><span class="class"><span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="comment">//当连接建立时，channelActive() 方法将使用 ChunkedInput 写文件数据</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.channelActive(ctx);</span><br><span class="line">        ctx.writeAndFlush(</span><br><span class="line">        <span class="keyword">new</span> ChunkedStream(<span class="keyword">new</span> FileInputStream(file))); <span class="comment">// ChunkedStream =&gt; ChunkedInput</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="序列化数据"><a href="#序列化数据" class="headerlink" title="序列化数据"></a>序列化数据</h1><p>这里介绍3种方法:</p>
<ol>
<li>JDK的<code>ObjectOutputStream</code>;</li>
<li>JBoss marshalling;</li>
<li>Protocol buffers.<h2 id="JDK序列化"><a href="#JDK序列化" class="headerlink" title="JDK序列化"></a>JDK序列化</h2>只要实现了<code>Serializable</code>接口的对象，就可以使用<code>ObjectOutputStream</code>。<br>示例代码:<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"t.tmp"</span>);</span><br><span class="line">ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(fos);</span><br><span class="line">oos.writeObject(<span class="keyword">new</span> Date());</span><br><span class="line">oos.close();</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>Netty提供的速度优化:<br><code>ObjectInputStream</code> =&gt;<code>ObjectDecoder</code><br><code>ObjectOutputStream</code>=&gt;<code>ObjectEncoder</code></p>
<h2 id="JBoss-Marshalling序列化"><a href="#JBoss-Marshalling序列化" class="headerlink" title="JBoss Marshalling序列化"></a>JBoss Marshalling序列化</h2><p>比JDK序列化快3倍。<br><code>MarshallingDecoder</code><br><code>MarshallingEncoder</code></p>
<p>示例代码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MarshallingInitializer</span> <span class="keyword">extends</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">Channel</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MarshallerProvider marshallerProvider;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> UnmarshallerProvider unmarshallerProvider;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MarshallingInitializer</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            UnmarshallerProvider unmarshallerProvider,</span></span></span><br><span class="line"><span class="function"><span class="params">            MarshallerProvider marshallerProvider)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.marshallerProvider = marshallerProvider;</span><br><span class="line">        <span class="keyword">this</span>.unmarshallerProvider = unmarshallerProvider;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(Channel channel)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ChannelPipeline pipeline = channel.pipeline();</span><br><span class="line">        <span class="comment">//添加 MarshallingDecoder 以将 ByteBuf 转换为 POJO</span></span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> MarshallingDecoder(unmarshallerProvider));</span><br><span class="line">        <span class="comment">//添加 MarshallingEncoder 以将POJO 转换为 ByteBuf</span></span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> MarshallingEncoder(marshallerProvider));</span><br><span class="line">        <span class="comment">//添加 ObjectHandler，以处理普通的实现了Serializable 接口的 POJO</span></span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> ObjectHandler());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjectHandler</span></span></span><br><span class="line"><span class="class">        <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">Serializable</span>&gt; </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            ChannelHandlerContext channelHandlerContext,</span></span></span><br><span class="line"><span class="function"><span class="params">            Serializable serializable)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="comment">// Do something</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中provider的创建代码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> MarshallingDecoder <span class="title">buildMarshallingDecoder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="comment">//首先通过Marshalling工具类的getProvidedMarshallerFactory静态方法获取MarshallerFactory实例</span></span><br><span class="line">       <span class="comment">//参数“serial”表示创建的是Java序列化工厂对象，它由jboss-marshalling-serial-1.3.0.CR9.jar提供。</span></span><br><span class="line">       <span class="keyword">final</span> MarshallerFactory marshallerFactory = Marshalling.getProvidedMarshallerFactory(<span class="string">"serial"</span>);</span><br><span class="line">       <span class="comment">//创建了MarshallingConfiguration对象</span></span><br><span class="line">       <span class="keyword">final</span> MarshallingConfiguration configuration = <span class="keyword">new</span> MarshallingConfiguration();</span><br><span class="line">       <span class="comment">//将它的版本号设置为5</span></span><br><span class="line">       configuration.setVersion(<span class="number">5</span>);</span><br><span class="line">       <span class="comment">//然后根据MarshallerFactory和MarshallingConfiguration创建UnmarshallerProvider实例</span></span><br><span class="line">       UnmarshallerProvider provider = <span class="keyword">new</span> DefaultUnmarshallerProvider(marshallerFactory, configuration);</span><br><span class="line">       <span class="comment">//最后通过构造函数创建Netty的MarshallingDecoder对象</span></span><br><span class="line">       <span class="comment">//它有两个参数，分别是UnmarshallerProvider和单个消息序列化后的最大长度。</span></span><br><span class="line">       MarshallingDecoder decoder = <span class="keyword">new</span> MarshallingDecoder(provider, <span class="number">1024</span>);</span><br><span class="line">       <span class="keyword">return</span> decoder;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>


<h2 id="Protocol-Buffer序列化"><a href="#Protocol-Buffer序列化" class="headerlink" title="Protocol Buffer序列化"></a>Protocol Buffer序列化</h2><p>google的序列化方案。<br>主要是4个类:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 解码:</span></span><br><span class="line">ProtobufVarint32FrameDecoder: bytes=&gt;msg; 解析出头部的长度字段,以正确划分帧;</span><br><span class="line">ProtobufDecoder: msg=&gt;msg;</span><br><span class="line"><span class="comment">// 编码:</span></span><br><span class="line">ProtobufVarint32LengthFieldPrepender: msg=&gt;bytes; 头部添加长度字段.</span><br><span class="line">ProtobufEncoder: msg=&gt;msg.</span><br></pre></td></tr></table></figure>


<p>示例代码:<br>服务端:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">.childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ch.pipeline()</span><br><span class="line">                .addLast(<span class="keyword">new</span> ProtobufVarint32FrameDecoder())</span><br><span class="line">                .addLast(<span class="keyword">new</span> ProtobufDecoder(</span><br><span class="line">                        ProtoObject.Req.getDefaultInstance()))</span><br><span class="line">                .addLast(<span class="keyword">new</span> ProtobufVarint32LengthFieldPrepender())</span><br><span class="line">                .addLast(<span class="keyword">new</span> ProtobufEncoder())</span><br><span class="line">                .addLast(<span class="keyword">new</span> ServerHandler());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>客户端:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">.childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ch.pipeline()</span><br><span class="line">                .addLast(<span class="keyword">new</span> ProtobufVarint32FrameDecoder())</span><br><span class="line">                .addLast(<span class="keyword">new</span> ProtobufDecoder(</span><br><span class="line">                        ProtoObject.Resp.getDefaultInstance()))</span><br><span class="line">                .addLast(<span class="keyword">new</span> ProtobufVarint32LengthFieldPrepender())</span><br><span class="line">                .addLast(<span class="keyword">new</span> ProtobufEncoder())</span><br><span class="line">                .addLast(<span class="keyword">new</span> ClientHandler());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><code>ProtobufDecoder</code>实际上可以接受<code>MessageLite</code>或者<code>Builder</code>。<br><code>Message</code>是<code>MessageLite</code>的子接口，因此可以用<code>Message</code>代替<code>MessageLite</code>。(基类指针存放子类对象)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Message</span> <span class="keyword">extends</span> <span class="title">MessageLite</span>, <span class="title">MessageOrBuilder</span> </span>&#123;...&#125;</span><br></pre></td></tr></table></figure>



      
    </div>
    <footer class="article-footer">
      <a data-url="http://xiaoyue26.github.io/2018/10/10/2018-10/Netty-in-action-%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0-SSL%E7%AD%89%E9%A2%84%E7%BD%AE%E5%AE%9E%E7%8E%B0-%E7%AC%94%E8%AE%B0/" data-id="ck96cxpop00e0maambxtf4rc5" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Netty/" rel="tag">Netty</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/" rel="tag">java</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-2018-09/通俗理解SSL-TLS协议区别与原理" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/09/26/2018-09/%E9%80%9A%E4%BF%97%E7%90%86%E8%A7%A3SSL-TLS%E5%8D%8F%E8%AE%AE%E5%8C%BA%E5%88%AB%E4%B8%8E%E5%8E%9F%E7%90%86/" class="article-date">
  <time datetime="2018-09-26T12:07:37.000Z" itemprop="datePublished">2018-09-26</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/java/">java</a>►<a class="article-category-link" href="/categories/java/Netty/">Netty</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/09/26/2018-09/%E9%80%9A%E4%BF%97%E7%90%86%E8%A7%A3SSL-TLS%E5%8D%8F%E8%AE%AE%E5%8C%BA%E5%88%AB%E4%B8%8E%E5%8E%9F%E7%90%86/">通俗理解SSL/TLS协议区别与原理</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <h1 id="区别-历史"><a href="#区别-历史" class="headerlink" title="区别(历史)"></a>区别(历史)</h1><p><code>TLS 1.0</code>又被叫做<code>SSL 3.1</code>。<br>换算关系:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">TLS 1.0 &#x3D; SSL 3.1</span><br><span class="line">TLS 1.1 &#x3D; SSL 3.2</span><br><span class="line">TLS 1.2 &#x3D; SSL 3.3</span><br></pre></td></tr></table></figure>
<p>综上，简单说，它们的区别只是版本更迭而已。<br>展开说的话，历史: </p>
<blockquote>
<p>1994年，NetScape公司设计了SSL协议（Secure Sockets Layer）的1.0版，但是未发布。<br>1995年，NetScape公司发布SSL 2.0版，很快发现有严重漏洞。<br>1996年，SSL 3.0版问世，得到大规模应用。<br>1999年，互联网标准化组织ISOC接替NetScape公司，发布了SSL的升级版TLS 1.0版。<br>2006年和2008年，TLS 1.1版和TLS 1.2版发布。（TLS1.2已经获得主流浏览器支持）<br>2008年8月，TLS 1.3版发布，性能好。移除了很多东西，速度快了很多，少了一次握手。</p>
</blockquote>
<p>TLS1.2: 兼容性高；握手需要2RTT；（重连需要1RTT）<br>TLS1.3: 安全、性能高；握手需要1RTT；(重连需要0RTT)</p>
<p>综上，可以先用<code>TLS 1.2</code>获得最大的兼容性。</p>
<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>和以前莉姐课上说的<code>PGP</code>协议差不多，都是三板斧：摘要、非对称加密、对称加密。</p>
<h2 id="要解决的问题"><a href="#要解决的问题" class="headerlink" title="要解决的问题"></a>要解决的问题</h2><pre><code>1. 窃听。解决方案：加密
2. 篡改。解决方案：摘要 （解决数据完整性）
3. 冒充。解决方案：数字签名 （解决中间人攻击）</code></pre><h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><p>ISO七层协议:<br><code>TCP</code> :  传输层<br><code>TLS</code> :  会话层<br>    <em>表示层略</em><br><code>HTTP</code>:  应用层<br>（<code>TLS</code>+<code>HTTP</code>=&gt;<code>HTTPS</code>）</p>
<p>所以是先进行<code>3</code>次握手建立<code>TCP</code>,然后<code>4</code>次握手建立<code>TLS</code>,然后进行<code>HTTP</code>数据传输。</p>
<p>如果在<code>TCP</code>层抓包的话，里头是<code>TLS</code>加密过的数据。（中间人无法知道内容）<br>如果在<code>HTTP</code>层（应用层）收取数据的话，是已经解密过的明文。(但是中间人不太可能在应用层，除非已经嵌入到业务层代码了。)</p>
<p>这个分层架构的划分其实不太合理，quic重新做了分层，详见:<br><a href="http://xiaoyue26.github.io/2022/02/17/2022-02/http3-quic%E4%BC%98%E7%BC%BA%E7%82%B9%E5%8F%8A%E5%8E%9F%E5%9B%A0/">http://xiaoyue26.github.io/2022/02/17/2022-02/http3-quic%E4%BC%98%E7%BC%BA%E7%82%B9%E5%8F%8A%E5%8E%9F%E5%9B%A0/</a></p>
<h2 id="简化版加密通信"><a href="#简化版加密通信" class="headerlink" title="简化版加密通信"></a>简化版加密通信</h2><p>假设用三个算法做一下加密通信，可以怎么实现呢？<br>定义如下：<br><code>RSA</code>: 一种非对称加密算法<br><code>AES</code>: 一种对称加密算法<br><code>SHA1</code>: 一种摘要算法</p>
<h3 id="方案1：AES-K-data"><a href="#方案1：AES-K-data" class="headerlink" title="方案1：AES(K,data)"></a>方案1：AES(K,data)</h3><p>假如客户端是<code>C</code>，服务端是<code>S</code>，<code>C</code>和<code>S</code>要传输的数据<code>data</code>。<br>直接传明文肯定是不行，可以加密一下。用一个密钥<code>K</code>，加密成<code>AES(K,data)</code>。<br>这里为啥用AES呢，不用RSA呢，因为非对称加密(RSA)太慢了。</p>
<img src="/images/2018-09/tls1.png" class="" width="400" height="600" title="加密">

<ul>
<li>问题：<br>虽然别人不知道你俩传输了啥，但是可能悄悄得在中间篡改了数据，双方察觉不到。</li>
<li>解决方案：<br>加上摘要算法。</li>
</ul>
<h3 id="方案2：AES-K-data-SHA1-data"><a href="#方案2：AES-K-data-SHA1-data" class="headerlink" title="方案2：AES(K,data+SHA1(data))"></a>方案2：AES(K,data+SHA1(data))</h3><p>可以在数据后面加上数据的摘要，然后再加密，这样中间人一旦乱改东西马上就会被检测出来，类似于校验位。</p>
<img src="/images/2018-09/tls2.png" class="" width="400" height="600" title="摘要">

<ul>
<li>问题：<br>上述方案都有一个前提，就是通信双方使用同一个K进行加解密。<br>那么一开始的时候怎么约定、协商这个密钥K呢？</li>
<li>解决方案:<br>先用RSA协商出一个对称密钥K。</li>
</ul>
<h3 id="协商密钥"><a href="#协商密钥" class="headerlink" title="协商密钥"></a>协商密钥</h3><p>最安全的方法当然是线下见面，约定一个密钥K。但是这个通信效率太低了，并发也不高。<br>为了避免中间人攻击，这个问题的关键点在于确认对方的身份。对于CS架构来说，最关键的是客户端确认服务端的身份。因此一个很自然的思路是让每个服务端有自己的身份证。</p>
<p>计算机领域的话，身份证就是数字证书，颁发身份证的机构就是CA。<br>具体原理就是非对称加密:<br>服务端通过数字签名向客户端证明自己的身份，客户端定义一个对称密钥K，然后用服务端的公钥加密一下发给服务端，因为只有服务端能用私钥解开，因此协商密钥的过程是安全的。（即使别人截获到也没关系）</p>
<h4 id="相关原理"><a href="#相关原理" class="headerlink" title="相关原理:"></a>相关原理:</h4><p>对称加密: </p>
<blockquote>
<p>加密时候用密钥K，解密时候也用密钥K，是对称的，因此叫对称加密。</p>
</blockquote>
<p>非对称加密: </p>
<blockquote>
<p>加密时候用公钥K1,解密时候用私钥K2,不是同一个密钥，不对称，因此叫非对称加密。<br>msg = RSA(K1,data);<br>data = RSA(K2,msg)</p>
</blockquote>
<p>也就是说，把数据用K1加密一下，可以且仅可以用K2解开；反之用K2加密消息，也可以且仅可以用K1解开，这个特性就很厉害了，正好可以用于身份认证的需求。</p>
<p>回到刚才的需求，需要有一种数字证书的机制。<br>简单实现就是服务端先去CA申请一对密钥(K1,K2)，他选K1作为公钥，另一个K2作为私钥。<br>当他需要向别人证明自己的身份的时候，他用私钥加密一下消息发给客户端（<code>RSA(K2,data)</code>，数字签名）。客户端可以用公钥K1解开消息，确认他的身份。客户端可以用公钥K1加密一份数据发出去，这份数据也就服务端能解开，因为只有服务端有私钥K2。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结:"></a>总结:</h4><pre><code>数字签名: RSA(私钥K2,data)
加密一份只有指定人能解开的数据: RSA(公钥K1,data)。</code></pre><p>这个过程中客户端如何得到公钥K1呢?<br>可以由服务端发给客户端数字证书，证书由CA签名证明服务端的公钥确实是K1。</p>
<p>客户端是因为信任CA,所以信任CA作保的服务端公钥K1，所以才可以用K1验证服务端的数字签名。（信任传递）<br>也就是说即使是网络世界，也还是需要签发证书的机构的。类似于一种官方机构。如果没有这种信任的基础，匿名的网络世界是很难建立起互信机制的。</p>
<h2 id="TLS组成部分"><a href="#TLS组成部分" class="headerlink" title="TLS组成部分"></a>TLS组成部分</h2><p>握手协议+记录协议</p>
<p>1。握手协议包括：</p>
<ul>
<li>握手：证书认证、协商算法和密钥；</li>
<li>密码规格变更协议：v1.3删除了；</li>
<li>警告协议: 错误的时候通知对方；</li>
<li>应用数据协议: 传输数据协议；<br>2。记录协议：负责使用对称密码对消息进行加密；</li>
</ul>
<h2 id="TLS运行流程"><a href="#TLS运行流程" class="headerlink" title="TLS运行流程"></a>TLS运行流程</h2><p>简单地说就是2个步骤：先协商一个密钥，之后的通信就用这个密钥加密数据。<br><code>TLS 1.2</code>:<br>协商: 4次握手，协商出一个对称加密的密钥K；<br>通信：双方用K加密数据以后通信。</p>
<img src="/images/2018-09/tls3.png" class="" width="400" height="600" title="tls3.png">
<p>如上图所示，这4次握手就是想要协商出一个对称加密的密钥KEY,以及摘要算法的密钥。<br>图中的变量定义:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">r1: 随机数1;</span><br><span class="line">r2: 随机数2;</span><br><span class="line">r3: 随机数3;</span><br><span class="line">AES(KEY,data): 密钥是KEY，对称加密data；</span><br><span class="line">RSA(K1,data): 密钥是K1, 非对称加密data；</span><br><span class="line">finish: finish信息</span><br><span class="line">HMAC(data): 用HMAC算法对data做摘要（key省略了）。</span><br></pre></td></tr></table></figure>
<p>其中对称加密的KEY是根据3个随机数r1,r2,r3生成出来的。之所以需要这么多随机数，是为了保证这个KEY的随机性。</p>
<p>具体展开来说的话4次握手：<br>1.客户端=&gt;服务端: </p>
<blockquote>
<p>(1)随机数r1;<br>(2)客户端支持的协议版本、算法版本；</p>
</blockquote>
<p>2.服务端=&gt;客户端: </p>
<blockquote>
<p>(1)随机数r2;<br>(2)确定用的协议、算法版本;<br>(3)CA签名的证书(里面有服务器公钥K1);<br>(4)服务端数字签名。</p>
</blockquote>
<p>3.客户端=&gt;服务端: 先确认服务端的身份、生成r3, 生成对称加密的key，然后发送数据:</p>
<blockquote>
<p>(1)用服务器公钥K1非对称加密后的随机数r3;<br>(2)对称加密过的finish信息以及摘要。<br>(此时客户端已经有了r1,r2,r3,可以生成对称加密密钥key)</p>
</blockquote>
<p>4.服务端=&gt;客户端: 先解开非对称加密的数据，得到r3,然后生成对称加密的key，然后解开finish信息，发现确实能用，也就是客户端进行的对称加密是符合预期的，然后发送:</p>
<blockquote>
<p>(1)对称加密过的server finish信息以及摘要。</p>
</blockquote>
<p>如果客户端和服务端都能对Finish信息进行正常加解密且消息正确的被验证，则说明握手通道已经建立成功，接下来，双方可以进行对称加密的数据传输了。</p>
<h3 id="几个小细节"><a href="#几个小细节" class="headerlink" title="几个小细节"></a>几个小细节</h3><ol>
<li>上面的HMAC摘要算法也是有key的，而且也是由r1,r2,r3算出来的;</li>
<li>大部分时候只需要认证服务端身份(http)，有时候也需要认证客户端身份，这个时候就需要客户端也有CA证书。</li>
<li>实际代码实现中，三个随机数都是有名字的: <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">r1: 随机数1; &#x3D;&gt; random_C(random number)</span><br><span class="line">r2: 随机数2; &#x3D;&gt; random_S(random number)</span><br><span class="line">r3: 随机数3; &#x3D;&gt; pre-master key(random number)</span><br></pre></td></tr></table></figure>
r3是关键的加密保护的随机数，r1,r2,r3一起生成key。<br>r1,r2的主要用途是为了避免中间人攻击、重放攻击。（用摘要确保r1,r2无篡改，然后又是随机数的话，就不会因为是重复的key被碰撞到相同的r3，从而生成相同的key）<br>此外其他术语也略有不同：<img src="/images/2018-09/real3.png" class="" width="400" height="600" title="实际握手">

</li>
</ol>
<h3 id="DH密钥交换算法（怎么用3个随机数算出密钥）"><a href="#DH密钥交换算法（怎么用3个随机数算出密钥）" class="headerlink" title="DH密钥交换算法（怎么用3个随机数算出密钥）"></a>DH密钥交换算法（怎么用3个随机数算出密钥）</h3><img src="/images/2022-02/DH_scret.png" class="" width="400" height="600" title="DH_scret">
<p>如上图所示:<br>客户端计算密钥:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A&#x3D; g^a mod p </span><br><span class="line">K &#x3D; B^a mod p</span><br></pre></td></tr></table></figure>
<p>服务端计算密钥: b</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">B &#x3D; g^b mod p</span><br><span class="line">K &#x3D; A^b mod p</span><br></pre></td></tr></table></figure>
<p>同模推导:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">K &#x3D; A^b mod p </span><br><span class="line">&#x3D; (g^a mod p) ^ b mod p </span><br><span class="line">&#x3D; g^ab mod p</span><br><span class="line">&#x3D; (g^b mod p ) ^ a mod p</span><br><span class="line">&#x3D; B^a mod p</span><br></pre></td></tr></table></figure>
<p>三个随机数中，有一个是本地随机生成的，不用网络传输；<br>（对于服务端来说是a，客户端是b，而网络传输的是A和B，因此中间人进行反向破解难度大）<br>由于网络上传输的只是p,g和A,B，难以破解出a,b，因此中间人也难以破解出K。</p>
<h3 id="tls1-2实际加密方式"><a href="#tls1-2实际加密方式" class="headerlink" title="tls1.2实际加密方式"></a>tls1.2实际加密方式</h3><p>实际上加密算法是需要padding的，最早的padding方法是:<br><code>AES(text+MAC(text)+padding)</code><br>后来因为这种方式容易遭遇padding攻击，因此tls1.3采用了更安全的padding方法:<br>先<code>E=AES(text+padding)</code><br>然后： <code>E+MAC(E)</code></p>
<blockquote>
<p>padding攻击，通过反复修改部分内容、并触发解密过程，从而探测猜测加密算法的密钥；</p>
</blockquote>
<h3 id="tls1-3的前向安全性"><a href="#tls1-3的前向安全性" class="headerlink" title="tls1.3的前向安全性"></a>tls1.3的前向安全性</h3><p>前向安全: 当前会话的密钥泄露后，不能用来解密以前会话的消息，也就是不影响以前会话的安全性。<br>例如如果每次会话都用ECDHE协商新的密钥，这次会话的密钥无法用于以前的会话解密，则可以达到前向安全性。</p>
<p><code>Ephemeral Secret</code> (ES)：每个连接新鲜的 ECDHE 协商得出的值。凡是从 ES 得出的值，都是前向安全的（当然，在 PSK only模式下，不是前向安全的）。<br><code>Static Secret</code> (SS)：从静态，或者半静态key得出的值。例如psk，或者服务器的半静态 ECDH 公钥。</p>
<p>如果用Session ticket或者server config机制来实现0RTT的快速建立连接，本质上是客户端缓存了一部分上次建连的密钥信息；<br>因此tls1.3虽然提高了性能，但是牺牲了一定时间(配置过期时间内)的前向安全性。</p>
<h2 id="可能的优化"><a href="#可能的优化" class="headerlink" title="可能的优化"></a>可能的优化</h2><p>TLS1.2的4次握手可以优化成近似3次握手。<br>因此协商过程中唯一不会被中间人破译的是客户端第三次握手发送的随机数r3，只要确保这一性质即可。这个r3之所以不会被破译，是因为是用服务端公钥加密的，只有服务端私钥能解开。<br>因此如果客户端事先知道服务端的公钥，可以在第一次握手的时候，就发送由服务端公钥加密的r3。（对于以前曾经通信过的服务端，这一前提是可行的）</p>
<p>因此整个流程就是：<br>1.客户端=&gt;服务端:<br>(1)r1; //防重放<br>(2)RSA(K1,r3+hash(r3)); //可以把自己支持的所有协议的随机数都算好，加密好。<br>(3)支持的协议、算法;<br>2.服务端=&gt;客户端:<br>(1)RSA(对r1的回应),顺便签名证明自己的身份,也消除了重放攻击;<br>(2)r2; 明文即可<br>(3)确定的协议、算法;<br>(4)AES(Key,finish信息+HMAC(finish信息)); // 客户端知道上述两个信息，就能算出对称加密的key了。</p>
<p>3.客户端=&gt;服务端: AES(Key,finish信息+HMAC(finish信息))</p>
<h2 id="TLS-1-3实际的优化"><a href="#TLS-1-3实际的优化" class="headerlink" title="TLS 1.3实际的优化"></a>TLS 1.3实际的优化</h2><p>回顾TLS1.2:<br>第1个RTT:协商用什么协议，client hello + server hello;<br>第2个RTT:协商对应协议下，用什么随机数，client key exchange + server key exchange;</p>
<p>TLS1.3的选择:<br>牺牲兼容性，去掉第一次rtt的密钥协议协商，直接按自己选择的成熟安全的密钥套件生成对应参数，然后发送给服务端;<br>如果失败，再走HelloRetryRequest。<br>因此Tls1.3只需要1RTT就可以建连。（第二次建立是甚至0RTT，连协商过程都省了，直接告诉服务器用上次的密钥）</p>
<p>参考链接:<br><a href="https://www.cnblogs.com/lovesong/p/5186200.html" target="_blank" rel="noopener">https://www.cnblogs.com/lovesong/p/5186200.html</a><br><a href="https://blog.soaer.com/1/3eac1f9d9045410fb249dbc81cff6b22.html" target="_blank" rel="noopener">https://blog.soaer.com/1/3eac1f9d9045410fb249dbc81cff6b22.html</a><br><a href="http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://xiaoyue26.github.io/2018/09/26/2018-09/%E9%80%9A%E4%BF%97%E7%90%86%E8%A7%A3SSL-TLS%E5%8D%8F%E8%AE%AE%E5%8C%BA%E5%88%AB%E4%B8%8E%E5%8E%9F%E7%90%86/" data-id="ck96cxpom00dnmaam2tyrfqth" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/AES/" rel="tag">AES</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/HMAC/" rel="tag">HMAC</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/HTTP/" rel="tag">HTTP</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Netty/" rel="tag">Netty</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/RSA/" rel="tag">RSA</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/SSL/" rel="tag">SSL</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/TLS/" rel="tag">TLS</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/" rel="tag">java</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-2018-09/Netty-in-action第十章-编解码器-笔记" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/09/22/2018-09/Netty-in-action%E7%AC%AC%E5%8D%81%E7%AB%A0-%E7%BC%96%E8%A7%A3%E7%A0%81%E5%99%A8-%E7%AC%94%E8%AE%B0/" class="article-date">
  <time datetime="2018-09-22T13:31:09.000Z" itemprop="datePublished">2018-09-22</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/java/">java</a>►<a class="article-category-link" href="/categories/java/Netty/">Netty</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/09/22/2018-09/Netty-in-action%E7%AC%AC%E5%8D%81%E7%AB%A0-%E7%BC%96%E8%A7%A3%E7%A0%81%E5%99%A8-%E7%AC%94%E8%AE%B0/">Netty in action-第十章-编解码器-笔记</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <p>编码器: encoder , 出站handler;<br>解码器: decoder,  入站handler。</p>
<p>用途包括:<br><code>POP3</code>,<code>IMAP</code>,<code>SMTP</code>协议。（邮件服务器）</p>
<h1 id="资源管理"><a href="#资源管理" class="headerlink" title="资源管理"></a>资源管理</h1><p>编码器和解码器的消息被消费后，会自动调用<code>ReferenceCountUtil.release(message)</code>进行释放。<br>如果要阻止这种自动释放，可以显式调用<code>ReferenceCountUtil.retain(message)</code>保留消息。（后续再自己手动释放）</p>
<h1 id="解码器"><a href="#解码器" class="headerlink" title="解码器"></a>解码器</h1><p>两种:<br>1.字节=&gt;消息:<code>ByteToMessageDecoder</code>,<code>ReplayingDecoder</code>;<br>2.消息=&gt;消息:<code>MessageToMessageDecoder</code>。(不需要检查<code>readableBytes</code>)</p>
<p>解码器包括:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.字节=&gt;消息: （解码）</span></span><br><span class="line">ByteToMessageDecoder: 抽象类;</span><br><span class="line">LineBasedFrameDecoder: 行分割消息数据， 实际类。</span><br><span class="line">HttpObjectDecoder: Http数据解析。抽象类。</span><br><span class="line"><span class="comment">// 2.消息=&gt;消息: （格式转换）</span></span><br><span class="line">MessageToMessageDecoder: 消息=&gt;消息;</span><br><span class="line">HttpObjectAggregator: Http数据转换。实际类。</span><br></pre></td></tr></table></figure>
<p>相应的声明:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LineBasedFrameDecoder</span> <span class="keyword">extends</span> <span class="title">ByteToMessageDecoder</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpObjectDecoder</span> <span class="keyword">extends</span> <span class="title">ByteToMessageDecoder</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpObjectAggregator</span> <span class="keyword">extends</span> <span class="title">MessageAggregator</span>&lt;<span class="title">HttpObject</span>, <span class="title">HttpMessage</span>, <span class="title">HttpContent</span>, <span class="title">FullHttpMessage</span>&gt;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageAggregator</span>&lt;<span class="title">I</span>, <span class="title">S</span>, <span class="title">C</span> <span class="keyword">extends</span> <span class="title">ByteBufHolder</span>, <span class="title">O</span> <span class="keyword">extends</span> <span class="title">ByteBufHolder</span>&gt; <span class="keyword">extends</span> <span class="title">MessageToMessageDecoder</span>&lt;<span class="title">I</span>&gt;</span>;</span><br></pre></td></tr></table></figure>


<h2 id="ByteToMessageDecoder-抽象类"><a href="#ByteToMessageDecoder-抽象类" class="headerlink" title="ByteToMessageDecoder(抽象类)"></a>ByteToMessageDecoder(抽象类)</h2><p>处理流程是字节=&gt;消息，也就是<code>ByteBuf in</code>=&gt;<code>List&lt;Object&gt;out</code>。<br>需要注意每次从<code>in</code>读之前，需要确认可读字节数量:<code>in.readableBytes()</code>。<br>具体代码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ToIntegerDecoder</span> <span class="keyword">extends</span> <span class="title">ByteToMessageDecoder</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">decode</span><span class="params">(ChannelHandlerContext ctx</span></span></span><br><span class="line"><span class="function"><span class="params">        ,ByteBuf in         // <span class="number">1.</span>输入</span></span></span><br><span class="line"><span class="function"><span class="params">        ,List&lt;Object&gt; out)</span>  <span class="comment">// 2.输出</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//检查是否至少有 4 字节可读（一个 int 的字节长度）</span></span><br><span class="line">        <span class="keyword">if</span> (in.readableBytes() &gt;= <span class="number">4</span>) &#123;</span><br><span class="line">            out.add(in.readInt());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>ByteToMessageDecoder</code>有俩api:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">decode:     必须实现，解析每条消息;</span><br><span class="line">decodeLast: 可选，处理最后一条消息，默认是调用decode。</span><br></pre></td></tr></table></figure>

<h2 id="ReplayingDecoder-抽象类-尽量不用"><a href="#ReplayingDecoder-抽象类-尽量不用" class="headerlink" title="ReplayingDecoder(抽象类)(尽量不用)"></a>ReplayingDecoder(抽象类)(尽量不用)</h2><p>使用上比<code>ByteToMessageDecoder</code>省略<code>readableBytes</code>的调用，但是速度稍慢。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ToIntegerDecoder2</span> <span class="keyword">extends</span> <span class="title">ReplayingDecoder</span>&lt;<span class="title">Void</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">decode</span><span class="params">(ChannelHandlerContext ctx, ByteBuf in, </span></span></span><br><span class="line"><span class="function"><span class="params">    //传入的 ByteBuf 是 ReplayingDecoderByteBuf</span></span></span><br><span class="line"><span class="function"><span class="params">        List&lt;Object&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//从入站 ByteBuf 中读取 一个 int，并将其添加到解码消息的 List 中</span></span><br><span class="line">        out.add(in.readInt());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>尽可能使用<code>ByteToMessageDecoder</code>而不是<code>ReplaingDecoder</code>。<br>两个原因:</p>
<ol>
<li><code>ReplaingDecoder</code>比较慢;</li>
<li>内部用的是<code>ReplayingDecoderByteBuf</code>，并没有支持所有<code>ByteBuf</code>的操作。(api不全)</li>
</ol>
<h2 id="MessageToMessageDecoder-抽象类"><a href="#MessageToMessageDecoder-抽象类" class="headerlink" title="MessageToMessageDecoder(抽象类)"></a>MessageToMessageDecoder(抽象类)</h2><p>消息=&gt;消息。<br>如果声明是<code>MessageToMessageDecoder&lt;Integer&gt;</code>,那么输入就是<code>Integer</code>类型。<br>具体签名是:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageToMessageDecoder</span>&lt;<span class="title">I</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span></span></span><br></pre></td></tr></table></figure>
<p>实际案例:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IntegerToStringDecoder</span> <span class="keyword">extends</span></span></span><br><span class="line"><span class="class">    <span class="title">MessageToMessageDecoder</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">decode</span><span class="params">(ChannelHandlerContext ctx</span></span></span><br><span class="line"><span class="function"><span class="params">        , Integer msg      // <span class="number">1.</span>输入</span></span></span><br><span class="line"><span class="function"><span class="params">        , List&lt;Object&gt; out // <span class="number">2.</span>输出</span></span></span><br><span class="line"><span class="function"><span class="params">)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        out.add(String.valueOf(msg));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以发现这种消息转换不需要检查<code>readableBytes</code>。(毕竟输入已经不是<code>byte</code>了)</p>
<h2 id="TooLongFrameException类"><a href="#TooLongFrameException类" class="headerlink" title="TooLongFrameException类"></a>TooLongFrameException类</h2><p>解码前，解码器会缓冲大量的数据。如果发现缓冲太多，可以抛出异常来报告这种情况:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SafeByteToMessageDecoder</span> <span class="keyword">extends</span> <span class="title">ByteToMessageDecoder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_FRAME_SIZE = <span class="number">1024</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">decode</span><span class="params">(ChannelHandlerContext ctx, ByteBuf in,</span></span></span><br><span class="line"><span class="function"><span class="params">        List&lt;Object&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> readable = in.readableBytes();</span><br><span class="line">            <span class="keyword">if</span> (readable &gt; MAX_FRAME_SIZE) &#123;</span><br><span class="line">                in.skipBytes(readable); <span class="comment">// 一种可能的处理</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> TooLongFrameException(<span class="string">"Frame too big!"</span>);<span class="comment">// 抛出异常</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>抛异常的用意:<br>1.可能是上游生产太快,因此需要识别这种情况;<br>2.可能是下游消费太慢,也需要识别这种情况。</p>
<p>后续可以用<code>exceptionCaught</code>来捕获这个异常，可能的处理包括:<br>1.向生产端返回一个特殊的响应;<br>如HTTP:<br><code>413</code> 错误 – 请求实体太大 (Request entity too large)<br><code>414</code> 错误 – 请求 URI 过长 (Request URI too long)<br>2.关闭对应的连接。<br>3.其他处理方案。</p>
<h1 id="编码器"><a href="#编码器" class="headerlink" title="编码器"></a>编码器</h1><p>两种:<br>1.消息=&gt;字节:MessageToByteEncoder;<br>2.消息=&gt;消息:MessageToMessageEncoder。<br>// 主要是入站出站方向不同，不然和前面的消息转换差不多。</p>
<p>编码器包括:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MessageToByteEncoder&lt;I&gt;: 消息=&gt;字节</span><br><span class="line">MessageToMessageEncoder: 消息=&gt;消息</span><br><span class="line">Websocket08FrameEncoder: 消息=&gt;消息</span><br><span class="line">ProtobufEncoder: 消息=&gt;消息</span><br></pre></td></tr></table></figure>
<p>具体代码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IntegerToStringEncoder</span></span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">MessageToMessageEncoder</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">encode</span><span class="params">(ChannelHandlerContext ctx</span></span></span><br><span class="line"><span class="function"><span class="params">        , Integer msg       // <span class="number">1.</span>输入 </span></span></span><br><span class="line"><span class="function"><span class="params">        , List&lt;Object&gt; out  // <span class="number">2.</span>输出</span></span></span><br><span class="line"><span class="function"><span class="params">)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        out.add(String.valueOf(msg));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解码器:<code>decode</code>,<code>decodeLast</code><br>编码器:<code>encode</code></p>
<h1 id="编解码器（编码器-解码器复合）"><a href="#编解码器（编码器-解码器复合）" class="headerlink" title="编解码器（编码器+解码器复合）"></a>编解码器（编码器+解码器复合）</h1><p>编解码复合，也有两种:</p>
<ol>
<li>字节&lt;=&gt;消息: <code>ByteToMessageCodec</code>;</li>
<li>消息&lt;=&gt;消息: <code>MessageToMessageCodec</code>.</li>
</ol>
<p>可以发现就是多了一个<code>Codec</code>后缀。</p>
<h2 id="ByteToMessageCodec-抽象类"><a href="#ByteToMessageCodec-抽象类" class="headerlink" title="ByteToMessageCodec(抽象类)"></a>ByteToMessageCodec(抽象类)</h2><p><code>ByteToMessageCodec</code>的方法就是把编码器和解码器的api都加上:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">decode(ctx,ByteBuf in,List&lt;Object&gt;out)</span><br><span class="line">decodeLast(ctx,ByteBuf in,List&lt;Object&gt;out)</span><br><span class="line">encode(ctx,I msg,ByteBuf out)</span><br></pre></td></tr></table></figure>

<h2 id="MessageToMessageCodec-抽象类"><a href="#MessageToMessageCodec-抽象类" class="headerlink" title="MessageToMessageCodec(抽象类)"></a>MessageToMessageCodec(抽象类)</h2><p>这是一个参数化的类，声明如下；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageToMessageCodec</span>&lt;<span class="title">INBOUND_IN</span>, <span class="title">OUTBOUND_IN</span>&gt; <span class="keyword">extends</span> <span class="title">ChannelDuplexHandler</span></span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">ChannelDuplexHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> <span class="keyword">implements</span> <span class="title">ChannelOutboundHandler</span></span></span><br></pre></td></tr></table></figure>
<p>看到这里大致可以发现一个规律，这些编码器、解码器最重要的是定义输入数据的数据类型，而输出数据的数据类型一般都是<code>List&lt;Object&gt;</code>。<br><code>MessageToMessageCodec</code>本质上是一个可以处理入站事件和出站事件的handler，因此需要定义入站和出站的数据类型:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">INBOUND_IN:  入站数据参数的数据类型</span><br><span class="line">OUTBOUND_IN: 出站数据参数的数据类型</span><br></pre></td></tr></table></figure>

<p>它的两个接口:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">encode</span><span class="params">(ChannelHandlerContext ctx</span></span></span><br><span class="line"><span class="function"><span class="params">, OUTBOUND_IN msg   -- 输入</span></span></span><br><span class="line"><span class="function"><span class="params">, List&lt;Object&gt; out)</span> -- 输出，实际上一般会是INBOUND_IN类型</span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">decode</span><span class="params">(ChannelHandlerContext ctx</span></span></span><br><span class="line"><span class="function"><span class="params">, INBOUND_IN msg    -- 输入</span></span></span><br><span class="line"><span class="function"><span class="params">, List&lt;Object&gt; out)</span> -- 输出，实际上一般会是OUTBOUND_IN类型</span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> Exception</span>;</span><br></pre></td></tr></table></figure>

<h2 id="CombinedChannelDuplexHandler类"><a href="#CombinedChannelDuplexHandler类" class="headerlink" title="CombinedChannelDuplexHandler类"></a>CombinedChannelDuplexHandler类</h2><p>编解码器是从头写一个，实现双向转换。<br><code>CombinedChannelDuplexHandler</code>是从已经写好的编码器和解码器，生成一个双向转换的封装类。<br>声明:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CombinedChannelDuplexHandler</span>&lt;<span class="title">I</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandler</span></span></span><br><span class="line"><span class="class">, <span class="title">O</span> <span class="keyword">extends</span> <span class="title">ChannelOutboundHandler</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">extends</span> <span class="title">ChannelDuplexHandler</span> </span>&#123;</span><br></pre></td></tr></table></figure>
<p>传入两个类,I是inbound,O是outbound。具体样例如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CombinedByteCharCodec</span> <span class="keyword">extends</span></span></span><br><span class="line"><span class="class">    <span class="title">CombinedChannelDuplexHandler</span>&lt;<span class="title">ByteToCharDecoder</span>, <span class="title">CharToByteEncoder</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CombinedByteCharCodec</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//将委托实例传递给父类</span></span><br><span class="line">        <span class="keyword">super</span>(<span class="keyword">new</span> ByteToCharDecoder(), <span class="keyword">new</span> CharToByteEncoder());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>传进来后调用父类默认写好的构造函数即可。</p>
<p>个人理解编解码器和DuplexHandler类都是高级用法，不一定实用。<br>个人偏好直接使用编码器、解码器就好了。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://xiaoyue26.github.io/2018/09/22/2018-09/Netty-in-action%E7%AC%AC%E5%8D%81%E7%AB%A0-%E7%BC%96%E8%A7%A3%E7%A0%81%E5%99%A8-%E7%AC%94%E8%AE%B0/" data-id="ck96cxpol00dkmaamasjl6b24" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Netty/" rel="tag">Netty</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/" rel="tag">java</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-2018-09/Netty-in-action第九章-单元测试-笔记" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/09/22/2018-09/Netty-in-action%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95-%E7%AC%94%E8%AE%B0/" class="article-date">
  <time datetime="2018-09-22T13:26:52.000Z" itemprop="datePublished">2018-09-22</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/java/">java</a>►<a class="article-category-link" href="/categories/java/Netty/">Netty</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/09/22/2018-09/Netty-in-action%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95-%E7%AC%94%E8%AE%B0/">Netty in action第九章-单元测试-笔记</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <h1 id="EmbeddedChannel-测试Handler"><a href="#EmbeddedChannel-测试Handler" class="headerlink" title="EmbeddedChannel(测试Handler)"></a>EmbeddedChannel(测试Handler)</h1><p>实际应用中,我们大概率需要编写各种<code>inboundHandler</code>,<code>outboundHandler</code>，这个时候可以使用<code>EmbeddedChannel</code>来测试处理逻辑。<br>(测<code>Handler</code>用的)</p>
<img src="/images/2018-09/9.1.png" class="" width="400" height="600" title="单元测试">
<table>
<thead>
<tr>
<th align="center">api</th>
<th align="left">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">writeInbound</td>
<td align="left">往测试channel里写数据.测试入站事件。如果这条数据能够通过所有<code>InboundHandler</code>，则返回<code>true</code></td>
</tr>
<tr>
<td align="center">writeOutbound</td>
<td align="left">往测试channel里写数据.测试出站事件。如果这条数据能够通过所有<code>OutboundHandler</code>，则返回<code>true</code></td>
</tr>
<tr>
<td align="center">readInbound</td>
<td align="left">读入站消息，无则返回<code>null</code></td>
</tr>
<tr>
<td align="center">readOutbound</td>
<td align="left">读出站消息，无则返回<code>null</code></td>
</tr>
<tr>
<td align="center">finish</td>
<td align="left">关闭写。还可以读。</td>
</tr>
</tbody></table>
<p>示例代码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFramesDecoded</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建一个 ByteBuf，并存储 9 字节</span></span><br><span class="line">    ByteBuf buf = Unpooled.buffer();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++) &#123;</span><br><span class="line">        buf.writeByte(i);</span><br><span class="line">    &#125;</span><br><span class="line">    ByteBuf input = buf.duplicate(); <span class="comment">// 1</span></span><br><span class="line">    EmbeddedChannel channel = <span class="keyword">new</span> EmbeddedChannel(</span><br><span class="line">        <span class="keyword">new</span> FixedLengthFrameDecoder(<span class="number">3</span>));</span><br><span class="line">     </span><br><span class="line">    assertTrue(channel.writeInbound(input.retain())); <span class="comment">// 2. 数据量够,能够传到末端</span></span><br><span class="line">    assertTrue(channel.finish()); <span class="comment">// 3. 还有可读数据,返回true</span></span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 读3帧(3个入站消息):</span></span><br><span class="line">    ByteBuf read = (ByteBuf) channel.readInbound();</span><br><span class="line">    assertEquals(buf.readSlice(<span class="number">3</span>), read); <span class="comment">// 4</span></span><br><span class="line">    read.release(); <span class="comment">// 5</span></span><br><span class="line"></span><br><span class="line">    read = (ByteBuf) channel.readInbound();</span><br><span class="line">    assertEquals(buf.readSlice(<span class="number">3</span>), read);</span><br><span class="line">    read.release();</span><br><span class="line"></span><br><span class="line">    read = (ByteBuf) channel.readInbound();</span><br><span class="line">    assertEquals(buf.readSlice(<span class="number">3</span>), read);</span><br><span class="line">    read.release();</span><br><span class="line"></span><br><span class="line">    assertNull(channel.readInbound());</span><br><span class="line">    buf.release();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以结合<code>JUnit</code>编写单元测试。<br>上述代码中标了几个要注意的地方:</p>
<ul>
<li><p>1.duplicate和copy:</p>
<blockquote>
<p>duplicate: 浅拷贝buf,生成input。数据是共享的，writerIndex和readerIndex是隔离的。<br>copy: 深拷贝，数据和index都是隔离的。</p>
</blockquote>
</li>
<li><p>2.retain和release:</p>
<blockquote>
<p>retain: 引用计数器+1;<br>release: 引用计数器-1。<br>因为进行了浅拷贝，把引用传递给方法之前必须调一次<code>retain</code>。<br>(如果只是和父ByteBuf同生命周期范围,不传递,可以不调。大部分时候还是调一下为好。)<br>最后使用结束记得要release。</p>
</blockquote>
</li>
<li><p>3.channel.finish():</p>
<blockquote>
<p>channel.finish():<br>标记这个channel已经不能再写入数据了。(但是可以读)</p>
</blockquote>
</li>
<li><p>4.buf.readSlice(3);</p>
<blockquote>
<p>返回值类似于buf.slice(3), 但是有一个read前缀,说明这个方法调用结束后会增加readerIndex。(消费行为)<br>作用是读出3个字节来。</p>
</blockquote>
</li>
<li><p>5.release: </p>
<blockquote>
<p>使用结束记得release。</p>
</blockquote>
</li>
</ul>
<p>上述代码是测试入站事件,所以样例用的是<code>inbound</code>和<code>decoder</code>；<br>如果要测试出站事件,只要类似改成<code>outbound</code>和<code>encoder</code>即可。</p>
<h2 id="异常测试"><a href="#异常测试" class="headerlink" title="异常测试"></a>异常测试</h2><p>除了出站入站事件,还可以测试异常捕捉(<code>exceptionCaught</code>)。</p>
<ul>
<li>如果写了<code>exceptionCaught</code>，期望的结果是测试中不能捕捉到异常;</li>
<li>反之如果没写,期望的结果是测试中能捕捉到异常。</li>
</ul>
<p>前者:期望不能捕捉到(被<code>exceptionCaught</code>处理了)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">        channel.writeInbound(input.readBytes(<span class="number">4</span>));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (TooLongFrameException e) &#123;</span><br><span class="line">    Assert.fail();<span class="comment">// 期望不能抵达这里</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>后者:期望能捕捉到:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">            channel.writeInbound(input.readBytes(<span class="number">4</span>));</span><br><span class="line">            Assert.fail();<span class="comment">// 期望不能抵达这里。</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (TooLongFrameException e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主要还是逻辑上的控制流测试。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://xiaoyue26.github.io/2018/09/22/2018-09/Netty-in-action%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95-%E7%AC%94%E8%AE%B0/" data-id="ck96cxpoh00d8maam9cav1fxs" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Netty/" rel="tag">Netty</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/" rel="tag">java</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-2018-09/Netty-in-action第八章-引导-笔记" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/09/17/2018-09/Netty-in-action%E7%AC%AC%E5%85%AB%E7%AB%A0-%E5%BC%95%E5%AF%BC-%E7%AC%94%E8%AE%B0/" class="article-date">
  <time datetime="2018-09-17T02:52:07.000Z" itemprop="datePublished">2018-09-17</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/java/">java</a>►<a class="article-category-link" href="/categories/java/Netty/">Netty</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/09/17/2018-09/Netty-in-action%E7%AC%AC%E5%85%AB%E7%AB%A0-%E5%BC%95%E5%AF%BC-%E7%AC%94%E8%AE%B0/">Netty in action第八章-引导-笔记</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <h1 id="AbstractBootstrap"><a href="#AbstractBootstrap" class="headerlink" title="AbstractBootstrap"></a>AbstractBootstrap</h1><p>引导: Bootstrapp<br>可以理解成一个对外的接口，可以把前面几章提到的内部组件封装起来，对外提供服务使用。</p>
<img src="/images/2018-09/8.1.png" class="" width="400" height="600" title="bootstrap">
<p>服务端: <code>ServerBootstrap</code>，一个父Channel创建多个子Channel;<br>客户端: <code>Bootstrap</code>,一个普通Channel用于所有网络通信。</p>
<p><code>Bootstrap</code>和<code>ServerBootstrap</code>都继承自<code>AbstractBootstrap</code>,具体声明如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractBootstrap</span>&lt;<span class="title">B</span> <span class="keyword">extends</span> <span class="title">AbstractBootstrap</span>&lt;<span class="title">B</span>, <span class="title">C</span>&gt;, <span class="title">C</span> <span class="keyword">extends</span> <span class="title">Channel</span>&gt; <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bootstrap</span> <span class="keyword">extends</span> <span class="title">AbstractBootstrap</span>&lt;<span class="title">Bootstrap</span>, <span class="title">Channel</span>&gt; </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerBootstrap</span> <span class="keyword">extends</span> <span class="title">AbstractBootstrap</span>&lt;<span class="title">ServerBootstrap</span>, <span class="title">ServerChannel</span>&gt; </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>为什么语法看起来有点复杂呢?</li>
</ol>
<ul>
<li>其实是为了配置类的接口能返回自身的类型的引用。</li>
</ul>
<ol start="2">
<li>为什么需要这样呢? (配置类的接口能返回自身的类型的引用) </li>
</ol>
<ul>
<li>根本目的是为了配置的时候实现流式语法糖,类似于builder的设计模式:<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">bootstrap.group(group)</span><br><span class="line">        .channel(NioSocketChannel<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">        .<span class="title">handler</span>(<span class="title">new</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">ByteBuf</span>&gt;() </span>&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">                ChannelHandlerContext channelHandlerContext,</span></span></span><br><span class="line"><span class="function"><span class="params">                ByteBuf byteBuf)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"Received data"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            &#125;);</span><br></pre></td></tr></table></figure>


</li>
</ul>
<p>不理解的话，具体看接口就理解了。<br>两者继承自<code>AbstractBootstrap</code>的接口有两类。</p>
<p>第一类, 返回<code>B</code>的,参照上面的声明，这里的<code>B</code>类型其实就是自身的类型,具体映射如下:<br><code>Bootstrap</code>: <code>B</code>=<code>Bootstrap</code>,<code>C</code>=<code>Channel</code>;<br><code>ServerBootstrap</code>:<code>B</code>=<code>ServerBootstrap</code>,<code>C</code>=<code>ServerChannel</code>:<br>记住这个映射关系,就能看懂下面的源码了:(Netty4)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> B <span class="title">channel</span><span class="params">(Class&lt;? extends C&gt; channelClass)</span> </span>&#123;<span class="comment">// 设置Channel</span></span><br><span class="line">        <span class="keyword">if</span> (channelClass == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"channelClass"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> channelFactory(<span class="keyword">new</span> ReflectiveChannelFactory&lt;C&gt;(channelClass));</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> B <span class="title">group</span><span class="params">(EventLoopGroup group)</span></span>;<span class="comment">// 设置EventLoop实现</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> B <span class="title">localAddress</span><span class="params">(SocketAddress localAddress)</span> </span>&#123;<span class="comment">// 设置本地地址</span></span><br><span class="line">        <span class="keyword">this</span>.localAddress = localAddress;</span><br><span class="line">        <span class="keyword">return</span> (B) <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> B <span class="title">localAddress</span><span class="params">(String inetHost, <span class="keyword">int</span> inetPort)</span> </span>&#123;<span class="comment">// 设置本地地址</span></span><br><span class="line">        <span class="keyword">return</span> localAddress(SocketUtils.socketAddress(inetHost, inetPort));</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">B <span class="title">option</span><span class="params">(ChannelOption&lt;T&gt; option, T value)</span> </span>&#123; <span class="comment">// 设置全局ChannelOption</span></span><br><span class="line">        <span class="keyword">if</span> (option == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"option"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (options) &#123;</span><br><span class="line">                options.remove(option);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (options) &#123;</span><br><span class="line">                options.put(option, value);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (B) <span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">B <span class="title">attr</span><span class="params">(AttributeKey&lt;T&gt; key, T value)</span></span>;<span class="comment">// 设置Channel的属性，后文会具体提到</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> B <span class="title">handler</span><span class="params">(ChannelHandler handler)</span>；<span class="comment">// 设置添加到pipeline的handler</span></span></span><br></pre></td></tr></table></figure>

<p>另一类接口是返回<code>ChannelFuture</code>的:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">bind</span><span class="params">()</span></span>; <span class="comment">// 绑定channel</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">connect</span><span class="params">()</span></span>; <span class="comment">// 连接到远程节点</span></span><br></pre></td></tr></table></figure>
<p>综上大致有两类接口:</p>
<ol>
<li>进行全局配置;</li>
<li>进行具体action。</li>
</ol>
<h1 id="Bootstrap-客户端-无连接服务端"><a href="#Bootstrap-客户端-无连接服务端" class="headerlink" title="Bootstrap: 客户端/无连接服务端"></a>Bootstrap: 客户端/无连接服务端</h1><p><code>Bootstrap</code>一般用于客户端，也可以用于无连接协议的服务端。<br>程序员可以通过<code>Bootstrap</code>上的接口设置一些程序需要的组件具体实现是什么。</p>
<p>两种引导行为:<br><code>bind</code>: (服务端) 绑定本地服务到某个端口, 然后创建一个Channel，准备接受连接;<br><code>connect</code>: (客户端) 创建一个Channel，连接远端服务。</p>
<p>简单客户端:<br>要点:<br>配置: 必须配置好group,channel和handler, 然后<code>connect</code>。<br>// channel或者channelFactory</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bootstrap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//设置 EventLoopGroup，提供用于处理 Channel 事件的 EventLoop</span></span><br><span class="line">        EventLoopGroup group = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        <span class="comment">//创建一个Bootstrap类的实例以创建和连接新的客户端Channel</span></span><br><span class="line">        Bootstrap bootstrap = <span class="keyword">new</span> Bootstrap();</span><br><span class="line">        bootstrap.group(group)</span><br><span class="line">            .channel(NioSocketChannel<span class="class">.<span class="keyword">class</span>) // <span class="title">NIO</span></span></span><br><span class="line"><span class="class">            .<span class="title">handler</span>(<span class="title">new</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">ByteBuf</span>&gt;() </span>&#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">                    ChannelHandlerContext channelHandlerContext,</span></span></span><br><span class="line"><span class="function"><span class="params">                    ByteBuf byteBuf)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    System.out.println(<span class="string">"Received data"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">        <span class="comment">//连接到远程主机</span></span><br><span class="line">        ChannelFuture future = bootstrap.connect(</span><br><span class="line">            <span class="keyword">new</span> InetSocketAddress(<span class="string">"xxx.com"</span>, <span class="number">80</span>));</span><br><span class="line">        future.addListener(<span class="keyword">new</span> ChannelFutureListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(ChannelFuture channelFuture)</span></span></span><br><span class="line"><span class="function">                <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (channelFuture.isSuccess()) &#123;</span><br><span class="line">                    System.out.println(<span class="string">"Connection established"</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    System.err.println(<span class="string">"Connection attempt failed"</span>);</span><br><span class="line">                    channelFuture.cause().printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h1 id="ServerBootstrap-服务端"><a href="#ServerBootstrap-服务端" class="headerlink" title="ServerBootstrap: 服务端"></a>ServerBootstrap: 服务端</h1><p><code>ServerBootstrap</code>比普通的<code>Bootstrap</code>多了几个接口:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">childOption: 后续accept的子Channel的配置; <span class="comment">// bind后生效</span></span><br><span class="line">childAttr: 设置给 已经accept 的子Channel属性; </span><br><span class="line">childHanlder: 设置给 已经accept 的子Channel的pipeline。</span><br></pre></td></tr></table></figure>
<p>作为对比的三个接口:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">option: 后续新建的serverChannel的配置; <span class="comment">// bind后生效</span></span><br><span class="line">attr: 设置给当前serverChannel的属性;</span><br><span class="line">handler: 设置给当前serverChannel的pipeline。</span><br></pre></td></tr></table></figure>
<p>容易混淆的就是Option用于配置固定的几个参数比如超时时间,Attr用于存自定义属性。</p>
<h2 id="ServerChannel"><a href="#ServerChannel" class="headerlink" title="ServerChannel"></a>ServerChannel</h2><p>accept新连接后,<code>ServerChannel</code>创建<code>子Channel</code>。<br>// <code>子Channel</code>代表已被接受的连接</p>
<img src="/images/2018-09/8.3.png" class="" width="400" height="600" title="serverChannel"> 
<p>工程过程:</p>
<ol>
<li>调用bind，创建<code>ServerChannel</code>, 绑定到本地端口开始提供服务;</li>
<li>接受1个新连接, <code>ServerChannel</code>创建1个新的<code>子Channel</code>。</li>
</ol>
<p>简单服务端:<br>要点: 配置group,channel,childHandler，然后<code>bind</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码清单 8-4 引导服务器</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bootstrap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        NioEventLoopGroup group = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        ServerBootstrap bootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">        <span class="comment">// 1. 设置:</span></span><br><span class="line">        bootstrap.group(group)</span><br><span class="line">            .channel(NioServerSocketChannel<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">            .<span class="title">childHandler</span>(<span class="title">new</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">ByteBuf</span>&gt;() </span>&#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext channelHandlerContext,</span></span></span><br><span class="line"><span class="function"><span class="params">                    ByteBuf byteBuf)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    System.out.println(<span class="string">"Received data"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        <span class="comment">// 2. bind: 通过配置好的 ServerBootstrap 的实例绑定该 Channel</span></span><br><span class="line">        ChannelFuture future = bootstrap.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">8080</span>));</span><br><span class="line">        <span class="comment">// 3. listener future:</span></span><br><span class="line">        future.addListener(<span class="keyword">new</span> ChannelFutureListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(ChannelFuture channelFuture)</span></span></span><br><span class="line"><span class="function">                <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (channelFuture.isSuccess()) &#123;</span><br><span class="line">                    System.out.println(<span class="string">"Server bound"</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    System.err.println(<span class="string">"Bind attempt failed"</span>);</span><br><span class="line">                    channelFuture.cause().printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h1 id="从Channel引导客户端-ServerBootstrap需要connect别的Server时"><a href="#从Channel引导客户端-ServerBootstrap需要connect别的Server时" class="headerlink" title="从Channel引导客户端(ServerBootstrap需要connect别的Server时)"></a>从Channel引导客户端(ServerBootstrap需要connect别的Server时)</h1><p>假设我们有一个<code>ServerBootstrap</code>，提供服务，收到一个请求，发现需要另一个服务的帮助。（相当于我们需要提供代理）<br>两种解决方案:</p>
<ol>
<li>再起一个<code>Bootstrap</code>，去<code>connect</code>另一个服务，获得结果再返回;</li>
<li>和1类似,稍有不同的时, 当前链路复用同一个<code>EventLoop</code>。</li>
</ol>
<p>方案2的优点:</p>
<ol>
<li>避免创建额外的线程; </li>
<li>减少上下文切换开销.</li>
</ol>
<p>示意图如下:</p>
<img src="/images/2018-09/8.4.png" class="" width="400" height="600" title="复合bootstrap">
<p>相关代码如下。<br>要点其实只有一句话:<br><code>bootstrap.group(ctx.channel().eventLoop());</code><br>这里用<code>EventLoop</code>填充<code>EventLoopGroup</code>，类似于子类对象填入基类指针。<br>因为<code>EventLoop</code>和<code>EventLoopGroup</code>的关系如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">EventLoop</span> <span class="keyword">extends</span> <span class="title">OrderedEventExecutor</span>, <span class="title">EventLoopGroup</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function">EventLoopGroup <span class="title">parent</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代理服务器代码: </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bootstrap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ServerBootstrap bootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">        <span class="comment">// 1. 配置:</span></span><br><span class="line">        bootstrap.group(<span class="keyword">new</span> NioEventLoopGroup(), <span class="keyword">new</span> NioEventLoopGroup())</span><br><span class="line">            .channel(NioServerSocketChannel<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">            .<span class="title">childHandler</span>(// 注意是<span class="title">childHandler</span></span></span><br><span class="line"><span class="class">                <span class="title">new</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">ByteBuf</span>&gt;() </span>&#123;</span><br><span class="line">                    ChannelFuture connectFuture; <span class="comment">// handler的成员变量</span></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span></span></span><br><span class="line"><span class="function">                        <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                        <span class="comment">// 1.1 新建boostrap</span></span><br><span class="line">                        Bootstrap bootstrap = <span class="keyword">new</span> Bootstrap();</span><br><span class="line">                        bootstrap.channel(NioSocketChannel<span class="class">.<span class="keyword">class</span>).<span class="title">handler</span>(</span></span><br><span class="line"><span class="class">                        // 注意是<span class="title">Handler</span></span></span><br><span class="line"><span class="class">                            <span class="title">new</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">ByteBuf</span>&gt;() </span>&#123;</span><br><span class="line">                                <span class="meta">@Override</span></span><br><span class="line">                                <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">                                    ChannelHandlerContext ctx, ByteBuf in)</span></span></span><br><span class="line"><span class="function">                                    <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                                    System.out.println(<span class="string">"Received data"</span>);</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;);</span><br><span class="line">                        <span class="comment">// 1.2 bootstrap配置: 使用channel的eventLoop引用:</span></span><br><span class="line">                        bootstrap.group(ctx.channel().eventLoop());</span><br><span class="line">                        connectFuture = bootstrap.connect(</span><br><span class="line">                            <span class="keyword">new</span> InetSocketAddress(<span class="string">"xxx.com"</span>, <span class="number">80</span>));</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">                        ChannelHandlerContext channelHandlerContext,</span></span></span><br><span class="line"><span class="function"><span class="params">                            ByteBuf byteBuf)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                        <span class="keyword">if</span> (connectFuture.isDone()) &#123; </span><br><span class="line">                            <span class="comment">// 1.3: 当连接完成时，执行一些数据操作（如代理）</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 2. bind: </span></span><br><span class="line">        ChannelFuture future = bootstrap.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">8080</span>));</span><br><span class="line">        future.addListener(<span class="keyword">new</span> ChannelFutureListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(ChannelFuture channelFuture)</span></span></span><br><span class="line"><span class="function">                <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (channelFuture.isSuccess()) &#123;</span><br><span class="line">                    System.out.println(<span class="string">"Server bound"</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    System.err.println(<span class="string">"Bind attempt failed"</span>);</span><br><span class="line">                    channelFuture.cause().printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以注意到还有一个与之前不同的奇异点:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bootstrap.group(<span class="keyword">new</span> NioEventLoopGroup(), <span class="keyword">new</span> NioEventLoopGroup())</span><br></pre></td></tr></table></figure>
<p>这里其实为<code>ServerChannel</code>和<code>子Channel</code>设置了不同的<code>EventLoopGroup</code>。以前都是设置成同一个的。<br>查看源码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ServerBootstrap <span class="title">group</span><span class="params">(EventLoopGroup group)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> group(group, group);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> ServerBootstrap <span class="title">group</span><span class="params">(EventLoopGroup parentGroup, EventLoopGroup childGroup)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.group(parentGroup);</span><br><span class="line">    <span class="keyword">if</span> (childGroup == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"childGroup"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.childGroup != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"childGroup set already"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.childGroup = childGroup;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此外，客户端使用<code>handler</code>,服务端使用<code>childhandler</code>。</p>
<h1 id="ChannelInitialize"><a href="#ChannelInitialize" class="headerlink" title="ChannelInitialize"></a>ChannelInitialize</h1><p>如果有多个<code>ChannelHandler</code>，一般会使用<code>ChannelInitialize</code>来添加：</p>
<ol>
<li><p><code>childHandler</code>里传入一个<code>ChannelInitialize</code>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bootstrap.group(<span class="keyword">new</span> NioEventLoopGroup(), <span class="keyword">new</span> NioEventLoopGroup())</span><br><span class="line">            .channel(NioServerSocketChannel<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">            .<span class="title">childHandler</span>(<span class="title">new</span> <span class="title">ChannelInitializerImpl</span>())</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>ChannelInitializerImpl</code>里依次添加真正的<code>handler</code>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ChannelInitializerImpl</span> <span class="keyword">extends</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">Channel</span>&gt; </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(Channel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">            pipeline.addLast(<span class="keyword">new</span> HttpClientCodec());</span><br><span class="line">            pipeline.addLast(<span class="keyword">new</span> HttpObjectAggregator(Integer.MAX_VALUE));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>这里用的是<code>ChannelInitializer&lt;Channel&gt;</code>，所以方法会应用到<code>SocketChannel</code>和<code>Channel</code>。<br>如果只想应用到<code>SocketChannel</code>，可以用<code>ChannelInitializer&lt;SocketChannel&gt;</code>。</p>
<h1 id="ChannelOption-Attr"><a href="#ChannelOption-Attr" class="headerlink" title="ChannelOption,Attr"></a>ChannelOption,Attr</h1><h3 id="ChannelOption"><a href="#ChannelOption" class="headerlink" title="ChannelOption:"></a>ChannelOption:</h3><p><code>bootstrap</code>的<code>option</code>方法可以用来设置之后创建的<code>channel</code>公用的配置项:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bootstrap.option(ChannelOption.SO_KEEPALIVE, <span class="keyword">true</span>)</span><br><span class="line">         .option(ChannelOption.CONNECT_TIMEOUT_MILLIS, <span class="number">5000</span>);</span><br></pre></td></tr></table></figure>
<p>可以设置底层连接的超时时间以及缓冲区设置。</p>
<h3 id="Attr"><a href="#Attr" class="headerlink" title="Attr"></a>Attr</h3><p><code>attr</code>则用来存储一些<code>Channel</code>公用自定义属性:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 声明:</span></span><br><span class="line"><span class="keyword">final</span> AttributeKey&lt;Integer&gt; id = AttributeKey.newInstance(<span class="string">"ID"</span>);</span><br><span class="line">Bootstrap bootstrap = <span class="keyword">new</span> Bootstrap();</span><br><span class="line"><span class="comment">// 2. 赋值:</span></span><br><span class="line">bootstrap.attr(id, <span class="number">123456</span>);</span><br><span class="line"><span class="comment">// 2. 使用:(某个handler里头:)</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRegistered</span><span class="params">(ChannelHandlerContext ctx)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Integer idValue = ctx.channel().attr(id).get();</span><br><span class="line">    <span class="comment">// do something with the idValue</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出两者都是整个<code>bootstrap</code>共用的，换言之是所有<code>Channel</code>共用的。</p>
<p>// 对于服务端来说可以使用<code>childOption</code>和<code>childAttr</code>。</p>
<h1 id="DatagramChannel-无连接"><a href="#DatagramChannel-无连接" class="headerlink" title="DatagramChannel/无连接"></a>DatagramChannel/无连接</h1><p>FileChannel：文件通道，用于文件的读写<br>DatagramChannel：用于UDP连接的接收和发送<br>SocketChannel：TCP客户端<br>ServerSocketChannel：TCP服务端</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. OIO版本:</span></span><br><span class="line">Bootstrap bootstrap = <span class="keyword">new</span> Bootstrap();</span><br><span class="line">        bootstrap.group(<span class="keyword">new</span> OioEventLoopGroup()).channel(</span><br><span class="line">            OioDatagramChannel<span class="class">.<span class="keyword">class</span>).<span class="title">handler</span>(</span></span><br><span class="line"><span class="class">            <span class="title">new</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">DatagramPacket</span>&gt;() </span>&#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx,</span></span></span><br><span class="line"><span class="function"><span class="params">                    DatagramPacket msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    <span class="comment">// Do something with the packet</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        );</span><br><span class="line">ChannelFuture future = bootstrap.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. NIO版本</span></span><br><span class="line"><span class="comment">// 服务端:</span></span><br><span class="line"><span class="keyword">final</span> NioEventLoopGroup nioEventLoopGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">Bootstrap bootstrap = <span class="keyword">new</span> Bootstrap();</span><br><span class="line">bootstrap.channel(NioDatagramChannel<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">bootstrap.group(nioEventLoopGroup);</span><br><span class="line">bootstrap.handler(<span class="keyword">new</span> ChannelInitializer&lt;NioDatagramChannel&gt;() &#123;...&#125;);</span><br><span class="line">ChannelFuture sync = bootstrap.bind(<span class="number">9009</span>).sync();</span><br><span class="line">Channel udpChannel = sync.channel();</span><br><span class="line">sync.closeFuture().await();<span class="comment">// 等待关闭。</span></span><br><span class="line"><span class="comment">// 客户端:</span></span><br><span class="line"><span class="keyword">final</span> NioEventLoopGroup nioEventLoopGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">Bootstrap bootstrap = <span class="keyword">new</span> Bootstrap();</span><br><span class="line">bootstrap.channel(NioDatagramChannel<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">bootstrap.group(nioEventLoopGroup);</span><br><span class="line">bootstrap.handler(<span class="keyword">new</span> ChannelInitializer&lt;NioDatagramChannel&gt;() &#123;...&#125;);</span><br><span class="line">ChannelFuture sync = bootstrap.bind(<span class="number">0</span>).sync();</span><br><span class="line">Channel udpChannel = sync.channel();</span><br><span class="line">String data = <span class="string">"data"</span>;</span><br><span class="line">udpChannel.writeAndFlush(<span class="keyword">new</span> DatagramPacket(Unpooled.copiedBuffer(data.getBytes(Charset.forName(<span class="string">"UTF-8"</span>))), <span class="keyword">new</span> InetSocketAddress(<span class="string">"192.168.2.29"</span>, <span class="number">9008</span>)));</span><br><span class="line">sync.closeFuture().await();<span class="comment">// 等待关闭。</span></span><br></pre></td></tr></table></figure>
<p>可以看出客户端和服务端是一样的。<br>都是用<code>Bootstrap</code>,<code>bind</code>方法。</p>
<h1 id="关闭"><a href="#关闭" class="headerlink" title="关闭"></a>关闭</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//shutdownGracefully()方法将释放所有的资源，并且关闭所有的当前正在使用中的 Channel</span></span><br><span class="line">Future&lt;?&gt; future = group.shutdownGracefully();</span><br><span class="line"><span class="comment">// block until the group has shutdown</span></span><br><span class="line">future.syncUninterruptibly();</span><br></pre></td></tr></table></figure>

<p>此外之前也可以用<code>channel.close()</code>手动关闭一些<code>channel</code>。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://xiaoyue26.github.io/2018/09/17/2018-09/Netty-in-action%E7%AC%AC%E5%85%AB%E7%AB%A0-%E5%BC%95%E5%AF%BC-%E7%AC%94%E8%AE%B0/" data-id="ck96cxpoj00demaamale135vj" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Netty/" rel="tag">Netty</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/" rel="tag">java</a></li></ul>

    </footer>
  </div>
  
</article>
 


  


  <nav id="page-nav">
    <a class="extend prev" rel="prev" href="/page/10/">&amp;laquo; 上一页</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/9/">9</a><a class="page-number" href="/page/10/">10</a><span class="page-number current">11</span><a class="page-number" href="/page/12/">12</a><a class="page-number" href="/page/13/">13</a><span class="space">&hellip;</span><a class="page-number" href="/page/23/">23</a><a class="extend next" rel="next" href="/page/12/">下一页&amp;raquo;</a>
  </nav>
</section>
           
    <aside id="sidebar">
  
    

  
    
  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title recent-posts">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/09/26/2022-09/%E5%B7%B2%E7%9F%A5%E6%98%8E%E6%96%87%E7%A0%B4%E8%A7%A3zip/">已知明文破解zip</a>
          </li>
        
          <li>
            <a href="/2022/09/26/2022-09/jwt%E7%A0%B4%E8%A7%A3/">jwt破解</a>
          </li>
        
          <li>
            <a href="/2022/09/25/2022-09/nc%E5%91%BD%E4%BB%A4%E7%AC%94%E8%AE%B0/">nc命令笔记</a>
          </li>
        
          <li>
            <a href="/2022/09/25/2022-09/%E8%B0%83%E4%BC%98-%E8%A7%A3%E5%86%B3%E7%BA%BF%E7%A8%8B%E6%B1%A0%E9%80%A0%E6%88%90%E7%9A%84%E8%BF%9B%E7%A8%8B%E5%8D%A1%E9%A1%BF%E3%80%81cpu%E6%AF%9B%E5%88%BA%E9%97%AE%E9%A2%98/">调优-解决线程池造成的进程卡顿、cpu毛刺问题</a>
          </li>
        
          <li>
            <a href="/2022/08/30/2022-08/%E8%B0%83%E4%BC%98-cpu%E6%AF%9B%E5%88%BA%E9%97%AE%E9%A2%98/">调优-cpu毛刺问题</a>
          </li>
        
      </ul>
    </div>
  </div>

  
    

  
</aside>

      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-left">
      &copy; 2014 - 2022 风梦七&nbsp;|&nbsp;
      主题 <a href="https://github.com/giscafer/hexo-theme-cafe/" target="_blank">Cafe</a>
    </div>
     <div id="footer-right">
      联系方式&nbsp;|&nbsp;296671657@qq.com
    </div>
  </div>
</footer>
 
<script src="/jquery/jquery.min.js"></script>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">首页</a>
  
    <a href="/archives" class="mobile-nav-link">归档</a>
  
    <a href="/about" class="mobile-nav-link">关于</a>
  
</nav>
    <img class="back-to-top-btn" src="/images/fly-to-top.png"/>
<script>
// Elevator script included on the page, already.
window.onload = function() {
  var elevator = new Elevator({
    selector:'.back-to-top-btn',
    element: document.querySelector('.back-to-top-btn'),
    duration: 1000 // milliseconds
  });
}
</script>
      

  
    <script>
      var cloudTieConfig = {
        url: document.location.href, 
        sourceId: "",
        productKey: "e2fb4051c49842688ce669e634bc983f",
        target: "cloud-tie-wrapper"
      };
    </script>
    <script src="https://img1.ws.126.net/f2e/tie/yun/sdk/loader.js"></script>
    

  







<!-- author:forvoid begin -->
<!-- author:forvoid begin -->

<!-- author:forvoid end -->

<!-- author:forvoid end -->


  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      })
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      })
    </script>
    <script type="text/javascript" src="https://cdn.rawgit.com/mathjax/MathJax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


 
<script src="/js/is.js"></script>



  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>


<script src="/js/elevator.js"></script>

  </div>
</body>
</html>