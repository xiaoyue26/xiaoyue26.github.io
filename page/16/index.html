<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>笔记本</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="笔记本">
<meta property="og:url" content="http://xiaoyue26.github.io/page/16/index.html">
<meta property="og:site_name" content="笔记本">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="风梦七">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="笔记本" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    
  
  
<link rel="stylesheet" href="/css/style.css">

  

<meta name="generator" content="Hexo 4.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    
    <div id="header-inner" class="inner">
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://xiaoyue26.github.io"></form>
      </div>
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">首页</a>
        
          <a class="main-nav-link" href="/archives">归档</a>
        
          <a class="main-nav-link" href="/about">关于</a>
        
      </nav>
      
    </div>
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">笔记本</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">风梦七</a>
        </h2>
      
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-2018-01/java并发编程的艺术笔记-第二章" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/01/13/2018-01/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E7%AB%A0/" class="article-date">
  <time datetime="2018-01-13T13:29:19.000Z" itemprop="datePublished">2018-01-13</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/java/">java</a>►<a class="article-category-link" href="/categories/java/%E5%B9%B6%E5%8F%91/">并发</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/01/13/2018-01/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E7%AB%A0/">java并发编程的艺术笔记-第二章</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <h1 id="第二章-java并发机制的底层实现原理"><a href="#第二章-java并发机制的底层实现原理" class="headerlink" title="第二章 java并发机制的底层实现原理"></a>第二章 java并发机制的底层实现原理</h1><ul>
<li>java代码执行流程</li>
</ul>
<ol>
<li>java代码编译成class文件(字节码);</li>
<li>class被类加载器加载到JVM中;</li>
<li>JVM执行class,生成汇编码;</li>
<li>汇编码(转化成机器码/cpu指令)在cpu上执行.</li>
</ol>
<p>因此java并发机制的底层实现依赖于两个层面:</p>
<ol>
<li>class=&gt;汇编码过程中增加的指令;</li>
<li>并发相关cpu指令的具体执行过程. </li>
</ol>
<h2 id="2-1-volatile"><a href="#2-1-volatile" class="headerlink" title="2.1 volatile"></a>2.1 volatile</h2><ul>
<li><p>定义<br>可见性. 对于volatile变量,所有线程看到的值是一致的.<br>换句话说,某个线程对于volatile的修改能立即生效.</p>
</li>
<li><p>实现</p>
</li>
</ul>
<ol>
<li>class=&gt;指令: 增加Lock指令</li>
<li>Lock指令具体执行:<br>(1) 将当前cpu包含该值的缓存行写回内存;<br>(2) 在总线上通知其他cpu这个地址已发生更改,需要刷新缓存.<br>(缓存一致性协议)</li>
</ol>
<ul>
<li>相关优化<br>由于上述实现中的2(1)为:”将当前cpu包含该值的缓存行写回内存”,<br>换句话说,如果这个值跨行了,就会影响两行的数据,也就会导致两行的缓存失效,<br>其他cpu刷新缓存的数据量变成两倍.<br>因此尽量要把数据对齐到一行. (比如32位,64位)</li>
</ul>
<h2 id="2-2-synchronized"><a href="#2-2-synchronized" class="headerlink" title="2.2 synchronized"></a>2.2 synchronized</h2><p>内置锁,锁某个对象.(可以是当前实例对象或当前类对象)</p>
<ul>
<li>实现</li>
</ul>
<ol>
<li><p>class=&gt;指令:<br>增加:<br>进入同步块: monitorenter<br>离开同步块: monitorexit (正常离开或者异常)</p>
</li>
<li><p>cpu对这俩指令的执行书里没有细讲,只说了对象头里相关数据是怎么存的.</p>
</li>
</ol>
<h3 id="2-2-1-对象头中锁相关数据"><a href="#2-2-1-对象头中锁相关数据" class="headerlink" title="2.2.1 对象头中锁相关数据"></a>2.2.1 对象头中锁相关数据</h3><ul>
<li>对象头内容</li>
</ul>
<ol>
<li>Mark Word: hashCode/分代年龄/锁信息. </li>
<li>类元数据地址;</li>
<li>数组长度. // 如果是数组</li>
</ol>
<ul>
<li>不同锁标志的信息</li>
</ul>
<ol>
<li>轻量级锁: 指向栈中锁记录的指针;   // 锁标志00</li>
<li>重量级锁: 指向互斥量的指针    ;   // 锁标志10</li>
<li>GC标记  : 空;                     // 锁标志11</li>
<li>偏向锁  : 线程ID,epoch,分代年龄,1; // 锁标志01</li>
</ol>
<p>锁的4种状态: (锁只能升级,不能降级)</p>
<ol>
<li>无锁;</li>
<li>偏向锁: 一个线程使用该对象;</li>
<li>轻量级锁: 多个线程交替使用该对象;</li>
<li>重量级锁: 多个线程同时竞争该对象. </li>
</ol>
<p><strong>偏向锁</strong><br>HotSpot作者:<br>大多数情况下不存在多个线程竞争一个对象,这个时候可以优化让线程获得锁的代价更低.</p>
<ul>
<li>获取偏向锁流程</li>
</ul>
<ol>
<li>检查对象头里线程ID是不是自己或者是否无锁状态;</li>
<li>复制对象头中Mark Word到栈中;</li>
<li>在副本上写线程ID为自己ID;</li>
<li>CAS,用副本替换Mark Word,获得偏向锁. </li>
</ol>
<p>如果成功的话,下次进入同步块的时候,只要第1步能成功,就不再需要CAS操作了.<br>换句话说,这种场景下, 同一个线程可以重入同一个对象的锁,只有第一次需要CAS操作(代价比较大的操作).</p>
<ul>
<li>偏向锁的撤销(也就是对象头中存储的线程ID改掉)</li>
</ul>
<ol>
<li>别的线程也申请这个锁;</li>
<li>之前拥有锁的线程不存活=&gt; 对象头设置成无锁;</li>
<li>之前拥有锁的线程存活 =&gt; 锁升级.</li>
</ol>
<p><strong>轻量级锁</strong></p>
<ul>
<li>获取轻量级锁流程</li>
</ul>
<ol>
<li>检查</li>
<li>复制对象头中Mark word到栈中;</li>
<li>副本中写指向自己锁记录的指针;</li>
<li>CAS,用副本替换Mark word,获得偏向锁. </li>
</ol>
<p>如果第4步失败,尝试先不阻塞,使用自旋获取锁.(有可能已经拥有这个锁,试试看)<br>如果又失败,膨胀(升级)为重量级锁.</p>
<ul>
<li>轻量级锁的解锁</li>
</ul>
<ol>
<li>CAS还原复制的对象头.</li>
</ol>
<p>如果成功,就解锁;<br>如果失败,说明除了自己还有别人也改过对象头.膨胀为重量级锁.</p>
<p>对比:</p>
<ol>
<li>偏向锁: 打个自己的标记;</li>
<li>轻量级锁: 不阻塞,自旋重试;</li>
<li>重量级锁: 阻塞,等待唤醒.</li>
</ol>
<h2 id="2-3-原子操作实现原理"><a href="#2-3-原子操作实现原理" class="headerlink" title="2.3 原子操作实现原理"></a>2.3 原子操作实现原理</h2><ol>
<li>总线锁: 某个cpu用Lock指令锁总线,独占内存; // 开销大</li>
<li>缓存锁: 某个cpu修改内存地址,使其他cpu缓存无效.//开销小</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://xiaoyue26.github.io/2018/01/13/2018-01/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E7%AB%A0/" data-id="ck96cxpnt00a6maamda4y0a46" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/" rel="tag">java</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-2018-01/谷歌的一致性哈希算法" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/01/13/2018-01/%E8%B0%B7%E6%AD%8C%E7%9A%84%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95/" class="article-date">
  <time datetime="2018-01-13T03:18:36.000Z" itemprop="datePublished">2018-01-13</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/01/13/2018-01/%E8%B0%B7%E6%AD%8C%E7%9A%84%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95/">谷歌的一致性哈希算法</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <h1 id="jump-consistent-hash"><a href="#jump-consistent-hash" class="headerlink" title="jump consistent hash"></a>jump consistent hash</h1><p><code>jump consistent hash</code>是谷歌发表的一种一致性哈希算法.<br>空间复杂度: O(1);<br>时间复杂度: O(lgn).</p>
<h2 id="设计目标："><a href="#设计目标：" class="headerlink" title="设计目标："></a>设计目标：</h2><p>1.平衡性，把对象均匀地分布在所有桶中。(这个大部分哈希算法都能做到)<br>2.单调性，当桶的数量变化时，只需要把最少量的对象从旧桶移动到新桶，不需要做更多移动。比如原来是10个桶,增加了10个桶,只需要移动一半的对象就好了.<br>(更改算法的输入参数n,会有一半的对象依然映射到原来的桶里,有一半的对象映射到新的桶里.)</p>
<h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><p>记 <code>ch(key,num_buckets)</code> 为桶数量为<code>num_buckets</code>时的<code>hash</code>函数,返回分配的桶下标。</p>
<ul>
<li><p>num_buckets=1时:<br>由于只有1个桶，显而易见，对任意k，有<code>ch(k,1)==0</code>。</p>
</li>
<li><p>num_buckets=2时:<br>为了使hash的结果保持均匀，ch(k,2)的结果应该有占比1/2的结果保持为0，有1/2跳变为1。</p>
</li>
</ul>
<p>由此可以归纳，一般规律是：</p>
<blockquote>
<p><code>num_buckets</code>从<code>n</code>变化到<code>n+1</code>后，<br><code>ch(k,n+1)</code> 的结果中，应该有占比 <code>n/(n+1)</code> 的结果保持不变，<br>而有 <code>1/(n+1)</code> 跳变为 <code>n+1</code>。</p>
</blockquote>
<p>因此，我们可以用一个随机数生成器，来决定每次要不要跳变，并且让这个随机数生成器的状态仅仅依赖于<code>key</code>。所以就得到下面这个初步代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ch</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> num_buckets)</span> </span>&#123;</span><br><span class="line">    random.seed(key) ;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; num_buckets; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (random.next() &lt; <span class="number">1.0</span>/(j+<span class="number">1</span>) ) &#123;</span><br><span class="line">            b = j ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="算法正确性"><a href="#算法正确性" class="headerlink" title="算法正确性"></a>算法正确性</h2><p>(0-based)<br>n个桶,从0开始往n-2跳变(n-2次)，每次跳变的概率依次是<code>1/2</code>,<code>1/3</code>,<code>1/4</code>…<code>1/n</code>。<br>从而保证keys在每个桶分布的概率均匀。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">P(b&#x3D;0(初始值)) &#x3D;每次都不变&#x3D;1&#x2F;2*2&#x2F;3*3&#x2F;4...(n-2)&#x2F;(n-1)*(n-1)&#x2F;n&#x3D;1&#x2F;n;</span><br><span class="line">P(b&#x3D;1) &#x3D;1&#x2F;2(变)*2&#x2F;3(不变)*....&#x3D;1&#x2F;n;</span><br><span class="line">P(b&#x3D;2) &#x3D;1(变或者不变)*1&#x2F;3(变)*3&#x2F;4*...(n-1)&#x2F;n&#x3D;1&#x2F;n;</span><br><span class="line">P(b&#x3D;3) &#x3D;1(变或者不变)*1(变或者不变)*1&#x2F;4*4&#x2F;5...*(n-1)&#x2F;n&#x3D;1&#x2F;n;</span><br><span class="line">P(b&#x3D;k) &#x3D;1*1....1&#x2F;k(变)*k&#x2F;(k+1)...(n-1)&#x2F;n&#x3D;1&#x2F;n;</span><br><span class="line">P(b&#x3D;n-2) &#x3D;1&#x2F;n;</span><br><span class="line">P(b&#x3D;n-1) &#x3D;1- (上述所有的和)&#x3D;1-(n-1)&#x2F;(n-2)&#x3D;1&#x2F;n.</span><br></pre></td></tr></table></figure>

<h2 id="算法复杂度"><a href="#算法复杂度" class="headerlink" title="算法复杂度"></a>算法复杂度</h2><p>n为桶的数量的话,进行n-1次跳变判断,算法复杂度是O(n).</p>
<h1 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h1><h2 id="改进的思路"><a href="#改进的思路" class="headerlink" title="改进的思路"></a>改进的思路</h2><p>通过随机数，确定下一个跳变的j，而不是对每一个位置进行跳变判断。<br>因为跳变的概率从1/2开始一直在减少，所以依概率来说每次跳变的间隔大于1,所以计算下一个跳变值的次数少于n-1.</p>
<blockquote>
<p>定义P(b,j&gt;=i)的含义为: 当前跳变值为b时,下一个跳变值为j,j&gt;=i的概率. </p>
</blockquote>
<p>假设我们使用0-base的数组,则下标i位置不变的概率为: <code>(i+1)/(i+2)</code><br>下一个跳变值j&gt;=i时,也就是[b+1,i-2]区间内保持不变,因此有:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">P(b,j&gt;&#x3D;b)&#x3D;1 &#x2F;&#x2F;(显然下一个跳变值&gt;b)</span><br><span class="line">P(b,j&gt;&#x3D;b+1)&#x3D;1 &#x2F;&#x2F;(显然下一个跳变值&gt;&#x3D;b+1)</span><br><span class="line">P(b,j&gt;&#x3D;b+2)&#x3D;1*(b+1&#x2F;b+2)</span><br><span class="line">...</span><br><span class="line">P(b,j&gt;&#x3D;i)&#x3D; 1*(b+1&#x2F;b+2)*(b+2)&#x2F;(b+3)...(i-1)&#x2F;i &#x3D; (b+1)&#x2F;i</span><br></pre></td></tr></table></figure>

<p>假设有一个在[0,1]区间均匀分布的随机变量R,由于均匀分布的特性,R &lt; k的概率为 k.<br>(例如R&lt; 0.3的概率为0.3),P(R&lt;(b+1)/i)= (b+1)/i = P(j&gt;=i);</p>
<p>因此可以生成一个[0,1]范围的随机数r,规定r&lt;(b+1)/i的时候,就有j&gt;=i;<br>因此 i&lt;(b+1)/r. 由于对于任意的i都有j&gt;=i,因此:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">j&#x3D;floor( (b+1)&#x2F;r)，</span><br></pre></td></tr></table></figure>
<p>这样我们用一个随机数r得到了j。</p>
<p>改进后代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ch</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> num_buckets)</span> </span>&#123;</span><br><span class="line">    random.seed(key) ;</span><br><span class="line">    <span class="keyword">int</span> b = -<span class="number">1</span>; <span class="comment">//  上次跳变值</span></span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>; <span class="comment">// 这次跳变值</span></span><br><span class="line">    <span class="keyword">while</span>(j&lt;num_buckets)&#123;<span class="comment">// j不能超出范围</span></span><br><span class="line">        b=j; </span><br><span class="line">        <span class="keyword">double</span> r=random.next(); <span class="comment">//  0&lt;r&lt;1.0</span></span><br><span class="line">        j = floor( (b+<span class="number">1</span>) /r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中r为<code>[0,1]</code>区间的随机数(均匀分布)。<br>算法中使用了一个64位的线性同余随机数生成器。<br>结果分布的均匀性与输入<code>key</code>的分布无关，由伪随机数生成器的均匀性保证。<br>由于用的是伪随机数,生成器由<code>key</code>进行seed,因此能保证一致性.</p>
<h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>根据概率计算.<br>由于r平均为0.5,因此j平均来说是成倍增长的,因此改进后算法的平均时间复杂度为：<code>O(log(n))</code></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://xiaoyue26.github.io/2018/01/13/2018-01/%E8%B0%B7%E6%AD%8C%E7%9A%84%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95/" data-id="ck96cxpns00a2maam6rh0b1uq" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C/" rel="tag">一致性哈希</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-2018-01/java并发编程实战笔记-15-16章" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/01/07/2018-01/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0-15-16%E7%AB%A0/" class="article-date">
  <time datetime="2018-01-07T12:15:33.000Z" itemprop="datePublished">2018-01-07</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/java/">java</a>►<a class="article-category-link" href="/categories/java/%E5%B9%B6%E5%8F%91/">并发</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/01/07/2018-01/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0-15-16%E7%AB%A0/">java并发编程实战-15-16章</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <h1 id="第十五章-原子变量与非阻塞同步机制"><a href="#第十五章-原子变量与非阻塞同步机制" class="headerlink" title="第十五章 原子变量与非阻塞同步机制"></a>第十五章 原子变量与非阻塞同步机制</h1><p>并发包里的工具(如信号量<code>Semaphore</code>和<code>ConcurrentLinkedQueue</code>)<br>比<code>synchronized</code>性能更好,伸缩性更好.<br>原因是使用了<code>原子变量与非阻塞同步机制</code>.</p>
<p>非阻塞的底层: CAS操作. (compare and swap)<br>没有锁,<code>Lock free</code>,因此更接近完美.<br>因此没有活跃性问题.</p>
<h2 id="15-1-锁的劣势"><a href="#15-1-锁的劣势" class="headerlink" title="15.1 锁的劣势"></a>15.1 锁的劣势</h2><p>性能不行.</p>
<h2 id="15-2-硬件对并发的支持"><a href="#15-2-硬件对并发的支持" class="headerlink" title="15.2 硬件对并发的支持"></a>15.2 硬件对并发的支持</h2><p>独占锁: 基于悲观假设,不互斥的话会出事.(悲观锁)<br>乐观方法: 特殊指令: 包括, Test And Set , Fetch and Increment, CAS, 条件存储.</p>
<h2 id="15-2-CAS-比较并交换"><a href="#15-2-CAS-比较并交换" class="headerlink" title="15.2 CAS 比较并交换"></a>15.2 CAS 比较并交换</h2><p><code>CAS</code>包括三个操作数: 内存位置,旧值,新值.<br>//类似对应java中<code>map</code>的<code>replace</code>操作的三个操作数: key,旧值,新值.</p>
<p>CAS操作失败的线程不会挂,会获得失败信息.(同步非阻塞)<br>可以反复重试. (类似于<code>poll</code>的轮询)</p>
<p>CAS的缺点:<br>需要调用者自己处理竞争问题.// 重试,回退,放弃.<br>CAS实现的非阻塞算法通常比用锁写复杂一些.</p>
<h2 id="15-3-原子变量类"><a href="#15-3-原子变量类" class="headerlink" title="15.3 原子变量类"></a>15.3 原子变量类</h2><p>包括<code>AtomicInteger</code>等等.提供各种原子操作,如CAS,自增等.<br>它和一样保证写后读,但还保证内容是原子更新的.(比如两块内存看似一起更新)</p>
<ul>
<li>tip:<blockquote>
<p>原子变量类不适合作为容器的Key.<br>容器的Key一般要是Immutable对象.(如Integer,String)</p>
</blockquote>
</li>
</ul>
<h2 id="15-4-具体案例"><a href="#15-4-具体案例" class="headerlink" title="15.4 具体案例"></a>15.4 具体案例</h2><p>这一节用CAS实现了链表,栈,原子的域更新器.<br>需要看着源码学习.</p>
<h3 id="15-4-4-ABA问题"><a href="#15-4-4-ABA问题" class="headerlink" title="15.4.4 ABA问题"></a>15.4.4 ABA问题</h3><p>CAS(V,A,B)需要判断V位置是否为A,然后替换为B.<br>但如果V位置发生变化: A-&gt;B-&gt;A.<br>这样其实和我们希望的条件已经不同了,本质上是变化了,只不过值没变,版本号变了.<br>实例来说,就是链表节点引用没变,引用的值已经变了.</p>
<p>解决方案:<br>使用<code>AtomicStampedReference</code>(以及<code>AtomicMarkableReference</code>)支持在两个变量上执行原子的条件更新. </p>
<ul>
<li><p><code>AtomicStampedReference</code><br>[对象,引用]二元组,在引用上加上版本号. </p>
</li>
<li><p><code>AtomicMarkableReference</code><br>[对象引用,布尔值]二元组,可标记节点为已删除的节点.</p>
</li>
</ul>
<h1 id="第十六章-java内存模型"><a href="#第十六章-java内存模型" class="headerlink" title="第十六章 java内存模型"></a>第十六章 java内存模型</h1><h2 id="16-1-概念"><a href="#16-1-概念" class="headerlink" title="16.1 概念"></a>16.1 概念</h2><p>为了性能,会进行指令重排,预测执行等等.<br>内存模型: <code>JMM</code>.<br>内存模型规定,优化(重排)时应该遵守哪些约束.</p>
<ul>
<li>串行一致性:<br>如果约束够用,执行结果就会和串行一样.</li>
</ul>
<h2 id="16-1-1-平台的内存模型"><a href="#16-1-1-平台的内存模型" class="headerlink" title="16.1.1 平台的内存模型"></a>16.1.1 平台的内存模型</h2><p>平台给出内存模型,约束自己,向外界保证xx条件下会发生什么.<br>提供接口/指令: 如内存栅栏,提供协调存储的接口.</p>
<h2 id="16-1-3-JAVA内存模型"><a href="#16-1-3-JAVA内存模型" class="headerlink" title="16.1.3 JAVA内存模型"></a>16.1.3 JAVA内存模型</h2><ol>
<li>程序顺序: 同一个线程里按源码顺序执行;</li>
<li>监视器锁: 解锁会在加锁之前;(A线程释放了,B线程才能获得锁)</li>
<li>volatile: 写后读. (原子变量也是)</li>
<li>线程启动: Thread.start之后才会有run等其他操作发生.</li>
<li>中断规则: (1)A线程中断B线程;(2)B检测到中断. 保证(1)在(2)前面. </li>
<li>终结器:   构造函数在终结器之前执行完成.</li>
<li>传递性:   上述规则可以传递.</li>
</ol>
<p>1是针对单一线程的,2-7都是针对多个线程之间的代码顺序.<br>口诀: 程锁原线中终传. </p>
<h2 id="16-1-4-借助同步"><a href="#16-1-4-借助同步" class="headerlink" title="16.1.4 借助同步"></a>16.1.4 借助同步</h2><p>也就是借助上述7个已有的约束设计代码,达到同步效果.<br>比如我们平时用的锁,就是利用用了第二条,监视器锁规则.</p>
<p>类库中提供的约束:</p>
<ol>
<li>线程安全容器: 写后读. </li>
<li><code>CountDownLatch</code>: 倒数操作在await返回之前.</li>
<li><code>Semaphore</code>: PV操作,V释放在P获得之前. (别人释放了,你才能获得)</li>
<li><code>Future</code>: get返回之前,任务的代码会执行完.</li>
<li><code>Executor</code>: 提交任务操作,将在执行任务操作之前.</li>
<li><code>CyclicBarrier</code>: (1)线程A到达栅栏;(2)其他线程离开栅栏. (1)会在(2)前面.换句话说,大家伙会等线程A到了才离开.<br>… </li>
</ol>
<h2 id="16-2-发布"><a href="#16-2-发布" class="headerlink" title="16.2 发布"></a>16.2 发布</h2><p>错误示例:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@NotThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Resource resource;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Resource <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(resource==<span class="keyword">null</span>)&#123;<span class="comment">// 显然多个线程会在这里冲突.</span></span><br><span class="line">            resource=<span class="keyword">new</span> Resource();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> resource;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>安全但是慢:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Resource resource;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> Resource <span class="title">getInstance</span><span class="params">()</span></span>&#123;<span class="comment">// 方法级同步</span></span><br><span class="line">        <span class="keyword">if</span>(resource==<span class="keyword">null</span>)&#123;</span><br><span class="line">            resource=<span class="keyword">new</span> Resource();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> resource;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>直接静态初始化:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">C</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Resource resource=<span class="keyword">new</span> Resource();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Resource <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> resource;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>占位符技术: 延迟静态初始化:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">D</span></span>&#123; </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ResourceHolder</span></span>&#123; <span class="comment">// 懒汉,完美. </span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> Resource resource=<span class="keyword">new</span> Resource();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Resource <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ResourceHolder.resource;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>双检(DCL): 不推荐. 慢,繁琐. </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">E</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Resource resource; <span class="comment">// volatile</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Resource <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(resource==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(E<span class="class">.<span class="keyword">class</span>)</span>&#123; <span class="comment">// Class对象锁.</span></span><br><span class="line">                <span class="keyword">if</span>(resource==<span class="keyword">null</span>)&#123;</span><br><span class="line">                    resource=<span class="keyword">new</span> Resource();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> resource;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 之所以需要volatile,是为了保证resource变量的写操作立即刷新到内存,起码在读之前. (StoreLoad屏障)</span></span><br></pre></td></tr></table></figure>



<h2 id="初始化安全域"><a href="#初始化安全域" class="headerlink" title="初始化安全域:"></a>初始化安全域:</h2><p>对象的初始引用不会被重排序到构造函数之前.</p>
<ul>
<li><code>final</code>:<br><code>final</code>域能够安全发布,通过<code>final</code>域可达的变量\容器的写入操作安全发布.</li>
</ul>
<p>示例:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SafeStates</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String,String&gt;States;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SafeStates</span><span class="params">()</span></span>&#123;</span><br><span class="line">        states= <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        states.put(<span class="string">"alaska"</span>,<span class="string">"AK"</span>);</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getV</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> states.get(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>线程A创建的SafeStates对象,线程B能安全得访问getV方法.</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://xiaoyue26.github.io/2018/01/07/2018-01/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0-15-16%E7%AB%A0/" data-id="ck96cxpnp009omaam6pwnfbf3" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/" rel="tag">java</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-2018-01/java并发编程实战笔记-10-11章" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/01/04/2018-01/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0-10-11%E7%AB%A0/" class="article-date">
  <time datetime="2018-01-04T14:28:55.000Z" itemprop="datePublished">2018-01-04</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/java/">java</a>►<a class="article-category-link" href="/categories/java/%E5%B9%B6%E5%8F%91/">并发</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/01/04/2018-01/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0-10-11%E7%AB%A0/">java并发编程实战笔记-10-11章</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <p>第十章主要介绍活跃性危险,也就是安全性和活跃性的权衡.锁不多不少.<br>安全性: 就是正确性.锁要够多,不然数据并发访问就错了.<br>活跃性: 就是性能.  锁不能太多,死锁了,或者太卡了.  </p>
<h1 id="10-1-死锁"><a href="#10-1-死锁" class="headerlink" title="10.1 死锁"></a>10.1 死锁</h1><p>哲学家问题: 循环等待死锁.<br>数据库服务器如何解决事务死锁:</p>
<blockquote>
<ol>
<li>检测到等待关系有向图有环;</li>
<li>选一个牺牲者kill了. </li>
<li>应用程序自己重试被kill的事务.</li>
</ol>
</blockquote>
<h2 id="10-1-1-锁顺序死锁"><a href="#10-1-1-锁顺序死锁" class="headerlink" title="10.1.1 锁顺序死锁"></a>10.1.1 锁顺序死锁</h2><p>避免死锁的手段1:</p>
<blockquote>
<p>控制获取锁的顺序.</p>
</blockquote>
<p>如果所有线程获取锁(资源)的顺序一样,就不会死锁. </p>
<h2 id="10-1-2-动态的锁顺序死锁"><a href="#10-1-2-动态的锁顺序死锁" class="headerlink" title="10.1.2 动态的锁顺序死锁"></a>10.1.2 动态的锁顺序死锁</h2><p>锁顺序很难处理. 比如两个账户转账.<br>一种方法是使用俩账户的hash码,比较顺序.<br>当遇到hash码冲突的时候,使用加时赛:</p>
<blockquote>
<ol>
<li>定义一个新的锁;</li>
<li>冲突的线程轮流申请这个锁,然后再申请账户锁.</li>
</ol>
</blockquote>
<p>相当于冲突的线程串行执行.</p>
<p>(其实我觉得对于这个问题,账户肯定有唯一id,用id排序就好了.)</p>
<h2 id="10-1-3-协作对象之间的死锁"><a href="#10-1-3-协作对象之间的死锁" class="headerlink" title="10.1.3 协作对象之间的死锁"></a>10.1.3 协作对象之间的死锁</h2><p>如果获取多个锁的操作不在唯一的同一个方法里, 问题变得麻烦.<br>成因:<br>方法1: 持有锁时调用外部方法,而外部方法请求了另一个锁.<br>方法2: 同上.</p>
<p>方法1,方法2获取锁的顺序相反时,可能死锁.</p>
<p>解决方法:<br>收缩<code>synchronized</code>的范围从方法级缩小到块级.</p>
<h2 id="10-1-4-开放调用"><a href="#10-1-4-开放调用" class="headerlink" title="10.1.4 开放调用"></a>10.1.4 开放调用</h2><p>开放调用: 调用方法时不需要持有锁.<br>也就是方法上没有加<code>synchronized</code>,而是在里头某一个块里用了.</p>
<h2 id="10-1-5-资源死锁"><a href="#10-1-5-资源死锁" class="headerlink" title="10.1.5 资源死锁"></a>10.1.5 资源死锁</h2><p>资源不够死锁. 如线程资源\数据库连接资源.</p>
<ul>
<li>解决方案:<br>书里没写, 我觉得可以考虑前文说的”选取牺牲者”方法.</li>
</ul>
<h1 id="10-2-死锁的避免与诊断"><a href="#10-2-死锁的避免与诊断" class="headerlink" title="10.2 死锁的避免与诊断"></a>10.2 死锁的避免与诊断</h1><ol>
<li>每个线程只获取一个锁. //比较不现实,涉及原子性的实现.</li>
<li>顺序获取.</li>
<li>支持定时的锁. // 代替内置锁</li>
</ol>
<h2 id="10-2-2-死锁的诊断"><a href="#10-2-2-死锁的诊断" class="headerlink" title="10.2.2 死锁的诊断"></a>10.2.2 死锁的诊断</h2><p>通过Thread Dump信息.<br>方法: 向JVM发送SIGQUIT信号.<br>命令行:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kill -3 [id]</span><br></pre></td></tr></table></figure>
<p>jdk1.5: 有内置锁信息, 无显式锁信息;<br>jdk1.6: 有内置锁信息, 少量显式锁信息.<br>(?那岂不是意味着尽量不要使用显式锁?)</p>
<h1 id="10-3-其他活跃性危险"><a href="#10-3-其他活跃性危险" class="headerlink" title="10.3 其他活跃性危险"></a>10.3 其他活跃性危险</h1><p>活跃性危险: 太卡<br>包括: 死锁,饥饿,丢失信号,活锁.</p>
<h2 id="10-3-1-饥饿"><a href="#10-3-1-饥饿" class="headerlink" title="10.3.1 饥饿"></a>10.3.1 饥饿</h2><p>如短作业优先调度的时候,长作业就会饥饿.</p>
<h2 id="10-3-2-糟糕的响应性"><a href="#10-3-2-糟糕的响应性" class="headerlink" title="10.3.2 糟糕的响应性"></a>10.3.2 糟糕的响应性</h2><p>GUI线程优先级太低, 响应性就会差.</p>
<h2 id="10-3-3-活锁"><a href="#10-3-3-活锁" class="headerlink" title="10.3.3 活锁"></a>10.3.3 活锁</h2><p>重复的失败.<br>如线程不停得获取锁,释放锁,似乎能完成,但其实总也完成不了,无间地狱,死循环.</p>
<ul>
<li>案例1: 华龙道<br>发数据包碰撞. 重试算法一样,总是在相同的路口再碰撞.<br>解决方法:<br>增加随机性. 重试时间加一个随机参数.</li>
</ul>
<ul>
<li>案例2:<br>过度的错误恢复.<br>解决方法:<br>不过度.</li>
</ul>
<h1 id="第十一章-性能与可伸缩性"><a href="#第十一章-性能与可伸缩性" class="headerlink" title="第十一章 性能与可伸缩性"></a>第十一章 性能与可伸缩性</h1><p>线程的使用<br>目的: 提高性能.<br>缺陷: 提高复杂性.<br>场景: 多cpu系统,任务不是cpu密集的.<br>衡量手段: 看cpu使用情况图.</p>
<h2 id="11-1-1-可伸缩性"><a href="#11-1-1-可伸缩性" class="headerlink" title="11.1.1 可伸缩性"></a>11.1.1 可伸缩性</h2><p>可伸缩性: 当增加资源时(cpu,内存等等),程序吞吐量/处理能力增加比例适中.</p>
<p>可伸缩性与性能往往矛盾.<br>单线程的性能优化方法 往往导致=&gt; 可伸缩性下降. </p>
<h2 id="11-2-Amdahl定律"><a href="#11-2-Amdahl定律" class="headerlink" title="11.2 Amdahl定律"></a>11.2 Amdahl定律</h2><p>增加计算资源时,程序理论上能实现的最高加速比.</p>
<p>Speedup &lt;= 1/ ( F + (1-F)/N )<br>N: N个处理器<br>F: 必须串行的任务比例. </p>
<p>N趋近于无穷大时,加速比为 1/F.<br>(F为50%时,加速比最大为2.)</p>
<p>提高可伸缩性方法总结:</p>
<ol>
<li>缩小锁的粒度;</li>
<li>减少锁的持有时间(好像和上一条差不多);</li>
<li>尽量使用非独占锁. </li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://xiaoyue26.github.io/2018/01/04/2018-01/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0-10-11%E7%AB%A0/" data-id="ck96cxpnr009wmaam63sqf43c" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/" rel="tag">java</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-2018-01/java并发编程实战笔记-8章" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/01/01/2018-01/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0-8%E7%AB%A0/" class="article-date">
  <time datetime="2018-01-01T07:34:18.000Z" itemprop="datePublished">2018-01-01</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/java/">java</a>►<a class="article-category-link" href="/categories/java/%E5%B9%B6%E5%8F%91/">并发</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/01/01/2018-01/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0-8%E7%AB%A0/">java并发编程实战笔记-8章</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <h1 id="线程池的使用"><a href="#线程池的使用" class="headerlink" title="线程池的使用"></a>线程池的使用</h1><p>这章介绍实际应用中配置调优的一些高级选项. 以及各种坑.</p>
<h1 id="8-1-任务与执行策略的隐形耦合"><a href="#8-1-任务与执行策略的隐形耦合" class="headerlink" title="8.1  任务与执行策略的隐形耦合"></a>8.1  任务与执行策略的隐形耦合</h1><p>有些任务需要指定执行策略:</p>
<ol>
<li>依赖性任务: 就是任务之间不独立</li>
<li>线程不封闭的: 就是只能单线程跑的.</li>
<li>对响应时间敏感的: 如GUI. </li>
<li>使用ThreadLocal的: 线程池会重用线程. 因此可能有风险.</li>
</ol>
<h2 id="8-1-1-死锁"><a href="#8-1-1-死锁" class="headerlink" title="8.1.1 死锁"></a>8.1.1 死锁</h2><p>有界线程池不能无限提交. 如果里头的任务都死锁了,线程池也死锁了.</p>
<h2 id="8-1-2-响应时间"><a href="#8-1-2-响应时间" class="headerlink" title="8.1.2 响应时间"></a>8.1.2 响应时间</h2><p>如果任务都很慢,线程池的响应时间自然也慢.<br>可以限时或者增大线程池容量.</p>
<h1 id="8-2-线程池大小公式"><a href="#8-2-线程池大小公式" class="headerlink" title="8.2 线程池大小公式"></a>8.2 线程池大小公式</h1><p>N = cpu数量 = Runtime.getRuntime().availableProcessors();<br>U = 目标cpu利用率<br>W/C= 等待时间和执行时间的比率 (响应度)<br>SIZE = N*U/(1+W/C) </p>
<h1 id="8-3-配置ThreadPoolExecutor"><a href="#8-3-配置ThreadPoolExecutor" class="headerlink" title="8.3 配置ThreadPoolExecutor"></a>8.3 配置ThreadPoolExecutor</h1><p>可以通过Executors获取jdk设计好的一些线程池实现.</p>
<h2 id="8-3-1-线程的创建与取消"><a href="#8-3-1-线程的创建与取消" class="headerlink" title="8.3.1 线程的创建与取消"></a>8.3.1 线程的创建与取消</h2><p>基本大小: 没有任务时候的线程大小.<br>最大大小: 上限.<br>存活时间: 线程空闲时间达到存活时间,则被回收.</p>
<h2 id="8-3-2-管理队列任务"><a href="#8-3-2-管理队列任务" class="headerlink" title="8.3.2 管理队列任务"></a>8.3.2 管理队列任务</h2><p>线程池满了以后,提交的任务进入等待队列.<br>newFixedThreadPool: 无界等待队列 LinkedBlockingQueue<br>newSingleThreadExecutor: 无界等待队列 LinkedBlockingQueue</p>
<p>有界等待队列的话,需要饱和策略. </p>
<h2 id="8-3-3-饱和策略"><a href="#8-3-3-饱和策略" class="headerlink" title="8.3.3 饱和策略"></a>8.3.3 饱和策略</h2><ol>
<li>中止(默认): abort. 抛异常.</li>
<li>调用者运行: 让主线程自己干. 拥塞会外延到TCP层. </li>
<li>丢弃: 抛弃该任务. 不抛异常.</li>
<li>丢弃最老: 丢弃下一个将要执行的.(如果用了优先级队列,就是抛弃优先级最高的,会造成错误.)</li>
</ol>
<h1 id="8-4-扩展ThreadPoolExecutor"><a href="#8-4-扩展ThreadPoolExecutor" class="headerlink" title="8.4 扩展ThreadPoolExecutor"></a>8.4 扩展ThreadPoolExecutor</h1><p>需要实际需求和应用案例才能学会. </p>
<h1 id="8-5-递归算法的并行化"><a href="#8-5-递归算法的并行化" class="headerlink" title="8.5 递归算法的并行化"></a>8.5 递归算法的并行化</h1><p>首先循环可以并行化:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">final</span> Ele e: eles)&#123;</span><br><span class="line">    exec.execute(</span><br><span class="line">    <span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;process(e);&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>递归也一样, 遍历依然是递归的, 但把每一个节点的计算收集到线程池中,异步计算.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dfs(node,exec,results)&#123;</span><br><span class="line"> exec.execute(...);</span><br><span class="line"> dfs(node.children());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>第九章是图形界面,略过.</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://xiaoyue26.github.io/2018/01/01/2018-01/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0-8%E7%AB%A0/" data-id="ck96cxpnu00aemaam6euicert" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/" rel="tag">java</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-2017-12/hive调优之数据倾斜" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/12/26/2017-12/hive%E8%B0%83%E4%BC%98%E4%B9%8B%E6%95%B0%E6%8D%AE%E5%80%BE%E6%96%9C/" class="article-date">
  <time datetime="2017-12-26T11:35:00.000Z" itemprop="datePublished">2017-12-26</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/hadoop/">hadoop</a>►<a class="article-category-link" href="/categories/hadoop/hive/">hive</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/12/26/2017-12/hive%E8%B0%83%E4%BC%98%E4%B9%8B%E6%95%B0%E6%8D%AE%E5%80%BE%E6%96%9C/">hive调优之数据倾斜</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <p>上一篇中记录了hive调优的一些常规手段. 但对于某些数据集, 常规手段是无能为力的, 例如数据倾斜时.</p>
<p>对于hive而言,数据倾斜就是某个reducer跑得特别慢,这一点可以从日志中reducer开在99%或某个值很久看出,也可以从web ui中查看:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">运行后:</span><br><span class="line">http:&#x2F;&#x2F;xxx:19888&#x2F;jobhistory&#x2F;tasks&#x2F;job_1472710912354_3070682&#x2F;r</span><br><span class="line">运行前:</span><br><span class="line">http:&#x2F;&#x2F;xxx:8088&#x2F;proxy&#x2F;application_1472710912354_3070684&#x2F;mapreduce&#x2F;tasks&#x2F;job_1472710912354_3070684&#x2F;r</span><br></pre></td></tr></table></figure>
<p>如果具体看日志的话,会发现大部分时间在进行外排.<br>对于这种任务最重要的是消除外排,有如下几种优化手段:</p>
<h2 id="1-加内存"><a href="#1-加内存" class="headerlink" title="1. 加内存"></a>1. 加内存</h2><p>最简单粗暴就是给reduce加内存了. 让它别外排:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> mapreduce.reduce.memory.mb=<span class="number">10240</span>;</span><br></pre></td></tr></table></figure>
<p>类似的,如果mapper内存不够,可以减小每个mapper处理的数据量,增大mapper的数量:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> mapreduce.input.fileinputformat.split.maxsize=<span class="number">64000000</span>;</span><br></pre></td></tr></table></figure>

<h2 id="2-倾斜key单独处理"><a href="#2-倾斜key单独处理" class="headerlink" title="2. 倾斜key单独处理"></a>2. 倾斜key单独处理</h2><p>第二种手段也比较简单, 就是把出现倾斜的key找出来,假如很少的话,可以把它们摘出来,单独处理(或遗弃). 开启hive自动消除数据倾斜:(效果有效)</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> hive.optimize.skewjoin = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">set</span> hive.skewjoin.key=<span class="number">1000</span>;</span><br><span class="line"><span class="keyword">set</span> hive.groupby.skewindata=<span class="literal">true</span>;</span><br><span class="line"><span class="keyword">set</span> hive.groupby.mapaggr.checkinterval=<span class="number">100</span>;</span><br></pre></td></tr></table></figure>

<h2 id="3-局部聚合-1-相同value聚合"><a href="#3-局部聚合-1-相同value聚合" class="headerlink" title="3. 局部聚合(1): 相同value聚合"></a>3. 局部聚合(1): 相同value聚合</h2><p>(没有什么优化是增加一个阶段不能解决的.如果有,就再加一个阶段)<br>为了减少最后汇聚到reducer上的数据量,可以在之前增加一个阶段,对某个key的数据进行局部聚合. </p>
<p>以某次需求为例,需要求各个省市区维度下的丢包率\延迟的50,90,99分位数.数据量每天200G. 分位数计算极其耗时, 尤其是计算周统计数据时, 数据量达到TB级. </p>
<p>在使用了前一篇优化笔记手段以及上述手段后,依然耗时4小时.原来查询最耗时的部分如下:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span>  es</span><br><span class="line">       ,province</span><br><span class="line">       ,city</span><br><span class="line">       ,ipOprator</span><br><span class="line">       ,percentile(xxx,<span class="number">0.5</span>,<span class="number">0.9</span>,<span class="number">0.99</span>)</span><br><span class="line"><span class="keyword">FROM</span> ttt</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> es,province,ipOprator <span class="keyword">with</span> <span class="keyword">cube</span></span><br></pre></td></tr></table></figure>
<p>查看hive的percentile源码实现,其对于同一个key的处理逻辑大致这么几步:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(依次输入每个value)</span><br><span class="line">1. O(n)</span><br><span class="line">把所有value放进一个Map&lt;value,LongWriteable&gt;里,相同的value则增加map中的计数值;</span><br><span class="line">2. O(nlogn)</span><br><span class="line">在reduce中把map中的所有entry放入一个List中,然后对List根据value值进行全排序(&#96;Collections.sort(entriesList, new MyComparator());&#96;);</span><br><span class="line">3. O(n)</span><br><span class="line">从头开始扫一遍上一步的List, 根据计数器的值总和,分位数,定位到对应的分位数,返回.</span><br></pre></td></tr></table></figure>
<p>将其重写为可以进行局部聚合, 从而略去第一步:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span>  es</span><br><span class="line">       ,province</span><br><span class="line">       ,city</span><br><span class="line">       ,ipOprator</span><br><span class="line">      ,percent_new(c1,<span class="keyword">num</span>,<span class="number">0.5</span>,<span class="number">0.9</span>,<span class="number">0.99</span>)</span><br><span class="line"><span class="keyword">FROM</span> (<span class="keyword">select</span> es,province,ipOprator,c1,<span class="keyword">count</span>(<span class="number">1</span>) <span class="keyword">as</span> <span class="keyword">num</span></span><br><span class="line">    <span class="keyword">FROM</span> xxx</span><br><span class="line">    <span class="keyword">GROUP</span> <span class="keyword">BY</span> es,province,ipOprator,c1</span><br><span class="line">) <span class="keyword">as</span> t </span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> es,province,ipOprator <span class="keyword">with</span> <span class="keyword">cube</span></span><br></pre></td></tr></table></figure>
<p>优化后,时间缩短到30分钟.</p>
<ul>
<li>TODO:<br>优化第二步中的全排序. </li>
</ul>
<h2 id="4-局部聚合2-相同key聚合"><a href="#4-局部聚合2-相同key聚合" class="headerlink" title="4. 局部聚合2: 相同key聚合"></a>4. 局部聚合2: 相同key聚合</h2><p>由于上一案例中的聚合函数是分位数计算,聚合的粒度只能达到相同value聚合,对于其他聚合函数,如最大值,最小值等,如果语义上能对相同key先聚合,问题的规模就可以进一步缩小. 方法是先把相同key的数据分拆成不同的key,加上前缀或后缀 如:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">key -&gt; key_1</span><br><span class="line">key -&gt; key_2</span><br><span class="line">...</span><br><span class="line">key -&gt; key_10</span><br></pre></td></tr></table></figure>
<p>分拆的数量等于并行度,取决于原有的数据集, 然后先进行一阶段聚合,最后去掉前缀后缀,再进行一次聚合得到最后的结果.<br>这种方法的关键就是要求同一个key的聚合计算可以分拆.</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://xiaoyue26.github.io/2017/12/26/2017-12/hive%E8%B0%83%E4%BC%98%E4%B9%8B%E6%95%B0%E6%8D%AE%E5%80%BE%E6%96%9C/" data-id="ck96cxpnk0090maam4d5qhboj" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hive/" rel="tag">hive</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-2017-12/hive调优" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/12/25/2017-12/hive%E8%B0%83%E4%BC%98/" class="article-date">
  <time datetime="2017-12-25T08:45:15.000Z" itemprop="datePublished">2017-12-25</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/hadoop/">hadoop</a>►<a class="article-category-link" href="/categories/hadoop/hive/">hive</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/12/25/2017-12/hive%E8%B0%83%E4%BC%98/">hive sql调优</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <p>这里记录一下hive任务调优的三(n)板斧.</p>
<h1 id="map-join"><a href="#map-join" class="headerlink" title="map join"></a>map join</h1><p>对于存在join的sql,首先最简单的就是开启map join:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> hive.auto.convert.join = <span class="literal">true</span> ; <span class="comment">-- 开启自动转化成mapjoin</span></span><br><span class="line"><span class="keyword">set</span> hive.mapjoin.smalltable.filesize = <span class="number">2500000</span> ; <span class="comment">-- 设置广播小表size</span></span><br></pre></td></tr></table></figure>
<p>sql中足够小的表应该放在join操作左边. 由于小表数据会被广播到各个节点,消除了shuffle运算,提高了运算效率.<br>前提当然是存在足够小的表. 实际业务中一般是各种维度表.</p>
<h1 id="排序消除"><a href="#排序消除" class="headerlink" title="排序消除"></a>排序消除</h1><blockquote>
<p>注: 是否加速取决于数据集.</p>
</blockquote>
<p>排序属于非常耗时的操作(<code>O(nlogn)</code>),所以对于order by,sort by语句,可以从语义上寻找突破口. 例如对于每天最后一次的用户行为,原来的可能是这样写的:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line">(<span class="keyword">select</span> userid</span><br><span class="line">      ,<span class="keyword">url</span></span><br><span class="line">      ,row_number(<span class="keyword">partition</span> <span class="keyword">by</span> userid <span class="keyword">order</span> <span class="keyword">by</span> <span class="built_in">bigint</span>(<span class="built_in">timestamp</span>)<span class="keyword">DESC</span>) <span class="keyword">as</span> <span class="keyword">rank</span></span><br><span class="line"><span class="keyword">FROM</span> xxxx</span><br><span class="line">)<span class="keyword">AS</span> a </span><br><span class="line"><span class="keyword">where</span> <span class="keyword">rank</span>=<span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>可以改为先求最大时间戳,再进行<code>join</code>(<code>map join</code>):</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span></span><br><span class="line">(<span class="keyword">select</span> userid,<span class="keyword">max</span>(<span class="built_in">bigint</span>(<span class="built_in">timestamp</span>)) <span class="keyword">from</span> xxx <span class="keyword">group</span> <span class="keyword">by</span> userid) <span class="keyword">as</span> a</span><br><span class="line"><span class="keyword">join</span> xxx <span class="keyword">on</span> b </span><br><span class="line">  <span class="keyword">on</span> a.timestamp=b.timestamp</span><br></pre></td></tr></table></figure>
<p>这样更改后虽然消除了排序操作,但是引入了shuffle操作(join)(并且对于hive要laod两遍数据),因此是否加速取决于具体的数据集. 对于任务卡死(或者很慢)在reduce阶段的hive任务,可以尝试进行排序消除.<br>实际经验来看,如果数据量大到导致外排,需要消除<code>order by</code>.</p>
<h1 id="distinct消除-两阶段group-by"><a href="#distinct消除-两阶段group-by" class="headerlink" title="distinct消除(两阶段group by)"></a>distinct消除(两阶段group by)</h1><p>回字有4种写法,而distinct一般有2种.</p>
<h2 id="1-多列或1列去重"><a href="#1-多列或1列去重" class="headerlink" title="1. 多列或1列去重"></a>1. 多列或1列去重</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> a,b,udf(c1) <span class="keyword">as</span> c2 <span class="keyword">from</span> xxx</span><br></pre></td></tr></table></figure>
<p>由于hive是通过<code>group by</code>实现distinct,上述sql其实等效于:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> a,b,udf(c1) <span class="keyword">from</span> xxx <span class="keyword">group</span> <span class="keyword">by</span> a,b,udf(c1)</span><br></pre></td></tr></table></figure>
<p>可以通过explain查看两者的执行计划是完全一致的.<br>如果能确定udf是单射变换,也就是c1到c2是一对一,而没有多对一,可以等效改写为:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> a,b,udf(c1) <span class="keyword">from</span> xxx <span class="keyword">group</span> <span class="keyword">by</span> a,b,c1</span><br></pre></td></tr></table></figure>
<p>总之,对于这个场景下的distinct使用,如果没有udf,可以不进行消除.</p>
<h2 id="2-聚合函数中使用-如uv计算"><a href="#2-聚合函数中使用-如uv计算" class="headerlink" title="2. 聚合函数中使用(如uv计算)"></a>2. 聚合函数中使用(如uv计算)</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> dt,<span class="keyword">count</span>(<span class="keyword">distinct</span> userid) <span class="keyword">as</span> uv </span><br><span class="line"><span class="keyword">from</span> xxx</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> dt</span><br></pre></td></tr></table></figure>
<p>这种聚合函数中使用distinct属于比较常见的业务查询需求,hive执行时会把所有数据灌到一个reducer中,毫无并行度.<br>可以使用两阶段group by进行优化,写法:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> dt,<span class="keyword">count</span>(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">(<span class="keyword">select</span> <span class="keyword">distinct</span> dt,userid <span class="keyword">from</span> xxx) <span class="keyword">as</span> t </span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> dt</span><br></pre></td></tr></table></figure>
<p>这样去重操作在第一个阶段分担到了多个reducer上,速度提升很多.</p>
<p>实际优化的时候,主要有三种情况阻碍,无法直接改写:</p>
<h3 id="1-同一列不同条件的count-distinct"><a href="#1-同一列不同条件的count-distinct" class="headerlink" title="1. 同一列不同条件的count distinct"></a>1. 同一列不同条件的count distinct</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> dt</span><br><span class="line">,<span class="keyword">count</span>(<span class="keyword">distinct</span> userid) <span class="keyword">as</span> seven_uv</span><br><span class="line">,<span class="keyword">count</span>(<span class="keyword">distinct</span> <span class="keyword">if</span>(c1&gt;xxx,userid,<span class="literal">NULL</span>)) <span class="keyword">as</span> new_uv</span><br><span class="line">,<span class="keyword">count</span>(<span class="keyword">distinct</span> <span class="keyword">if</span>(c2&gt;xxx,userid,<span class="literal">NULL</span>)) <span class="keyword">as</span> query_uv</span><br></pre></td></tr></table></figure>
<p>可以通过增加标记列转化:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> dt</span><br><span class="line">,<span class="keyword">count</span>(userid) <span class="keyword">as</span> seven_uv</span><br><span class="line">,<span class="keyword">count</span>(<span class="keyword">if</span>(is_new=<span class="number">1</span>,userid,<span class="literal">NULL</span>)) <span class="keyword">as</span> new_uv</span><br><span class="line">,<span class="keyword">count</span>(<span class="keyword">if</span>(is_query=<span class="number">1</span>,userid,<span class="literal">NULL</span>)) <span class="keyword">as</span> query_uidnum <span class="comment">-- query_uv</span></span><br><span class="line"><span class="keyword">from</span> </span><br><span class="line">(...</span><br><span class="line">,<span class="keyword">max</span>(<span class="keyword">if</span>(c1&gt;xxx,<span class="number">1</span>,<span class="number">0</span>)) is_new</span><br><span class="line">,<span class="keyword">max</span>(<span class="keyword">if</span>(c2&gt;xxx,<span class="number">1</span>,<span class="number">0</span>)) <span class="keyword">as</span> is_query</span><br><span class="line">...) <span class="keyword">as</span> tt</span><br></pre></td></tr></table></figure>

<h3 id="2-多维聚合-group-by-with-cube"><a href="#2-多维聚合-group-by-with-cube" class="headerlink" title="2. 多维聚合(group by with cube)"></a>2. 多维聚合(group by with cube)</h3><p>可以通过一行变多行,手动维护grouping sets的组合:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">lateral view explode(array('全部',platform)) tt1 as platform_t</span><br><span class="line">lateral view explode(array('全部',version)) tt2 as version_t</span><br><span class="line">lateral view explode(array('全部',vendor)) tt3 as vendor_t</span><br><span class="line">lateral view explode(array('全部',phase)) tt4 as phase_t</span><br><span class="line">GROUP BY platform_t,version_t,vendor_t,phase_t</span><br><span class="line">     ,userid</span><br></pre></td></tr></table></figure>

<h2 id="不同列聚合"><a href="#不同列聚合" class="headerlink" title="不同列聚合."></a>不同列聚合.</h2><p>例如:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">count(distinct userid)</span><br><span class="line">count(distinct deviceid)</span><br></pre></td></tr></table></figure>
<p>这种如果确实出现了reduce卡死,可以进行分拆成两个查询分别计算(load两遍数据),最后join到一起. 代码会比较长. </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://xiaoyue26.github.io/2017/12/25/2017-12/hive%E8%B0%83%E4%BC%98/" data-id="ck96cxpnl0094maam0f7p0mtm" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hive/" rel="tag">hive</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-2017-12/hive之bug汇总" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/12/20/2017-12/hive%E4%B9%8Bbug%E6%B1%87%E6%80%BB/" class="article-date">
  <time datetime="2017-12-20T10:01:19.000Z" itemprop="datePublished">2017-12-20</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/hadoop/">hadoop</a>►<a class="article-category-link" href="/categories/hadoop/hive/">hive</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/12/20/2017-12/hive%E4%B9%8Bbug%E6%B1%87%E6%80%BB/">hive之bug汇总</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <p>这里总结一下hive的bug,或者说表现与spark sql不同的feature(bug?).<br>由于hive的distinct实际实现为group by,因此下述的group by相关bug也适用于distinct.</p>
<h1 id="1-列重命名BUG"><a href="#1-列重命名BUG" class="headerlink" title="1. 列重命名BUG"></a>1. 列重命名BUG</h1><blockquote>
<p>导致结果错误.<br>spark-sql能正常处理.</p>
</blockquote>
<p>子查询中重命名列时,如果和原有表中某列名相同,并且where条件中有那一列,取原有表的列值.<br>构造测试用例:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span></span><br><span class="line">(<span class="keyword">SELECT</span> <span class="number">123</span> <span class="keyword">as</span> paperid</span><br><span class="line"><span class="keyword">FROM</span>  temp.feng_test1</span><br><span class="line"><span class="keyword">where</span> paperid=<span class="number">70455</span></span><br><span class="line">)<span class="keyword">AS</span> a</span><br></pre></td></tr></table></figure>
<p>上述查询的结果是70455,而不是我们想象中的123.<br>而这个查询:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span></span><br><span class="line">(<span class="keyword">SELECT</span> <span class="number">123</span> <span class="keyword">as</span> paperid</span><br><span class="line"><span class="keyword">FROM</span>  temp.feng_test1</span><br><span class="line">)<span class="keyword">AS</span> a</span><br></pre></td></tr></table></figure>
<p>或这个查询:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span></span><br><span class="line">(<span class="keyword">SELECT</span> <span class="number">123</span> <span class="keyword">as</span> paperid</span><br><span class="line"><span class="keyword">FROM</span>  (<span class="keyword">select</span> <span class="number">70455</span> <span class="keyword">as</span> paperid) <span class="keyword">as</span> t </span><br><span class="line"><span class="keyword">where</span> paperid=<span class="number">70455</span></span><br><span class="line">)<span class="keyword">AS</span> a</span><br></pre></td></tr></table></figure>
<p>都能正确返回123.</p>
<h1 id="2-GROUP-BY-UDF-Serde复合bug"><a href="#2-GROUP-BY-UDF-Serde复合bug" class="headerlink" title="2. GROUP BY+UDF+Serde复合bug"></a>2. GROUP BY+UDF+Serde复合bug</h1><blockquote>
<p>导致抛异常退出.<br>spark-sql能正常处理.</p>
</blockquote>
<p>GROUP BY,自定义UDF和自定义Serde都能正常独立工作.<br>这是一个多重条件下产生的bug:<br>1.表定义为string,而自定义的serde类放入了long对象;(bug)<br>2.自定义UDF使用简便写法(继承UDF,复杂写法为继承GenericUDF);(正常行为)<br>3.运行如下语句:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> xx</span><br><span class="line"><span class="keyword">from</span> <span class="string">`1中serde的表`</span></span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> <span class="string">`2中udf`</span></span><br></pre></td></tr></table></figure>

<p>这个bug可以说是serde写得有问题导致的,严格来说hive没有太大问题.<br>原因是hive调用简单udf时,是运行时进行反射,填入方法的参数,实参与形参定义不同抛出异常.</p>
<h1 id="3-GROUP-BY-重复列-BUG"><a href="#3-GROUP-BY-重复列-BUG" class="headerlink" title="3. GROUP BY+重复列 BUG"></a>3. GROUP BY+重复列 BUG</h1><blockquote>
<p>导致结果错误.<br>spark-sql能正常处理.</p>
</blockquote>
<p>GROUP BY 时,如果有涉及引用的重复列, 如构造用例中的alist[0],由于hive在各种方面都会重用引用,会导致bug.<br>用例的输出结果为: <code>1,1,1</code>.<br>而不是我们想象中的: <code>1,1,3333</code>.</p>
<p>构造用例如下:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> aid,bid,mistake</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">      (<span class="keyword">SELECT</span> <span class="number">1</span> <span class="keyword">as</span> aid</span><br><span class="line">      )<span class="keyword">AS</span> a</span><br><span class="line"><span class="keyword">JOIN</span></span><br><span class="line">      (<span class="keyword">SELECT</span> alist[<span class="number">0</span>] <span class="keyword">as</span> bid</span><br><span class="line">            ,mistake</span><br><span class="line">      <span class="keyword">FROM</span> (<span class="keyword">SELECT</span> <span class="number">2</span> <span class="keyword">as</span> courseid) <span class="keyword">AS</span> a</span><br><span class="line">      <span class="keyword">JOIN</span> (<span class="keyword">SELECT</span> <span class="number">2</span> <span class="keyword">as</span> courseid</span><br><span class="line">                  ,<span class="string">'3333'</span> <span class="keyword">as</span> mistake</span><br><span class="line">                  ,<span class="built_in">array</span>(<span class="number">1</span>) <span class="keyword">as</span> alist</span><br><span class="line">            ) <span class="keyword">AS</span> b</span><br><span class="line">        <span class="keyword">ON</span> a.courseid=b.courseid</span><br><span class="line">      <span class="keyword">GROUP</span> <span class="keyword">BY</span> alist[<span class="number">0</span>]</span><br><span class="line">              ,alist[<span class="number">0</span>]</span><br><span class="line">              ,mistake</span><br><span class="line">      )<span class="keyword">AS</span> b</span><br><span class="line"> <span class="keyword">ON</span> aid=bid</span><br></pre></td></tr></table></figure>

<h1 id="4-row-number-数据类型溢出-bug"><a href="#4-row-number-数据类型溢出-bug" class="headerlink" title="4. row_number + 数据类型溢出 bug"></a>4. row_number + 数据类型溢出 bug</h1><blockquote>
<p>导致结果错误.<br>spark-sql能正常处理.</p>
</blockquote>
<p>假设tp是一个字符串类型,强行转换成int类型时,如果发生数据溢出,比如值是13位时间戳(1514285700375),排序行为将不可预测.既不是降序也不是升序.</p>
<p>构造错误样例如下:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> userid,phaseid,tp</span><br><span class="line">,row_number()<span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> userid <span class="keyword">order</span> <span class="keyword">by</span> <span class="built_in">int</span>(tp)) <span class="keyword">as</span> <span class="keyword">rank</span></span><br><span class="line"><span class="keyword">from</span> xxxx</span><br></pre></td></tr></table></figure>

<p>正确样例:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> userid,phaseid,tp</span><br><span class="line">,row_number()<span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> userid <span class="keyword">order</span> <span class="keyword">by</span> <span class="built_in">bigint</span>(tp)) <span class="keyword">as</span> <span class="keyword">rank</span></span><br><span class="line"><span class="keyword">from</span> xxxx</span><br></pre></td></tr></table></figure>

<h1 id="5-sort-array-BUG-Feature-函数副作用"><a href="#5-sort-array-BUG-Feature-函数副作用" class="headerlink" title="5. sort_array BUG(Feature) 函数副作用"></a>5. sort_array BUG(Feature) 函数副作用</h1><blockquote>
<p>导致结果错误.<br>spark-sql能正确处理.</p>
</blockquote>
<p>hive中对数组进行排序后,会改变原有数组.(会在原有数组基础上排序)<br>spark-sql则会返回一个深拷贝,不改变原有数组.</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> alist</span><br><span class="line">      ,sort_array(alist) <span class="keyword">as</span> alist2</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">(<span class="keyword">select</span> <span class="built_in">array</span>(<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>) <span class="keyword">as</span> alist</span><br><span class="line">)<span class="keyword">AS</span> t</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://xiaoyue26.github.io/2017/12/20/2017-12/hive%E4%B9%8Bbug%E6%B1%87%E6%80%BB/" data-id="ck96cxpnj008xmaamc8xl8r5i" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hive/" rel="tag">hive</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-2017-12/mysql调优小记" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/12/07/2017-12/mysql%E8%B0%83%E4%BC%98%E5%B0%8F%E8%AE%B0/" class="article-date">
  <time datetime="2017-12-07T10:49:56.000Z" itemprop="datePublished">2017-12-07</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/mysql/">mysql</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/12/07/2017-12/mysql%E8%B0%83%E4%BC%98%E5%B0%8F%E8%AE%B0/">mysql调优小记</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <ul>
<li>摘要<blockquote>
<p>mysql表出现慢查询,单表数据量500W<del>700W条. 每天2</del>3W条.<br>措施: </p>
<ol>
<li>优化查询语句; </li>
<li>更改存储引擎.</li>
<li>优化索引.</li>
</ol>
</blockquote>
</li>
</ul>
<h3 id="详情"><a href="#详情" class="headerlink" title="详情"></a>详情</h3><p>同事去塞班岛玩前留了个大坑,导致网站报表卡死刷不开.</p>
<h3 id="STEP-1"><a href="#STEP-1" class="headerlink" title="STEP 1"></a>STEP 1</h3><p>进入后台:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">processlist</span></span><br></pre></td></tr></table></figure>
<p>发现Query很多,<code>show full processlist</code>找出查询语句,发现多表join的时候没有利用到索引.<br>查询语句模式如下:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> ...</span><br></pre></td></tr></table></figure>
<p>发现没有用上索引,更改查询语句。</p>
<ul>
<li><p><code>explain</code>查询计划中的<code>type</code>:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const(system): 根据PRI或Unique key,只取出确定的(一行)数据,常量优化. </span><br><span class="line"></span><br><span class="line">eq_ref: JOIN条件包括了所有索引,并且索引是Unique key. </span><br><span class="line">ref: JOIN条件包括部分索引或不是Unique key.</span><br><span class="line">ref_or_null: WHERE col=exp or col is null</span><br><span class="line"></span><br><span class="line">index_merge: Where id=xx or userid=xxx. 索引合并优化.</span><br><span class="line"></span><br><span class="line">unique_subquery: where col in( <span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> xxx). 这里<span class="keyword">id</span>唯一.</span><br><span class="line">index_subquery: 同上,只是<span class="keyword">id</span>不唯一.</span><br><span class="line"></span><br><span class="line"><span class="keyword">range</span>: 索引在某个范围内.</span><br><span class="line"><span class="keyword">all</span>: 扫全表</span><br></pre></td></tr></table></figure>
</li>
<li><p>TODO:<br>研究除了子查询以外的方式使用索引.</p>
</li>
</ul>
<p>此外, 索引对于数据类型敏感, 查询中存在字符串和date类型相等的时候, 无法利用索引,<br>需要将date类型转成字符串.</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dt = date_format(date_sub(current_date, interval 1 day), '%Y-%m-%d')</span><br></pre></td></tr></table></figure>

<h3 id="STEP-2"><a href="#STEP-2" class="headerlink" title="STEP 2"></a>STEP 2</h3><p>检查后台,发现许多连接状态都是:<br><code>waiting for table level lock</code>.<br>进一步发现这几张表的存储引擎是<code>MYISAM</code>,而不是默认的<code>innodb</code>.<br>由于<code>myisam</code>引擎只有表级锁,不符合我们的使用要求.于是我把涉及到的几张表引擎都改为<code>innodb</code>.</p>
<h3 id="STEP-3"><a href="#STEP-3" class="headerlink" title="STEP 3"></a>STEP 3</h3><p>修改后,查询不会卡死(毕竟不扫全表了ORZ),降低到40s,但还是太慢了.<br>进一步检查explain结果,发现<code>key_len</code>太长了.<br>于是重新设计索引, 把筛选度高的放前面(利用最左前缀), 并且根据具体业务\语义,尽量缩短索引字段的长度,<br>实在无法缩短的则取其中一部分. 最后查询缩短到0.04sec,几个报表都是秒出.  </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://xiaoyue26.github.io/2017/12/07/2017-12/mysql%E8%B0%83%E4%BC%98%E5%B0%8F%E8%AE%B0/" data-id="ck96cxpni008vmaamfhcygtrf" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/mysql/" rel="tag">mysql</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-2017-12/sqoop的SQL注入漏洞" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/12/01/2017-12/sqoop%E7%9A%84SQL%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E/" class="article-date">
  <time datetime="2017-12-01T13:29:38.000Z" itemprop="datePublished">2017-12-01</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/hadoop/">hadoop</a>►<a class="article-category-link" href="/categories/hadoop/sqoop/">sqoop</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/12/01/2017-12/sqoop%E7%9A%84SQL%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E/">sqoop的SQL注入漏洞</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <p>早上起来发现公司有一个sqoop导表任务挂了,查看日志错误提示大致如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">INFO [main] org.apache.sqoop.mapreduce.db.DBRecordReader: Executing query: SELECT id,xxx FROM taname where ( udid &gt;&#x3D; &#39;abc&#39; ) AND ( udid &lt; &#39;xx&#39; ;select pg_sleep(3) --)</span><br><span class="line">ERROR 1064 (42000): You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near &#39;)&#39; at line 1</span><br></pre></td></tr></table></figure>

<p>也就是说sqoop生成的查询语句错了,搜了一下源码没有发现哪里会生成</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> pg_sleep(<span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<p>这种语句,而且我们用的是mysql,按理说不应当生成pgsql.<br>而且这个导表任务也不是第一天上线了,此前一直是好好的.</p>
<p>首先按照经验,调整了分隔符配置;查看表结构发现有blob字段,去掉了配置中的direct模式,均没有效果.<br>其次查job的其他日志,发现其他几个mapper都成功了,只有1个mapper挂了,于是调整并行度,把并行度调成1,导表任务就成功了.</p>
<p>回过头来继续研究这个问题.<br>也就是说在分割表数据到几个mapper的时候,划分split的时候,查询语句错了.<br>报错的上一行的日志大致是:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">org.apache.hadoop.mapred.MapTask: Processing split: udid &gt;&#x3D; &#39;xxx&#39; AND udid &lt; &#39;xxx&#39;); select pg_sleep(3) -- &#39;</span><br></pre></td></tr></table></figure>

<p>sqoop划分split的原理:</p>
<ol>
<li><code>--table</code> 按表导: 按主键最大最小取值划分范围,然后按中间值划分split.</li>
<li><code>--query</code> : 按配置中的<code>-- split by</code>参数对应的列取max,min,然后同上.</li>
</ol>
<p>因此如果作为划分列的值中如果有脏数据,sqoop就会被sql注入.<br>因此导致了我们遇到的问题.<br>平时脏数据没有落在分割点上, 今天可能是由于脏数据的比例逐渐上升,终于落在了分割点上,因此导致了任务失败.<br>(<code>pg_sleep</code>一般是用于sql注入.)</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://xiaoyue26.github.io/2017/12/01/2017-12/sqoop%E7%9A%84SQL%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E/" data-id="ck96cxpnm0098maam2w3x536l" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/sql%E6%B3%A8%E5%85%A5/" rel="tag">sql注入</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/sqoop/" rel="tag">sqoop</a></li></ul>

    </footer>
  </div>
  
</article>
 


  


  <nav id="page-nav">
    <a class="extend prev" rel="prev" href="/page/15/">&amp;laquo; 上一页</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/14/">14</a><a class="page-number" href="/page/15/">15</a><span class="page-number current">16</span><a class="page-number" href="/page/17/">17</a><a class="page-number" href="/page/18/">18</a><span class="space">&hellip;</span><a class="page-number" href="/page/24/">24</a><a class="extend next" rel="next" href="/page/17/">下一页&amp;raquo;</a>
  </nav>
</section>
           
    <aside id="sidebar">
  
    

  
    
  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title recent-posts">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/10/03/2022-10/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%94%BB%E5%87%BB-md/">java反序列化攻击</a>
          </li>
        
          <li>
            <a href="/2022/09/27/2022-09/sql%E6%B3%A8%E5%85%A5%E6%94%BB%E5%87%BB/">sql注入攻击</a>
          </li>
        
          <li>
            <a href="/2022/09/26/2022-09/%E5%B7%B2%E7%9F%A5%E6%98%8E%E6%96%87%E7%A0%B4%E8%A7%A3zip/">已知明文破解zip</a>
          </li>
        
          <li>
            <a href="/2022/09/26/2022-09/jwt%E7%A0%B4%E8%A7%A3/">jwt破解</a>
          </li>
        
          <li>
            <a href="/2022/09/25/2022-09/nc%E5%91%BD%E4%BB%A4%E7%AC%94%E8%AE%B0/">nc命令笔记</a>
          </li>
        
      </ul>
    </div>
  </div>

  
    

  
</aside>

      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-left">
      &copy; 2014 - 2022 风梦七&nbsp;|&nbsp;
      主题 <a href="https://github.com/giscafer/hexo-theme-cafe/" target="_blank">Cafe</a>
    </div>
     <div id="footer-right">
      联系方式&nbsp;|&nbsp;296671657@qq.com
    </div>
  </div>
</footer>
 
<script src="/jquery/jquery.min.js"></script>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">首页</a>
  
    <a href="/archives" class="mobile-nav-link">归档</a>
  
    <a href="/about" class="mobile-nav-link">关于</a>
  
</nav>
    <img class="back-to-top-btn" src="/images/fly-to-top.png"/>
<script>
// Elevator script included on the page, already.
window.onload = function() {
  var elevator = new Elevator({
    selector:'.back-to-top-btn',
    element: document.querySelector('.back-to-top-btn'),
    duration: 1000 // milliseconds
  });
}
</script>
      

  
    <script>
      var cloudTieConfig = {
        url: document.location.href, 
        sourceId: "",
        productKey: "e2fb4051c49842688ce669e634bc983f",
        target: "cloud-tie-wrapper"
      };
    </script>
    <script src="https://img1.ws.126.net/f2e/tie/yun/sdk/loader.js"></script>
    

  







<!-- author:forvoid begin -->
<!-- author:forvoid begin -->

  <link rel="stylesheet" href="https://jjeejj.github.io/css/gitment.css">
  <script src="https://www.wenjunjiang.win/js/gitment.js"></script>
  <script>
  var gitment = new Gitment({
    // id: '页面 ID', // 可选。默认为 location.href
    owner: 'xiaoyue26',
    repo: 'xiaoyue26.github.io',
    oauth: {
    client_id: 'cfe53b938f0d4c782371',
    client_secret: 'f96e68ae1103e7500c106aa3656a8bb31fe0ee99',
    }
  })
  gitment.render(document.getElementById("gitment_comments"))
</script>


<!-- author:forvoid end -->

<!-- author:forvoid begin -->

<!-- author:forvoid end -->

<!-- author:forvoid end -->


  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      })
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      })
    </script>
    <script type="text/javascript" src="https://cdn.rawgit.com/mathjax/MathJax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


 
<script src="/js/is.js"></script>



  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>


<script src="/js/elevator.js"></script>

  </div>
</body>
</html>