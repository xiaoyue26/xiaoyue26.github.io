<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>调优-ByteString相关内存拷贝问题 | 笔记本</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="背景媒体中心api内存消耗较大，检查内存分配情况:   对应的伪代码: 123451. byte[] bytes &#x3D; BlobStore.loadFile(); 2. ByteString pb &#x3D; ByteString.copyFrom(bytes); 3. ByteString afterDecrypt &#x3D; callRpc(pb); &#x2F;&#x2F; 2次拷贝 4. byte[] decryptBytes">
<meta property="og:type" content="article">
<meta property="og:title" content="调优-ByteString相关内存拷贝问题">
<meta property="og:url" content="http://xiaoyue26.github.io/2023/02/03/2023-02/%E8%B0%83%E4%BC%98-ByteString%E7%9B%B8%E5%85%B3%E5%86%85%E5%AD%98%E6%8B%B7%E8%B4%9D%E9%97%AE%E9%A2%98/index.html">
<meta property="og:site_name" content="笔记本">
<meta property="og:description" content="背景媒体中心api内存消耗较大，检查内存分配情况:   对应的伪代码: 123451. byte[] bytes &#x3D; BlobStore.loadFile(); 2. ByteString pb &#x3D; ByteString.copyFrom(bytes); 3. ByteString afterDecrypt &#x3D; callRpc(pb); &#x2F;&#x2F; 2次拷贝 4. byte[] decryptBytes">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://xiaoyue26.github.io/images/2023-02/bytestring-background.png">
<meta property="article:published_time" content="2023-02-03T03:01:39.000Z">
<meta property="article:modified_time" content="2023-02-09T06:34:47.299Z">
<meta property="article:author" content="风梦七">
<meta property="article:tag" content="java">
<meta property="article:tag" content="jvm">
<meta property="article:tag" content="ByteString">
<meta property="article:tag" content="HttpRange">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://xiaoyue26.github.io/images/2023-02/bytestring-background.png">
  
    <link rel="alternate" href="/atom.xml" title="笔记本" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    
  
  
<link rel="stylesheet" href="/css/style.css">

  

<meta name="generator" content="Hexo 4.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    
    <div id="header-inner" class="inner">
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://xiaoyue26.github.io"></form>
      </div>
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">首页</a>
        
          <a class="main-nav-link" href="/archives">归档</a>
        
          <a class="main-nav-link" href="/about">关于</a>
        
      </nav>
      
    </div>
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">笔记本</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">风梦七</a>
        </h2>
      
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-2023-02/调优-ByteString相关内存拷贝问题" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2023/02/03/2023-02/%E8%B0%83%E4%BC%98-ByteString%E7%9B%B8%E5%85%B3%E5%86%85%E5%AD%98%E6%8B%B7%E8%B4%9D%E9%97%AE%E9%A2%98/" class="article-date">
  <time datetime="2023-02-03T03:01:39.000Z" itemprop="datePublished">2023-02-03</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/java/">java</a>►<a class="article-category-link" href="/categories/java/%E6%80%A7%E8%83%BD/">性能</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      调优-ByteString相关内存拷贝问题
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>媒体中心api内存消耗较大，检查内存分配情况:</p>
<img src="/images/2023-02/bytestring-background.png" class="" width="800" height="1200" title="background">

<p>对应的伪代码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>. <span class="keyword">byte</span>[] bytes = BlobStore.loadFile(); </span><br><span class="line"><span class="number">2</span>. ByteString pb = ByteString.copyFrom(bytes); </span><br><span class="line"><span class="number">3</span>. ByteString afterDecrypt = callRpc(pb); <span class="comment">// 2次拷贝 </span></span><br><span class="line"><span class="number">4</span>. <span class="keyword">byte</span>[] decryptBytes = afterDecryp.toByteArray(); </span><br><span class="line"><span class="number">5</span>. <span class="keyword">byte</span>[] resp = XXXUtils.downloadRange(decryptBytes);</span><br></pre></td></tr></table></figure>

<p>涉及到的堆内内存申请：（堆外暂且不管）<br>1.业务线程: 从blobstore读取数据；<br>2.业务线程: 解密前拷贝给pb；<br>3.grpc线程: 接收rpc结果;<br>4.grpc线程: 从结果拷贝到resp;<br>5.业务线程: 从resp拷贝到byte[];<br>6.业务线程: range下载,byte[]到byte[]。</p>
<h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><h2 id="ByteString-copyFrom优化"><a href="#ByteString-copyFrom优化" class="headerlink" title="ByteString.copyFrom优化"></a>ByteString.copyFrom优化</h2><h3 id="常规写法"><a href="#常规写法" class="headerlink" title="常规写法"></a>常规写法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span>[] videoBytes = doLoadFile(videoKey);</span><br><span class="line"><span class="keyword">return</span> ByteString.copyFrom(videoBytes);</span><br></pre></td></tr></table></figure>
<p>会多一份内存申请的内存消耗和拷贝的性能消耗。</p>
<blockquote>
<p>ByteString 实例通常使用 ByteString.CopyFrom(byte[] data) 创建。 此方法会分配新的 ByteString 和新的 byte[]。 数据会复制到新的字节数组中。</p>
</blockquote>
<p>  通过使用 UnsafeByteOperations.UnsafeWrap(ReadOnlyMemory<byte> bytes) 创建 ByteString 实例，可以避免其他分配和复制操作。</p>
<h3 id="优化写法"><a href="#优化写法" class="headerlink" title="优化写法"></a>优化写法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 要求fileBytes是immutable的，数据不能再修改</span></span><br><span class="line">ByteString data = UnsafeByteOperations.unsafeWrap(fileBytes);</span><br></pre></td></tr></table></figure>

<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h3><p>1。 UnsafeByteOperations.UnsafeWrap 要求使用 Google.Protobuf 版本 3.15.0 或更高版本：<br>参考:<br><a href="https://learn.microsoft.com/zh-cn/aspnet/core/grpc/performance?view=aspnetcore-7.0" target="_blank" rel="noopener">https://learn.microsoft.com/zh-cn/aspnet/core/grpc/performance?view=aspnetcore-7.0</a><br>2。 如果修改了数据可能会导致抛各种异常:<br>参考: <a href="https://cloud.google.com/java/docs/reference/protobuf/latest/com.google.protobuf.UnsafeByteOperations" target="_blank" rel="noopener">https://cloud.google.com/java/docs/reference/protobuf/latest/com.google.protobuf.UnsafeByteOperations</a></p>
<h1 id="ByteString-toByteArray优化"><a href="#ByteString-toByteArray优化" class="headerlink" title="ByteString.toByteArray优化"></a>ByteString.toByteArray优化</h1><p>ByteString有多种实现，不一定内部有byte数组,所以要根据实际情况选择<code>inputStream</code>或者<code>byte</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 方法1:</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> InputStream <span class="title">newInput</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 2. 方法2:</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuffer <span class="title">asReadOnlyByteBuffer</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>

<h2 id="RangeDownload优化"><a href="#RangeDownload优化" class="headerlink" title="RangeDownload优化"></a>RangeDownload优化</h2><p>spring5的<code>org.springframework.web.servlet.mvc.method.annotation.AbstractMessageConverterMethodProcessor</code>默认实现对于大部分Resouce类型的Http Range协议支持，尽量不要自己实现Range协议，因为里面的规范、边界还是很多很繁琐的；<br>目前XXXUtils实现的版本就会多一次byte数组的拷贝问题，也没有实现全部规范。<br>spring的处理源码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.springframework.web.servlet.mvc.method.annotation.AbstractMessageConverterMethodProcessor#writeWithMessageConverters(T, org.springframework.core.MethodParameter, org.springframework.http.server.ServletServerHttpRequest, org.springframework.http.server.ServletServerHttpResponse)</span></span><br><span class="line"><span class="keyword">if</span> (isResourceType(value, returnType)) &#123;</span><br><span class="line">			outputMessage.getHeaders().set(HttpHeaders.ACCEPT_RANGES, <span class="string">"bytes"</span>);</span><br><span class="line">			<span class="keyword">if</span> (value != <span class="keyword">null</span> &amp;&amp; inputMessage.getHeaders().getFirst(HttpHeaders.RANGE) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">					outputMessage.getServletResponse().getStatus() == <span class="number">200</span>) &#123;</span><br><span class="line">				Resource resource = (Resource) value;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					List&lt;HttpRange&gt; httpRanges = inputMessage.getHeaders().getRange();</span><br><span class="line">					outputMessage.getServletResponse().setStatus(HttpStatus.PARTIAL_CONTENT.value());</span><br><span class="line">					body = HttpRange.toResourceRegions(httpRanges, resource);</span><br><span class="line">					valueType = body.getClass();</span><br><span class="line">					targetType = RESOURCE_REGION_LIST_TYPE;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">catch</span> (IllegalArgumentException ex) &#123;</span><br><span class="line">					outputMessage.getHeaders().set(HttpHeaders.CONTENT_RANGE, <span class="string">"bytes */"</span> + resource.contentLength());</span><br><span class="line">					outputMessage.getServletResponse().setStatus(HttpStatus.REQUESTED_RANGE_NOT_SATISFIABLE.value());</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>

<h3 id="示例使用"><a href="#示例使用" class="headerlink" title="示例使用"></a>示例使用</h3><p>底层是byte数组时:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/load"</span>)</span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResponseEntity&lt;ByteArrayResource&gt; <span class="title">load</span><span class="params">(@RequestParam(value = <span class="string">"fileKey"</span>)</span> String fileKey, HttpServletRequest request) </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] fileBytes = doLoadFile(fileKey, <span class="keyword">false</span>);</span><br><span class="line">        MediaType mediaType = parseMediaType(fileKey);</span><br><span class="line">        <span class="keyword">final</span> HttpHeaders headers = <span class="keyword">new</span> HttpHeaders();</span><br><span class="line">        headers.setContentType(mediaType);</span><br><span class="line">        headers.set(<span class="string">"Content-Disposition"</span>, <span class="string">"attachment; filename="</span> + fileKey);</span><br><span class="line">        headers.set(<span class="string">"Access-Control-Allow-Headers"</span>, <span class="string">"Range,Content-Length"</span>);</span><br><span class="line">        headers.set(<span class="string">"Access-Control-Allow-Methods"</span>, <span class="string">"GET,POST,OPTIONS"</span>);</span><br><span class="line">        headers.set(<span class="string">"Access-Control-Allow-Origin"</span>, <span class="string">"*"</span>);</span><br><span class="line">        <span class="keyword">return</span> ResponseEntity.ok()</span><br><span class="line">                .headers(headers)</span><br><span class="line">                .body(<span class="keyword">new</span> ByteArrayResource(fileBytes));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>底层是ByteString时:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/video"</span>)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ResponseEntity&lt;ByteStringResource&gt; <span class="title">loadVideo</span><span class="params">(HttpServletRequest request, @RequestParam(value = <span class="string">"fileKey"</span>)</span> String fileKey)</span>&#123;</span><br><span class="line">  ByteString byteString = doLoadFileV2(fileKey);</span><br><span class="line">            <span class="keyword">return</span> ResponseEntity.ok()</span><br><span class="line">                    .contentType(VIDEO_TYPE)</span><br><span class="line">                    .cacheControl(maxAge(DEFAULT_CACHE_AGE, DAYS).cachePublic())</span><br><span class="line">                    .eTag(eTag)</span><br><span class="line">                    .body(<span class="keyword">new</span> ByteStringResource(byteString));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>并不是所有<code>Resource</code>类型spring都支持了<code>Http Range</code>，可以看spring源码特别单独排除了<code>InputStreamResource</code>类型。<br>相关的拦截部分源码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Return whether the returned value or the declared return type extends &#123;<span class="doctag">@link</span> Resource&#125;.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isResourceType</span><span class="params">(@Nullable Object value, MethodParameter returnType)</span> </span>&#123;</span><br><span class="line">		Class&lt;?&gt; clazz = getReturnValueType(value, returnType);</span><br><span class="line">		<span class="keyword">return</span> clazz != InputStreamResource<span class="class">.<span class="keyword">class</span> &amp;&amp; <span class="title">Resource</span>.<span class="title">class</span>.<span class="title">isAssignableFrom</span>(<span class="title">clazz</span>)</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Turn a &#123;<span class="doctag">@code</span> Resource&#125; into a &#123;<span class="doctag">@link</span> ResourceRegion&#125; using the range</span></span><br><span class="line"><span class="comment">	 * information contained in the current &#123;<span class="doctag">@code</span> HttpRange&#125;.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> resource the &#123;<span class="doctag">@code</span> Resource&#125; to select the region from</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> the selected region of the given &#123;<span class="doctag">@code</span> Resource&#125;</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@since</span> 4.3</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> ResourceRegion <span class="title">toResourceRegion</span><span class="params">(Resource resource)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// Don't try to determine contentLength on InputStreamResource - cannot be read afterwards...</span></span><br><span class="line">		<span class="comment">// Note: custom InputStreamResource subclasses could provide a pre-calculated content length!</span></span><br><span class="line">		Assert.isTrue(resource.getClass() != InputStreamResource<span class="class">.<span class="keyword">class</span>,</span></span><br><span class="line">				"Cannot convert an InputStreamResource to a ResourceRegion");</span><br><span class="line">		<span class="keyword">long</span> contentLength = getLengthFor(resource);</span><br><span class="line">		<span class="keyword">long</span> start = getRangeStart(contentLength);</span><br><span class="line">		<span class="keyword">long</span> end = getRangeEnd(contentLength);</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> ResourceRegion(resource, start, end - start + <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>原因是Range协议中需要获取contentLength，<br>而InputStreamResource的数据大小获取的默认实现是将inputStream先遍历一遍，这样显然是不符合实际使用场景的。(只能读1次数据)<br>所以如果我们拿到的是inputStream+数据大小时，我们需要将contentLength自行实现一个版本（不遍历的）。<br>这里可以参考ByteStringResource:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> fengmengqi &lt;fengmengqi@xxx.com&gt;</span></span><br><span class="line"><span class="comment"> * Created on 2023-02-02</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ByteStringResource</span> <span class="keyword">extends</span> <span class="title">AbstractResource</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ByteString byteString;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String description;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Create a new &#123;<span class="doctag">@code</span> ByteStringResource&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> byteString the byteString to wrap</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ByteStringResource</span><span class="params">(ByteString byteString)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(byteString, <span class="string">"resource loaded from byteString"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Create a new &#123;<span class="doctag">@code</span> ByteStringResource&#125; with a description.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> byteString the byteString to wrap</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> description where the byteString comes from</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ByteStringResource</span><span class="params">(ByteString byteString, @Nullable String description)</span> </span>&#123;</span><br><span class="line">        Assert.notNull(byteString, <span class="string">"ByteString must not be null"</span>);</span><br><span class="line">        <span class="keyword">this</span>.byteString = byteString;</span><br><span class="line">        <span class="keyword">this</span>.description = (description != <span class="keyword">null</span> ? description : <span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Return the underlying byteString.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ByteString <span class="title">getByteString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.byteString;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * This implementation always returns &#123;<span class="doctag">@code</span> true&#125;.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">exists</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * This implementation returns the length of the underlying byte array.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">contentLength</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.byteString.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * This implementation returns a ByteArrayInputStream for the</span></span><br><span class="line"><span class="comment">     * underlying byte array.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> java.io.ByteArrayInputStream</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> InputStream <span class="title">getInputStream</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> byteString.newInput();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * This implementation returns a description that includes the passed-in</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> description&#125;, if any.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getDescription</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"ByteString resource ["</span> + <span class="keyword">this</span>.description + <span class="string">"]"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * This implementation compares the underlying byte array.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> java.util.Arrays#equals(byte[], byte[])</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object other)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">this</span> == other || (other <span class="keyword">instanceof</span> ByteStringResource</span><br><span class="line">                &amp;&amp; ((ByteStringResource) other).byteString.equals(<span class="keyword">this</span>.byteString)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * This implementation returns the hash code based on the</span></span><br><span class="line"><span class="comment">     * underlying byte array.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">byte</span>[]<span class="class">.<span class="keyword">class</span>.<span class="title">hashCode</span>() * 29 * <span class="title">this</span>.<span class="title">byteString</span>.<span class="title">size</span>())</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="展望"><a href="#展望" class="headerlink" title="展望"></a>展望</h2><p>理论上这个场景下（假如不修改业务逻辑），最小内存申请次数应该是2次而不是3次。（解密前、解密后）<br>目前多出来的这一次，是背景一节中，grpc代码对于一次数据的响应会进行两次堆内内存的申请，相关源码参考：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// com.google.protobuf.CodedInputStream.StreamDecoder#readBytesSlowPath</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Like readBytes, but caller must have already checked the fast path: (size &lt;= (bufferSize -</span></span><br><span class="line"><span class="comment">     * pos) &amp;&amp; size &gt; 0 || size == 0)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> ByteString <span class="title">readBytesSlowPath</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> size)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">      <span class="keyword">final</span> <span class="keyword">byte</span>[] result = readRawBytesSlowPathOneChunk(size);</span><br><span class="line">      <span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// We must copy as the byte array was handed off to the InputStream and a malicious</span></span><br><span class="line">        <span class="comment">// implementation could retain a reference.</span></span><br><span class="line">        <span class="keyword">return</span> ByteString.copyFrom(result);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">final</span> <span class="keyword">int</span> originalBufferPos = pos;</span><br><span class="line">      <span class="keyword">final</span> <span class="keyword">int</span> bufferedBytes = bufferSize - pos;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Mark the current buffer consumed.</span></span><br><span class="line">      totalBytesRetired += bufferSize;</span><br><span class="line">      pos = <span class="number">0</span>;</span><br><span class="line">      bufferSize = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Determine the number of bytes we need to read from the input stream.</span></span><br><span class="line">      <span class="keyword">int</span> sizeLeft = size - bufferedBytes;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// The size is very large. For security reasons we read them in small</span></span><br><span class="line">      <span class="comment">// chunks.</span></span><br><span class="line">      List&lt;<span class="keyword">byte</span>[]&gt; chunks = readRawBytesSlowPathRemainingChunks(sizeLeft);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// OK, got everything.  Now concatenate it all into one buffer.</span></span><br><span class="line">      <span class="keyword">final</span> <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[size];</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Start by copying the leftover bytes from this.buffer.</span></span><br><span class="line">      System.arraycopy(buffer, originalBufferPos, bytes, <span class="number">0</span>, bufferedBytes);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// And now all the chunks.</span></span><br><span class="line">      <span class="keyword">int</span> tempPos = bufferedBytes;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">final</span> <span class="keyword">byte</span>[] chunk : chunks) &#123;</span><br><span class="line">        System.arraycopy(chunk, <span class="number">0</span>, bytes, tempPos, chunk.length);</span><br><span class="line">        tempPos += chunk.length;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">return</span> ByteString.wrap(bytes);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>主要是<code>readRawBytesSlowPathOneChunk</code>和<code>copyFrom</code>这两次。<br>2020年有人发现了类似情况，相关issue参考：<br><a href="https://github.com/protocolbuffers/protobuf/issues/7899" target="_blank" rel="noopener">https://github.com/protocolbuffers/protobuf/issues/7899</a><br>目前还比较遗憾出于安全角度（回复是要保持<code>immutable</code>）被拒绝无法优化。</p>
<p>实际上用户观看一个视频的过程中chrome首先会发一个bytes=0-的请求（最早可能还有一个http到https的307），<br>然后如果服务端支持range，chrome会分段range请求，所以服务端会收到同一个文件的多个http请求。<br>本篇优化了一半内存分配，最坏gc时间压平到2s；<br>再加上临时磁盘缓存，同一个文件多次http请求只会分配3次内存，再调优一下gc配置（固定新生代大小），最坏gc时间压低到了130ms，平时大概是90ms。</p>
<figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除60min未访问视频</span></span><br><span class="line">find /data/tmp/ -amin +60 -name '*.mp4' -type f -delete</span><br><span class="line">find /data/tmp/ -amin +60 -name '*.MOV' -type f -delete</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://xiaoyue26.github.io/2023/02/03/2023-02/%E8%B0%83%E4%BC%98-ByteString%E7%9B%B8%E5%85%B3%E5%86%85%E5%AD%98%E6%8B%B7%E8%B4%9D%E9%97%AE%E9%A2%98/" data-id="cldnys0mk00004vamflr0czpc" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ByteString/" rel="tag">ByteString</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/HttpRange/" rel="tag">HttpRange</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/" rel="tag">java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/jvm/" rel="tag">jvm</a></li></ul>

    </footer>
  </div>
  
    
 
<script src="/jquery/jquery.min.js"></script>

  <div id="random_posts">
    <h2>推荐文章</h2>
    <div class="random_posts_ul">
      <script>
          var random_count =4
          var site = {BASE_URI:'/'};
          function load_random_posts(obj) {
              var arr=site.posts;
              if (!obj) return;
              // var count = $(obj).attr('data-count') || 6;
              for (var i, tmp, n = arr.length; n; i = Math.floor(Math.random() * n), tmp = arr[--n], arr[n] = arr[i], arr[i] = tmp);
              arr = arr.slice(0, random_count);
              var html = '<ul>';
            
              for(var j=0;j<arr.length;j++){
                var item=arr[j];
                html += '<li><strong>' + 
                item.date + ':&nbsp;&nbsp;<a href="' + (site.BASE_URI+item.uri) + '">' + 
                (item.title || item.uri) + '</a></strong>';
                if(item.excerpt){
                  html +='<div class="post-excerpt">'+item.excerpt+'</div>';
                }
                html +='</li>';
                
              }
              $(obj).html(html + '</ul>');
          }
          $('.random_posts_ul').each(function () {
              var c = this;
              if (!site.posts || !site.posts.length){
                  $.getJSON(site.BASE_URI + 'js/posts.js',function(json){site.posts = json;load_random_posts(c)});
              } 
               else{
                load_random_posts(c);
              }
          });
      </script>
    </div>
  </div>

    
<nav id="article-nav">
  
    <a href="/2023/09/24/2023-09/%E6%97%B6%E9%92%9F%E5%90%8C%E6%AD%A5%E5%8F%8A%E4%B8%80%E8%87%B4%E6%80%A7/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">上一篇</strong>
      <div class="article-nav-title">
        
          时钟同步及一致性
        
      </div>
    </a>
  
  
    <a href="/2023/02/01/2023-02/%E8%AF%8A%E6%96%AD-jvm%E7%A8%8B%E5%BA%8Fcpu%E9%97%AE%E9%A2%98/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">下一篇</strong>
      <div class="article-nav-title">诊断-jvm程序cpu问题</div>
    </a>
  
</nav>

  
</article>
 
     
  <div class="comments" id="comments">
    
     
       
      <div id="cloud-tie-wrapper" class="cloud-tie-wrapper"></div>
    
       
      
      
      
  </div>
 
  

</section>
           
    <aside id="sidebar">
  
    

  
    
    <div class="widget-wrap">
    
      <div class="widget" id="toc-widget-fixed">
      
        <strong class="toc-title">文章目录</strong>
        <div class="toc-widget-list">
              <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#背景"><span class="toc-number">1.</span> <span class="toc-text">背景</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#解决方案"><span class="toc-number">2.</span> <span class="toc-text">解决方案</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#ByteString-copyFrom优化"><span class="toc-number">2.1.</span> <span class="toc-text">ByteString.copyFrom优化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#常规写法"><span class="toc-number">2.1.1.</span> <span class="toc-text">常规写法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#优化写法"><span class="toc-number">2.1.2.</span> <span class="toc-text">优化写法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#注意事项："><span class="toc-number">2.1.3.</span> <span class="toc-text">注意事项：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ByteString-toByteArray优化"><span class="toc-number">3.</span> <span class="toc-text">ByteString.toByteArray优化</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#RangeDownload优化"><span class="toc-number">3.1.</span> <span class="toc-text">RangeDownload优化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#示例使用"><span class="toc-number">3.1.1.</span> <span class="toc-text">示例使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#注意事项"><span class="toc-number">3.1.2.</span> <span class="toc-text">注意事项</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#展望"><span class="toc-number">3.2.</span> <span class="toc-text">展望</span></a></li></ol></li></ol>
          </div>
      </div>
    </div>

  
    

  
    
  
    
  
    

  
</aside>

      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-left">
      &copy; 2014 - 2023 风梦七&nbsp;|&nbsp;
      主题 <a href="https://github.com/giscafer/hexo-theme-cafe/" target="_blank">Cafe</a>
    </div>
     <div id="footer-right">
      联系方式&nbsp;|&nbsp;296671657@qq.com
    </div>
  </div>
</footer>
 
<script src="/jquery/jquery.min.js"></script>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">首页</a>
  
    <a href="/archives" class="mobile-nav-link">归档</a>
  
    <a href="/about" class="mobile-nav-link">关于</a>
  
</nav>
    <img class="back-to-top-btn" src="/images/fly-to-top.png"/>
<script>
// Elevator script included on the page, already.
window.onload = function() {
  var elevator = new Elevator({
    selector:'.back-to-top-btn',
    element: document.querySelector('.back-to-top-btn'),
    duration: 1000 // milliseconds
  });
}
</script>
      

  
    <script>
      var cloudTieConfig = {
        url: document.location.href, 
        sourceId: "",
        productKey: "e2fb4051c49842688ce669e634bc983f",
        target: "cloud-tie-wrapper"
      };
    </script>
    <script src="https://img1.ws.126.net/f2e/tie/yun/sdk/loader.js"></script>
    

  







<!-- author:forvoid begin -->
<!-- author:forvoid begin -->

<!-- author:forvoid end -->

<!-- author:forvoid begin -->

<!-- author:forvoid end -->


   <script src="https://sidecar.gitter.im/dist/sidecar.v1.js" async defer></script>

  <script>
    ((window.gitter = {}).chat = {}).options = {
      //room替换成自己的聊天室名称即可，room的名称规则是：username/roomname
      room: 'xiaoyue26/comment'
    };
  </script>


<!-- author:forvoid end -->


  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      })
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      })
    </script>
    <script type="text/javascript" src="https://cdn.rawgit.com/mathjax/MathJax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


 
<script src="/js/is.js"></script>



  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>


<script src="/js/elevator.js"></script>

  </div>
</body>
</html>